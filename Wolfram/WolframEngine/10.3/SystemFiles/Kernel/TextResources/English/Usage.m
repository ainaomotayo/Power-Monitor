AASTriangle::usage = "\!\(\*RowBox[{\"AASTriangle\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) returns a filled triangle with angles \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) and side length \!\(\*StyleBox[\"a\", \"TI\"]\), where \!\(\*StyleBox[\"a\", \"TI\"]\) is adjacent to one angle only."
AbelianGroup::usage = "\!\(\*RowBox[{\"AbelianGroup\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents the direct product of the cyclic groups of degrees \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
AbortKernels::usage = "\!\(\*RowBox[{\"AbortKernels\", \"[\", \"]\"}]\) aborts evaluations running in all parallel subkernels."
AbortProtect::usage = "\!\(\*RowBox[{\"AbortProtect\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), saving any aborts until the evaluation is complete. "
AbortScheduledTask::usage = "\!\(\*RowBox[{\"AbortScheduledTask\", \"[\", StyleBox[\"task\", \"TI\"], \"]\"}]\) interrupts any currently evaluating instances of the cloud task \!\(\*StyleBox[\"task\", \"TI\"]\)."
Abort::usage = "\!\(\*RowBox[{\"Abort\", \"[\", \"]\"}]\) generates an interrupt to abort a computation. "
Above::usage = "Above is a symbol that represents the region above an object for purposes of placement."
AbsArg::usage = "\!\(\*RowBox[{\"AbsArg\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the list \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"Abs\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}], \",\", RowBox[{\"Arg\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]}], \"}\"}]\) of the number \!\(\*StyleBox[\"z\", \"TI\"]\)."
AbsoluteCorrelationFunction::usage = "\!\(\*RowBox[{\"AbsoluteCorrelationFunction\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) estimates the absolute correlation function at lags \!\(\*StyleBox[\"hspec\", \"TI\"]\) from \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"AbsoluteCorrelationFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) represents the absolute correlation function at lags \!\(\*StyleBox[\"hspec\", \"TI\"]\) for the random process \!\(\*StyleBox[\"proc\", \"TI\"]\). \n\!\(\*RowBox[{\"AbsoluteCorrelationFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents the absolute correlation function at times \!\(\*StyleBox[\"s\", \"TI\"]\) and \!\(\*StyleBox[\"t\", \"TI\"]\) for the random process \!\(\*StyleBox[\"proc\", \"TI\"]\). "
AbsoluteCorrelation::usage = "\!\(\*RowBox[{\"AbsoluteCorrelation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the absolute correlation between the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"AbsoluteCorrelation\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the absolute correlation matrix for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"AbsoluteCorrelation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the absolute correlation matrix for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"AbsoluteCorrelation\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the absolute correlation matrix for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"AbsoluteCorrelation\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) absolute correlation for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). "
AbsoluteCurrentValue::usage = "\!\(\*RowBox[{\"AbsoluteCurrentValue\", \"[\", StyleBox[\"item\", \"TI\"], \"]\"}]\) gives the absolute current value of \!\(\*StyleBox[\"item\", \"TI\"]\) at a location in the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\", \"ReplacedText\" -> {StyleBox[\"Mathematica\", FontSlant -> \"Italic\"], \" system\"}]\) and interface. \n\!\(\*RowBox[{\"AbsoluteCurrentValue\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"item\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the absolute current value for the feature of \!\(\*StyleBox[\"item\", \"TI\"]\) specified by \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"AbsoluteCurrentValue\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"item\", \"TI\"]}], \"]\"}]\) gives the absolute current value of \!\(\*StyleBox[\"item\", \"TI\"]\) associated with the object \!\(\*StyleBox[\"obj\", \"TI\"]\). "
AbsoluteDashing::usage = "\!\(\*RowBox[{\"AbsoluteDashing\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a graphics directive which specifies that lines which follow are to be drawn dashed, with successive segments having absolute lengths \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] (repeated cyclically). \n\!\(\*RowBox[{\"AbsoluteDashing\", \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\) is equivalent to \!\(\*RowBox[{\"AbsoluteDashing\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \"]\"}]\). "
AbsoluteFileName::usage = "\!\(\*RowBox[{\"AbsoluteFileName\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the full absolute version of the name for a file in your filesystem."
AbsoluteOptions::usage = "\!\(\*RowBox[{\"AbsoluteOptions\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the absolute settings of options specified in an expression such as a graphics object. \n\!\(\*RowBox[{\"AbsoluteOptions\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) gives the absolute setting for the option \!\(\*StyleBox[\"name\", \"TI\"]\). \n\!\(\*RowBox[{\"AbsoluteOptions\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of the absolute settings for the options \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"AbsoluteOptions\", \"[\", StyleBox[\"object\", \"TI\"], \"]\"}]\) gives the absolute settings for options associated with an external object such as a NotebookObject. "
AbsolutePointSize::usage = "\!\(\*RowBox[{\"AbsolutePointSize\", \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that points which follow are to be shown if possible as circular regions with absolute diameter \!\(\*StyleBox[\"d\", \"TI\"]\). "
AbsoluteThickness::usage = "\!\(\*RowBox[{\"AbsoluteThickness\", \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that lines which follow are to be drawn with absolute thickness \!\(\*StyleBox[\"d\", \"TI\"]\). "
AbsoluteTime::usage = "\!\(\*RowBox[{\"AbsoluteTime\", \"[\", \"]\"}]\) gives the total number of seconds since the beginning of January 1, 1900, in your time zone.\n\!\(\*RowBox[{\"AbsoluteTime\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the absolute time specification corresponding to a date list. \n\!\(\*RowBox[{\"AbsoluteTime\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) gives the absolute time specification corresponding to a DateObject.\n\!\(\*RowBox[{\"AbsoluteTime\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the absolute time specification corresponding to a date string.\n\!\(\*RowBox[{\"AbsoluteTime\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"e\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"e\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \"]\"}]\) takes the date string to contain the elements \"\!\(\*SubscriptBox[\nStyleBox[\"e\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\"."
AbsoluteTiming::usage = "\!\(\*RowBox[{\"AbsoluteTiming\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), returning a list of the absolute number of seconds in real time that have elapsed, together with the result obtained. "
Abs::usage = "\!\(\*RowBox[{\"Abs\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the absolute value of the real or complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
AccountingForm::usage = "\!\(\*RowBox[{\"AccountingForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints with all numbers in \!\(\*StyleBox[\"expr\", \"TI\"]\) given in standard accounting notation. \n\!\(\*RowBox[{\"AccountingForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) prints with numbers given to \!\(\*StyleBox[\"n\", \"TI\"]\)\[Hyphen]digit precision. "
Accumulate::usage = "\!\(\*RowBox[{\"Accumulate\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a list of the successive accumulated totals of elements in \!\(\*StyleBox[\"list\", \"TI\"]\). "
AccuracyGoal::usage = "AccuracyGoal is an option for various numerical operations which specifies how many effective digits of accuracy should be sought in the final result. "
Accuracy::usage = "\!\(\*RowBox[{\"Accuracy\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the effective number of digits to the right of the decimal point in the number \!\(\*StyleBox[\"x\", \"TI\"]\). "
ActionMenuBoxOptions::usage = "\!\(\*RowBox[{ActionMenuBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for ActionMenuBox."
ActionMenu::usage = "\!\(\*RowBox[{\"ActionMenu\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \":>\", SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \":>\", SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents an action menu with label \!\(\*StyleBox[\"name\", \"TI\"]\) and with items labeled \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that evaluates the expression \!\(\*SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) if the corresponding item is chosen."
Activate::usage = "\!\(\*RowBox[{\"Activate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) replaces all instances of \!\(\*RowBox[{\"Inactive\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) in \!\(\*StyleBox[\"expr\", \"TI\"]\) with \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"Activate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) replaces only instances of \!\(\*RowBox[{\"Inactive\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) for which \!\(\*StyleBox[\"f\", \"TI\"]\) matches the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\)."
ActiveStyle::usage = "ActiveStyle is an option for Hyperlink and related constructs that specifies styles to add when the constructs are active, typically as a result of the mouse being over them. "
Active::usage = "Active is an option for ButtonBox, Cell, and Notebook that specifies whether a button should be active. "
AcyclicGraphQ::usage = "\!\(\*RowBox[{\"AcyclicGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is an acyclic graph and False otherwise."
AddOnHelpPath::usage = "AddOnHelpPath is a global option that specifies which directories are searched for additional help files used within the help system."
AddTo::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"+=\", StyleBox[\"dx\", \"TI\"]}]\) adds \!\(\*StyleBox[\"dx\", \"TI\"]\) to \!\(\*StyleBox[\"x\", \"TI\"]\) and returns the new value of \!\(\*StyleBox[\"x\", \"TI\"]\). "
AddUsers::usage = "\!\(\*RowBox[{\"AddUsers\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) adds the users \!\(\*SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to the permissions group \!\(\*StyleBox[\"group\", \"TI\"]\). "
AdjacencyGraph::usage = "\!\(\*RowBox[{\"AdjacencyGraph\", \"[\", StyleBox[\"amat\", \"TI\"], \"]\"}]\) gives the graph with adjacency matrix \!\(\*StyleBox[\"amat\", \"TI\"]\).\n\!\(\*RowBox[{\"AdjacencyGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"amat\", \"TI\"]}], \"]\"}]\) gives the graph with vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and adjacency matrix \!\(\*StyleBox[\"amat\", \"TI\"]\)."
AdjacencyList::usage = "\!\(\*RowBox[{\"AdjacencyList\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives a list of vertices adjacent to vertex \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"AdjacencyList\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of vertices adjacent to vertices that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"AdjacencyList\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives a list of vertices that are at distance at most \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"AdjacencyList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
AdjacencyMatrix::usage = "\!\(\*RowBox[{\"AdjacencyMatrix\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the vertex\[Dash]vertex adjacency matrix of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"AdjacencyMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
AdjustmentBoxOptions::usage = "AdjustmentBoxOptions is an option that specifies settings for AdjustmentBox."
AdjustmentBox::usage = "\!\(\*RowBox[{AdjustmentBox, \"[\", RowBox[{StyleBox[\"box\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) is a low-level box construct which displays with the placement of \!\(\*StyleBox[\"box\", \"TI\"]\) adjusted using the options given. "
AdjustTimeSeriesForecast::usage = "\!\(\*RowBox[{\"AdjustTimeSeriesForecast\", \"[\", RowBox[{StyleBox[\"tproc\", \"TI\"], \",\", StyleBox[\"forecast\", \"TI\"], \",\", StyleBox[\"newdata\", \"TI\"]}], \"]\"}]\) adjusts \!\(\*StyleBox[\"forecast\", \"TI\"]\) using new observations \!\(\*StyleBox[\"newdata\", \"TI\"]\) according to the time series model \!\(\*StyleBox[\"tproc\", \"TI\"]\)."
AdministrativeDivisionData::usage = "\!\(\*RowBox[{\"AdministrativeDivisionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the administrative division \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"AdministrativeDivisionData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified administrative division names.\n\!\(\*RowBox[{\"AdministrativeDivisionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
AffineHalfSpace::usage = "\!\(\*RowBox[{\"AffineHalfSpace\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \"\[Ellipsis]\", \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"k\", StyleBox[\"+\", FontSlant -> \"Plain\"], StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]]}], \"}\"}], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) represents \!\(\*RowBox[{\"AffineSpace\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"k\", StyleBox[\"+\", FontSlant -> \"Plain\"], StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]]}], \"}\"}], \"]\"}]\) extended in the direction \!\(\*StyleBox[\"w\", \"TI\"]\).\n\!\(\*RowBox[{\"AffineHalfSpace\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \"\[Ellipsis]\", \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) represents \!\(\*RowBox[{\"AffineSpace\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) extended in the direction \!\(\*StyleBox[\"w\", \"TI\"]\)."
AffineSpace::usage = "\!\(\*RowBox[{\"AffineSpace\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \"\[Ellipsis]\", \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"k\", StyleBox[\"+\", FontSlant -> \"Plain\"], StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]]}], \"}\"}], \"]\"}]\) represents the affine space passing through the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"AffineSpace\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \"\[Ellipsis]\", \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the affine space passing through \!\(\*StyleBox[\"p\", \"TI\"]\) in the directions \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
AffineStateSpaceModel::usage = "\!\(\*RowBox[{\"AffineStateSpaceModel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) represents the affine state-space model \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"'\"}], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \"\[Equal]\", RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \")\"}], \"+\", RowBox[{RowBox[{StyleBox[\"b\", \"TI\"], \"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \")\"}], \".\", RowBox[{StyleBox[\"u\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}]}]}]\), \!\(\*RowBox[{RowBox[{StyleBox[\"y\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \"=\", RowBox[{RowBox[{StyleBox[\"c\", \"TI\"], \"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \")\"}], \"+\", RowBox[{RowBox[{StyleBox[\"d\", \"TI\"], \"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \")\"}], \".\", RowBox[{StyleBox[\"u\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}]}]}]\).\n\!\(\*RowBox[{\"AffineStateSpaceModel\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives an affine state-space model corresponding to the system model \!\(\*StyleBox[\"sys\", \"TI\"]\).\n\!\(\*RowBox[{\"AffineStateSpaceModel\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"10\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"10\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the affine state-space model obtained by Taylor input linearization about the dependent variable \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"0\", \"TR\"]]]\) and input \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) at \!\(\*SubscriptBox[SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"j\", \"TI\"]], StyleBox[\"0\", \"TR\"]]\) of the differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) with outputs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and independent variable \!\(\*StyleBox[\"t\", \"TI\"]\)."
AffineTransform::usage = "\!\(\*RowBox[{\"AffineTransform\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a TransformationFunction that represents an affine transform that maps \!\(\*StyleBox[\"r\", \"TI\"]\) to \!\(\*RowBox[{StyleBox[\"m\", \"TI\"], \".\", StyleBox[\"r\", \"TI\"]}]\). \n\!\(\*RowBox[{\"AffineTransform\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"]\"}]\) gives an affine transform that maps \!\(\*StyleBox[\"r\", \"TI\"]\) to \!\(\*RowBox[{RowBox[{StyleBox[\"m\", \"TI\"], \".\", StyleBox[\"r\", \"TI\"]}], \"+\", StyleBox[\"v\", \"TI\"]}]\)."
After::usage = "After is a symbol that represents the region after an object for purposes of placement."
AircraftData::usage = "\!\(\*RowBox[{\"AircraftData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the aircraft \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"AircraftData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified aircraft entities.\n\!\(\*RowBox[{\"AircraftData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
AirportData::usage = "\!\(\*RowBox[{\"AirportData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the airport \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"AirportData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified airport entities.\n\!\(\*RowBox[{\"AirportData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
AirPressureData::usage = "\!\(\*RowBox[{\"AirPressureData\", \"[\", \"]\"}]\) gives the most recent measurement for air pressure near the current location.\n\!\(\*RowBox[{\"AirPressureData\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the air pressure value for the specified time near the current location.\n\!\(\*RowBox[{\"AirPressureData\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the most recent measurement for air pressure near the specified locations.\n\!\(\*RowBox[{\"AirPressureData\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the value or values for the specified date and location.\n\!\(\*RowBox[{\"AirPressureData\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives values for all specified locations on the specified dates."
AirTemperatureData::usage = "\!\(\*RowBox[{\"AirTemperatureData\", \"[\", \"]\"}]\) gives the most recent measurement for air temperature near the current location.\n\!\(\*RowBox[{\"AirTemperatureData\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the air temperature value for the specified time near the current location.\n\!\(\*RowBox[{\"AirTemperatureData\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the most recent measurement for air temperature near the specified location.\n\!\(\*RowBox[{\"AirTemperatureData\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the value or values for the specified date and location.\n\!\(\*RowBox[{\"AirTemperatureData\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives values for all specified locations on the specified dates."
AiryAiPrime::usage = "\!\(\*RowBox[{\"AiryAiPrime\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the derivative of the Airy function \!\(\*RowBox[{SuperscriptBox[\"Ai\", \"\[Prime]\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
AiryAi::usage = "\!\(\*RowBox[{\"AiryAi\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Airy function \!\(\*RowBox[{\"Ai\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
AiryAiZero::usage = "\!\(\*RowBox[{\"AiryAiZero\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero of the Airy function \!\(\*RowBox[{\"Ai\", \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"AiryAiZero\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero less than \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
AiryBiPrime::usage = "\!\(\*RowBox[{\"AiryBiPrime\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the derivative of the Airy function \!\(\*RowBox[{SuperscriptBox[\"Bi\", \"\[Prime]\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
AiryBi::usage = "\!\(\*RowBox[{\"AiryBi\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Airy function \!\(\*RowBox[{\"Bi\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
AiryBiZero::usage = "\!\(\*RowBox[{\"AiryBiZero\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero of the Airy function \!\(\*RowBox[{\"Bi\", \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"AiryBiZero\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero less than \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
AlgebraicIntegerQ::usage = "\!\(\*RowBox[{\"AlgebraicIntegerQ\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"a\", \"TI\"]\) is an algebraic integer, and yields False otherwise."
AlgebraicNumberDenominator::usage = "\!\(\*RowBox[{\"AlgebraicNumberDenominator\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives the smallest positive integer \!\(\*StyleBox[\"n\", \"TI\"]\) such that \!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \" \", StyleBox[\"a\", \"TI\"]}]\) is an algebraic integer."
AlgebraicNumberNorm::usage = "\!\(\*RowBox[{\"AlgebraicNumberNorm\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives the norm of the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
AlgebraicNumberPolynomial::usage = "\!\(\*RowBox[{\"AlgebraicNumberPolynomial\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the polynomial in \!\(\*StyleBox[\"x\", \"TI\"]\) corresponding to the AlgebraicNumber object \!\(\*StyleBox[\"a\", \"TI\"]\)."
AlgebraicNumberTrace::usage = "\!\(\*RowBox[{\"AlgebraicNumberTrace\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives the trace of the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
AlgebraicNumber::usage = "\!\(\*RowBox[{\"AlgebraicNumber\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the algebraic number in the field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", \"\[Theta]\", \"]\"}]\) given by \!\(\*RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], \"0\"], \"+\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], \"1\"], \"\[Theta]\"}], \" \", \"+\", \"\[Ellipsis]\", \"+\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]], \" \", SuperscriptBox[\"\[Theta]\", StyleBox[\"n\", \"TI\"]]}]}]\)."
AlgebraicRulesData::usage = "AlgebraicRulesData is an object returned by AlgebraicRules. Its OutputForm appears to be a list of rules, but the rules will be used algebraically rather than syntactically by Replace and related functions."
Algebraics::usage = "Algebraics represents the domain of algebraic numbers, as in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], StyleBox[\"\[Element]\", \"TR\"], \"Algebraics\"}]\). "
AlgebraicUnitQ::usage = "\!\(\*RowBox[{\"AlgebraicUnitQ\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"a\", \"TI\"]\) is an algebraic unit, and yields False otherwise."
AlignmentPoint::usage = "AlignmentPoint is an option which specifies how objects should by default be aligned when they appear in Inset."
Alignment::usage = "Alignment is an option which specifies how the contents of a displayed object should be aligned within the available area in the object."
AllowedDimensions::usage = "AllowedDimensions is an option for Grid and related functions that specifies the allowed minimum and maximum dimensions of the Grid under interactive editing."
AllowGroupClose::usage = "AllowGroupClose is an option for Cell that specifies whether a cell group can be closed normally."
AllowInlineCells::usage = "AllowInlineCells is an option for SelectedCells, Cell, and related constructs that specifies whether inline cells are permitted."
AllowLooseGrammar::usage = "AllowLooseGrammar is an option for GrammarRules and related functions that specifies whether grammatical \"fluff\" should automatically be ignored in applying grammar rules."
AllowReverseGroupClose::usage = "AllowReverseGroupClose is an option for Cell that specifies whether a cell group can be reverse closed."
AllowScriptLevelChange::usage = "AllowScriptLevelChange is an option for fractions and grids that controls whether certain operators, such as \[Sum], \[Product], and \[Integral], always appear smaller than normal size."
AllTrue::usage = "\!\(\*RowBox[{\"AllTrue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) yields True if \!\(\*RowBox[{StyleBox[\"test\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True for all of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"AllTrue\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"level\", \"TI\"]}], \"]\"}]\) tests parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) at level \!\(\*StyleBox[\"level\", \"TI\"]\).\n\!\(\*RowBox[{\"AllTrue\", \"[\", StyleBox[\"test\", \"TI\"], \"]\"}]\) represents an operator form of AllTrue that can be applied to an expression."
All::usage = "All is a setting used for certain options. In Part and related functions, All specifies all parts at a particular level. "
AlphabeticSort::usage = "\!\(\*RowBox[{\"AlphabeticSort\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) sorts the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) into alphabetical order.\n\!\(\*RowBox[{\"AlphabeticSort\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"lang\", \"TI\"]}], \"]\"}]\) sorts using an ordering suitable for the language \!\(\*StyleBox[\"lang\", \"TI\"]\)."
Alphabet::usage = "\!\(\*RowBox[{\"Alphabet\", \"[\", \"]\"}]\) gives a list of the lowercase letters a through z in the English alphabet.\n\!\(\*RowBox[{\"Alphabet\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) gives the alphabet for the language or class \!\(\*StyleBox[\"type\", \"TI\"]\)."
AlphaChannel::usage = "\!\(\*RowBox[{\"AlphaChannel\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) returns the alpha channel of \!\(\*StyleBox[\"image\", \"TI\"]\)."
AlternateImage::usage = "AlternateImage is an option to CDFInformation that specifies an image that should be used if the plugin is not available."
AlternatingFactorial::usage = "\!\(\*RowBox[{\"AlternatingFactorial\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the alternating factorial \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\)."
AlternatingGroup::usage = "\!\(\*RowBox[{\"AlternatingGroup\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the alternating group of degree \!\(\*StyleBox[\"n\", \"TI\"]\)."
AlternativeHypothesis::usage = "AlternativeHypothesis is an option for hypothesis testing functions like LocationTest that specifies the alternative hypothesis."
Alternatives::usage = "\!\(\*RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"|\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"|\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) is a pattern object which represents any of the patterns \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
AltitudeMethod::usage = "AltitudeMethod is an option for SunPosition, MoonPosition, and related functions that determines whether to take atmospheric refraction into account when computing altitude."
AmbientLight::usage = "AmbientLight is an option for Graphics3D and related functions that gives the level of simulated ambient illumination in a three-dimensional picture. "
AmbiguityFunction::usage = "AmbiguityFunction is an option for SemanticInterpretation, Interpreter, and related functions that specifies how to resolve ambiguities generated during semantic interpretation."
AmbiguityList::usage = "\!\(\*RowBox[{\"AmbiguityList\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents possible results derived from an ambiguous semantic interpretation.\n\!\(\*RowBox[{\"AmbiguityList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents possible results from semantic interpretation of an input string.\n\!\(\*RowBox[{\"AmbiguityList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) includes a sequence of associations giving details of the interpretations used to obtain the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Analytic::usage = "Analytic is an option for Limit and Series. With \!\(\*RowBox[{\"Analytic\", \" \", \"->\", \" \", \"True\"}]\), unrecognized functions are treated as analytic, and processed using Taylor series expansions; with \!\(\*RowBox[{\"Analytic\", \" \", \"->\", \" \", \"False\"}]\), Taylor series are not used unless the function is recognized as analytic."
AnatomyData::usage = "\!\(\*RowBox[{\"AnatomyData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the anatomical structure \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"AnatomyData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \"\[Ellipsis]\"}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified anatomical structure entities.\n\!\(\*RowBox[{\"AnatomyData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
AnchoredSearch::usage = "AnchoredSearch is an option for Find and FindList that specifies whether the text searched for must be at the beginning of a record. "
AndersonDarlingTest::usage = "\!\(\*RowBox[{\"AndersonDarlingTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed using the Anderson\[Dash]Darling test.\n\!\(\*RowBox[{\"AndersonDarlingTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is distributed according to \!\(\*StyleBox[\"dist\", \"TI\"]\) using the Anderson\[Dash]Darling test.\n\!\(\*RowBox[{\"AndersonDarlingTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
And::usage = "\!\(\*RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"&&\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"&&\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) is the logical AND function. It evaluates its arguments in order, giving False immediately if any of them are False, and True if they are all True. "
AngerJ::usage = "\!\(\*RowBox[{\"AngerJ\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Anger function \!\(\*SubscriptBox[StyleBox[\"J\", \"TI\"], StyleBox[\"v\", \"TI\"]]\)\!\(\*RowBox[{\"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"AngerJ\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the associated Anger function \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"J\", \"TI\"], \"\[Nu]\", \"\[Mu]\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
AngleBracket::usage = "\!\(\*RowBox[{\"AngleBracket\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{\"\[LeftAngleBracket]\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", \"\[Ellipsis]\"}], \"\[RightAngleBracket]\"}]\)."
AnglePath::usage = "\!\(\*RowBox[{\"AnglePath\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"3\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the list of 2D coordinates corresponding to a path that starts at \!\(\*RowBox[{\"{\", RowBox[{\"0\", \",\", \"0\"}], \"}\"}]\), then takes a series of steps of unit length at successive relative angles \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"AnglePath\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) takes successive steps of lengths \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"AnglePath\", \"[\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"step\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"step\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts at angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"0\", \"TR\"]]\) with respect to the \!\(\*StyleBox[\"x\", \"TI\"]\) axis.\n\!\(\*RowBox[{\"AnglePath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"step\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"step\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts at the point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) with initial angle 0 with respect to the \!\(\*StyleBox[\"x\", \"TI\"]\) axis.\n\!\(\*RowBox[{\"AnglePath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"step\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"step\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts at \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) with initial angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"0\", \"TR\"]]\) with respect to the \!\(\*StyleBox[\"x\", \"TI\"]\) axis.\n\!\(\*RowBox[{\"AnglePath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"step\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"step\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the first step to go from \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to \!\(\*RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"+\", StyleBox[\"dx\", \"TI\"]}], \",\", RowBox[{StyleBox[\"y\", \"TI\"], \"+\", StyleBox[\"dy\", \"TI\"]}]}], \"}\"}]\)."
AngleVector::usage = "\!\(\*RowBox[{\"AngleVector\", \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}]\) gives the list representing the 2D unit vector at angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) relative to the \!\(\*StyleBox[\"x\", \"TI\"]\) axis.\n\!\(\*RowBox[{\"AngleVector\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the list representing the 2D vector of length \!\(\*StyleBox[\"r\", \"TI\"]\) at angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\).\n\!\(\*RowBox[{\"AngleVector\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) gives the result of starting from the point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\), then going a unit distance at angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\).\n\!\(\*RowBox[{\"AngleVector\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the result of starting from the point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\), then going distance \!\(\*StyleBox[\"r\", \"TI\"]\) at angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\)."
AngularGauge::usage = "\!\(\*RowBox[{\"AngularGauge\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}]\) draws a gauge showing \!\(\*StyleBox[\"value\", \"TI\"]\) in the range 0 to 1.\n\!\(\*RowBox[{\"AngularGauge\", \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) draws a gauge showing \!\(\*StyleBox[\"value\", \"TI\"]\) in a range of \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"AngularGauge\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) allows \!\(\*StyleBox[\"value\", \"TI\"]\) to be set interactively using the gauge.\n\!\(\*RowBox[{\"AngularGauge\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) draws a gauge showing multiple values."
Animate::usage = "\!\(\*RowBox[{\"Animate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates an animation of \!\(\*StyleBox[\"expr\", \"TI\"]\) in which \!\(\*StyleBox[\"u\", \"TI\"]\) varies continuously from \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"Animate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"du\", \"TI\"]}], \"}\"}]}], \"]\"}]\) takes \!\(\*StyleBox[\"u\", \"TI\"]\) to vary in steps \!\(\*StyleBox[\"du\", \"TI\"]\). \n\!\(\*RowBox[{\"Animate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) makes \!\(\*StyleBox[\"u\", \"TI\"]\) take on discrete values \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. \n\!\(\*RowBox[{\"Animate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) varies all the variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), \[Ellipsis]. "
AnimationCycleOffset::usage = "AnimationCycleOffset is an option for cells that specifies the relative position of the next graphic to be used in an animation sequence."
AnimationCycleRepetitions::usage = "AnimationCycleRepetitions is an option for cells that specifies the number of times a given animation cycle should be repeated."
AnimationDirection::usage = "AnimationDirection is an option which specifies the direction to run an animation. "
AnimationDisplayTime::usage = "AnimationDisplayTime is an option for Cell that specifies the minimum time in seconds for which a cell should be displayed in the course of an animation that runs through a sequence of selected cells. "
AnimationRate::usage = "AnimationRate is an option for Animate and Animator that specifies at what rate an animation should run, in units per second. "
AnimationRepetitions::usage = "AnimationRepetitions is an option to Animate and related functions that specifies how many times the animation they create runs before stopping."
AnimationRunning::usage = "AnimationRunning is an option to Animate and related functions that specifies whether the animation they create is running."
AnimationRunTime::usage = "AnimationRunTime is an option to Animator and related functions that indicates how long the animation has been continuously running."
AnimationTimeIndex::usage = "AnimationTimeIndex is an option to Animator and related functions that specifies the current time index for the animator."
AnimatorBoxOptions::usage = "\!\(\*RowBox[{AnimatorBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for AnimatorBox objects."
Animator::usage = "\!\(\*RowBox[{\"Animator\", \"[\", StyleBox[\"u\", \"TI\"], \"]\"}]\) represents an object that displays with the value of \!\(\*StyleBox[\"u\", \"TI\"]\) being continually increased from 0 to 1 with time. \n\!\(\*RowBox[{\"Animator\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) makes \!\(\*StyleBox[\"u\", \"TI\"]\) vary from \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"Animator\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"du\", \"TI\"]}], \"}\"}]}], \"]\"}]\) makes \!\(\*StyleBox[\"u\", \"TI\"]\) vary in steps \!\(\*StyleBox[\"du\", \"TI\"]\). \n\!\(\*RowBox[{\"Animator\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"ups\", \"TI\"]}], \"]\"}]\) makes the value of \!\(\*StyleBox[\"u\", \"TI\"]\) increase at a rate of \!\(\*StyleBox[\"ups\", \"TI\"]\) units per second. "
Annotation::usage = "\!\(\*RowBox[{\"Annotation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) represents an expression \!\(\*StyleBox[\"expr\", \"TI\"]\), with annotation \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"Annotation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) specifies the type of annotation being given."
AnnuityDue::usage = "\!\(\*RowBox[{\"AnnuityDue\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents an annuity due of fixed payments \!\(\*StyleBox[\"p\", \"TI\"]\) made over \!\(\*StyleBox[\"t\", \"TI\"]\) periods.\n\!\(\*RowBox[{\"AnnuityDue\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], StyleBox[\"]\", \"TI\"]}]\) represents a series of payments occurring at time intervals \!\(\*StyleBox[\"q\", \"TI\"]\).\n\!\(\*RowBox[{\"AnnuityDue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"initial\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"final\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents an annuity due with the specified initial and final payments."
Annuity::usage = "\!\(\*RowBox[{\"Annuity\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents an annuity of fixed payments \!\(\*StyleBox[\"p\", \"TI\"]\) made over \!\(\*StyleBox[\"t\", \"TI\"]\) periods.\n\!\(\*RowBox[{\"Annuity\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], StyleBox[\"]\", \"TI\"]}]\) represents a series of payments occurring at time intervals \!\(\*StyleBox[\"q\", \"TI\"]\).\n\!\(\*RowBox[{\"Annuity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"initial\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"final\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents an annuity with the specified initial and final payments."
Annulus::usage = "\!\(\*RowBox[{\"Annulus\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"inner\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"outer\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents an annulus centered at \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) with inner radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"inner\", \"TI\"]]\) and outer radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"outer\", \"TI\"]]\).\n\!\(\*RowBox[{\"Annulus\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"inner\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"outer\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents an annulus from angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
ANOVA`ANOVA::usage = "\!\(\*RowBox[{\"ANOVA\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) performs a one\[Hyphen]way analysis of variance.\n\!\(\*RowBox[{\"ANOVA\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"model\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) performs an analysis of variance for \!\(\*StyleBox[\"model\", \"TI\"]\) as a function of the categorical variables \!\(\*StyleBox[\"vars\", \"TI\"]\)."
ANOVA`Bonferroni::usage = "Bonferroni is a possible value for the PostTests option for ANOVA."
ANOVA`CellMeans::usage = "CellMeans is an option for ANOVA that specifies whether cell means should be included in the output."
ANOVA`Duncan::usage = "Duncan is a possible value for the PostTests option for ANOVA."
ANOVA`Dunnett::usage = "Dunnett is a possible value for the PostTests option for ANOVA."
ANOVA`PostTests::usage = "PostTests is an option for ANOVA that specifies which significance tests to perform."
ANOVA`StudentNewmanKeuls::usage = "StudentNewmanKeuls is a possible value for the PostTests option for ANOVA."
ANOVA`Tukey::usage = "Tukey is a possible value for the PostTests option for ANOVA."
Antialiasing::usage = "Antialiasing is a Style option which specifies whether antialiasing should be done in rendering graphics. "
AntihermitianMatrixQ::usage = "\!\(\*RowBox[{\"AntihermitianMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly antihermitian, and False otherwise."
AntisymmetricMatrixQ::usage = "\!\(\*RowBox[{\"AntisymmetricMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly antisymmetric, and False otherwise."
Antisymmetric::usage = "\!\(\*RowBox[{\"Antisymmetric\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents the symmetry of a tensor that is antisymmetric in the slots \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
AnyOrder::usage = "\!\(\*RowBox[{\"AnyOrder\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is a grammar rules pattern object that represents a sequence of elements matching \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in any order."
AnySubset::usage = "\!\(\*RowBox[{\"AnySubset\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an element in an interpreter or form that accepts any subset of the choices \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"AnySubset\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lab\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lab\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) accepts any subset of the \!\(\*SubscriptBox[StyleBox[\"lab\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), yielding the corresponding \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as results.\n\!\(\*RowBox[{\"AnySubset\", \"[\", RowBox[{\"EntityClass\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"class\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}], \"]\"}]\) accepts any subset of the entities in the specified entity class.\n\!\(\*RowBox[{\"AnySubset\", \"[\", RowBox[{StyleBox[\"choices\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"]\"}]\) allows at most \!\(\*StyleBox[\"max\", \"TI\"]\) choices to be selected.\n\!\(\*RowBox[{\"AnySubset\", \"[\", RowBox[{StyleBox[\"choices\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], StyleBox[\"}\", \"TI\"]}]}], \"]\"}]\) allows at least \!\(\*StyleBox[\"min\", \"TI\"]\) and at most \!\(\*StyleBox[\"max\", \"TI\"]\) choices to be selected."
AnyTrue::usage = "\!\(\*RowBox[{\"AnyTrue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) yields True if \!\(\*RowBox[{StyleBox[\"test\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True for any of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"AnyTrue\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"level\", \"TI\"]}], \"]\"}]\) tests parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) at level \!\(\*StyleBox[\"level\", \"TI\"]\).\n\!\(\*RowBox[{\"AnyTrue\", \"[\", StyleBox[\"test\", \"TI\"], \"]\"}]\) represents an operator form of AnyTrue that can be applied to an expression."
ApartSquareFree::usage = "\!\(\*RowBox[{\"ApartSquareFree\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) rewrites a rational expression as a sum of terms whose denominators are powers of square-free polynomials. \n\!\(\*RowBox[{\"ApartSquareFree\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) treats all variables other than \!\(\*StyleBox[\"var\", \"TI\"]\) as constants. "
Apart::usage = "\!\(\*RowBox[{\"Apart\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) rewrites a rational expression as a sum of terms with minimal denominators. \n\!\(\*RowBox[{\"Apart\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) treats all variables other than \!\(\*StyleBox[\"var\", \"TI\"]\) as constants. "
APIFunction::usage = "\!\(\*RowBox[{\"APIFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"fun\", \"TI\"]}], \"]\"}]\) represents an API with parameters \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that evaluates the function \!\(\*StyleBox[\"fun\", \"TI\"]\) whenever it is called. The function \!\(\*StyleBox[\"fun\", \"TI\"]\) is applied to \!\(\*RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]\), where the \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are the settings for the parameters, interpreted as being of types \!\(\*SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"APIFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"default\", \"TI\"], StyleBox[\"1\", \"TR\"]]}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"fun\", \"TI\"]}], \"]\"}]\) takes the value of the parameter \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to be \!\(\*SubscriptBox[StyleBox[\"default\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) if it is not specified when the API is called.\n\!\(\*RowBox[{\"APIFunction\", \"[\", RowBox[{StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"fun\", \"TI\"], \",\", StyleBox[\"fmt\", \"TI\"]}], \"]\"}]\) specifies that the result from applying \!\(\*StyleBox[\"fun\", \"TI\"]\) should be returned in format \!\(\*StyleBox[\"fmt\", \"TI\"]\).\n\!\(\*RowBox[{\"APIFunction\", \"[\", RowBox[{StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"fun\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"fmt\", \"TI\"], \",\", StyleBox[\"rform\", \"TI\"]}], \"}\"}]}], \"]\"}]\) specifies that the result should be returned as a response of the form \!\(\*StyleBox[\"rform\", \"TI\"]\).\n\!\(\*RowBox[{\"APIFunction\", \"[\", RowBox[{StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"fun\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"fmt\", \"TI\"], \",\", StyleBox[\"rform\", \"TI\"], \",\", StyleBox[\"failfmt\", \"TI\"]}], \"}\"}]}], \"]\"}]\) specifies that in the event of failure, the result should be returned in format \!\(\*StyleBox[\"failfmt\", \"TI\"]\)."
AppearanceElements::usage = "AppearanceElements is an option for functions like Manipulate that specifies what elements should be included in the displayed form of the object generated."
AppearanceRules::usage = "AppearanceRules is an option for FormObject, FormFunction, and similar functions that gives rules for the appearance of a form."
Appearance::usage = "Appearance is an option for displayed objects such as Button and Slider that specifies the general type of appearance they should have. "
AppellF1::usage = "\!\(\*RowBox[{\"AppellF1\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is the Appell hypergeometric function of two variables \!\(\*RowBox[{SubscriptBox[StyleBox[\"F\", \"TI\"], \"1\"], RowBox[{\"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", SubscriptBox[StyleBox[\"b\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], \"2\"], \";\", StyleBox[\"c\", \"TI\"], \";\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \")\"}]}]\). "
AppendTo::usage = "\!\(\*RowBox[{\"AppendTo\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"]}], \"]\"}]\) appends \!\(\*StyleBox[\"elem\", \"TI\"]\) to the value of \!\(\*StyleBox[\"s\", \"TI\"]\), and resets \!\(\*StyleBox[\"s\", \"TI\"]\) to the result. "
Append::usage = "\!\(\*RowBox[{\"Append\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"expr\", \"TI\"]\) with \!\(\*StyleBox[\"elem\", \"TI\"]\) appended. \n\!\(\*RowBox[{\"Append\", \"[\", StyleBox[\"elem\", \"TI\"], \"]\"}]\) represents an operator form of Append that can be applied to an expression."
Apply::usage = "\!\(\*RowBox[{\"Apply\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"@@\", StyleBox[\"expr\", \"TI\"]}]\) replaces the head of \!\(\*StyleBox[\"expr\", \"TI\"]\) by \!\(\*StyleBox[\"f\", \"TI\"]\). \n\!\(\*RowBox[{\"Apply\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", \"1\", \"}\"}]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"@@@\", StyleBox[\"expr\", \"TI\"]}]\) replaces heads at level 1 of \!\(\*StyleBox[\"expr\", \"TI\"]\) by \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"Apply\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) replaces heads in parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"Apply\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of Apply that can be applied to an expression."
ArcCosh::usage = "\!\(\*RowBox[{\"ArcCosh\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the inverse hyperbolic cosine \!\(\*RowBox[{SuperscriptBox[\"cosh\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcCos::usage = "\!\(\*RowBox[{\"ArcCos\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the arc cosine \!\(\*RowBox[{SuperscriptBox[\"cos\", RowBox[{\"-\", \"1\"}]], \"(\", \"z\", \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcCoth::usage = "\!\(\*RowBox[{\"ArcCoth\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the inverse hyperbolic cotangent \!\(\*RowBox[{SuperscriptBox[\"coth\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcCot::usage = "\!\(\*RowBox[{\"ArcCot\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the arc cotangent \!\(\*RowBox[{SuperscriptBox[\"cot\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcCsch::usage = "\!\(\*RowBox[{\"ArcCsch\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the inverse hyperbolic cosecant \!\(\*RowBox[{SuperscriptBox[\"csch\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcCsc::usage = "\!\(\*RowBox[{\"ArcCsc\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the arc cosecant \!\(\*RowBox[{SuperscriptBox[\"csc\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcCurvature::usage = "\!\(\*RowBox[{\"ArcCurvature\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the curvature of the parametrized curve whose Cartesian coordinates \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are functions of \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"ArcCurvature\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) interprets the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as coordinates in the specified coordinate chart."
ARCHProcess::usage = "\!\(\*RowBox[{\"ARCHProcess\", \"[\", RowBox[{StyleBox[\"\[Kappa]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents an autoregressive conditionally heteroscedastic process of order \!\(\*StyleBox[\"q\", \"TI\"]\), driven by a standard white noise.\n\!\(\*RowBox[{\"ARCHProcess\", \"[\", RowBox[{StyleBox[\"\[Kappa]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) represents an ARCH process with initial data \!\(\*StyleBox[\"init\", \"TI\"]\)."
ArcLength::usage = "\!\(\*RowBox[{\"ArcLength\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives the length of the one-dimensional region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"ArcLength\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the length of the parametrized curve whose Cartesian coordinates \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are functions of \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"ArcLength\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) interprets the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as coordinates in the specified coordinate chart."
ArcSech::usage = "\!\(\*RowBox[{\"ArcSech\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the inverse hyperbolic secant \!\(\*RowBox[{SuperscriptBox[\"sech\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcSec::usage = "\!\(\*RowBox[{\"ArcSec\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the arc secant \!\(\*RowBox[{SuperscriptBox[\"sec\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcSinDistribution::usage = "\!\(\*RowBox[{\"ArcSinDistribution\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"TI\"]}], \"}\"}], \"]\"}]\) represents the arc sine distribution supported between \!\(\*StyleBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"TI\"]\) and \!\(\*StyleBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"TI\"]\).\n\!\(\*RowBox[{\"ArcSinDistribution\", \"[\", \"]\"}]\) represents the arc sine distribution supported between zero and one."
ArcSinh::usage = "\!\(\*RowBox[{\"ArcSinh\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the inverse hyperbolic sine \!\(\*RowBox[{SuperscriptBox[\"sinh\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcSin::usage = "\!\(\*RowBox[{\"ArcSin\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the arc sine \!\(\*RowBox[{SuperscriptBox[\"sin\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcTanh::usage = "\!\(\*RowBox[{\"ArcTanh\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the inverse hyperbolic tangent \!\(\*RowBox[{SuperscriptBox[\"tanh\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ArcTan::usage = "\!\(\*RowBox[{\"ArcTan\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the arc tangent \!\(\*RowBox[{SuperscriptBox[\"tan\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). \n\!\(\*RowBox[{\"ArcTan\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) gives the arc tangent of \!\(\*FractionBox[StyleBox[\"y\", \"TI\"], StyleBox[\"x\", \"TI\"]]\), taking into account which quadrant the point \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \")\"}]\) is in. "
Area::usage = "\!\(\*RowBox[{\"Area\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives the area of the two-dimensional region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"Area\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the area of the parametrized surface whose Cartesian coordinates \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are functions of \!\(\*StyleBox[\"s\", \"TI\"]\) and \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"Area\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) interprets the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as coordinates in the specified coordinate chart."
ArgMax::usage = "\!\(\*RowBox[{\"ArgMax\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a position \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) at which \!\(\*StyleBox[\"f\", \"TI\"]\) is maximized.\n\!\(\*RowBox[{\"ArgMax\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) at which \!\(\*StyleBox[\"f\", \"TI\"]\) is maximized.\n\!\(\*RowBox[{\"ArgMax\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position at which \!\(\*StyleBox[\"f\", \"TI\"]\) is maximized subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"ArgMax\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"ArgMax\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) constrains variables to the domain \!\(\*StyleBox[\"dom\", \"TI\"]\), typically Reals or Integers."
ArgMin::usage = "\!\(\*RowBox[{\"ArgMin\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a position \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) at which \!\(\*StyleBox[\"f\", \"TI\"]\) is minimized.\n\!\(\*RowBox[{\"ArgMin\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) at which \!\(\*StyleBox[\"f\", \"TI\"]\) is minimized.\n\!\(\*RowBox[{\"ArgMin\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position at which \!\(\*StyleBox[\"f\", \"TI\"]\) is minimized subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"ArgMin\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"ArgMin\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) constrains variables to the domain \!\(\*StyleBox[\"dom\", \"TI\"]\), typically Reals or Integers."
ArgumentCountQ::usage = "\!\(\*RowBox[{\"ArgumentCountQ\", \"[\", RowBox[{StyleBox[\"head\", \"TI\"], \",\", \" \", StyleBox[\"len\", \"TI\"], \",\", \" \", StyleBox[\"min\", \"TI\"], \",\", \" \", StyleBox[\"max\", \"TI\"]}], \"]\"}]\) tests whether the number \!\(\*StyleBox[\"len\", \"TI\"]\) of arguments of a function \!\(\*StyleBox[\"head\", \"TI\"]\) is between \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"ArgumentCountQ\", \"[\", RowBox[{StyleBox[\"head\", \"TI\"], \",\", StyleBox[\"len\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], StyleBox[\",\", \"TR\"], SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) tests whether the number \!\(\*StyleBox[\"len\", \"TI\"]\) of arguments of a function \!\(\*StyleBox[\"head\", \"TI\"]\) is one of the \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Arg::usage = "\!\(\*RowBox[{\"Arg\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the argument of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ARIMAProcess::usage = "\!\(\*RowBox[{\"ARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents an autoregressive integrated moving-average process \!\(\*RowBox[{StyleBox[\"y\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\) such that its \!\(\*StyleBox[\"d\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) difference is a weakly stationary \!\(\*RowBox[{\"ARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\).\n\!\(\*RowBox[{\"ARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a vector ARIMA process \!\(\*RowBox[{\"(\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \" \", \",\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}]}], \")\"}]\) such that its \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"d\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) difference is a vector weakly stationary ARMAProcess.\n\!\(\*RowBox[{\"ARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a vector ARIMA process \!\(\*RowBox[{\"(\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \" \", \",\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}]}], \")\"}]\) such that its \!\(\*RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) difference is a vector weakly stationary ARMAProcess.\n\!\(\*RowBox[{\"ARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) represents an ARIMA process with initial data \!\(\*StyleBox[\"init\", \"TI\"]\). \n\!\(\*RowBox[{\"ARIMAProcess\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents an ARIMA process with a constant \!\(\*StyleBox[\"c\", \"TI\"]\)."
ArithmeticGeometricMean::usage = "\!\(\*RowBox[{\"ArithmeticGeometricMean\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the arithmetic\[Hyphen]geometric mean of \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\). "
ARMAProcess::usage = "\!\(\*RowBox[{\"ARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents a weakly stationary autoregressive moving-average process with AR coefficients \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), MA coefficients \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"j\", \"TI\"]]\), and normal white noise variance \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"ARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a weakly stationary vector ARMA process with coefficient matrices \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) and covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\). \n\!\(\*RowBox[{\"ARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) represents an ARMA process with initial data \!\(\*StyleBox[\"init\", \"TI\"]\). \n\!\(\*RowBox[{\"ARMAProcess\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents an ARMA process with a constant \!\(\*StyleBox[\"c\", \"TI\"]\)."
ARProcess::usage = "\!\(\*RowBox[{\"ARProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents a weakly stationary autoregressive process of order \!\(\*StyleBox[\"p\", \"TI\"]\) with normal white noise variance \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"ARProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a weakly stationary vector AR process with multinormal white noise covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"ARProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) represents an AR process with initial data \!\(\*StyleBox[\"init\", \"TI\"]\). \n\!\(\*RowBox[{\"ARProcess\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"]\", \"TR\"]}]\) represents an AR process with a constant \!\(\*StyleBox[\"c\", \"TI\"]\)."
ArrayComponents::usage = "\!\(\*RowBox[{\"ArrayComponents\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) gives an array in which all identical elements of \!\(\*StyleBox[\"array\", \"TI\"]\) are replaced by an integer index representing the component in which the element lies.\n\!\(\*RowBox[{\"ArrayComponents\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"level\", \"TI\"]}], \"]\"}]\) finds the identical elements at the specified level in \!\(\*StyleBox[\"array\", \"TI\"]\)\n\!\(\*RowBox[{\"ArrayComponents\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"level\", \"TI\"], \",\", StyleBox[\"rules\", \"TI\"]}], \"]\"}]\) uses a rule or a list of rules for specifying the labels."
ArrayDepth::usage = "\!\(\*RowBox[{\"ArrayDepth\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the depth to which \!\(\*StyleBox[\"expr\", \"TI\"]\) is a full array, with all the parts at a particular level being lists of the same length, or is a SparseArray object. "
ArrayFilter::usage = "\!\(\*RowBox[{\"ArrayFilter\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to all range-\!\(\*StyleBox[\"r\", \"TI\"]\) blocks in the specified array.\n\!\(\*RowBox[{\"ArrayFilter\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"array\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to blocks with ranges \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in successive dimensions.\n\!\(\*RowBox[{\"ArrayFilter\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"template\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) over blocks specified by the position of 1s in the array \!\(\*StyleBox[\"template\", \"TI\"]\)."
ArrayFlatten::usage = "\!\(\*RowBox[{\"ArrayFlatten\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a single flattened matrix from a matrix of matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[RowBox[{\"i\", \"\[InvisibleSpace]\", \"j\"}], \"TI\"]]\). \n\!\(\*RowBox[{\"ArrayFlatten\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) flattens out \!\(\*StyleBox[\"r\", \"TI\"]\) pairs of levels in the array \!\(\*StyleBox[\"a\", \"TI\"]\)."
ArrayPad::usage = "\!\(\*RowBox[{\"ArrayPad\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives an array with \!\(\*StyleBox[\"m\", \"TI\"]\) 0s of padding on every side. \n\!\(\*RowBox[{\"ArrayPad\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"]}], \"]\"}]\) uses the specified padding.\n\!\(\*RowBox[{\"ArrayPad\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) pads with \!\(\*StyleBox[\"m\", \"TI\"]\) elements at the beginning and \!\(\*StyleBox[\"n\", \"TI\"]\) elements at the end. \n\!\(\*RowBox[{\"ArrayPad\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) pads with \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) elements at level \!\(\*StyleBox[\"i\", \"TI\"]\) in \!\(\*StyleBox[\"array\", \"TI\"]\). "
ArrayPlot::usage = "\!\(\*RowBox[{\"ArrayPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a plot in which the values in an array are shown in a discrete array of squares. "
ArrayQ::usage = "\!\(\*RowBox[{\"ArrayQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a full array or a SparseArray object, and gives False otherwise. \n\!\(\*RowBox[{\"ArrayQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) requires \!\(\*StyleBox[\"expr\", \"TI\"]\) to be a full array with a depth that matches the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\). \n\!\(\*RowBox[{\"ArrayQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) requires also that \!\(\*StyleBox[\"test\", \"TI\"]\) yield True when applied to each of the array elements in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
ArrayResample::usage = "\!\(\*RowBox[{\"ArrayResample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) resamples \!\(\*StyleBox[\"array\", \"TI\"]\) to have dimensions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"ArrayResample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"dspec\", \"TI\"]}], \"]\"}]\) resamples \!\(\*StyleBox[\"array\", \"TI\"]\) according to the dimension specification \!\(\*StyleBox[\"dspec\", \"TI\"]\).\n\!\(\*RowBox[{\"ArrayResample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[\"scheme\", \"TI\"]}], \"]\"}]\) specifies resampling \!\(\*StyleBox[\"scheme\", \"TI\"]\), either point or bin based. \n\!\(\*RowBox[{\"ArrayResample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[\"scheme\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) resamples in the data subrange \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) using the rest of \!\(\*StyleBox[\"array\", \"TI\"]\) for padding if necessary."
ArrayReshape::usage = "\!\(\*RowBox[{\"ArrayReshape\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"dims\", \"TI\"]}], \"]\"}]\) arranges the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) into a rectangular array with dimensions \!\(\*StyleBox[\"dims\", \"TI\"]\).\n\!\(\*RowBox[{\"ArrayReshape\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"dims\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"]}], \"]\"}]\) uses the specified padding if \!\(\*StyleBox[\"list\", \"TI\"]\) does not contain enough elements."
ArrayRules::usage = "\!\(\*RowBox[{\"ArrayRules\", \"[\", RowBox[{\"SparseArray\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}]\) gives the rules \!\(\*RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) specifying elements in a sparse array. \n\!\(\*RowBox[{\"ArrayRules\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives rules for \!\(\*RowBox[{\"SparseArray\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\). "
Arrays::usage = "\!\(\*RowBox[{\"Arrays\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents the domain of arrays of rank \!\(\*StyleBox[\"r\", \"TI\"]\) and dimensions \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Arrays\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) represents the domain of arrays of dimensions \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), with components in the domain \!\(\*StyleBox[\"dom\", \"TI\"]\).\n\!\(\*RowBox[{\"Arrays\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"dom\", \"TI\"], \",\", StyleBox[\"sym\", \"TI\"]}], \"]\"}]\) represents the subdomain of arrays with dimensions \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and symmetry \!\(\*StyleBox[\"sym\", \"TI\"]\)."
Array::usage = "\!\(\*RowBox[{\"Array\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates a list of length \!\(\*StyleBox[\"n\", \"TI\"]\), with elements \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"i\", \"TI\"], \"]\"}]\). \n\!\(\*RowBox[{\"Array\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) generates a list using the index origin \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"Array\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]\) generates a list using \!\(\*StyleBox[\"n\", \"TI\"]\) values from \!\(\*StyleBox[\"a\", \"TI\"]\) to \!\(\*StyleBox[\"b\", \"TI\"]\).\n\!\(\*RowBox[{\"Array\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates an \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis] array of nested lists, with elements \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\). \n\!\(\*RowBox[{\"Array\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates a list using the index origins \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) (default 1). \n\!\(\*RowBox[{\"Array\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates a list using \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) values from \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Array\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"dims\", \"TI\"], \",\", StyleBox[\"origin\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) uses head \!\(\*StyleBox[\"h\", \"TI\"]\), rather than List, for each level of the array. "
Arrowheads::usage = "\!\(\*RowBox[{\"Arrowheads\", \"[\", StyleBox[\"spec\", \"TI\"], \"]\"}]\) is a graphics directive specifying that arrows that follow should have arrowheads with sizes, positions, and forms specified by \!\(\*StyleBox[\"spec\", \"TI\"]\). "
Arrow::usage = "\!\(\*RowBox[{\"Arrow\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) is a graphics primitive that represents an arrow from \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"Arrow\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) represents an arrow with its ends set back from \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) by a distance \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"Arrow\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) sets back by \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) from \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) from \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). \n\!\(\*RowBox[{\"Arrow\", \"[\", RowBox[{StyleBox[\"curve\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents an arrow following the specified \!\(\*StyleBox[\"curve\", \"TI\"]\)."
ASATriangle::usage = "\!\(\*RowBox[{\"ASATriangle\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) returns a filled triangle with angles \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) and side length \!\(\*StyleBox[\"c\", \"TI\"]\), and \!\(\*StyleBox[\"c\", \"TI\"]\) is adjacent to both angles."
AspectRatioFixed::usage = "AspectRatioFixed is an option for Cell that specifies whether graphics in the cell should be constrained to stay the same shape when they are interactively resized using the front end. "
AspectRatio::usage = "AspectRatio is an option for Graphics and related functions that specifies the ratio of height to width for a plot. "
Assert::usage = "\!\(\*RowBox[{\"Assert\", \"[\", StyleBox[\"test\", \"TI\"], \"]\"}]\) represents the assertion that \!\(\*StyleBox[\"test\", \"TI\"]\) is True. If assertions have been enabled, \!\(\*StyleBox[\"test\", \"TI\"]\) is evaluated when the assertion is encountered. If \!\(\*StyleBox[\"test\", \"TI\"]\) is not True, then an assertion failure is generated.\n\!\(\*RowBox[{\"Assert\", \"[\", RowBox[{StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) specifies a tag that will be used to identify the assertion if it fails."
AssociateTo::usage = "\!\(\*RowBox[{\"AssociateTo\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", RowBox[{StyleBox[\"key\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}]}], \"]\"}]\) changes the association \!\(\*StyleBox[\"a\", \"TI\"]\) by adding the key-value pair \!\(\*RowBox[{StyleBox[\"key\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}]\).\n\!\(\*RowBox[{\"AssociateTo\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) adds all key-value pairs \!\(\*RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\)."
AssociationFormat::usage = "AssociationFormat is an option to TextString and related functions that determines how associations are formatted."
AssociationMap::usage = "\!\(\*RowBox[{\"AssociationMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) creates the association \!\(\*RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"]\"}]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]\).\n\!\(\*RowBox[{\"AssociationMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]}], \"]\"}]\) creates the association \!\(\*RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]\).\n\!\(\*RowBox[{\"AssociationMap\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of AssociationMap that can be applied to an expression."
AssociationQ::usage = "\!\(\*RowBox[{\"AssociationQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a valid Association object, and False otherwise."
AssociationThread::usage = "\!\(\*RowBox[{\"AssociationThread\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the association \!\(\*RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]\).\n\!\(\*RowBox[{\"AssociationThread\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) also gives the association \!\(\*RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]\)."
Association::usage = "\!\(\*RowBox[{\"Association\", \"[\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) or \!\(\*RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]\) represents an association between keys and values."
Assuming::usage = "\!\(\*RowBox[{\"Assuming\", \"[\", RowBox[{StyleBox[\"assum\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) with \!\(\*StyleBox[\"assum\", \"TI\"]\) appended to $Assumptions, so that \!\(\*StyleBox[\"assum\", \"TI\"]\) is included in the default assumptions used by functions such as Refine, Simplify, and Integrate. "
Assumptions::usage = "Assumptions is an option for functions such as Simplify, Refine, and Integrate that specifies default assumptions to be made about symbolic quantities. "
AstronomicalData::usage = "\!\(\*RowBox[{\"AstronomicalData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property of the astronomical object with the specified name.\n\!\(\*RowBox[{\"AstronomicalData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"date\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the value of a property at a particular date and time."
AsynchronousTaskObject::usage = "\!\(\*RowBox[{\"AsynchronousTaskObject\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"id\", \"TI\"], \",\", StyleBox[\"sessionid\", \"TI\"]}], \"]\"}]\) is an object that represents asynchronous evaluations from a particular asynchronous task."
AsynchronousTasks::usage = "\!\(\*RowBox[{\"AsynchronousTasks\", \"[\", \"]\"}]\) returns a list of running asynchronous tasks."
Asynchronous::usage = "Asynchronous is an option for WolframAlpha that determines whether to use the asynchronous features of the Wolfram|Alpha API."
AtomQ::usage = "\!\(\*RowBox[{\"AtomQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is an expression which cannot be divided into subexpressions, and yields False otherwise. "
Attributes::usage = "\!\(\*RowBox[{\"Attributes\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) gives the list of attributes for a symbol. "
Audio`AmplitudeModulation::usage = "\!\(\*RowBox[{\"AmplitudeModulation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"c\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"m\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"dur\", \"TI\"]}], \"]\"}]\) creates a Sound object that is an amplitude-modulated sinusoid, having carrier and modulating frequencies \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"c\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"m\", \"TI\"]]\), measured in hertz, a modulation index of \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and a duration of \!\(\*StyleBox[\"dur\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"AmplitudeModulation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"c\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"m\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"dur\", \"TI\"], \",\", RowBox[{\"RingModulation\", \"->\", \"True\"}]}], \"]\"}]\) creates a ring-modulated sinusoid."
Audio`Cascade::usage = "Cascade is a setting of ModulationType, an option of function FrequencyModulation. "
Audio`FrequencyModulation::usage = "\!\(\*RowBox[{\"FrequencyModulation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"c\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"m\", \"TI\"]], \",\", StyleBox[\"pd\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"dur\", \"TI\"]}], \"]\"}]\) creates a Sound object that is a frequency-modulated sinusoid, having carrier and modulating frequencies \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"c\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"m\", \"TI\"]]\), measured in hertz, peak deviation \!\(\*StyleBox[\"pd\", \"TI\"]\) hertz, and a duration of \!\(\*StyleBox[\"dur\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"FrequencyModulation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"c\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pd\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pd\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dur\", \"TI\"], \",\", RowBox[{\"ModulationType\", \"->\", \"Cascade\"}]}], \"]\"}]\) creates a cascade frequency-modulated sinusoid, where \!\(\*SubscriptBox[StyleBox[\"pd\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is the peak deviation associated with modulating frequency \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FrequencyModulation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"c\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pd\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pd\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dur\", \"TI\"], \",\", RowBox[{\"ModulationType\", \"->\", \"Parallel\"}]}], \"]\"}]\) creates a parallel frequency-modulated sinusoid, where \!\(\*SubscriptBox[StyleBox[\"pd\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is the peak deviation associated with modulating frequency \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Audio`ListWaveform::usage = "\!\(\*RowBox[{\"ListWaveform\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"freq\", \"TI\"], \",\", StyleBox[\"dur\", \"TI\"]}], \"]\"}]\) creates a Sound object with fundamental frequency of \!\(\*StyleBox[\"freq\", \"TI\"]\) hertz, lasting for \!\(\*StyleBox[\"dur\", \"TI\"]\) seconds, with a spectrum in which relative frequency \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) has relative amplitude \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Audio`ModulationType::usage = "ModulationType is an option of FrequencyModulation, specifying the type of modulation."
Audio`Overtones::usage = "Overtones is an option to Waveform that specifies the number of overtones to be present in a standard waveform when created with Fourier summation."
Audio`Parallel::usage = "Parallel is a setting of ModulationType, an option of function FrequencyModulation. "
Audio`RingModulation::usage = "RingModulation is an option to AmplitudeModulation that specifies whether to use ring modulation. "
Audio`Ring::usage = "Ring is an an option to AmplitudeModulation."
Audio`Sawtooth::usage = "Sawtooth is a type of waveform."
Audio`Sinusoid::usage = "Sinusoid is a type of waveform."
Audio`Standard::usage = "Standard is a setting of ModulationType, an option of function FrequencyModulation."
Audio`Waveform::usage = "\!\(\*RowBox[{\"Waveform\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"freq\", \"TI\"], \",\", StyleBox[\"dur\", \"TI\"]}], \"]\"}]\) creates a Sound object that is a standard waveform of type \!\(\*StyleBox[\"type\", \"TI\"]\), having a fundamental frequency of \!\(\*StyleBox[\"freq\", \"TI\"]\) hertz, and a duration of \!\(\*StyleBox[\"dur\", \"TI\"]\) seconds."
AugmentedSymmetricPolynomial::usage = "\!\(\*RowBox[{\"AugmentedSymmetricPolynomial\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a formal augmented symmetric polynomial with exponents \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\).\n\!\(\*RowBox[{\"AugmentedSymmetricPolynomial\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[RowBox[{\"1\", \"n\"}], \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[RowBox[{\"2\", \"n\"}], \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a multivariate formal augmented symmetric polynomial with exponent vectors \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", \" \", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[RowBox[{\"1\", \"n\"}], \"TI\"]]}], \"}\"}]\), \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", \" \", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[RowBox[{\"2\", \"n\"}], \"TI\"]]}], \"}\"}]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\).\n\!\(\*RowBox[{\"AugmentedSymmetricPolynomial\", \"[\", RowBox[{StyleBox[\"rspec\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) gives the augmented symmetric polynomial in \!\(\*StyleBox[\"data\", \"TI\"]\)."
AuthorTools`Common`SelectedCellStyles::usage = "SelectedCellStyles is an option that determines what cells from the user's notebook are itemized when building a table of contents or browser categories. It can be set to a list of style names."
AuthorTools`ExportNotebook`ExportDirectory::usage = "ExportDirectory is an option for ExportNotebook that determines the location of the generated files. The default value of Automatic uses the directory containing the given notebook."
AuthorTools`ExportNotebook`ExportFormat::usage = "ExportFormat is an option that determines the file format for files created by the \!\(\*StyleBox[\"AuthorTools\", FontSlant -> \"Italic\"]\) export palette."
AuthorTools`ExportNotebook`ExportNotebook::usage = "\!\(\*RowBox[{\"ExportNotebook\", \"[\", RowBox[{StyleBox[\"nb\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"fmt\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) creates image files of format \!\(\*StyleBox[\"fmt\", \"TI\"]\) in the notebook's directory for each cell of the indicated style. \n\!\(\*RowBox[{\"ExportNotebook\", \"[\", RowBox[{StyleBox[\"nb\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"elem\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"fmt\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) extracts cells. (See also ExtractionMethod.)"
AuthorTools`ExportNotebook`ExtractionMethod::usage = "ExtractionMethod is an option for ExportNotebook that determines how the information is read from the notebook. The default setting of Automatic will use \"NotebookGet\" or \"Get\". Settings of \"NotebookGet\" or \"Get\" are oftentimes more time efficient, and \"NotebookRead\" or \"NotebookLookup\" are more memory efficient. The memory-efficient methods are not available for all exports."
AuthorTools`MakeContents`MakeContents::usage = "\!\(\*RowBox[{\"MakeContents\", \"[\", RowBox[{RowBox[{StyleBox[\"nb\", \"TI\"], \"|\", StyleBox[\"proj\", \"TI\"]}], \",\", StyleBox[\"format\", \"TI\"]}], \"]\"}]\) writes a table of contents for the specified notebook or project in the given format."
AuthorTools`MakeIndex`AddIndexEntry::usage = "\!\(\*RowBox[{\"AddIndexEntry\", \"[\", RowBox[{StyleBox[\"nb\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"main\", \"TI\"], \",\", StyleBox[\"sub\", \"TI\"]}], \"}\"}]}], \"]\"}]\) adds an index entry with the given \!\(\*StyleBox[\"main\", \"TI\"]\) and \!\(\*StyleBox[\"sub\", \"TI\"]\) entry to the currently selected cells in \!\(\*StyleBox[\"nb\", \"TI\"]\)."
AuthorTools`MakeIndex`MakeIndex::usage = "\!\(\*RowBox[{\"MakeIndex\", \"[\", RowBox[{RowBox[{StyleBox[\"nb\", \"TI\"], \"|\", StyleBox[\"proj\", \"TI\"]}], \",\", StyleBox[\"format\", \"TI\"]}], \"]\"}]\) creates a new index file for the given notebook or project in the specified format and opens it in the front end."
AuthorTools`MakeProject`WriteProjectData::usage = "\!\(\*RowBox[{\"WriteProjectData\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) rewrites \!\(\*StyleBox[\"file\", \"TI\"]\) as a project data file containing the given data."
AuthorTools`Pagination`OpenAllCellGroups::usage = "OpenAllCellGroups is an option to Paginate that determines whether to open all the cell groups in each notebook before calculating page breaks."
AuthorTools`Pagination`Paginate::usage = "\!\(\*RowBox[{\"Paginate\", \"[\", StyleBox[\"proj\", \"TI\"], \"]\"}]\) sets the starting page number for each notebook file in the given project to be the page after the previous notebook finished. It caches the page numbers in each notebook's tagging rules."
AuthorTools`Pagination`PaginationFunction::usage = "PaginationFunction is an option to Paginate that specifies a function to apply to each notebook object after page numbers are calculated but before the notebook is closed."
AuthorTools`Pagination`StartingPages::usage = "StartingPages is an option to Paginate that specifies a list \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\), where \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"k\", \"TI\"]]\) is the starting page number for the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) notebook in the project. Values can be integers, Inherited, \"Next\", \"Even\", or \"Odd\"."
AutoAction::usage = "AutoAction is an option for objects such as Slider, Locator, and Button that specifies whether they should automatically take action whenever the mouse pointer is over them, even if they are not clicked. "
Autocomplete::usage = "\!\(\*RowBox[{\"Autocomplete\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a list of the \!\(\*SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that can complete \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"Autocomplete\", \"[\", RowBox[{RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) puts the completions in order of decreasing weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Autocomplete\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses completions specified by the associations \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Autocomplete\", \"[\", RowBox[{StyleBox[\"comps\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the first at most \!\(\*StyleBox[\"n\", \"TI\"]\) completions.\n\!\(\*RowBox[{\"Autocomplete\", \"[\", StyleBox[\"comps\", \"TI\"], \"]\"}]\) gives an \!\(\*RowBox[{\"AutocompletionFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied to a string."
AutocompletionFunction::usage = "\!\(\*RowBox[{\"AutcompletionFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents a function to be applied to a string to generate possible completions. "
AutocorrelationTest::usage = "\!\(\*RowBox[{\"AutocorrelationTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the \!\(\*StyleBox[\"data\", \"TI\"]\) is autocorrelated.\n\!\(\*RowBox[{\"AutocorrelationTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) tests whether the \!\(\*StyleBox[\"data\", \"TI\"]\) is autocorrelated up to lag \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"AutocorrelationTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\!\(\*\nStyleBox[\"\\\"\", \"TI\"]\) for a given model."
AutoDelete::usage = "AutoDelete is an option for boxes that specifies whether a box is automatically deleted when its contents are edited."
AutoGeneratedPackage::usage = "AutoGeneratedPackage is an option for notebooks that specifies whether a package is automatically created when a notebook that contains initialization cells or groups is saved."
AutoIndent::usage = "AutoIndent is an option for Style and Cell that specifies what automatic indentation should be done at the beginning of a new line after an explicit return character has been entered. "
AutoItalicWords::usage = "AutoItalicWords is an option for Cell that gives a list of words that should automatically be put in italics when they are entered. "
AutoloadPath::usage = "AutoloadPath is a global option that specifies from which directories packages are automatically loaded when \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) is started."
Automatic::usage = "Automatic represents an option or other value that is to be chosen automatically by a built\[Hyphen]in function. "
AutoMultiplicationSymbol::usage = "AutoMultiplicationSymbol is an option for objects such as Cell and Notebook that specifies whether to automatically display a multiplication symbol between numbers that would be multiplied if evaluated."
AutoOpenNotebooks::usage = "AutoOpenNotebooks is a global option that specifies which notebooks should be automatically opened when \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) is started."
AutoOpenPalettes::usage = "AutoOpenPalettes is a global option that specifies the palettes that are automatically opened when \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) is started."
AutoRefreshed::usage = "\!\(\*RowBox[{\"AutoRefreshed\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents an expression to be reevaluated every hour and made available in the cloud.\n\!\(\*RowBox[{\"AutoRefreshed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"dt\", \"TI\"]}], \"]\"}]\) reevaluates at time interval \!\(\*StyleBox[\"dt\", \"TI\"]\). \n\!\(\*RowBox[{\"AutoRefreshed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"]}], \"]\"}]\) reevaluates on the schedule specified by \!\(\*StyleBox[\"timespec\", \"TI\"]\).\n\!\(\*RowBox[{\"AutoRefreshed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"], \",\", StyleBox[\"fmt\", \"TI\"]}], \"]\"}]\) specifies that the result from evaluating \!\(\*StyleBox[\"expr\", \"TI\"]\) should be given in format \!\(\*StyleBox[\"fmt\", \"TI\"]\).\n\!\(\*RowBox[{\"AutoRefreshed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"fmt\", \"TI\"], \",\", StyleBox[\"rform\", \"TI\"]}], \"}\"}]}], \"]\"}]\) specifies that the result should be given as a response of the form \!\(\*StyleBox[\"rform\", \"TI\"]\)."
AutoRemove::usage = "AutoRemove is an option controlling the self-destruct behavior of ScheduledTask and DocumentGenerator."
AutorunSequencing::usage = "AutorunSequencing is an option for Manipulate that specifies how autorun should use the controls provided."
AutoScroll::usage = "AutoScroll is an option to SelectionMove and related functions that specifies whether a notebook should automatically be scrolled to display the current selection."
AutoSpacing::usage = "AutoSpacing is an option for Style and Cell that specifies whether spaces between successive characters should be adjusted automatically. "
AutoSubmitting::usage = "\!\(\*RowBox[{\"AutoSubmitting\", \"[\", StyleBox[\"spec\", \"TI\"], \"]\"}]\) represents an element of a form that automatically submits the whole form if it is entered."
AxesEdge::usage = "AxesEdge is an option for three-dimensional graphics functions that specifies on which edges of the bounding box axes should be drawn. "
AxesLabel::usage = "AxesLabel is an option for graphics functions that specifies labels for axes. "
AxesOrigin::usage = "AxesOrigin is an option for graphics functions that specifies where any axes drawn should cross. "
AxesStyle::usage = "AxesStyle is an option for graphics functions that specifies how axes should be rendered. "
Axes::usage = "Axes is an option for graphics functions that specifies whether axes should be drawn. "
Axis::usage = "Axis is a symbol that represents the axis for purposes of alignment and positioning. "
BabyMonsterGroupB::usage = "\!\(\*RowBox[{\"BabyMonsterGroupB\", \"[\", \"]\"}]\) represents the sporadic simple baby monster group B."
Background::usage = "Background is an option that specifies what background color to use. "
Backslash::usage = "\!\(\*RowBox[{\"Backslash\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Backslash]\", StyleBox[\"y\", \"TI\"], \"\[Backslash]\", \"\[Ellipsis]\"}]\)."
Back::usage = "Back is a symbol that represents the back of a graphic for purposes of placement and alignment."
Backward::usage = "Backward is a symbol that represents the backward direction for purposes of motion and animation."
Ball::usage = "\!\(\*RowBox[{\"Ball\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) represents the unit ball centered at the point \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"Ball\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents the ball of radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at the point \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"Ball\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a collection of balls of radius \!\(\*StyleBox[\"r\", \"TI\"]\)."
BandpassFilter::usage = "\!\(\*RowBox[{\"BandpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) applies a bandpass filter with cutoff frequencies \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\) to an array of data.\n\!\(\*RowBox[{\"BandpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"q\", \"TI\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) uses center frequency \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\) and quality factor \!\(\*StyleBox[\"q\", \"TI\"]\).\n\!\(\*RowBox[{\"BandpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses a filter kernel of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"BandpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to the filter kernel.\n\!\(\*RowBox[{\"BandpassFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a bandpass filter to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"BandpassFilter\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a bandpass filter to sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
BandstopFilter::usage = "\!\(\*RowBox[{\"BandstopFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) applies a bandstop filter with cutoff frequencies \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\) to an array of data.\n\!\(\*RowBox[{\"BandstopFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"q\", \"TI\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) uses center frequency \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\) and quality factor \!\(\*StyleBox[\"q\", \"TI\"]\). \n\!\(\*RowBox[{\"BandstopFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses a filter kernel of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"BandstopFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to the filter kernel.\n\!\(\*RowBox[{\"BandstopFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a bandstop filter to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"BandstopFilter\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a bandstop filter to sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
Band::usage = "\!\(\*RowBox[{\"Band\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"}\"}], \"]\"}]\) represents the sequence of positions on the diagonal band that starts with \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"}\"}]\) in a sparse array.\n\!\(\*RowBox[{\"Band\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the positions between \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) and \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"Band\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"di\", \"TI\"], \",\", StyleBox[\"dj\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents positions starting with \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) and then moving with step \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"di\", \"TI\"], \",\", StyleBox[\"dj\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
BarabasiAlbertGraphDistribution::usage = "\!\(\*RowBox[{\"BarabasiAlbertGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents a Barabasi\[Dash]Albert graph distribution for \!\(\*StyleBox[\"n\", \"TI\"]\)-vertex graphs where a new vertex with \!\(\*StyleBox[\"k\", \"TI\"]\) edges is added at each step."
BarChart3D::usage = "\!\(\*RowBox[{\"BarChart3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D bar chart with bar lengths \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"BarChart3D\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D bar chart with bar features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"BarChart3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D bar chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
BarCharts`BarEdgeStyle::usage = "BarEdgeStyle is an option for bar charts that determines the style for the edges."
BarCharts`BarEdges::usage = "BarEdges is an option for bar charts that determines whether edges are to be drawn around the bars."
BarCharts`BarGroupSpacing::usage = "BarGroupSpacing is an option for BarChart that determines the spacing between groups of bars."
BarCharts`BarLabels::usage = "BarLabels is an option for BarChart, StackedBarChart, and PercentileBarChart that allows a label to be placed at the tick mark for each bar (or group of bars for multiple datasets). Labels are specified in a list."
BarCharts`BarOrientation::usage = "BarOrientation is an option for BarChart that determines whether the bars are oriented vertically or horizontally."
BarCharts`BarStyle::usage = "BarStyle is an option for bar charts that determines the default style for the bars. "
BarCharts`BarValues::usage = "BarValues is an option for BarChart and GeneralizedBarChart that allows the length of the bar to be displayed above each bar."
BarCharts`GeneralizedBarChart3D::usage = "\!\(\*RowBox[{\"GeneralizedBarChart3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"xpos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ypos\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"height\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"xwidth\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ywidth\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"xpos\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ypos\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"height\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"xwidth\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ywidth\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a three-dimensional bar chart with the solid bars at the given positions, heights, and widths."
BarCharts`GeneralizedBarChart::usage = "\!\(\*RowBox[{\"GeneralizedBarChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"height\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"width\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"height\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"width\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], RowBox[{\"}\", \"]\"}]}]}]}]}]\) generates a bar chart with the bars at the given positions, and with given heights and widths.\n\!\(\*RowBox[{\"GeneralizedBarChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}], \"]\"}]\) generates a bar chart from lists of data."
BarCharts`PercentileBarChart::usage = "\!\(\*RowBox[{\"PercentileBarChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a stacked bar chart of the data in the lists. The data for each group of bars is scaled so that the sum of the absolute values in a group of bars is 1."
BarCharts`StackedBarChart::usage = "\!\(\*RowBox[{\"StackedBarChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a stacked bar chart of the data in the lists."
BarChart::usage = "\!\(\*RowBox[{\"BarChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a bar chart with bar lengths \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*RowBox[{StyleBox[\" \", \"TI\"], SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]\), \[Ellipsis].\n\!\(\*RowBox[{\"BarChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a bar chart with bar features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"BarChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a bar chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
BarcodeImage::usage = "\!\(\*RowBox[{\"BarcodeImage\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"format\", \"TI\"]}], \"]\"}]\) generates a barcode image of \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" in the specified \!\(\*StyleBox[\"format\", \"TI\"]\).\n\!\(\*RowBox[{\"BarcodeImage\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"format\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) attempts to generate a barcode image of the specified \!\(\*StyleBox[\"size\", \"TI\"]\)."
BarcodeRecognize::usage = "\!\(\*RowBox[{\"BarcodeRecognize\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) recognizes a barcode in \!\(\*StyleBox[\"image\", \"TI\"]\) and returns it as a string.\n\!\(\*RowBox[{\"BarcodeRecognize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the specified property of the barcode.\n\!\(\*RowBox[{\"BarcodeRecognize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"format\", \"TI\"]}], \"]\"}]\) recognizes barcodes of the specified \!\(\*StyleBox[\"format\", \"TI\"]\) only."
BaringhausHenzeTest::usage = "\!\(\*RowBox[{\"BaringhausHenzeTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether data follows a MultinormalDistribution using the Baringhaus\[Dash]Henze test.\n\!\(\*RowBox[{\"BaringhausHenzeTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"MultinormalDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]}], \"]\"}]\) tests whether data follows the distribution with mean vector \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"BaringhausHenzeTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\". "
BarLegend::usage = "\!\(\*RowBox[{\"BarLegend\", \"[\", StyleBox[\"cf\", \"TI\"], \"]\"}]\) generates a legend that identifies colors from the color function \!\(\*StyleBox[\"cf\", \"TI\"]\) with an automatic range of values.\n\!\(\*RowBox[{\"BarLegend\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"cf\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"}\"}], \"]\"}]\) generates a legend that identifies colors from the color function \!\(\*StyleBox[\"cf\", \"TI\"]\) with the range of values between \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"BarLegend\", \"[\", RowBox[{StyleBox[\"cf\", \"TI\"], \",\", StyleBox[\"contours\", \"TI\"]}], \"]\"}]\) generates a legend that identifies color ranges from the color function \!\(\*StyleBox[\"cf\", \"TI\"]\) based on the set of contours \!\(\*StyleBox[\"contours\", \"TI\"]\)."
BarlowProschanImportance::usage = "\!\(\*RowBox[{\"BarlowProschanImportance\", \"[\", StyleBox[\"rdist\", \"TI\"], \"]\"}]\) gives the Barlow\[Dash]Proschan importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\). \n\!\(\*RowBox[{\"BarlowProschanImportance\", \"[\", StyleBox[\"fdist\", \"TI\"], \"]\"}]\) gives the Barlow\[Dash]Proschan importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\)."
BarnesG::usage = "\!\(\*RowBox[{\"BarnesG\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Barnes G-function \!\(\*RowBox[{StyleBox[\"G\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
BarOrigin::usage = "BarOrigin is an option to BarChart and related functions that specifies the origin placement for bars. "
BarSpacing::usage = "BarSpacing is an option to BarChart and related functions that controls the spacing between bars and groups of bars."
BartlettHannWindow::usage = "\!\(\*RowBox[{\"BartlettHannWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Bartlett\[Dash]Hann window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
BartlettWindow::usage = "\!\(\*RowBox[{\"BartlettWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Bartlett window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
BaseForm::usage = "\!\(\*RowBox[{\"BaseForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) prints with the numbers in \!\(\*StyleBox[\"expr\", \"TI\"]\) given in base \!\(\*StyleBox[\"n\", \"TI\"]\). "
BaselinePosition::usage = "BaselinePosition is an option that specifies where the baseline of an object is considered to be for purposes of alignment with surrounding text or other expressions. "
Baseline::usage = "Baseline is a symbol that represents the baseline for purposes of alignment and positioning. "
BaseStyle::usage = "BaseStyle is an option for formatting and related constructs that specifies the base style to use for them. "
BatesDistribution::usage = "\!\(\*RowBox[{\"BatesDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the distribution of a mean of \!\(\*StyleBox[\"n\", \"TI\"]\) random variables uniformly distributed from 0 to 1.\n\!\(\*RowBox[{\"BatesDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents the distribution of a mean of \!\(\*StyleBox[\"n\", \"TI\"]\) random variables uniformly distributed from \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\)."
BattleLemarieWavelet::usage = "\!\(\*RowBox[{\"BattleLemarieWavelet\", \"[\", \"]\"}]\) represents the Battle-Lemari\[EAcute] wavelet of order 3.\n\!\(\*RowBox[{\"BattleLemarieWavelet\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the Battle-Lemari\[EAcute] wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\) evaluated on equally spaced interval \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"-\", \"10\"}], \",\", \"10\"}], \"}\"}]\).\n\!\(\*RowBox[{\"BattleLemarieWavelet\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"lim\", \"TI\"]}], \"]\"}]\) represents the Battle-Lemari\[EAcute] wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\) evaluated on equally spaced interval \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"-\", StyleBox[\"lim\", \"TI\"]}], StyleBox[\",\", \"TI\"], StyleBox[\"lim\", \"TI\"]}], \"}\"}]\). "
Because::usage = "\!\(\*RowBox[{\"Because\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Because]\", StyleBox[\"y\", \"TI\"]}]\)."
BeckmannDistribution::usage = "\!\(\*RowBox[{\"BeckmannDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) represents the Beckmann distribution with means \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\) and standard deviations \!\(\*SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"BeckmannDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Rho]\", \"TR\"]}], \"]\"}]\) represents the Beckmann distribution with means \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\), standard deviations \!\(\*SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\), and correlation \!\(\*StyleBox[\"\[Rho]\", \"TR\"]\)."
Beep::usage = "\!\(\*RowBox[{\"Beep\", \"[\", \"]\"}]\) generates an audible beep when evaluated. "
Before::usage = "Before is a symbol that represents the region before an object for purposes of placement."
BeginDialogPacket::usage = "\!\(\*RowBox[{\"BeginDialogPacket\", \"[\", StyleBox[\"integer\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that indicates the start of the Dialog subsession referenced by \!\(\*StyleBox[\"integer\", \"TI\"]\)."
BeginPackage::usage = "\!\(\*RowBox[{\"BeginPackage\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \"]\"}]\) makes \!\(\*StyleBox[RowBox[{StyleBox[\"context\", \"TI\"], \"`\"}]]\) and System` the only active contexts. \n\!\(\*RowBox[{\"BeginPackage\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"need\\\",\\\"TI\\\"]\\_\*StyleBox[1, TR]\\)`\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"need\\\",\\\"TI\\\"]\\_\*StyleBox[2, TR]\\)`\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) calls Needs on the \!\(\*SubscriptBox[StyleBox[\"need\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
Begin::usage = "\!\(\*RowBox[{\"Begin\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \"]\"}]\) resets the current context. "
BellB::usage = "\!\(\*RowBox[{\"BellB\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Bell number \!\(\*SubscriptBox[StyleBox[\"B\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"BellB\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Bell polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"B\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
BellY::usage = "\!\(\*RowBox[{\"BellY\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[RowBox[{\"n\", \"-\", \"k\", \"+\", \"1\"}], \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the partial Bell polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"Y\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}]], \"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \"-\", StyleBox[\"k\", \"TI\"], \"+\", \"1\"}]]}], \")\"}]\).\n\!\(\*RowBox[{\"BellY\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the generalized partial Bell polynomial of a matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"BellY\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the generalized Bell polynomial of a matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
Below::usage = "Below is a symbol that represents the region below an object for purposes of placement."
Benchmarking`BenchmarkReport::usage = "\!\(\*RowBox[{\"BenchmarkReport\", \"[\", \"]\"}]\) runs the \!\(\*StyleBox[\"WolframMark\", FontSlant -> \"Italic\"]\) benchmark and produces a report in a separate notebook comparing this system to a selection of reference systems. \n\!\(\*RowBox[{\"BenchmarkReport\", \"[\", RowBox[{SubscriptBox[StyleBox[\"system\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"system\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) produces a custom report comparing the specified systems from $BenchmarkSystems and the specified data returned from Benchmark."
Benchmarking`Benchmark::usage = "\!\(\*RowBox[{\"Benchmark\", \"[\", \"]\"}]\) runs the \!\(\*StyleBox[\"WolframMark\", FontSlant -> \"Italic\"]\) benchmark. "
Benchmarking`$BenchmarkSystems::usage = "$BenchmarkSystems gives the names of systems for which the \!\(\*StyleBox[\"WolframMark\", FontSlant -> \"Italic\"]\) benchmark data is known."
BenfordDistribution::usage = "\!\(\*RowBox[{\"BenfordDistribution\", \"[\", StyleBox[\"b\", \"TI\"], \"]\"}]\) represents a Benford distribution with base parameter \!\(\*StyleBox[\"b\", \"TI\"]\)."
BeniniDistribution::usage = "\!\(\*RowBox[{\"BeniniDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a Benini distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
BenktanderGibratDistribution::usage = "\!\(\*RowBox[{\"BenktanderGibratDistribution\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) represents a Benktander distribution of type I with parameters \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\)."
BenktanderWeibullDistribution::usage = "\!\(\*RowBox[{\"BenktanderWeibullDistribution\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) represents a Benktander distribution of type II with parameters \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\)."
BernoulliB::usage = "\!\(\*RowBox[{\"BernoulliB\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Bernoulli number \!\(\*SubscriptBox[StyleBox[\"B\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"BernoulliB\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Bernoulli polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"B\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
BernoulliDistribution::usage = "\!\(\*RowBox[{\"BernoulliDistribution\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) represents a Bernoulli distribution with probability parameter \!\(\*StyleBox[\"p\", \"TI\"]\)."
BernoulliGraphDistribution::usage = "\!\(\*RowBox[{\"BernoulliGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents a Bernoulli graph distribution for \!\(\*StyleBox[\"n\", \"TI\"]\)-vertex graphs with edge probability \!\(\*StyleBox[\"p\", \"TI\"]\)."
BernoulliProcess::usage = "\!\(\*RowBox[{\"BernoulliProcess\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) represents a Bernoulli process with event probability \!\(\*StyleBox[\"p\", \"TI\"]\)."
BernsteinBasis::usage = "\!\(\*RowBox[{\"BernsteinBasis\", \"[\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) represents the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) Bernstein basis function of degree \!\(\*StyleBox[\"d\", \"TI\"]\) at \!\(\*StyleBox[\"x\", \"TI\"]\)."
BesselFilterModel::usage = "\!\(\*RowBox[{\"BesselFilterModel\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) designs a lowpass Bessel filter of order \!\(\*StyleBox[\"n\", \"TI\"]\) and cutoff frequency 1.\n\!\(\*RowBox[{\"BesselFilterModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"}\"}], \"]\"}]\) uses the cutoff frequency \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]\).\n\!\(\*RowBox[{\"BesselFilterModel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) expresses the model in terms of the variable \!\(\*StyleBox[\"var\", \"TI\"]\)."
BesselI::usage = "\!\(\*RowBox[{\"BesselI\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the modified Bessel function of the first kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"I\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
BesselJ::usage = "\!\(\*RowBox[{\"BesselJ\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Bessel function of the first kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"J\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
BesselJZero::usage = "\!\(\*RowBox[{\"BesselJZero\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero of the Bessel function \!\(\*RowBox[{SubscriptBox[StyleBox[\"J\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"BesselJZero\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero greater than \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
BesselK::usage = "\!\(\*RowBox[{\"BesselK\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the modified Bessel function of the second kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"K\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
BesselY::usage = "\!\(\*RowBox[{\"BesselY\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Bessel function of the second kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"Y\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
BesselYZero::usage = "\!\(\*RowBox[{\"BesselYZero\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero of the Bessel function of the second kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"Y\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"BesselYZero\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero greater than \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
BetaBinomialDistribution::usage = "\!\(\*RowBox[{\"BetaBinomialDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a beta binomial mixture distribution with beta distribution parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\), and \!\(\*StyleBox[\"n\", \"TI\"]\) binomial trials."
BetaDistribution::usage = "\!\(\*RowBox[{\"BetaDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a continuous beta distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\)."
BetaNegativeBinomialDistribution::usage = "\!\(\*RowBox[{\"BetaNegativeBinomialDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a beta negative binomial mixture distribution with beta distribution parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) and \!\(\*StyleBox[\"n\", \"TI\"]\) successful trials."
BetaPrimeDistribution::usage = "\!\(\*RowBox[{\"BetaPrimeDistribution\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents a beta prime distribution with shape parameters \!\(\*StyleBox[\"p\", \"TI\"]\) and \!\(\*StyleBox[\"q\", \"TI\"]\). \n\!\(\*RowBox[{\"BetaPrimeDistribution\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a generalized beta prime distribution with scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"BetaPrimeDistribution\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a generalized beta distribution of the second kind with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
BetaRegularized::usage = "\!\(\*RowBox[{\"BetaRegularized\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the regularized incomplete beta function \!\(\*RowBox[{SubscriptBox[StyleBox[\"I\", \"TI\"], StyleBox[\"z\", \"TI\"]], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \")\"}]\). "
Beta::usage = "\!\(\*RowBox[{\"Beta\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the Euler beta function \!\(\*RowBox[{\"\[CapitalBeta]\", \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \")\"}]\). \n\!\(\*RowBox[{\"Beta\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the incomplete beta function \!\(\*RowBox[{SubscriptBox[\"\[CapitalBeta]\", StyleBox[\"z\", \"TI\"]], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \")\"}]\). "
BetweennessCentrality::usage = "\!\(\*RowBox[{\"BetweennessCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of betweenness centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"BetweennessCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Between::usage = "\!\(\*RowBox[{\"Between\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) is equivalent to \!\(\*RowBox[{StyleBox[\"min\", \"TI\"], \"\[LessEqual]\", StyleBox[\"x\", \"TI\"], \"\[LessEqual]\", StyleBox[\"max\", \"TI\"]}]\).\n\!\(\*RowBox[{\"Between\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"min\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"max\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"min\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"max\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) is equivalent to \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"min\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[LessEqual]\", StyleBox[\"x\", \"TI\"], \"\[LessEqual]\", SubscriptBox[StyleBox[\"max\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"||\", RowBox[{SubscriptBox[StyleBox[\"min\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[LessEqual]\", StyleBox[\"x\", \"TI\"], \"\[LessEqual]\", SubscriptBox[StyleBox[\"max\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"||\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\).\n\!\(\*RowBox[{\"Between\", \"[\", StyleBox[\"range\", \"TI\"], \"]\"}]\) is an operator form that yields \!\(\*RowBox[{\"Between\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"range\", \"TI\"]}], \"]\"}]\) when applied to an expression \!\(\*StyleBox[\"x\", \"TI\"]\)."
BezierCurve3DBoxOptions::usage = "\!\(\*RowBox[{BezierCurve3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for cells that specifies settings for BezierCurve3DBox objects within the cell."
BezierCurveBoxOptions::usage = "\!\(\*RowBox[{BezierCurveBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for BezierCurveBox objects."
BezierCurve::usage = "\!\(\*RowBox[{\"BezierCurve\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a graphics primitive that represents a B\[EAcute]zier curve with control points \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
BezierFunction::usage = "\!\(\*RowBox[{\"BezierFunction\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a B\[EAcute]zier function for a curve defined by the control points \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BezierFunction\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) represents a B\[EAcute]zier function for a surface or high-dimensional manifold. "
BilateralFilter::usage = "\!\(\*RowBox[{\"BilateralFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) applies a bilateral filter of spatial spread \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\) and pixel value spread \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"BilateralFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a bilateral filter to an array of data."
Binarize::usage = "\!\(\*RowBox[{\"Binarize\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) creates a binary image from \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing all values above a globally determined threshold with 1 and others with 0.\n\!\(\*RowBox[{\"Binarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) creates a binary image by replacing all values above \!\(\*StyleBox[\"t\", \"TI\"]\) with 1 and others with 0.\n\!\(\*RowBox[{\"Binarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) creates a binary image by replacing all values in the range \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with 1 and others with 0.\n\!\(\*RowBox[{\"Binarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) creates a binary image by replacing all channel value lists for which \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"v\", \"TI\"], \"]\"}]\) yields True with 1, and others with 0."
BinaryDistance::usage = "\!\(\*RowBox[{\"BinaryDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the binary distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\), equal to 0 if they are identical and 1 otherwise."
BinaryFormat::usage = "BinaryFormat is an option for OpenRead and related functions that specifies that a stream should be opened in binary format, so that no textual interpretation of newlines or other data is done."
BinaryImageQ::usage = "\!\(\*RowBox[{\"BinaryImageQ\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"image\", \"TI\"]\) has the form of a binary Image or Image3D object, and False otherwise."
BinaryReadList::usage = "\!\(\*RowBox[{\"BinaryReadList\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) reads all remaining bytes from a file, and returns them as a list of integers from 0 to 255. \n\!\(\*RowBox[{\"BinaryReadList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) reads objects of the specified type from a file, until the end of the file is reached. The list of objects read is returned. \n\!\(\*RowBox[{\"BinaryReadList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reads objects with a sequence of types, until the end of the file is reached. \n\!\(\*RowBox[{\"BinaryReadList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"types\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) reads only the first \!\(\*StyleBox[\"n\", \"TI\"]\) objects of the specified types. "
BinaryRead::usage = "\!\(\*RowBox[{\"BinaryRead\", \"[\", StyleBox[\"stream\", \"TI\"], \"]\"}]\) reads one byte of raw binary data from an input stream, and returns an integer from 0 to 255. \n\!\(\*RowBox[{\"BinaryRead\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) reads an object of the specified type. \n\!\(\*RowBox[{\"BinaryRead\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reads a sequence of objects of the specified types."
BinaryWrite::usage = "\!\(\*RowBox[{\"BinaryWrite\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) writes a byte of data, specified as an integer from 0 to 255. \n\!\(\*RowBox[{\"BinaryWrite\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) writes a sequence of bytes. \n\!\(\*RowBox[{\"BinaryWrite\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes the raw sequence of characters in a string. \n\!\(\*RowBox[{\"BinaryWrite\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) writes an object of the specified type. \n\!\(\*RowBox[{\"BinaryWrite\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) writes a sequence of objects of the specified type. \n\!\(\*RowBox[{\"BinaryWrite\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) writes a sequence of objects with a sequence of types. "
BinCounts::usage = "\!\(\*RowBox[{\"BinCounts\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) counts the number of elements \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) whose values lie in successive integer bins.\n\!\(\*RowBox[{\"BinCounts\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dx\", \"TI\"]}], \"]\"}]\) counts the number of elements \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) whose values lie in successive bins of width \!\(\*StyleBox[\"dx\", \"TI\"]\).\n\!\(\*RowBox[{\"BinCounts\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}]}], \"]\"}]\) counts the number of \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in successive bins of width \!\(\*StyleBox[\"dx\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"BinCounts\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) counts the number of \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the intervals \!\(\*RowBox[{RowBox[{\"[\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \")\"}]\), \!\(\*RowBox[{RowBox[{\"[\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"3\", \"TR\"]]}]}], \")\"}]\), \[Ellipsis]. \n\!\(\*RowBox[{\"BinCounts\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"xbins\", \"TI\"], \",\", StyleBox[\"ybins\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives an array of counts where the first index corresponds to \!\(\*StyleBox[\"x\", \"TI\"]\) bins, the second to \!\(\*StyleBox[\"y\", \"TI\"]\), and so on. "
BinLists::usage = "\!\(\*RowBox[{\"BinLists\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives lists of the elements \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) whose values lie in successive integer bins.\n\!\(\*RowBox[{\"BinLists\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dx\", \"TI\"]}], \"]\"}]\) gives lists of the elements \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) whose values lie in successive bins of width \!\(\*StyleBox[\"dx\", \"TI\"]\).\n\!\(\*RowBox[{\"BinLists\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives lists of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that lie in successive bins of width \!\(\*StyleBox[\"dx\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"BinLists\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) gives lists of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that lie in the intervals \!\(\*RowBox[{RowBox[{\"[\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \")\"}]\), \!\(\*RowBox[{RowBox[{\"[\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"3\", \"TR\"]]}]}], \")\"}]\), \[Ellipsis]. \n\!\(\*RowBox[{\"BinLists\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"xbins\", \"TI\"], \",\", StyleBox[\"ybins\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives an array of lists where the first index corresponds to \!\(\*StyleBox[\"x\", \"TI\"]\) bins, the second to \!\(\*StyleBox[\"y\", \"TI\"]\), and so on. "
BinomialDistribution::usage = "\!\(\*RowBox[{\"BinomialDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents a binomial distribution with \!\(\*StyleBox[\"n\", \"TI\"]\) trials and success probability \!\(\*StyleBox[\"p\", \"TI\"]\)."
BinomialProcess::usage = "\!\(\*RowBox[{\"BinomialProcess\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) represents a binomial process with event probability \!\(\*StyleBox[\"p\", \"TI\"]\)."
Binomial::usage = "\!\(\*RowBox[{\"Binomial\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the binomial coefficient \!\(\*RowBox[{\"(\", GridBox[{{StyleBox[\"n\", \"TI\"]}, {StyleBox[\"m\", \"TI\"]}}], \")\"}]\)."
BinormalDistribution::usage = "\!\(\*RowBox[{\"BinormalDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Rho]\", \"TR\"]}], \"]\"}]\) represents a bivariate normal distribution with mean \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\) and covariance matrix \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SuperscriptBox[SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{StyleBox[\"\[Rho]\", \"TR\"], \" \", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \" \", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"\[Rho]\", \"TR\"], \" \", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \" \", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \",\", SuperscriptBox[SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}]\).\n\!\(\*RowBox[{\"BinormalDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Rho]\", \"TR\"]}], \"]\"}]\) represents a bivariate normal distribution with zero mean.\n\!\(\*RowBox[{\"BinormalDistribution\", \"[\", StyleBox[\"\[Rho]\", \"TR\"], \"]\"}]\) represents a bivariate normal distribution with zero mean and covariance matrix \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{\"1\", \",\", StyleBox[\"\[Rho]\", \"TR\"]}], \" \", \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Rho]\", \"TR\"], \",\", \"1\"}], \"}\"}]}], \"}\"}]\)."
BiorthogonalSplineWavelet::usage = "\!\(\*RowBox[{\"BiorthogonalSplineWavelet\", \"[\", \"]\"}]\) represents a biorthogonal spline wavelet of order 4 and dual order 2.\n\!\(\*RowBox[{\"BiorthogonalSplineWavelet\", \"[\", StyleBox[RowBox[{\"n\", \",\", \"m\"}], \"TI\"], \"]\"}]\) represents a biorthogonal spline wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\) and dual order \!\(\*StyleBox[\"m\", \"TI\"]\)."
BipartiteGraphQ::usage = "\!\(\*RowBox[{\"BipartiteGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a bipartite graph and False otherwise."
BirnbaumImportance::usage = "\!\(\*RowBox[{\"BirnbaumImportance\", \"[\", RowBox[{StyleBox[\"rdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the Birnbaum importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"BirnbaumImportance\", \"[\", RowBox[{StyleBox[\"fdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the Birnbaum importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\)."
BirnbaumSaundersDistribution::usage = "\!\(\*RowBox[{\"BirnbaumSaundersDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"]\"}]\) represents the Birnbaum\[Dash]Saunders distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\)."
BitAnd::usage = "\!\(\*RowBox[{\"BitAnd\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the bitwise AND of the integers \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
BitClear::usage = "\!\(\*RowBox[{\"BitClear\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) sets to 0 the bit corresponding to the coefficient of \!\(\*SuperscriptBox[\"2\", StyleBox[\"k\", \"TI\"]]\) in the integer \!\(\*StyleBox[\"n\", \"TI\"]\). "
BitGet::usage = "\!\(\*RowBox[{\"BitGet\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gets the bit corresponding to the coefficient of \!\(\*SuperscriptBox[\"2\", StyleBox[\"k\", \"TI\"]]\) in the integer \!\(\*StyleBox[\"n\", \"TI\"]\). "
BitLength::usage = "\!\(\*RowBox[{\"BitLength\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number of binary bits necessary to represent the integer \!\(\*StyleBox[\"n\", \"TI\"]\). "
BitNot::usage = "\!\(\*RowBox[{\"BitNot\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the bitwise NOT of the integer \!\(\*StyleBox[\"n\", \"TI\"]\). "
BitOr::usage = "\!\(\*RowBox[{\"BitOr\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the bitwise OR of the integers \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
BitSet::usage = "\!\(\*RowBox[{\"BitSet\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) sets to 1 the bit corresponding to the coefficient of \!\(\*SuperscriptBox[\"2\", StyleBox[\"k\", \"TI\"]]\) in the integer \!\(\*StyleBox[\"n\", \"TI\"]\). "
BitShiftLeft::usage = "\!\(\*RowBox[{\"BitShiftLeft\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) shifts the binary bits in the integer \!\(\*StyleBox[\"n\", \"TI\"]\) to the left by \!\(\*StyleBox[\"k\", \"TI\"]\) places, padding with zeros on the right.\n\!\(\*RowBox[{\"BitShiftLeft\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) shifts one bit to the left."
BitShiftRight::usage = "\!\(\*RowBox[{\"BitShiftRight\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) shifts the binary bits in the integer \!\(\*StyleBox[\"n\", \"TI\"]\) to the right by \!\(\*StyleBox[\"k\", \"TI\"]\) places, dropping bits that are shifted past the unit's position on the right. \n\!\(\*RowBox[{\"BitShiftRight\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) shifts one bit to the right."
BitXor::usage = "\!\(\*RowBox[{\"BitXor\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the bitwise XOR of the integers \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
BlackBodyRadiation`BlackBodyProfile::usage = "\!\(\*RowBox[{\"BlackBodyProfile\", \"[\", RowBox[{SubscriptBox[StyleBox[\"temp\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"temp\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"]\"}]\) generates a plot of black-body spectral distribution profiles at the specified temperatures \!\(\*RowBox[{SubscriptBox[StyleBox[\"temp\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"temp\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
BlackBodyRadiation`MaxPower::usage = "\!\(\*RowBox[{\"MaxPower\", \"[\", RowBox[{StyleBox[\"temp\", \"TI\"], \",\", StyleBox[\"band\", \"TI\"]}], \"]\"}]\) gives the radiative power emitted by a black body in the specified wavelength band \!\(\*StyleBox[\"band\", \"TI\"]\) about the peak wavelength, at the specified temperature \!\(\*StyleBox[\"temp\", \"TI\"]\)."
BlackBodyRadiation`PeakWavelength::usage = "\!\(\*RowBox[{\"PeakWavelength\", \"[\", StyleBox[\"temp\", \"TI\"], \"]\"}]\) gives the wavelength of the maximum emission of a black body at the specified temperature \!\(\*StyleBox[\"temp\", \"TI\"]\)."
BlackBodyRadiation`TotalPower::usage = "\!\(\*RowBox[{\"TotalPower\", \"[\", StyleBox[\"temp\", \"TI\"], \"]\"}]\) gives the total radiative power emitted by a black body at the specified temperature \!\(\*StyleBox[\"temp\", \"TI\"]\)."
BlackmanHarrisWindow::usage = "\!\(\*RowBox[{\"BlackmanHarrisWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Blackman\[Dash]Harris window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
BlackmanNuttallWindow::usage = "\!\(\*RowBox[{\"BlackmanNuttallWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Blackman\[Dash]Nuttall window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
BlackmanWindow::usage = "\!\(\*RowBox[{\"BlackmanWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Blackman window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
Black::usage = "Black represents the color black in graphics or style specifications. "
BlankForm::usage = "BlankForm is an internal symbol used for formatting and printing."
BlankNullSequence::usage = "___ (three _ characters) or \!\(\*RowBox[{\"BlankNullSequence\", \"[\", \"]\"}]\) is a pattern object that can stand for any sequence of zero or more \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) expressions. \n\!\(\*StyleBox[RowBox[{\"___\", StyleBox[\"h\", \"TI\"]}]]\) or \!\(\*RowBox[{\"BlankNullSequence\", \"[\", StyleBox[\"h\", \"TI\"], \"]\"}]\) can stand for any sequence of expressions, all of which have head \!\(\*StyleBox[\"h\", \"TI\"]\). "
BlankSequence::usage = "__ (two _ characters) or \!\(\*RowBox[{\"BlankSequence\", \"[\", \"]\"}]\) is a pattern object that can stand for any sequence of one or more \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) expressions. \n\!\(\*StyleBox[RowBox[{\"__\", StyleBox[\"h\", \"TI\"]}]]\) or \!\(\*RowBox[{\"BlankSequence\", \"[\", StyleBox[\"h\", \"TI\"], \"]\"}]\) can stand for any sequence of one or more expressions, all of which have head \!\(\*StyleBox[\"h\", \"TI\"]\). "
Blank::usage = "_ or \!\(\*RowBox[{\"Blank\", \"[\", \"]\"}]\) is a pattern object that can stand for any \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) expression. \n\!\(\*StyleBox[RowBox[{\"_\", StyleBox[\"h\", \"TI\"]}]]\) or \!\(\*RowBox[{\"Blank\", \"[\", StyleBox[\"h\", \"TI\"], \"]\"}]\) can stand for any expression with head \!\(\*StyleBox[\"h\", \"TI\"]\). "
Blend::usage = "\!\(\*RowBox[{\"Blend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a color obtained by blending a fraction \!\(\*RowBox[{\"1\", \"-\", StyleBox[\"x\", \"TI\"]}]\) of color \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*StyleBox[\"x\", \"TI\"]\) of color \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"Blend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) linearly interpolates between colors \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as \!\(\*StyleBox[\"x\", \"TI\"]\) varies from 0 to 1.\n\!\(\*RowBox[{\"Blend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) interpolates to give \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) when \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\).\n\!\(\*RowBox[{\"Blend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) blends all the \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), using fraction \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) of color \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Blend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) blends pixel values of 2D or 3D images \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
BlockMap::usage = "\!\(\*RowBox[{\"BlockMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to non-overlapping sublists of length \!\(\*StyleBox[\"n\", \"TI\"]\) in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"BlockMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to sublists with offset \!\(\*StyleBox[\"d\", \"TI\"]\) in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"BlockMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to blocks of size \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Times]\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Times]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
BlockRandom::usage = "\!\(\*RowBox[{\"BlockRandom\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) with all pseudorandom generators localized, so that uses of SeedRandom, RandomInteger, and related functions within the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\) do not affect subsequent pseudorandom sequences."
Block::usage = "\!\(\*RowBox[{\"Block\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) specifies that \!\(\*StyleBox[\"expr\", \"TI\"]\) is to be evaluated with local values for the symbols \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis]. \n\!\(\*RowBox[{\"Block\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) defines initial local values for \!\(\*StyleBox[\"x\", \"TI\"]\), \[Ellipsis]. "
BlomqvistBetaTest::usage = "\!\(\*RowBox[{\"BlomqvistBetaTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"BlomqvistBetaTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"BlomqvistBetaTest\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], StyleBox[\",\", \"TI\"], StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
BlomqvistBeta::usage = "\!\(\*RowBox[{\"BlomqvistBeta\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Blomqvist's medial correlation coefficient \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) for the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"BlomqvistBeta\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives Blomqvist's medial correlation coefficient \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"BlomqvistBeta\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Blomqvist's medial correlation coefficient \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"BlomqvistBeta\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the medial correlation coefficient matrix for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"BlomqvistBeta\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) medial correlation coefficient for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
Blue::usage = "Blue represents the color blue in graphics or style specifications. "
Blur::usage = "\!\(\*RowBox[{\"Blur\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a blurred version of \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"Blur\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives a version of \!\(\*StyleBox[\"image\", \"TI\"]\) blurred over pixel radius \!\(\*StyleBox[\"r\", \"TI\"]\)."
BodePlot::usage = "\!\(\*RowBox[{\"BodePlot\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) generates a Bode plot of a linear time-invariant system \!\(\*StyleBox[\"lsys\", \"TI\"]\).\n\!\(\*RowBox[{\"BodePlot\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots for the frequency range \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"BodePlot\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots \!\(\*StyleBox[\"expr\", \"TI\"]\) using the variable \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
BohmanWindow::usage = "\!\(\*RowBox[{\"BohmanWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Bohman window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
Bold::usage = "Bold represents a bold font weight."
Bookmarks::usage = "Bookmarks is an option for Manipulate and related functions that gives a list of bookmark settings."
BooleanConsecutiveFunction::usage = "\!\(\*RowBox[{\"BooleanConsecutiveFunction\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a Boolean function of \!\(\*StyleBox[\"n\", \"TI\"]\) variables that gives True if \!\(\*StyleBox[\"k\", \"TI\"]\) consecutive variables are True.\n\!\(\*RowBox[{\"BooleanConsecutiveFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"k\", \"TI\"], StyleBox[\",\", \"TI\"], \"True\"}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) treats the variable list as cyclic.\n\!\(\*RowBox[{\"BooleanConsecutiveFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"d\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"d\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a Boolean function of \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \" \", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \" \", \"\[CenterEllipsis]\", \" \", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"d\", \"TI\"]]}]\) variables that gives True if all variables in a \!\(\*RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], \"1\"], \"\[Cross]\", SubscriptBox[StyleBox[\"k\", \"TI\"], \"2\"], \"\[Cross]\", \"\[Ellipsis]\", \"\[Cross]\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"d\", \"TI\"]]}]\) block of the \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], \"1\"], \"\[Cross]\", SubscriptBox[StyleBox[\"n\", \"TI\"], \"2\"], \"\[Cross]\", \"\[Ellipsis]\", \"\[Cross]\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"d\", \"TI\"]]}]\) variable array are True.\n\!\(\*RowBox[{\"BooleanConsecutiveFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"d\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"d\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"d\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) treats the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) level of the variable array as cyclic if \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is True. \n\!\(\*RowBox[{\"BooleanConsecutiveFunction\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the Boolean expression in variables \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the Boolean consecutive function specified by \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"BooleanConsecutiveFunction\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the Boolean expression in the form specified by \!\(\*StyleBox[\"form\", \"TI\"]\)."
BooleanConvert::usage = "\!\(\*RowBox[{\"BooleanConvert\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts the Boolean expression \!\(\*StyleBox[\"expr\", \"TI\"]\) to disjunctive normal form.\n\!\(\*RowBox[{\"BooleanConvert\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) converts the Boolean expression \!\(\*StyleBox[\"expr\", \"TI\"]\) to the specified form.\n\!\(\*RowBox[{\"BooleanConvert\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"cond\", \"TI\"]}], \"]\"}]\) finds an expression in the specified form that is equivalent to \!\(\*StyleBox[\"expr\", \"TI\"]\) when \!\(\*StyleBox[\"cond\", \"TI\"]\) is true."
BooleanCountingFunction::usage = "\!\(\*RowBox[{\"BooleanCountingFunction\", \"[\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a Boolean function of \!\(\*StyleBox[\"n\", \"TI\"]\) variables that gives True if at most \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) variables are True.\n\!\(\*RowBox[{\"BooleanCountingFunction\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"k\", \"TI\"], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a function of \!\(\*StyleBox[\"n\", \"TI\"]\) variables that gives True if exactly \!\(\*StyleBox[\"k\", \"TI\"]\) variables are True.\n\!\(\*RowBox[{\"BooleanCountingFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a function that gives True if between \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) variables are True.\n\!\(\*RowBox[{\"BooleanCountingFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a function that gives True if exactly \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) variables are True.\n\!\(\*RowBox[{\"BooleanCountingFunction\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the Boolean expression in variables \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the Boolean counting function specified by \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"BooleanCountingFunction\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the Boolean expression in the form specified by \!\(\*StyleBox[\"form\", \"TI\"]\)."
BooleanFunction::usage = "\!\(\*RowBox[{\"BooleanFunction\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) Boolean function in \!\(\*StyleBox[\"n\", \"TI\"]\) variables.\n\!\(\*RowBox[{\"BooleanFunction\", \"[\", StyleBox[\"values\", \"TI\"], \"]\"}]\) represents the Boolean function corresponding to the specified vector of truth values.\n\!\(\*RowBox[{\"BooleanFunction\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"o\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents the Boolean function defined by the specified mapping from inputs to outputs.\n\!\(\*RowBox[{\"BooleanFunction\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the Boolean expression in variables \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the Boolean function specified by \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"BooleanFunction\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the Boolean expression in the form specified by \!\(\*StyleBox[\"form\", \"TI\"]\)."
BooleanGraph::usage = "\!\(\*RowBox[{\"BooleanGraph\", \"[\", RowBox[{StyleBox[\"bfunc\", \"TI\"], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"]\"}]\) gives the Boolean graph defined by the Boolean function \!\(\*StyleBox[\"bfunc\", \"TI\"]\) on the graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \[Ellipsis], \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
BooleanMaxterms::usage = "\!\(\*RowBox[{\"BooleanMaxterms\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) maxterm in \!\(\*StyleBox[\"n\", \"TI\"]\) variables.\n\!\(\*RowBox[{\"BooleanMaxterms\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents the conjunction of the maxterms \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BooleanMaxterms\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents the conjunction of maxterms given by the exponent vectors \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"BooleanMaxterms\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the Boolean expression in variables \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the maxterms function specified by \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"BooleanMaxterms\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the Boolean expression in the form specified by \!\(\*StyleBox[\"form\", \"TI\"]\)."
BooleanMinimize::usage = "\!\(\*RowBox[{\"BooleanMinimize\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) finds a minimal-length disjunctive normal form representation of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"BooleanMinimize\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) finds a minimal-length representation for \!\(\*StyleBox[\"expr\", \"TI\"]\) in the specified form.\n\!\(\*RowBox[{\"BooleanMinimize\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"cond\", \"TI\"]}], \"]\"}]\) finds a minimal-length expression in the specified form that is equivalent to \!\(\*StyleBox[\"expr\", \"TI\"]\) when \!\(\*StyleBox[\"cond\", \"TI\"]\) is true."
BooleanMinterms::usage = "\!\(\*RowBox[{\"BooleanMinterms\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) minterm in \!\(\*StyleBox[\"n\", \"TI\"]\) variables.\n\!\(\*RowBox[{\"BooleanMinterms\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents the disjunction of the minterms \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BooleanMinterms\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents the disjunction of minterms given by the exponent vectors \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"BooleanMinterms\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the Boolean expression in variables \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the minterms function specified by \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"BooleanMinterms\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the Boolean expression in the form specified by \!\(\*StyleBox[\"form\", \"TI\"]\)."
BooleanQ::usage = "\!\(\*RowBox[{\"BooleanQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is either True or False."
BooleanRegion::usage = "\!\(\*RowBox[{\"BooleanRegion\", \"[\", RowBox[{StyleBox[\"bfunc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the Boolean combination \!\(\*StyleBox[\"bfunc\", \"TI\"]\) of regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
BooleanStrings::usage = "BooleanStrings is an option to TextString and related functions that determines what strings correspond to the Wolfram Language symbols True and False."
Booleans::usage = "Booleans represents the domain of Booleans, as in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], StyleBox[\"\[Element]\", \"TR\"], \"Booleans\"}]\). "
BooleanTable::usage = "\!\(\*RowBox[{\"BooleanTable\", \"[\", StyleBox[\"bf\", \"TI\"], \"]\"}]\) gives a list of truth values for all possible combinations of variable values supplied to the Boolean function \!\(\*StyleBox[\"bf\", \"TI\"]\).\n\!\(\*RowBox[{\"BooleanTable\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of the truth values of the Boolean expression \!\(\*StyleBox[\"expr\", \"TI\"]\) for all possible combinations of values of the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BooleanTable\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a nested table of truth values of \!\(\*StyleBox[\"expr\", \"TI\"]\) with the outermost level giving possible combinations of the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
BooleanVariables::usage = "\!\(\*RowBox[{\"BooleanVariables\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives a list of the Boolean variables in the Boolean expression \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"BooleanVariables\", \"[\", StyleBox[\"bf\", \"TI\"], \"]\"}]\) gives the number of Boolean variables in the BooleanFunction object \!\(\*StyleBox[\"bf\", \"TI\"]\)."
Boole::usage = "\!\(\*RowBox[{\"Boole\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) yields 1 if \!\(\*StyleBox[\"expr\", \"TI\"]\) is True and 0 if it is False. "
BorderDimensions::usage = "\!\(\*RowBox[{\"BorderDimensions\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the pixel width of uniform borders of \!\(\*StyleBox[\"image\", \"TI\"]\) in the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"left\", \"TI\"], \",\", StyleBox[\"right\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"bottom\", \"TI\"], \",\", StyleBox[\"top\", \"TI\"]}], \"}\"}]}], \"}\"}]\).\n\!\(\*RowBox[{\"BorderDimensions\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds borders whose pixels vary by an amount less than \!\(\*StyleBox[\"t\", \"TI\"]\)."
BorelTannerDistribution::usage = "\!\(\*RowBox[{\"BorelTannerDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a Borel\[Dash]Tanner distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"n\", \"TI\"]\)."
BottomHatTransform::usage = "\!\(\*RowBox[{\"BottomHatTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the morphological bottom-hat transform of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"BottomHatTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the bottom-hat transform with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"BottomHatTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a bottom-hat transform to an array of data."
Bottom::usage = "Bottom is a symbol that represents the bottom for purposes of alignment and positioning. "
BoundaryDiscretizeGraphics::usage = "\!\(\*RowBox[{\"BoundaryDiscretizeGraphics\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) discretizes a 2D or 3D graphic \!\(\*StyleBox[\"g\", \"TI\"]\) into a BoundaryMeshRegion.\n\!\(\*RowBox[{\"BoundaryDiscretizeGraphics\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) discretizes only the elements in \!\(\*StyleBox[\"g\", \"TI\"]\) that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\)."
BoundaryDiscretizeRegion::usage = "\!\(\*RowBox[{\"BoundaryDiscretizeRegion\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) discretizes the region \!\(\*StyleBox[\"reg\", \"TI\"]\) into a BoundaryMeshRegion.\n\!\(\*RowBox[{\"BoundaryDiscretizeRegion\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) restricts to the bounds \!\(\*RowBox[{RowBox[{\"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]}], \"]\"}], \"\[Times]\", \"\[CenterEllipsis]\"}]\)."
BoundaryMeshRegionQ::usage = "\!\(\*RowBox[{\"BoundaryMeshRegionQ\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) yields True if the region \!\(\*StyleBox[\"reg\", \"TI\"]\) is a valid BoundaryMeshRegion object and False otherwise."
BoundaryMeshRegion::usage = "\!\(\*RowBox[{\"BoundaryMeshRegion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"bcell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"bcell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields a mesh with boundary cells \!\(\*SubscriptBox[StyleBox[\"bcell\", \"TI\"], StyleBox[\"j\", \"TI\"]]\), where coordinates given as integer \!\(\*StyleBox[\"i\", \"TI\"]\) are taken to be \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), where the cells together represent a closed curve, surface, etc. \n\!\(\*RowBox[{\"BoundaryMeshRegion\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"bcell\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields a mesh with cell properties defined by the symbolic wrapper \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BoundaryMeshRegion\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"boundary\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"boundary\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields a mesh from multiple boundaries \!\(\*SubscriptBox[StyleBox[\"boundary\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
BoundaryMesh::usage = "\!\(\*RowBox[{\"BoundaryMesh\", \"[\", StyleBox[\"mreg\", \"TI\"], \"]\"}]\) gives a BoundaryMeshRegion from a MeshRegion \!\(\*StyleBox[\"mreg\", \"TI\"]\). "
BoundaryStyle::usage = "BoundaryStyle is an option for plotting functions that specifies the style in which boundaries of regions should be drawn. "
BoundedRegionQ::usage = "\!\(\*RowBox[{\"BoundedRegionQ\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"reg\", \"TI\"]\) is a bounded region and False otherwise. "
BoxBaselineShift::usage = "BoxBaselineShift is an option for AdjustmentBox that specifies how much the baseline of the box should be shifted relative to those of neighboring characters."
BoxData::usage = "\!\(\*RowBox[{BoxData, \"[\", StyleBox[\"boxes\", \"TI\"], \"]\"}]\) is a low-level representation of the contents of a typesetting cell."
Boxed::usage = "Boxed is an option for Graphics3D that specifies whether to draw the edges of the bounding box in a three\[Hyphen]dimensional picture. "
BoxFormFormatTypes::usage = "BoxFormFormatTypes is a global option that specifies the list of typeset format types that are currently defined."
BoxFrame::usage = "BoxFrame is an option for FrameBox objects that specifies whether to draw a frame around the contents of the box."
BoxMargins::usage = "BoxMargins is an option for AdjustmentBox objects that specifies the margins to leave around the contents of the box."
BoxMatrix::usage = "\!\(\*RowBox[{BoxMatrix, \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives a \!\(\*RowBox[{\"(\", RowBox[{RowBox[{\"2\", \" \", StyleBox[\"r\", \"TI\"]}], \"+\", \"1\"}], \")\"}]\)\!\(\*StyleBox[\"\[Times]\", \"TR\"]\)\!\(\*RowBox[{\"(\", RowBox[{RowBox[{\"2\", \" \", StyleBox[\"r\", \"TI\"]}], \"+\", \"1\"}], \")\"}]\) matrix of 1s.\n\!\(\*RowBox[{BoxMatrix, \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) gives a \!\(\*RowBox[{\"(\", RowBox[{RowBox[{\"2\", \" \", StyleBox[\"r\", \"TI\"]}], \"+\", \"1\"}], \")\"}]\)\!\(\*StyleBox[\"\[Times]\", \"TR\"]\)\!\(\*RowBox[{\"(\", RowBox[{RowBox[{\"2\", \" \", StyleBox[\"r\", \"TI\"]}], \"+\", \"1\"}], \")\"}]\) block of 1s centered in a \!\(\*RowBox[{StyleBox[\"w\", \"TI\"], \"\[Times]\", StyleBox[\"w\", \"TI\"]}]\) matrix of 0s.\n\!\(\*RowBox[{BoxMatrix, \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a \!\(\*RowBox[{RowBox[{\"(\", RowBox[{RowBox[{\"2\", \" \", SubscriptBox[StyleBox[\"r\", \"TI\"], \"1\"]}], \"+\", \"1\"}], \")\"}], \" \", RowBox[{\"(\", RowBox[{RowBox[{\"2\", \" \", SubscriptBox[StyleBox[\"r\", \"TI\"], \"2\"]}], \"+\", \"1\"}], \")\"}], \" \", \"\[Ellipsis]\"}]\) array of 1s."
BoxObject::usage = "\!\(\*RowBox[{BoxObject, \"[\", StyleBox[\"id\", \"TI\"], \"]\"}]\) is an object that represents a box structure in an open notebook in the front end."
BoxRatios::usage = "BoxRatios is an option for Graphics3D that gives the ratios of side lengths for the bounding box of the three\[Hyphen]dimensional picture. "
BoxStyle::usage = "BoxStyle is an option for three-dimensional graphics functions that specifies how the bounding box should be rendered. "
BoxWhiskerChart::usage = "\!\(\*RowBox[{BoxWhiskerChart, \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a box\[Hyphen]and\[Hyphen]whisker chart for the values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{BoxWhiskerChart, \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bwspec\", \"TI\"]}], \"]\"}]\) makes a chart with box\[Hyphen]and\[Hyphen]whisker symbol specification \!\(\*StyleBox[\"bwspec\", \"TI\"]\).\n\!\(\*RowBox[{BoxWhiskerChart, \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) makes a chart with box\[Hyphen]and\[Hyphen]whisker symbol for each \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{BoxWhiskerChart, \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) makes a box\[Hyphen]and\[Hyphen]whisker chart from multiple groups of datasets \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
BracketingBar::usage = "\!\(\*RowBox[{\"BracketingBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", \" \", StyleBox[\"y\", \"TI\"], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{\"\[LeftBracketingBar]\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightBracketingBar]\"}]\)."
BrayCurtisDistance::usage = "\!\(\*RowBox[{\"BrayCurtisDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Bray\[Dash]Curtis distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
BreadthFirstScan::usage = "\!\(\*RowBox[{\"BreadthFirstScan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) performs a breadth-first scan (bfs) of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) starting at the vertex \!\(\*StyleBox[\"s\", \"TI\"]\) and evaluates \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) whenever \"\!\(\*SubscriptBox[\nStyleBox[\"event\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\" occurs.\n\!\(\*RowBox[{\"BreadthFirstScan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) performs a breadth-first scan of the whole graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"BreadthFirstScan\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Break::usage = "\!\(\*RowBox[{\"Break\", \"[\", \"]\"}]\) exits the nearest enclosing Do, For, or While. "
BridgeData::usage = "\!\(\*RowBox[{\"BridgeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the bridge \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"BridgeData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified bridge entities.\n\!\(\*RowBox[{\"BridgeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
BroadcastStationData::usage = "\!\(\*RowBox[{\"BroadcastStationData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the broadcast station \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"BroadcastStationData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified broadcast station entities.\n\!\(\*RowBox[{\"BroadcastStationData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
BrownForsytheTest::usage = "\!\(\*RowBox[{\"BrownForsytheTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the variance of \!\(\*StyleBox[\"data\", \"TI\"]\) is 1. \n\!\(\*RowBox[{\"BrownForsytheTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the variances of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"BrownForsytheTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[SubsuperscriptBox[\"\[Sigma]\", \"0\", \"2\"], \"TR\"]}], \"]\"}]\) tests a dispersion measure against \!\(\*StyleBox[SubsuperscriptBox[\"\[Sigma]\", \"0\", \"2\"], \"TR\"]\).\n\!\(\*RowBox[{\"BrownForsytheTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[SubsuperscriptBox[\"\[Sigma]\", \"0\", \"2\"], \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
BrownianBridgeProcess::usage = "\!\(\*RowBox[{\"BrownianBridgeProcess\", \"[\", RowBox[{StyleBox[\"\[Sigma]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents the Brownian bridge process from value \!\(\*StyleBox[\"a\", \"TI\"]\) at time \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to value \!\(\*StyleBox[\"b\", \"TI\"]\) at time \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with volatility \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{RowBox[{\"BrownianBridgeProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}], \" \"}]\) represents the standard Brownian bridge process from value \!\(\*StyleBox[\"a\", \"TI\"]\) at time \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to value \!\(\*StyleBox[\"b\", \"TI\"]\) at time \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{RowBox[{\"BrownianBridgeProcess\", \"[\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}], \" \"}]\) represents the standard Brownian bridge process pinned at 0 at times \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"BrownianBridgeProcess\", \"[\", \"]\"}]\) represents the standard Brownian bridge process pinned at 0 at time 0 and at time 1."
Brown::usage = "Brown represents the color brown in graphics or style specifications. "
BSplineBasis::usage = "\!\(\*RowBox[{\"BSplineBasis\", \"[\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the zeroth uniform B-spline basis function of degree \!\(\*StyleBox[\"d\", \"TI\"]\) at \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"BSplineBasis\", \"[\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) uniform B-spline basis function of degree \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{RowBox[{\"BSplineBasis\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}], \" \"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) non-uniform B-spline basis function of degree \!\(\*StyleBox[\"d\", \"TI\"]\) with knots at positions \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
BSplineCurve3DBoxOptions::usage = "\!\(\*RowBox[{BSplineCurve3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for BSplineCurve3DBox objects."
BSplineCurveBoxOptions::usage = "\!\(\*RowBox[{BSplineCurveBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for BSplineCurveBox objects."
BSplineCurve::usage = "\!\(\*RowBox[{\"BSplineCurve\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a graphics primitive that represents a nonuniform rational B-spline curve with control points \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
BSplineFunction::usage = "\!\(\*RowBox[{\"BSplineFunction\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a B-spline function for a curve defined by the control points \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BSplineFunction\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) represents a B-spline function for a surface or high-dimensional manifold. "
BSplineSurface3DBoxOptions::usage = "\!\(\*RowBox[{BSplineSurface3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for BSplineSurface3DBox objects."
BSplineSurface::usage = "\!\(\*RowBox[{\"BSplineSurface\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) is a graphics primitive that represents a nonuniform rational B-spline surface defined by an array of \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}]\) control points."
BubbleChart3D::usage = "\!\(\*RowBox[{\"BubbleChart3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D bubble chart with bubbles at positions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) with sizes \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BubbleChart3D\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"j\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"j\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D bubble chart with bubble features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"BubbleChart3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D bubble chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
BubbleChart::usage = "\!\(\*RowBox[{\"BubbleChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a bubble chart with bubbles at positions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) with sizes \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BubbleChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"j\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"j\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a bubble chart with bubble features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"BubbleChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a bubble chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
BubbleScale::usage = "BubbleScale is an option to BubbleChart and related functions that specifies how the scale of each bubble should be determined from the value of each data element."
BubbleSizes::usage = "BubbleSizes is an option to BubbleChart and related functions that specifies the range of sizes used for bubbles. "
BuildingData::usage = "\!\(\*RowBox[{\"BuildingData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the building \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"BuildingData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified building entities.\n\!\(\*RowBox[{\"BuildingData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
BulletGauge::usage = "\!\(\*RowBox[{\"BulletGauge\", \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"reference\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) draws a bullet gauge showing \!\(\*StyleBox[\"value\", \"TI\"]\) and \!\(\*StyleBox[\"reference\", \"TI\"]\) in a range of \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"BulletGauge\", \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"reference\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) draws a bullet gauge with performance regions split at the \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"BulletGauge\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) draws a bullet gauge with multiple values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"BulletGauge\", \"[\", RowBox[{StyleBox[\"values\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) draws a bullet gauge with multiple references \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
BusinessDayQ::usage = "\!\(\*RowBox[{\"BusinessDayQ\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) returns True if the date is a business day and returns False otherwise."
ButterflyGraph::usage = "\!\(\*RowBox[{\"ButterflyGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the order-\!\(\*StyleBox[\"n\", \"TI\"]\) butterfly graph. \n\!\(\*RowBox[{\"ButterflyGraph\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the base-\!\(\*StyleBox[\"b\", \"TI\"]\) order-\!\(\*StyleBox[\"n\", \"TI\"]\) butterfly graph. "
ButtonBar::usage = "\!\(\*RowBox[{\"ButtonBar\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \":>\", SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \":>\", SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a bar of buttons with labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that perform actions \!\(\*SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) when pressed."
ButtonBoxOptions::usage = "\!\(\*RowBox[{ButtonBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for ButtonBox."
ButtonBox::usage = "\!\(\*RowBox[{ButtonBox, \"[\", StyleBox[\"boxes\", \"TI\"], \"]\"}]\) is a low-level box construct that represents a button in a notebook expression."
ButtonData::usage = "ButtonData is an option for the low-level function ButtonBox that specifies the second argument to give to the ButtonFunction for the button when the button is active and is clicked. "
ButtonEvaluator::usage = "ButtonEvaluator is an option for the low-level function ButtonBox that specifies where the expression constructed from ButtonFunction should be sent for evaluation. "
ButtonExpandable::usage = "ButtonExpandable is an option for the low-level function ButtonBox that specifies whether the button should expand to fill any GridBox position in which it appears. "
ButtonFrame::usage = "ButtonFrame is an option for the low-level function ButtonBox that specifies the type of frame to display around a button. "
ButtonFunction::usage = "ButtonFunction is an option for the low-level function ButtonBox that specifies the function to execute when the button is active and is clicked. "
ButtonMargins::usage = "ButtonMargins is an option for ButtonBox that specifies how much space in printer's points to leave around the contents of a button when the button is displayed. "
ButtonMinHeight::usage = "ButtonMinHeight is an option for the low-level function ButtonBox that specifies the minimum total height in units of font size that should be allowed for the button. "
ButtonNotebook::usage = "\!\(\*RowBox[{\"ButtonNotebook\", \"[\", \"]\"}]\) gives the notebook, if any, that contains the button which initiated the current evaluation. "
ButtonNote::usage = "ButtonNote is an option for ButtonBox that specifies what should be displayed in the status line of the current notebook window when the button is active and the cursor is placed on top of it. "
ButtonSource::usage = "ButtonSource is an option for the low-level function ButtonBox that specifies the first argument to give to the ButtonFunction for the button when the button is active and is clicked. "
ButtonStyle::usage = "ButtonStyle is an option for ButtonBox that specifies the default properties for the button. "
Button::usage = "\!\(\*RowBox[{\"Button\", \"[\", RowBox[{StyleBox[\"label\", \"TI\"], \",\", StyleBox[\"action\", \"TI\"]}], \"]\"}]\) represents a button that is labeled with \!\(\*StyleBox[\"label\", \"TI\"]\), and evaluates \!\(\*StyleBox[\"action\", \"TI\"]\) whenever it is clicked. "
ByteArrayQ::usage = "\!\(\*RowBox[{\"ByteArrayQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a valid ByteArray object, and False otherwise."
ByteArray::usage = "\!\(\*RowBox[{\"ByteArray\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) constructs a ByteArray object containing the byte values \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ByteArray\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) constructs a ByteArray object by extracting byte values from a Base64-encoded string."
ByteCount::usage = "\!\(\*RowBox[{\"ByteCount\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the number of bytes used internally by \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) to store \!\(\*StyleBox[\"expr\", \"TI\"]\). "
ByteOrdering::usage = "ByteOrdering is an option for BinaryRead, BinaryWrite, and related functions that specifies what ordering of bytes should be assumed for your computer system."
Byte::usage = "Byte represents a single byte of data in Read. "
CachePersistence::usage = "CachePersistence is an option to Delayed and related constructs that specifies how long to keep cached versions of computations that are done."
Calendar`CalendarChange::usage = "\!\(\*RowBox[{\"CalendarChange\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"calendar\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"calendar\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) converts the date \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"]}], \"}\"}]\) given in calendar \!\(\*SubscriptBox[StyleBox[\"calendar\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) into a date given in calendar \!\(\*RowBox[{SubscriptBox[StyleBox[\"calendar\", \"TI\"], StyleBox[\"2\", \"TR\"]], \".\"}]\)\n\!\(\*RowBox[{\"CalendarChange\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"calendar\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"calendar\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) converts the given date \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}]\)."
Calendar`Calendar::usage = "Calendar is an option for calendar functions that specifies which calendar system to use."
CalendarConvert::usage = "\!\(\*RowBox[{\"CalendarConvert\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"calendar\", \"TI\"]}], \"]\"}]\) converts the date object \!\(\*StyleBox[\"date\", \"TI\"]\) to the specified calendar type \!\(\*StyleBox[\"calendar\", \"TI\"]\).\n\!\(\*RowBox[{\"CalendarConvert\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) converts to the default calendar type.\n\!\(\*RowBox[{\"CalendarConvert\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"calendar\", \"TI\"]}], \"]\"}]\) converts \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"n\", \"TI\"]]\) to the specified \!\(\*StyleBox[\"calendar\", \"TI\"]\)."
CalendarData::usage = "\!\(\*RowBox[{\"CalendarData\", \"[\", \"]\"}]\) gives countries with prebuilt calendar schedules.\n\!\(\*RowBox[{\"CalendarData\", \"[\", StyleBox[\"country\", \"TI\"], \"]\"}]\) gives available subspecifications for \!\(\*StyleBox[\"country\", \"TI\"]\)."
Calendar`DateQ::usage = "\!\(\*RowBox[{\"DateQ\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"]}], \"}\"}], \"]\"}]\) yields True if date \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"]}], \"}\"}]\) is a valid date in the current calendar system, and yields False otherwise. \n\!\(\*RowBox[{\"DateQ\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}], \"]\"}]\) date given in long form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}]\)."
Calendar`DayOfWeek::usage = "\!\(\*RowBox[{\"DayOfWeek\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the day of the week on which the given date \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"]}], \"}\"}]\) occurred.\n\!\(\*RowBox[{\"DayOfWeek\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the day of the week for the given date."
Calendar`DaysBetween::usage = "\!\(\*RowBox[{\"DaysBetween\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"year\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"month\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"day\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"year\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"month\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"day\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the number of days between the dates \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"year\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"month\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"day\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]\) and \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"year\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"month\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"day\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"DaysBetween\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"year\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"month\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"day\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"hour\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"minute\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"second\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"year\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"month\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"day\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"hour\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"minute\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"second\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the number of days between the given dates."
Calendar`DaysPlus::usage = "\!\(\*RowBox[{\"DaysPlus\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the date \!\(\*StyleBox[\"n\", \"TI\"]\) days after the date \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"DaysPlus\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the date \!\(\*StyleBox[\"n\", \"TI\"]\) days after the date \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}]\)."
Calendar`EasterSundayGreekOrthodox::usage = "\!\(\*RowBox[{\"EasterSundayGreekOrthodox\", \"[\", StyleBox[\"year\", \"TI\"], \"]\"}]\) gives the date of Easter Sunday according to the Greek Orthodox Church, using the Gregorian system."
Calendar`EasterSunday::usage = "\!\(\*RowBox[{\"EasterSunday\", \"[\", StyleBox[\"year\", \"TI\"], \"]\"}]\) gives the date of Easter Sunday in the Gregorian calendar system."
Calendar`Gregorian::usage = "Gregorian represents the Gregorian calendar system."
Calendar`Islamic::usage = "Islamic represents the Islamic calendar system."
Calendar`JewishNewYear::usage = "\!\(\*RowBox[{\"JewishNewYear\", \"[\", StyleBox[\"year\", \"TI\"], \"]\"}]\) gives the date of the Jewish New Year occurring in Gregorian years."
Calendar`Jewish::usage = "Jewish represents the Jewish calendar system. "
Calendar`Julian::usage = "Julian represents the Julian calendar system."
CalendarType::usage = "CalendarType is an option that determines the calendar system in which all dates are to be interpreted and output."
CallPacket::usage = "\!\(\*RowBox[{\"CallPacket\", \"[\", RowBox[{StyleBox[\"integer\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet encapsulating a request to invoke the external function numbered \!\(\*StyleBox[\"integer\", \"TI\"]\) with the arguments contained in \!\(\*StyleBox[\"list\", \"TI\"]\)."
CanberraDistance::usage = "\!\(\*RowBox[{\"CanberraDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Canberra distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
CancelButton::usage = "\!\(\*RowBox[{\"CancelButton\", \"[\", \"]\"}]\) represents a \!\(\*StyleBox[\"Cancel\", \"DialogElementName\"]\) button in a dialog that closes the dialog window when clicked.\n\!\(\*RowBox[{\"CancelButton\", \"[\", StyleBox[\"action\", \"TI\"], \"]\"}]\) represents a button labeled \!\(\*StyleBox[\"Cancel\", \"DialogElementName\"]\) that evaluates \!\(\*StyleBox[\"action\", \"TI\"]\) when clicked.\n\!\(\*RowBox[{\"CancelButton\", \"[\", RowBox[{StyleBox[\"label\", \"TI\"], \",\", StyleBox[\"action\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"label\", \"TI\"]\) as the label for the button."
Cancel::usage = "\!\(\*RowBox[{\"Cancel\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) cancels out common factors in the numerator and denominator of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
CandlestickChart::usage = "\!\(\*RowBox[{\"CandlestickChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"open\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"high\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"low\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"close\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a chart with candles representing open, high, low, and close prices for each date. \n\!\(\*RowBox[{\"CandlestickChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"daterange\", \"TI\"]}], StyleBox[\"}\", \"TI\"]}], \"]\"}]\) makes a candlestick chart for the financial entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" over the date range \!\(\*StyleBox[\"daterange\", \"TI\"]\). "
CanonicalGraph::usage = "\!\(\*RowBox[{\"CanonicalGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a canonical graph of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"CanonicalGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
CanonicalName::usage = "\!\(\*RowBox[{\"CanonicalName\", \"[\", StyleBox[\"entity\", \"TI\"], \"]\"}]\) gives the canonical name for the entity specified by \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"CanonicalName\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the canonical name for \!\(\*SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
CantorStaircase::usage = "\!\(\*RowBox[{\"CantorStaircase\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the Cantor staircase function \!\(\*RowBox[{SubscriptBox[StyleBox[\"F\", \"TI\"], StyleBox[\"C\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\)."
CapForm::usage = "\!\(\*RowBox[{\"CapForm\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) is a graphics primitive that specifies what type of caps should be used at the ends of lines, tubes, and related primitives."
CapitalDifferentialD::usage = "\!\(\*RowBox[{\"CapitalDifferentialD\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) displays as \!\(\*RowBox[{\"\[CapitalDifferentialD]\", StyleBox[\"x\", \"TI\"]}]\)."
Capitalize::usage = "\!\(\*RowBox[{\"Capitalize\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) yields a string in which the first character has been made upper case."
CapsuleShape::usage = "\!\(\*RowBox[{\"CapsuleShape\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents the filled capsule between points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) and radius \!\(\*StyleBox[\"r\", \"TI\"]\)."
Cap::usage = "\!\(\*RowBox[{\"Cap\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Cap]\", StyleBox[\"y\", \"TI\"], \"\[Cap]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
CarlemanLinearize::usage = "\!\(\*RowBox[{\"CarlemanLinearize\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"]}], \"]\"}]\) Carleman linearizes the nonlinear state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\) according to \!\(\*StyleBox[\"spec\", \"TI\"]\)."
CarmichaelLambda::usage = "\!\(\*RowBox[{\"CarmichaelLambda\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Carmichael function \!\(\*RowBox[{\"\[Lambda]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\), defined as the smallest integer \!\(\*StyleBox[\"m\", \"TI\"]\) such that \!\(\*RowBox[{SuperscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"\[Congruent]\", RowBox[{\"1\", \"mod\", \" \", StyleBox[\"n\", \"TI\"]}]}]\) for all \!\(\*StyleBox[\"k\", \"TI\"]\) relatively prime to \!\(\*StyleBox[\"n\", \"TI\"]\). "
CaseOrdering::usage = "CaseOrdering is an option for AlphabeticSort and related functions that specifies how upper versus lower case should be sorted."
CaseSensitive::usage = "\!\(\*RowBox[{\"CaseSensitive\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) represents a string pattern that requires matching typographical case, even with the overall option setting \!\(\*RowBox[{\"IgnoreCase\", \"->\", \"True\"}]\)."
Cases::usage = "\!\(\*RowBox[{\"Cases\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) gives a list of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that match the pattern. \n\!\(\*RowBox[{\"Cases\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{StyleBox[\"pattern\", \"TI\"], \"\[Rule]\", StyleBox[\"rhs\", \"TI\"]}]}], \"]\"}]\) gives a list of the values of \!\(\*StyleBox[\"rhs\", \"TI\"]\) corresponding to the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that match the pattern. \n\!\(\*RowBox[{\"Cases\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) gives a list of all parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) on levels specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\) that match the pattern. \n\!\(\*RowBox[{\"Cases\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"pattern\", \"TI\"], \"\[Rule]\", StyleBox[\"rhs\", \"TI\"]}], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) gives the values of \!\(\*StyleBox[\"rhs\", \"TI\"]\) that match the pattern. \n\!\(\*RowBox[{\"Cases\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"n\", \"TI\"]\) parts in \!\(\*StyleBox[\"expr\", \"TI\"]\) that match the pattern. \n\!\(\*RowBox[{\"Cases\", \"[\", StyleBox[\"pattern\", \"TI\"], \"]\"}]\) represents an operator form of Cases that can be applied to an expression."
Cashflow::usage = "\!\(\*RowBox[{\"Cashflow\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents a series of cash flows occurring at unit time intervals.\n\!\(\*RowBox[{\"Cashflow\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents cash flows occurring at time intervals \!\(\*StyleBox[\"q\", \"TI\"]\).\n\!\(\*RowBox[{\"Cashflow\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"time\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"time\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents cash flows occurring at the specified times."
Casoratian::usage = "\!\(\*RowBox[{\"Casoratian\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the Casoratian determinant for the sequences \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] depending on \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"Casoratian\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the Casoratian determinant for the basis of the solutions of the linear difference equation \!\(\*StyleBox[\"eqn\", \"TI\"]\) involving \!\(\*RowBox[{StyleBox[\"y\", \"TI\"], \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \"+\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\). \n\!\(\*RowBox[{\"Casoratian\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the Casoratian determinant for the system of linear difference equations \!\(\*StyleBox[\"eqns\", \"TI\"]\)."
CatalanNumber::usage = "\!\(\*RowBox[{\"CatalanNumber\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) Catalan number \!\(\*SubscriptBox[StyleBox[\"C\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
Catalan::usage = "Catalan is Catalan's constant, with numerical value \!\(\*RowBox[{\"\[TildeEqual]\", \"0.915966\"}]\). "
Catch::usage = "\!\(\*RowBox[{\"Catch\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the argument of the first Throw generated in the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Catch\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) returns \!\(\*StyleBox[\"value\", \"TI\"]\) from the first \!\(\*RowBox[{\"Throw\", \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) for which \!\(\*StyleBox[\"form\", \"TI\"]\) matches \!\(\*StyleBox[\"tag\", \"TI\"]\). \n\!\(\*RowBox[{\"Catch\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) returns \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\). "
Catenate::usage = "\!\(\*RowBox[{\"Catenate\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) yields a single list with all elements from the \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in order. \n\!\(\*RowBox[{\"Catenate\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) yields a list of all values in order appearing in the associations \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
CauchyDistribution::usage = "\!\(\*RowBox[{\"CauchyDistribution\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) represents a Cauchy distribution with location parameter \!\(\*StyleBox[\"a\", \"TI\"]\) and scale parameter \!\(\*StyleBox[\"b\", \"TI\"]\).\n\!\(\*RowBox[{\"CauchyDistribution\", \"[\", \"]\"}]\) represents a Cauchy distribution with location parameter 0 and scale parameter 1."
CauchyWindow::usage = "\!\(\*RowBox[{\"CauchyWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Cauchy window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"CauchyWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
CayleyGraph::usage = "\!\(\*RowBox[{\"CayleyGraph\", \"[\", StyleBox[\"group\", \"TI\"], \"]\"}]\) returns a Cayley graph representation of \!\(\*StyleBox[\"group\", \"TI\"]\)."
CCodeGenerator`CCodeGenerate::usage = "\!\(\*RowBox[{\"CCodeGenerate\", \"[\", RowBox[{StyleBox[\"cfun\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) generates C code from the compiled function \!\(\*StyleBox[\"cfun\", \"TI\"]\) using the name as the exported function \!\(\*StyleBox[\"name\", \"TI\"]\), and saves in the file \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \".\", \"c\"}]\).\n\!\(\*RowBox[{\"CCodeGenerate\", \"[\", RowBox[{StyleBox[\"cfun\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"filename\", \"TI\"]}], \"]\"}]\) generates output in \!\(\*StyleBox[\"filename\", \"TI\"]\). \n\!\(\*RowBox[{\"CCodeGenerate\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"cfun\", \"TI\"], StyleBox[\"1\", FontSlant -> \"Plain\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"cfun\", \"TI\"], StyleBox[\"2\", FontSlant -> \"Plain\"]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", \" \", RowBox[{StyleBox[SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", FontSlant -> \"Plain\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", FontSlant -> \"Plain\"]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"filename\", \"TI\"]}], \"]\"}]\) generates C code from several compiled functions and saves in \!\(\*StyleBox[\"filename\", \"TI\"]\)."
CCodeGenerator`CCodeStringGenerate::usage = "\!\(\*RowBox[{\"CCodeStringGenerate\", \"[\", RowBox[{StyleBox[\"cfun\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) generates C code from the compiled function \!\(\*StyleBox[\"cfun\", \"TI\"]\) using the name as the exported function \!\(\*StyleBox[\"name\", \"TI\"]\)."
CCodeGenerator`LibraryGenerate::usage = "\!\(\*RowBox[{\"LibraryGenerate\", \"[\", RowBox[{StyleBox[\"cfun\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) generates a shared library from the compiled function \!\(\*StyleBox[\"cfun\", \"TI\"]\) using the name as the exported function \!\(\*StyleBox[\"name\", \"TI\"]\)."
CCodeGenerator`SymbolicCGenerate::usage = "\!\(\*RowBox[{\"SymbolicCGenerate\", \"[\", RowBox[{StyleBox[\"cfun\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) generates symbolic C from the compiled function \!\(\*StyleBox[\"cfun\", \"TI\"]\) using name as the exported function \!\(\*StyleBox[\"name\", \"TI\"]\)."
CCompilerDriver`CCompilers::usage = "\!\(\*RowBox[{\"CCompilers\", \"[\", \"]\"}]\) returns the list of C compilers supported for this version of \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\)\!\(\*StyleBox[\" \", FontSlant -> \"Italic\"]\)that can be found on your system.\n\!\(\*RowBox[{\"CCompilers\", \"[\", \"Full\", \"]\"}]\) returns the list of all C compilers supported for this version of \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\)\!\(\*StyleBox[\" \", FontSlant -> \"Italic\"]\)(but which may not actually be installed). "
CCompilerDriver`CreateExecutable::usage = "\!\(\*RowBox[{\"CreateExecutable\", \"[\", RowBox[{StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) compiles a string of C code and creates an executable file, \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \".\", StyleBox[\"ext\", \"TI\"]}]\).\n\!\(\*RowBox[{\"CreateExecutable\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"1\", FontSlant -> \"Plain\"]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) compiles a number of C and mprep source files and creates an executable file, \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \".\", StyleBox[\"ext\", \"TI\"]}]\)."
CCompilerDriver`CreateLibrary::usage = "\!\(\*RowBox[{\"CreateLibrary\", \"[\", RowBox[{StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) compiles a string of C code and creates a library file, \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \".\", StyleBox[\"ext\", \"TI\"]}]\).\n\!\(\*RowBox[{\"CreateLibrary\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"1\", FontSlant -> \"Plain\"]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) compiles a number of C source files and creates a library file, \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \".\", StyleBox[\"ext\", \"TI\"]}]\)."
CCompilerDriver`CreateObjectFile::usage = "\!\(\*RowBox[{\"CreateObjectFile\", \"[\", RowBox[{StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) compiles a string of C code and creates an object file, \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \".\", StyleBox[\"ext\", \"TI\"]}]\).\n\!\(\*RowBox[{\"CreateObjectFile\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"file\", \"TI\"], \"}\"}], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) compiles a C source file and creates an object file, \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \".\", StyleBox[\"ext\", \"TI\"]}]\)."
CCompilerDriver`$CCompilerDefaultDirectory::usage = "$CCompilerDefaultDirectory returns the default location for creating output."
CCompilerDriver`$CCompiler::usage = "$CCompiler sets the default C compiler to use for operating on C code."
CDFDeploy::usage = "\!\(\*RowBox[{\"CDFDeploy\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).cdf\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) deploys \!\(\*StyleBox[\"expr\", \"TI\"]\) in a form that can be played by Wolfram\!\(\*StyleBox[\" CDF Player\", FontSlant -> \"Italic\"]\).\n\!\(\*RowBox[{\"CDFDeploy\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).cdf\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"notebook\", \"TI\"]}], \"]\"}]\) deploys a notebook.\n\!\(\*RowBox[{\"CDFDeploy\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).cdf\\\"\",ShowStringCharacters->True], \",\", RowBox[{\"NotebookSelection\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]}], \"]\"}]\) deploys the current selection in \!\(\*StyleBox[\"notebook\", \"TI\"]\).\n\!\(\*RowBox[{\"CDFDeploy\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"outfile\\\",\\\"TI\\\"]\\).cdf\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"infile\\\",\\\"TI\\\"]\\).nb\\\"\",ShowStringCharacters->True]}], \"]\"}]\) deploys the notebook \"\!\(\*\nStyleBox[\"infile\", \"TI\"]\).nb\"."
CDFInformation::usage = "\!\(\*RowBox[{\"CDFInformation\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives a list of properties relevant to a CDF deployed with the content \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"CDFInformation\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) gives usage properties for a CDF to be deployed from the given notebook.\n\!\(\*RowBox[{\"CDFInformation\", \"[\", RowBox[{\"NotebookSelection\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}], \"]\"}]\) gives CDF usage properties for only the selected cells in the given notebook.\n\!\(\*RowBox[{\"CDFInformation\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives CDF usage properties for the named notebook or CDF file."
CDF::usage = "\!\(\*RowBox[{\"CDF\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the cumulative distribution function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) evaluated at \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"CDF\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multivariate cumulative distribution function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) evaluated at \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"CDF\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the CDF as a pure function."
CDFWavelet::usage = "\!\(\*RowBox[{\"CDFWavelet\", \"[\", \"]\"}]\) represents a Cohen\[Dash]Daubechies\[Dash]Feauveau wavelet of type \"9/7\". \n\!\(\*RowBox[{\"CDFWavelet\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents a Cohen\[Dash]Daubechies\[Dash]Feauveau wavelet of type \"\!\(\*\nStyleBox[\"type\", \"TI\"]\)\". "
Ceiling::usage = "\!\(\*RowBox[{\"Ceiling\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the smallest integer greater than or equal to \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Ceiling\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives the smallest multiple of \!\(\*StyleBox[\"a\", \"TI\"]\) greater than or equal to \!\(\*StyleBox[\"x\", \"TI\"]\). "
CelestialSystem::usage = "CelestialSystem is an option for SunPosition, MoonPosition, and related functions that specifies the coordinate system to use for the results."
CellAutoOverwrite::usage = "CellAutoOverwrite is an option for Cell which specifies whether an output cell should be overwritten by new output when the preceding input cell is evaluated. "
CellBaseline::usage = "CellBaseline is an option for Cell which specifies where the baseline of the cell should be assumed to be when it appears inside another cell. "
CellBracketOptions::usage = "\!\(\*RowBox[{\"CellBracketOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for cells that specifies settings for cell brackets."
CellChangeTimes::usage = "CellChangeTimes is an option to Cell that specifies when changes were made to the cell."
CellContext::usage = "CellContext is an option for Cell which specifies the context to use for the evaluation of the contents of the cell."
CellDingbat::usage = "CellDingbat is an option for Cell which specifies what dingbat to use to emphasize a cell. "
CellDynamicExpression::usage = "CellDynamicExpression is an option for cells that specifies an expression to be dynamically updated whenever the cell is visible on-screen."
CellEditDuplicate::usage = "CellEditDuplicate is an option for Cell which specifies whether the front end should make a copy of the cell before actually applying any changes in its contents that you request. "
CellEpilog::usage = "CellEpilog is an option for Cell which gives an expression to evaluate after each ordinary evaluation of the contents of the cell."
CellEvaluationDuplicate::usage = "CellEvaluationDuplicate is an option for Cell which specifies whether the front end should make a copy of the cell before performing any evaluation of its contents that you request. "
CellEvaluationFunction::usage = "CellEvaluationFunction is an option for Cell that gives a function to be applied to every expression from the cell that is sent to the kernel for ordinary evaluation. "
CellEventActions::usage = "CellEventActions is an option for Cell that gives a list of actions to perform when specified events occur in connection with a cell in a notebook. "
CellFrameColor::usage = "CellFrameColor is an option that specifies the color of the frame around a cell."
CellFrameLabelMargins::usage = "CellFrameLabelMargins is an option for cells that specifies the absolute margins in printer's points between a cell's frame and the labels around the frame."
CellFrameLabels::usage = "CellFrameLabels is an option that specifies the labels associated with the frame around a cell."
CellFrameMargins::usage = "CellFrameMargins is an option for Cell that specifies the absolute margins in printer\[CloseCurlyQuote]s points to leave inside a frame that is drawn around a cell. "
CellFrame::usage = "CellFrame is an option for Cell that specifies whether a frame should be drawn around a cell. "
CellGroupData::usage = "\!\(\*RowBox[{\"CellGroupData\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a low-level construct that represents an open group of cells in a notebook. \n\!\(\*RowBox[{\"CellGroupData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"1\"}], \"]\"}]\) represents a cell group in which only the first cell is open.\n\!\(\*RowBox[{\"CellGroupData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a cell group with cells at positions \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] open. "
CellGroupingRules::usage = "CellGroupingRules is an option for cells that specifies the rules used for grouping a cell."
CellGrouping::usage = "CellGrouping is a notebook option that specifies how cells in the notebook should be assembled into groups. "
CellGroup::usage = "\!\(\*RowBox[{\"CellGroup\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives an open group of cells that can appear in a \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) notebook.\n\!\(\*RowBox[{\"CellGroup\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"1\"}], \"]\"}]\) gives a cell group in which only the first cell is open.\n\!\(\*RowBox[{\"CellGroup\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"-\", \"1\"}]}], \"]\"}]\) gives a cell group in which only the last cell is open.\n\!\(\*RowBox[{\"CellGroup\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a cell group in which cells \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] are open. "
CellHorizontalScrolling::usage = "CellHorizontalScrolling is an option for cells that specifies whether the contents of a cell can be scrolled from left to right using the horizontal scroll bar of the notebook."
CellID::usage = "CellID is an option for Cell that specifies a unique ID number for a cell."
CellLabelAutoDelete::usage = "CellLabelAutoDelete is an option for Cell which specifies whether a label for the cell should be automatically deleted if the contents of the cell are modified or the notebook containing the cell is saved in a file. "
CellLabelMargins::usage = "CellLabelMargins is an option for cells that specifies the absolute margins in printer's points around a cell label."
CellLabelPositioning::usage = "CellLabelPositioning is an option for cells that specifies where the label for a cell is positioned."
CellLabel::usage = "CellLabel is an option for Cell which gives the label to use for a particular cell. "
CellMargins::usage = "CellMargins is an option for Cell that specifies the absolute margins in printer's points to leave around a cell. "
CellObject::usage = "\!\(\*RowBox[{\"CellObject\", \"[\", StyleBox[\"id\", \"TI\"], \"]\"}]\) is an object that represents a cell in an open notebook in the front end."
CellOpen::usage = "CellOpen is an option for Cell that specifies whether the contents of a cell should be explicitly displayed. "
CellPrint::usage = "\!\(\*RowBox[{\"CellPrint\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) inserts \!\(\*StyleBox[\"expr\", \"TI\"]\) as a complete cell in the current notebook just below the cell being evaluated. \n\!\(\*RowBox[{\"CellPrint\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) inserts a sequence of cells. "
CellProlog::usage = "CellProlog is an option to Cell that gives an expression to evaluate before each ordinary evaluation of the contents of the cell."
CellSize::usage = "CellSize is an option for cells that specifies the width and height of an inline cell."
CellStyle::usage = "CellStyle is a setting for functions such as NotebookFind and Cells that specifies the name of a cell style to search for in a notebook."
Cells::usage = "\!\(\*RowBox[{\"Cells\", \"[\", \"]\"}]\) returns a list of CellObject expressions corresponding to cells in the current notebook.\n\!\(\*RowBox[{\"Cells\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) returns the list of CellObject expressions in \!\(\*StyleBox[\"obj\", \"TI\"]\).\n\!\(\*RowBox[{\"Cells\", \"[\", RowBox[{\"NotebookSelection\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}], \"]\"}]\) returns the list of CellObject expressions for currently selected cells."
CellTags::usage = "CellTags is an option for Cell that gives a list of tags to associate with a cell. "
CellularAutomaton::usage = "\!\(\*RowBox[{\"CellularAutomaton\", \"[\", RowBox[{StyleBox[\"rule\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) generates a list representing the evolution of the cellular automaton with the specified rule from initial condition \!\(\*StyleBox[\"init\", \"TI\"]\) for \!\(\*StyleBox[\"t\", \"TI\"]\) steps. \n\!\(\*RowBox[{\"CellularAutomaton\", \"[\", RowBox[{StyleBox[\"rule\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) gives the result of evolving \!\(\*StyleBox[\"init\", \"TI\"]\) for one step. \n\!\(\*RowBox[{\"CellularAutomaton\", \"[\", RowBox[{StyleBox[\"rule\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"tspec\", \"TI\"], \",\", StyleBox[\"xspec\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives only those parts of the evolution specified by \!\(\*StyleBox[\"tspec\", \"TI\"]\), \!\(\*StyleBox[\"xspec\", \"TI\"]\), etc. \n\!\(\*RowBox[{\"CellularAutomaton\", \"[\", RowBox[{StyleBox[\"rule\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", \"All\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) includes at each step all cells that could be affected over the course of \!\(\*StyleBox[\"t\", \"TI\"]\) steps. \n\!\(\*RowBox[{\"CellularAutomaton\", \"[\", StyleBox[\"rule\", \"TI\"], \"]\"}]\) is an operator form of CellularAutomaton that corresponds to one step of evolution."
Cell::usage = "\!\(\*RowBox[{\"Cell\", \"[\", StyleBox[\"contents\", \"TI\"], \"]\"}]\) is the low-level representation of a cell inside a \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) notebook. \n\!\(\*RowBox[{\"Cell\", \"[\", RowBox[{StyleBox[\"contents\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents a cell in the specified style."
CensoredDistribution::usage = "\!\(\*RowBox[{\"CensoredDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) represents the distribution of values that come from \!\(\*StyleBox[\"dist\", \"TI\"]\) and are censored to be between \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"CensoredDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) represents the distribution of values that come from the multivariate distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) and are censored to be between \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]\), etc."
Censoring::usage = "\!\(\*RowBox[{\"Censoring\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents a censored event time \!\(\*StyleBox[\"t\", \"TI\"]\) with censoring \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"Censoring\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents a vector of censored event times \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with censoring \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"Censoring\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a vector of event times \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with corresponding censoring \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
CenterDot::usage = "\!\(\*RowBox[{\"CenterDot\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[CenterDot]\", StyleBox[\"y\", \"TI\"], \"\[CenterDot]\", \"\[Ellipsis]\"}]\)."
Center::usage = "Center is a symbol that represents the center for purposes of alignment and positioning. "
CentralMomentGeneratingFunction::usage = "\!\(\*RowBox[{\"CentralMomentGeneratingFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the central moment-generating function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variable \!\(\*StyleBox[\"t\", \"TI\"]\). \n\!\(\*RowBox[{\"CentralMomentGeneratingFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the central moment-generating function for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variables \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. "
CentralMoment::usage = "\!\(\*RowBox[{\"CentralMoment\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) central moment of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\) with respect to their mean.\n\!\(\*RowBox[{\"CentralMoment\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) central moment of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"CentralMoment\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) represents the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) formal central moment. "
CForm::usage = "\!\(\*RowBox[{\"CForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as a C language version of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
ChampernowneNumber::usage = "\!\(\*RowBox[{\"ChampernowneNumber\", \"[\", StyleBox[\"b\", \"TI\"], \"]\"}]\) gives the base-\!\(\*StyleBox[\"b\", \"TI\"]\) Champernowne number \!\(\*SubscriptBox[StyleBox[\"C\", \"TI\"], StyleBox[\"b\", \"TI\"]]\).\n\!\(\*RowBox[{\"ChampernowneNumber\", \"[\", \"]\"}]\) gives the base-10 Champernowne number."
ChanVeseBinarize::usage = "\!\(\*RowBox[{\"ChanVeseBinarize\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds a two-level segmentation of \!\(\*StyleBox[\"image\", \"TI\"]\) by computing optimal contours around regions of consistent intensity in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ChanVeseBinarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"marker\", \"TI\"]\) to create an initial contour.\n\!\(\*RowBox[{\"ChanVeseBinarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) specify the Chan-Vese weights \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\), \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\), and \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
CharacterCounts::usage = "\!\(\*RowBox[{\"CharacterCounts\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives an association whose keys are the distinct characters in \!\(\*StyleBox[\"string\", \"TI\"]\), and whose values give the number of times those characters appear in \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"CharacterCounts\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives counts of the distinct \!\(\*StyleBox[\"n\", \"TI\"]\)-grams consisting of runs of \!\(\*StyleBox[\"n\", \"TI\"]\) characters in \!\(\*StyleBox[\"string\", \"TI\"]\)."
CharacterEncodingsPath::usage = "CharacterEncodingsPath is a global option that specifies which directories are searched for character encoding files."
CharacterEncoding::usage = "CharacterEncoding is an option for input and output functions which specifies what raw character encoding should be used. "
CharacteristicFunction::usage = "\!\(\*RowBox[{\"CharacteristicFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the characteristic function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variable \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"CharacteristicFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the characteristic function for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variables \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] ."
CharacteristicPolynomial::usage = "\!\(\*RowBox[{\"CharacteristicPolynomial\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the characteristic polynomial for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"CharacteristicPolynomial\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the generalized characteristic polynomial with respect to \!\(\*StyleBox[\"a\", \"TI\"]\). "
CharacterName::usage = "\!\(\*RowBox[{\"CharacterName\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"c\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the name of the character \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"CharacterName\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the name of the character with character code \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"CharacterName\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a name of the specified type."
CharacterRange::usage = "\!\(\*RowBox[{\"CharacterRange\", \"[\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields a list of the characters in the range from \"\!\(\*SubscriptBox[\nStyleBox[\"c\", \"TI\"], \nStyleBox[\"1\", \"TR\"]]\)\" to \"\!\(\*SubscriptBox[\nStyleBox[\"c\", \"TI\"], \nStyleBox[\"2\", \"TR\"]]\)\". \n\!\(\*RowBox[{\"CharacterRange\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields a list of the characters with character codes in the range \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \".\"}]\)"
Characters::usage = "\!\(\*RowBox[{\"Characters\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the characters in a string. "
Character::usage = "Character represents a single character in Read. "
ChartBaseStyle::usage = "ChartBaseStyle is an option for charting functions that specifies the base style for all chart elements."
ChartElementFunction::usage = "ChartElementFunction is an option for charting functions such as BarChart that gives a function to use to generate the primitives for rendering each chart element."
ChartElements::usage = "ChartElements is an option to charting functions such as BarChart that specifies the graphics to use as the basis for bars or other chart elements. "
ChartLabels::usage = "ChartLabels is an option for charting functions that specifies what labels should be used for chart elements."
ChartLayout::usage = "ChartLayout is an option to charting functions which specifies the overall layout to use."
ChartLegends::usage = "ChartLegends is an option for charting functions that specifies what legends should be used for chart elements. "
ChartStyle::usage = "ChartStyle is an option for charting functions that specifies styles in which chart elements should be drawn."
Chebyshev1FilterModel::usage = "\!\(\*RowBox[{\"Chebyshev1FilterModel\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) creates a lowpass Chebyshev type 1 filter of order \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"Chebyshev1FilterModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"}\"}], \"]\"}]\) uses the cutoff frequency \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]\).\n\!\(\*RowBox[{\"Chebyshev1FilterModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \"]\"}]\) creates a filter of a given \"\!\(\*\nStyleBox[\"type\", \"TI\"]\)\" using the specified parameters \!\(\*StyleBox[\"spec\", \"TI\"]\). \n\!\(\*RowBox[{\"Chebyshev1FilterModel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) expresses the model in terms of the variable \!\(\*StyleBox[\"var\", \"TI\"]\)."
Chebyshev2FilterModel::usage = "\!\(\*RowBox[{\"Chebyshev2FilterModel\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) creates a lowpass Chebyshev type 2 filter of order \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"Chebyshev2FilterModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"}\"}], \"]\"}]\) uses the cutoff frequency \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]\).\n\!\(\*RowBox[{\"Chebyshev2FilterModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \"]\"}]\) uses the full filter specification \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"Chebyshev2FilterModel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) expresses the model in terms of the variable \!\(\*StyleBox[\"var\", \"TI\"]\)."
ChebyshevDistance::usage = "\!\(\*RowBox[{\"ChebyshevDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Chebyshev or sup norm distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
ChebyshevT::usage = "\!\(\*RowBox[{\"ChebyshevT\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Chebyshev polynomial of the first kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"T\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
ChebyshevU::usage = "\!\(\*RowBox[{\"ChebyshevU\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Chebyshev polynomial of the second kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"U\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
CheckAbort::usage = "\!\(\*RowBox[{\"CheckAbort\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"failexpr\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), returning \!\(\*StyleBox[\"failexpr\", \"TI\"]\) if an abort occurs. "
CheckAll::usage = "\!\(\*RowBox[{\"CheckAll\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) evaluates expr and returns \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"HoldComplete\", \"[\", RowBox[{SubscriptBox[StyleBox[\"control\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]}], \"]\"}]\) where the \!\(\*SubscriptBox[StyleBox[\"control\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) expressions are aborts, throws, or other flow control commands currently being executed (but stopped by CheckAll)."
CheckboxBar::usage = "\!\(\*RowBox[{\"CheckboxBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a checkbox bar with setting \!\(\*StyleBox[\"x\", \"TI\"]\) and with checkboxes for values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to include in the list \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"CheckboxBar\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the values in the list \!\(\*StyleBox[\"x\", \"TI\"]\) being reset every time a checkbox is clicked.\n\!\(\*RowBox[{\"CheckboxBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a checkbox bar in which the checkbox associated with value \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) has label \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
CheckboxBoxOptions::usage = "\!\(\*RowBox[{CheckboxBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for CheckboxBox objects."
Checkbox::usage = "\!\(\*RowBox[{\"Checkbox\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a checkbox with setting \!\(\*StyleBox[\"x\", \"TI\"]\), displayed as \!\(\*CheckboxBox[True]\) when \!\(\*StyleBox[\"x\", \"TI\"]\) is True and \!\(\*CheckboxBox[False]\) when \!\(\*StyleBox[\"x\", \"TI\"]\) is False. \n\!\(\*RowBox[{\"Checkbox\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being toggled if the checkbox is clicked. \n\!\(\*RowBox[{\"Checkbox\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents a checkbox that toggles between values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and displays as \!\(\*CheckboxBox[False]\) and \!\(\*CheckboxBox[True]\) respectively. \n\!\(\*RowBox[{\"Checkbox\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a checkbox that cycles through values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and displays as \!\(\*CheckboxBox[3, {1, 2, 3}]\) for all \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \">\", \"2\"}]\). "
Check::usage = "\!\(\*RowBox[{\"Check\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"failexpr\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), and returns the result, unless messages were generated, in which case it evaluates and returns \!\(\*StyleBox[\"failexpr\", \"TI\"]\). \n\!\(\*RowBox[{\"Check\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"failexpr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"::\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"::\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) checks only for the specified messages. \n\!\(\*RowBox[{\"Check\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"failexpr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) checks only for messages in the named message group."
ChemicalData::usage = "\!\(\*RowBox[{\"ChemicalData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the chemical \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"ChemicalData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a structure diagram for the chemical with the specified name.\n\!\(\*RowBox[{\"ChemicalData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"class\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of available chemicals in the specified class."
ChessboardDistance::usage = "\!\(\*RowBox[{\"ChessboardDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the chessboard, Chebyshev, or sup norm distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
ChiDistribution::usage = "\!\(\*RowBox[{\"ChiDistribution\", \"[\", StyleBox[\"\[Nu]\", \"TR\"], \"]\"}]\) represents a \[Chi] distribution with \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom."
ChineseRemainder::usage = "\!\(\*RowBox[{\"ChineseRemainder\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the smallest non\[Hyphen]negative \!\(\*StyleBox[\"x\", \"TI\"]\) that satisfies all the integer congruences \!\(\*StyleBox[\"x\", \"TI\"]\) mod \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) = \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) mod \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ChiSquareDistribution::usage = "\!\(\*RowBox[{\"ChiSquareDistribution\", \"[\", StyleBox[\"\[Nu]\", \"TR\"], \"]\"}]\) represents a \!\(\*SuperscriptBox[\"\[Chi]\", \"2\"]\) distribution with \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom."
ChoiceButtons::usage = "\!\(\*RowBox[{\"ChoiceButtons\", \"[\", \"]\"}]\) represents a pair of \!\(\*StyleBox[\"OK\", \"MenuName\"]\) and \!\(\*StyleBox[\"Cancel\", \"MenuName\"]\) buttons that close a dialog.\n\!\(\*RowBox[{\"ChoiceButtons\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"ok\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"cancel\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents \!\(\*StyleBox[\"OK\", \"MenuName\"]\) and \!\(\*StyleBox[\"Cancel\", \"MenuName\"]\) buttons that evaluate the corresponding \!\(\*SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) when clicked.\n\!\(\*RowBox[{\"ChoiceButtons\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"ok\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"cancel\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"ok\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"cancel\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) uses the \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to label the buttons."
ChoiceDialog::usage = "\!\(\*RowBox[{\"ChoiceDialog\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) puts up a standard choice dialog that displays \!\(\*StyleBox[\"expr\", \"TI\"]\) together with \!\(\*StyleBox[\"OK\", \"DialogElementName\"]\) and \!\(\*StyleBox[\"Cancel\", \"DialogElementName\"]\) buttons, and returns True if \!\(\*StyleBox[\"OK\", \"DialogElementName\"]\) is clicked and False if \!\(\*StyleBox[\"Cancel\", \"DialogElementName\"]\) is clicked.\n\!\(\*RowBox[{\"ChoiceDialog\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) includes buttons with labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and returns the corresponding \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for the button clicked."
CholeskyDecomposition::usage = "\!\(\*RowBox[{\"CholeskyDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the Cholesky decomposition of a matrix \!\(\*StyleBox[\"m\", \"TI\"]\). "
Chop::usage = "\!\(\*RowBox[{\"Chop\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) replaces approximate real numbers in \!\(\*StyleBox[\"expr\", \"TI\"]\) that are close to zero by the exact integer 0. "
ChromaticityPlot3D::usage = "\!\(\*RowBox[{\"ChromaticityPlot3D\", \"[\", StyleBox[\"colspace\", \"TI\"], \"]\"}]\) returns a 3D gamut of the color space \!\(\*StyleBox[\"colspace\", \"TI\"]\).\n\!\(\*RowBox[{\"ChromaticityPlot3D\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) plots the specific \!\(\*StyleBox[\"color\", \"TI\"]\).\n\!\(\*RowBox[{\"ChromaticityPlot3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots multiple colors and color spaces.\n\!\(\*RowBox[{\"ChromaticityPlot3D\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) plots the pixels of \!\(\*StyleBox[\"image\", \"TI\"]\) as individual colors.\n\!\(\*RowBox[{\"ChromaticityPlot3D\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"refcolspace\", \"TI\"]}], \"]\"}]\) uses the reference color space \!\(\*StyleBox[\"refcolspace\", \"TI\"]\)."
ChromaticityPlot::usage = "\!\(\*RowBox[{\"ChromaticityPlot\", \"[\", StyleBox[\"colspace\", \"TI\"], \"]\"}]\) plots a 2D slice of the color space \!\(\*StyleBox[\"colspace\", \"TI\"]\). \n\!\(\*RowBox[{\"ChromaticityPlot\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) plots the specific \!\(\*StyleBox[\"color\", \"TI\"]\).\n\!\(\*RowBox[{\"ChromaticityPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots multiple colors and color spaces.\n\!\(\*RowBox[{\"ChromaticityPlot\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) plots the pixels of \!\(\*StyleBox[\"image\", \"TI\"]\) as individual colors.\n\!\(\*RowBox[{\"ChromaticityPlot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"refcolspace\", \"TI\"]}], \"]\"}]\) uses the reference color space \!\(\*StyleBox[\"refcolspace\", \"TI\"]\)."
ChromaticPolynomial::usage = "\!\(\*RowBox[{\"ChromaticPolynomial\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the chromatic polynomial of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"ChromaticPolynomial\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
CircleDot::usage = "\!\(\*RowBox[{\"CircleDot\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[CircleDot]\", StyleBox[\"y\", \"TI\"], \"\[CircleDot]\", \"\[Ellipsis]\"}]\)."
CircleMinus::usage = "\!\(\*RowBox[{\"CircleMinus\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[CircleMinus]\", StyleBox[\"y\", \"TI\"]}]\). "
CirclePlus::usage = "\!\(\*RowBox[{\"CirclePlus\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[CirclePlus]\", StyleBox[\"y\", \"TI\"], \"\[CirclePlus]\", \"\[Ellipsis]\"}]\)."
CirclePoints::usage = "\!\(\*RowBox[{\"CirclePoints\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the positions of \!\(\*StyleBox[\"n\", \"TI\"]\) points equally spaced around the unit circle.\n\!\(\*RowBox[{\"CirclePoints\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the positions of \!\(\*StyleBox[\"n\", \"TI\"]\) points equally spaced around a circle of radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"CirclePoints\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) starts at angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) with respect to the \!\(\*StyleBox[\"x\", \"TI\"]\) axis.\n\!\(\*RowBox[{\"CirclePoints\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"rspec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) centers the circle at \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\)."
CircleTimes::usage = "\!\(\*RowBox[{\"CircleTimes\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) displays as \!\(\*RowBox[{\"\[CircleTimes]\", StyleBox[\"x\", \"TI\"]}]\).\n\!\(\*RowBox[{\"CircleTimes\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[CircleTimes]\", StyleBox[\"y\", \"TI\"], \"\[CircleTimes]\", \"\[Ellipsis]\"}]\)."
Circle::usage = "\!\(\*RowBox[{\"Circle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a circle of radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"Circle\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"]\"}]\) gives a circle of radius 1. \n\!\(\*RowBox[{\"Circle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives an axis-aligned ellipse with semi-axes lengths \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"x\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"y\", \"TI\"]]\).\n\!\(\*RowBox[{\"Circle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives a circular or ellipse arc from angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
CirculantGraph::usage = "\!\(\*RowBox[{\"CirculantGraph\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the circulant graph \!\(\*RowBox[{SubscriptBox[StyleBox[\"C\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"j\", \"TI\"], \")\"}]\) with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and jump \!\(\*StyleBox[\"j\", \"TI\"]\).\n\!\(\*RowBox[{\"CirculantGraph\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the circulant graph \!\(\*RowBox[{SubscriptBox[StyleBox[\"C\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], \"2\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \")\"}]\) with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and jumps \!\(\*SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
CircularOrthogonalMatrixDistribution::usage = "\!\(\*RowBox[{\"CircularOrthogonalMatrixDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a circular orthogonal matrix distribution with matrix dimensions \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\)."
CircularQuaternionMatrixDistribution::usage = "\!\(\*RowBox[{\"CircularQuaternionMatrixDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a circular quaternion matrix distribution with matrix dimensions \!\(\*RowBox[{\"{\", RowBox[{StyleBox[RowBox[{\"2\", \" \", \"n\"}], \"TI\"], \",\", StyleBox[RowBox[{\"2\", \" \", \"n\"}], \"TI\"]}], \"}\"}]\) over the field of complex numbers."
CircularRealMatrixDistribution::usage = "\!\(\*RowBox[{\"CircularRealMatrixDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a circular real matrix distribution with matrix dimensions \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\)."
CircularSymplecticMatrixDistribution::usage = "\!\(\*RowBox[{\"CircularSymplecticMatrixDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a circular symplectic matrix distribution with matrix dimensions \!\(\*RowBox[{\"{\", RowBox[{StyleBox[RowBox[{\"2\", \" \", \"n\"}], \"TI\"], \",\", StyleBox[RowBox[{\"2\", \" \", \"n\"}], \"TI\"]}], \"}\"}]\) over the field of complex numbers."
CircularUnitaryMatrixDistribution::usage = "\!\(\*RowBox[{\"CircularUnitaryMatrixDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a circular unitary matrix distribution with matrix dimensions \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\)."
Circumsphere::usage = "\!\(\*RowBox[{\"Circumsphere\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"n\", StyleBox[\"+\", FontSlant -> \"Plain\"], StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]]}], \"}\"}], \"]\"}]\) returns the \!\(\*RowBox[{\"Sphere\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that circumscribes the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in \!\(\*SuperscriptBox[\"\[DoubleStruckCapitalR]\", StyleBox[\"n\", \"TI\"]]\)."
CityData::usage = "\!\(\*RowBox[{\"CityData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the city with the specified name.\n\!\(\*RowBox[{\"CityData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the full specifications of cities whose names are consistent with \!\(\*StyleBox[\"name\", \"TI\"]\)."
ClassifierFunction::usage = "\!\(\*RowBox[{\"ClassifierFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents a function generated by Classify that classifies data into classes."
ClassifierInformation::usage = "\!\(\*RowBox[{\"ClassifierInformation\", \"[\", StyleBox[\"classifier\", \"TI\"], \"]\"}]\) generates a report giving information on the classifier function \!\(\*StyleBox[\"classifier\", \"TI\"]\).\n\!\(\*RowBox[{\"ClassifierInformation\", \"[\", RowBox[{StyleBox[\"classifier\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives information for \!\(\*StyleBox[\"classifier\", \"TI\"]\) associated with property \!\(\*StyleBox[\"prop\", \"TI\"]\)."
ClassifierMeasurementsObject::usage = "\!\(\*RowBox[{\"ClassifierMeasurementsObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents an object generated by ClassifierMeasurements that can be applied to properties."
ClassifierMeasurements::usage = "\!\(\*RowBox[{\"ClassifierMeasurements\", \"[\", RowBox[{StyleBox[\"classifier\", \"TI\"], \",\", StyleBox[\"testset\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives measurements associated with property \!\(\*StyleBox[\"prop\", \"TI\"]\) when \!\(\*StyleBox[\"classifier\", \"TI\"]\) is evaluated on \!\(\*StyleBox[\"testset\", \"TI\"]\).\n\!\(\*RowBox[{\"ClassifierMeasurements\", \"[\", RowBox[{StyleBox[\"classifier\", \"TI\"], \",\", StyleBox[\"testset\", \"TI\"]}], \"]\"}]\) yields a \!\(\*RowBox[{\"ClassifierMeasurementsObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied to any property."
Classify::usage = "\!\(\*RowBox[{\"Classify\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"example\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"class\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"example\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"class\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a \!\(\*RowBox[{\"ClassifierFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) based on the examples and classes given.\n\!\(\*RowBox[{\"Classify\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"example\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"example\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"class\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"class\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) also generates a \!\(\*RowBox[{\"ClassifierFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) based on the examples and classes given.\n\!\(\*RowBox[{\"Classify\", \"[\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"class\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"example\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"example\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", RowBox[{SubscriptBox[StyleBox[\"class\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"example\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}], \"]\"}]\) generates a \!\(\*RowBox[{\"ClassifierFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) based on an association of classes with their examples.\n\!\(\*RowBox[{\"Classify\", \"[\", RowBox[{StyleBox[\"training\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) attempts to classify \!\(\*StyleBox[\"data\", \"TI\"]\) using a classifier function deduced from the training set given.\n\!\(\*RowBox[{\"Classify\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) attempts to classify \!\(\*StyleBox[\"data\", \"TI\"]\) using the built-in classifier function represented by \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"Classify\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives the specified property of the classification associated with \!\(\*StyleBox[\"data\", \"TI\"]\)."
ClassPriors::usage = "ClassPriors is an option for Classify and related functions that specifies explicit prior probabilities to assume for output classes, independent of anything deduced from the training set."
ClearAll::usage = "\!\(\*RowBox[{\"ClearAll\", \"[\", RowBox[{SubscriptBox[StyleBox[\"symb\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"symb\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) clears all values, definitions, attributes, messages, and defaults associated with symbols. \n\!\(\*RowBox[{\"ClearAll\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) clears all symbols whose names textually match any of the \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
ClearAttributes::usage = "\!\(\*RowBox[{\"ClearAttributes\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"attr\", \"TI\"]}], \"]\"}]\) removes \!\(\*StyleBox[\"attr\", \"TI\"]\) from the list of attributes of the symbol \!\(\*StyleBox[\"s\", \"TI\"]\). "
ClearPermissions::usage = "\!\(\*RowBox[{\"ClearPermissions\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"class\", \"TI\"]}], \"]\"}]\) clears permissions for the specified class of users for the cloud object \!\(\*StyleBox[\"obj\", \"TI\"]\). \n\!\(\*RowBox[{\"ClearPermissions\", \"[\", StyleBox[\"class\", \"TI\"], \"]\"}]\) clears permissions for the cloud object corresponding to the current document."
ClearSystemCache::usage = "\!\(\*RowBox[{\"ClearSystemCache\", \"[\", \"]\"}]\) clears internal system caches of stored results."
Clear::usage = "\!\(\*RowBox[{\"Clear\", \"[\", RowBox[{SubscriptBox[StyleBox[\"symbol\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"symbol\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) clears values and definitions for the \!\(\*SubscriptBox[StyleBox[\"symbol\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Clear\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) clears values and definitions for all symbols whose names match any of the string patterns \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
ClebschGordan::usage = "\!\(\*RowBox[{\"ClebschGordan\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the Clebsch\[Dash]Gordan coefficient for the decomposition of \!\(\*RowBox[{RowBox[{RowBox[{\"\[VerticalSeparator]\", \"j\"}], \",\", \"m\"}], \"\[RightAngleBracket]\"}]\) in terms of \!\(\*RowBox[{RowBox[{RowBox[{RowBox[{RowBox[{RowBox[{\"\[VerticalSeparator]\", SubscriptBox[StyleBox[\"j\", \"TI\"], \"1\"]}], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], \"1\"]}], \"\[RightAngleBracket]\"}], \"\[VerticalSeparator]\", SubscriptBox[StyleBox[\"j\", \"TI\"], \"2\"]}], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], \"2\"]}], \"\[RightAngleBracket]\"}]\). "
ClickPane::usage = "\!\(\*RowBox[{\"ClickPane\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) represents a clickable pane that displays as \!\(\*StyleBox[\"image\", \"TI\"]\) and applies \!\(\*StyleBox[\"func\", \"TI\"]\) to the \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}]\) coordinates of each click within the pane.\n\!\(\*RowBox[{\"ClickPane\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) specifies the range of coordinates to use."
ClipFill::usage = "ClipFill is an option for plotting functions that specifies what should be shown where curves or surfaces would extend beyond the plot range. "
ClippingStyle::usage = "ClippingStyle is an option for plotting functions that specifies the style of what should be drawn when curves or surfaces would extend beyond the plot range. "
ClipPlanesStyle::usage = "ClipPlanesStyle is an option to Graphics3D that specifies how clipping planes defined with the ClipPlanes option should be rendered."
ClipPlanes::usage = "ClipPlanes is an option to Graphics3D that specifies a list of clipping planes that can cut away portions of a 3D scene from the resulting view."
ClipRange::usage = "ClipRange is an option to Raster3D that specifies a rectangular region that is cut away from the resulting view."
Clip::usage = "\!\(\*RowBox[{\"Clip\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives \!\(\*StyleBox[\"x\", \"TI\"]\) clipped to be between \!\(\*RowBox[{\"-\", \"1\"}]\) and \!\(\*RowBox[{\"+\", \"1\"}]\). \n\!\(\*RowBox[{\"Clip\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*StyleBox[\"x\", \"TI\"]\) for \!\(\*RowBox[{StyleBox[\"min\", \"TI\"], \"\[LessEqual]\", StyleBox[\"x\", \"TI\"], \"\[LessEqual]\", StyleBox[\"max\", \"TI\"]}]\), \!\(\*StyleBox[\"min\", \"TI\"]\) for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<\", StyleBox[\"min\", \"TI\"]}]\) and \!\(\*StyleBox[\"max\", \"TI\"]\) for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \">\", StyleBox[\"max\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Clip\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<\", StyleBox[\"min\", \"TI\"]}]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \">\", StyleBox[\"max\", \"TI\"]}]\). "
ClockGauge::usage = "\!\(\*RowBox[{\"ClockGauge\", \"[\", \"]\"}]\) draws an analog clock face showing the local time with hours, minutes, and seconds.\n\!\(\*RowBox[{\"ClockGauge\", \"[\", StyleBox[\"time\", \"TI\"], \"]\"}]\) draws an analog clock face showing the time corresponding to an AbsoluteTime, DateObject, or TimeObject specification.\n\!\(\*RowBox[{\"ClockGauge\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) draws an analog clock face showing hour \!\(\*StyleBox[\"h\", \"TI\"]\), minute \!\(\*StyleBox[\"m\", \"TI\"]\), and seconds \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{\"ClockGauge\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) draws an analog clock face showing the time corresponding to the date list in a DateList specification.\n\!\(\*RowBox[{\"ClockGauge\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) draws an analog clock face showing the time \!\(\*RowBox[{\"DateList\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\)."
Clock::usage = "\!\(\*RowBox[{\"Clock\", \"[\", \"]\"}]\) represents a clock variable whose value cycles continuously from 0 to 1 once per second when it appears inside a dynamically updated object such as a Dynamic. \n\!\(\*RowBox[{\"Clock\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) cycles from 0 to \!\(\*StyleBox[\"t\", \"TI\"]\) every \!\(\*StyleBox[\"t\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"Clock\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) cycles from 0 to \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) every \!\(\*StyleBox[\"t\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"Clock\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) cycles through the range \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) every \!\(\*StyleBox[\"t\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"Clock\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \"]\"}]\) cycles through the range \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) over the course of \!\(\*RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"-\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\) seconds.\n\!\(\*RowBox[{\"Clock\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dv\", \"TI\"]}], \"}\"}], \"]\"}]\) cycles from \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) in steps of \!\(\*StyleBox[\"dv\", \"TI\"]\), spending \!\(\*StyleBox[\"dv\", \"TI\"]\) seconds at each value.\n\!\(\*RowBox[{\"Clock\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dv\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) cycles from \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) in steps \!\(\*StyleBox[\"dv\", \"TI\"]\) every \!\(\*StyleBox[\"t\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"Clock\", \"[\", RowBox[{StyleBox[\"vals\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) goes through the cycle only \!\(\*StyleBox[\"n\", \"TI\"]\) times, then always yields only the maximum value."
CloseKernels::usage = "\!\(\*RowBox[{\"CloseKernels\", \"[\", \"]\"}]\) terminates all parallel kernels from the list \!\(\*RowBox[{\"Kernels\", \"[\", \"]\"}]\).\n\!\(\*RowBox[{\"CloseKernels\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]\) terminates the kernel \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"CloseKernels\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) terminates the kernels \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
ClosenessCentrality::usage = "\!\(\*RowBox[{\"ClosenessCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of closeness centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"ClosenessCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Close::usage = "\!\(\*RowBox[{\"Close\", \"[\", StyleBox[\"stream\", \"TI\"], \"]\"}]\) closes a stream. "
ClosingAutoSave::usage = "ClosingAutoSave is an option for notebooks that specifies whether a notebook is automatically saved when it is closed."
Closing::usage = "\!\(\*RowBox[{\"Closing\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the morphological closing of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to the structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"Closing\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the closing with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"Closing\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies closing to an array of data."
CloudAccountData::usage = "\!\(\*RowBox[{\"CloudAccountData\", \"[\", \"]\"}]\) gives data associated with the cloud account currently being used.\n\!\(\*RowBox[{\"CloudAccountData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the property \!\(\*StyleBox[\"prop\", \"TI\"]\) associated with the cloud account being used."
CloudBase::usage = "CloudBase is an option specifying the base URI of the server to use for cloud operations."
CloudConnect::usage = "\!\(\*RowBox[{\"CloudConnect\", \"[\", RowBox[{StyleBox[\"username\", \"TI\"], \",\", StyleBox[\"password\", \"TI\"]}], \"]\"}]\) authenticates to the Wolfram Cloud using the specified username and password.\n\!\(\*RowBox[{\"CloudConnect\", \"[\", StyleBox[\"username\", \"TI\"], \"]\"}]\) shows a dialog to input the password.\n\!\(\*RowBox[{\"CloudConnect\", \"[\", \"]\"}]\) shows a dialog to input both the username and the password."
CloudDeploy::usage = "\!\(\*RowBox[{\"CloudDeploy\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) deploys \!\(\*StyleBox[\"expr\", \"TI\"]\) to a new anonymous cloud object.\n\!\(\*RowBox[{\"CloudDeploy\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) deploys \!\(\*StyleBox[\"expr\", \"TI\"]\) to a cloud object at a given URI.\n\!\(\*RowBox[{\"CloudDeploy\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]}], \"]\"}]\) deploys \!\(\*StyleBox[\"expr\", \"TI\"]\) to a given cloud object."
CloudDirectory::usage = "\!\(\*RowBox[{\"CloudDirectory\", \"[\", \"]\"}]\) gives a CloudObject representing the current working directory used for cloud objects. "
CloudDisconnect::usage = "\!\(\*RowBox[{\"CloudDisconnect\", \"[\", \"]\"}]\) disconnects a non-cloud instance of the Wolfram Language from the Wolfram Cloud."
CloudEvaluate::usage = "\!\(\*RowBox[{\"CloudEvaluate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) in the cloud and returns the result.\n\!\(\*RowBox[{\"CloudEvaluate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) wraps the head \!\(\*StyleBox[\"h\", \"TI\"]\) around the result before returning it."
CloudExport::usage = "\!\(\*RowBox[{\"CloudExport\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) exports \!\(\*StyleBox[\"expr\", \"TI\"]\) to a new anonymous cloud object in the specified format.\n\!\(\*RowBox[{\"CloudExport\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) exports to a cloud object at a given URI.\n\!\(\*RowBox[{\"CloudExport\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]}], \"]\"}]\) exports to a given cloud object."
CloudFunction::usage = "\!\(\*RowBox[{\"CloudFunction\", \"[\", StyleBox[\"fun\", \"TI\"], \"]\"}]\) represents a pure function that evaluates \!\(\*RowBox[{StyleBox[\"fun\", \"TI\"], \"[\", StyleBox[\"args\", \"TI\"], \"]\"}]\) in the cloud.\n\!\(\*RowBox[{\"CloudFunction\", \"[\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}]\) represents a function that applies the contents of the specified cloud object.\n\!\(\*RowBox[{\"CloudFunction\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) wraps the head \!\(\*StyleBox[\"h\", \"TI\"]\) around the result of the function before returning it."
CloudGet::usage = "\!\(\*RowBox[{\"CloudGet\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) reads in a cloud object at a given URI, evaluating each expression in it and returning the last one.\n\!\(\*RowBox[{\"CloudGet\", \"[\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}], \"]\"}]\) reads in a given cloud object."
CloudImport::usage = "\!\(\*RowBox[{\"CloudImport\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) imports from a cloud object at a given URI.\n\!\(\*RowBox[{\"CloudImport\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"elements\", \"TI\"]}], \"]\"}]\) imports the specified elements of a cloud object.\n\!\(\*RowBox[{\"CloudImport\", \"[\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}], \"]\"}]\) imports from a given cloud object."
CloudObjects::usage = "\!\(\*RowBox[{\"CloudObjects\", \"[\", \"]\"}]\) gives a list of cloud objects in your current cloud directory.\n\!\(\*RowBox[{\"CloudObjects\", \"[\", StyleBox[\"dir\", \"TI\"], \"]\"}]\) gives a list of cloud objects in the cloud directory \!\(\*StyleBox[\"dir\", \"TI\"]\).\n\!\(\*RowBox[{\"CloudObjects\", \"[\", \"None\", \"]\"}]\) gives a list of all unnamed cloud objects owned by you.\n\!\(\*RowBox[{\"CloudObjects\", \"[\", RowBox[{StyleBox[\"dir\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) gives a list of cloud objects of the specified type.\n\!\(\*RowBox[{\"CloudObjects\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) gives a list of cloud objects matching the filters defined by the association \!\(\*StyleBox[\"assoc\", \"TI\"]\)."
CloudObject::usage = "\!\(\*RowBox[{\"CloudObject\", \"[\", \"]\"}]\) represents a new anonymous cloud object.\n\!\(\*RowBox[{\"CloudObject\", \"[\", \"http://StyleBox[\[Ellipsis], TR]\", \"]\"}]\), \!\(\*RowBox[{\"CloudObject\", \"[\", \"https://StyleBox[\[Ellipsis], TR]\", \"]\"}]\) represents a cloud object with a given URI.\n\!\(\*RowBox[{\"CloudObject\", \"[\", \"user:StyleBox[user, TI]/StyleBox[path, TI]\", \"]\"}]\) represents a cloud object of a given \!\(\*StyleBox[\"user\", \"TI\"]\) with a given \!\(\*StyleBox[\"path\", \"TI\"]\).\n\!\(\*RowBox[{\"CloudObject\", \"[\", \"/StyleBox[abspath, TI]\", \"]\"}]\) represents a cloud object of the currently authenticated user at an absolute path.\n\!\(\*RowBox[{\"CloudObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"relpath\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents a cloud object of the currently authenticated user at a relative path.\n\!\(\*RowBox[{\"CloudObject\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"relpath\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"cbase\", \"TI\"]}], \"]\"}]\) represents a cloud object with a path relative to the base \!\(\*StyleBox[\"cbase\", \"TI\"]\). "
CloudPublish::usage = "\!\(\*RowBox[{\"CloudPublish\", \"[\", \"]\"}]\) makes the current document public.\n\!\(\*RowBox[{\"CloudPublish\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) makes the cloud object \!\(\*StyleBox[\"obj\", \"TI\"]\) public.\n\!\(\*RowBox[{\"CloudPublish\", \"[\", StyleBox[\"nb\", \"TI\"], \"]\"}]\) deploys the notebook \!\(\*StyleBox[\"nb\", \"TI\"]\) to the cloud and makes it public."
CloudPut::usage = "\!\(\*RowBox[{\"CloudPut\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) writes \!\(\*StyleBox[\"expr\", \"TI\"]\) to a new anonymous cloud object.\n\!\(\*RowBox[{\"CloudPut\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes \!\(\*StyleBox[\"expr\", \"TI\"]\) to a cloud object at a given URI.\n\!\(\*RowBox[{\"CloudPut\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]}], \"]\"}]\) writes \!\(\*StyleBox[\"expr\", \"TI\"]\) to a given cloud object."
CloudSave::usage = "\!\(\*RowBox[{\"CloudSave\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) saves definitions associated with the specified symbol to a new anonymous cloud object.\n\!\(\*RowBox[{\"CloudSave\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) saves definitions associated with all symbols whose names match the string pattern \"\!\(\*\nStyleBox[\"form\", \"TI\"]\)\". \n\!\(\*RowBox[{\"CloudSave\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) saves definitions associated with all symbols in the specified context. \n\!\(\*RowBox[{\"CloudSave\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) saves definitions associated with several objects. \n\!\(\*RowBox[{\"CloudSave\", \"[\", RowBox[{StyleBox[\"symspec\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]}]\) appends definitions associated with \!\(\*StyleBox[\"symspec\", \"TI\"]\) to the cloud object at the given URI.\n\!\(\*RowBox[{\"CloudSave\", \"[\", RowBox[{StyleBox[\"symspec\", \"TI\"], \",\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"uri\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]}], \"]\"}]\) appends definitions to the given cloud object."
CloudShare::usage = "\!\(\*RowBox[{\"CloudShare\", \"[\", StyleBox[\"user\", \"TI\"], \"]\"}]\) shares the current cloud document with the specified user.\n\!\(\*RowBox[{\"CloudShare\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) shares the current document with all the users \!\(\*SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"CloudShare\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"users\", \"TI\"]}], \"]\"}]\) shares the cloud object \!\(\*StyleBox[\"obj\", \"TI\"]\) with the specified users."
CloudSubmit::usage = "\!\(\*RowBox[{\"CloudSubmit\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) submits \!\(\*StyleBox[\"expr\", \"TI\"]\) for immediate asynchronous cloud evaluation."
CloudSymbol::usage = "\!\(\*RowBox[{\"CloudSymbol\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents a symbol whose value is persistently stored in the cloud.\n\!\(\*RowBox[{\"CloudSymbol\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) represents a persistent symbol corresponding to the cloud object \!\(\*StyleBox[\"obj\", \"TI\"]\)."
ClusteringComponents::usage = "\!\(\*RowBox[{\"ClusteringComponents\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) gives an array in which each element at the lowest level of \!\(\*StyleBox[\"array\", \"TI\"]\) is replaced by an integer index representing the cluster in which the element lies.\n\!\(\*RowBox[{\"ClusteringComponents\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"n\", \"TI\"]\) clusters.\n\!\(\*RowBox[{\"ClusteringComponents\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"level\", \"TI\"]}], \"]\"}]\) finds clusters at the specified level in \!\(\*StyleBox[\"array\", \"TI\"]\).\n\!\(\*RowBox[{\"ClusteringComponents\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds clusters of pixels with similar values in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ClusteringComponents\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"n\", \"TI\"]\) clusters in \!\(\*StyleBox[\"image\", \"TI\"]\)."
CMYKColor::usage = "\!\(\*RowBox[{\"CMYKColor\", \"[\", RowBox[{StyleBox[\"cyan\", \"TI\"], \",\", StyleBox[\"magenta\", \"TI\"], \",\", StyleBox[\"yellow\", \"TI\"], \",\", StyleBox[\"black\", \"TI\"]}], \"]\"}]\) is a graphics directive specifying that objects that follow are to be displayed, in the color given. \n\!\(\*RowBox[{\"CMYKColor\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) specifies opacity \!\(\*StyleBox[\"a\", \"TI\"]\). "
CodeAssistOptions::usage = "\!\(\*RowBox[{\"CodeAssistOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for cells that specifies settings for controlling code input assistance features, including autocompletion, function template insertion, and mouseover behaviors for code."
CoefficientArrays::usage = "\!\(\*RowBox[{\"CoefficientArrays\", \"[\", RowBox[{StyleBox[\"polys\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) gives the arrays of coefficients of the variables \!\(\*StyleBox[\"vars\", \"TI\"]\) in the polynomials \!\(\*StyleBox[\"polys\", \"TI\"]\). "
CoefficientDomain::usage = "CoefficientDomain is an option for GroebnerBasis, PolynomialReduce and PolynomialMod which specifies the domain for polynomial coefficients."
CoefficientList::usage = "\!\(\*RowBox[{\"CoefficientList\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) gives a list of coefficients of powers of \!\(\*StyleBox[\"var\", \"TI\"]\) in \!\(\*StyleBox[\"poly\", \"TI\"]\), starting with power \!\(\*StyleBox[\"0\", \"TR\"]\). \n\!\(\*RowBox[{\"CoefficientList\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an array of coefficients of the \!\(\*SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"CoefficientList\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dim\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dim\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an array of dimensions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dim\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dim\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), truncating or padding with zeros as needed."
CoefficientRules::usage = "\!\(\*RowBox[{\"CoefficientRules\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the list \!\(\*RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) of exponent vectors and coefficients for the monomials in \!\(\*StyleBox[\"poly\", \"TI\"]\) with respect to the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"CoefficientRules\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"order\", \"TI\"]}], \"]\"}]\) gives the result with the monomial ordering specified by \!\(\*StyleBox[\"order\", \"TI\"]\)."
Coefficient::usage = "\!\(\*RowBox[{\"Coefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the coefficient of \!\(\*StyleBox[\"form\", \"TI\"]\) in the polynomial \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Coefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the coefficient of \!\(\*RowBox[{StyleBox[\"form\", \"TI\"], \"^\", StyleBox[\"n\", \"TI\"]}]\) in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
CoifletWavelet::usage = "\!\(\*RowBox[{\"CoifletWavelet\", \"[\", \"]\"}]\) represents a Coiflet wavelet of order 2.\n\!\(\*RowBox[{\"CoifletWavelet\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a Coiflet wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\)."
Collect::usage = "\!\(\*RowBox[{\"Collect\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) collects together terms involving the same powers of objects matching \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Collect\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) collects together terms that involve the same powers of objects matching \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. \n\!\(\*RowBox[{\"Collect\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"h\", \"TI\"]\) to the expression that forms the coefficient of each term obtained. "
ColonForm::usage = "\!\(\*RowBox[{\"ColonForm\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) prints as \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \":\", \" \", StyleBox[\"b\", \"TI\"]}]\)."
Colon::usage = "\!\(\*RowBox[{\"Colon\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Colon]\", StyleBox[\"y\", \"TI\"], \"\[Colon]\", \"\[Ellipsis]\"}]\)."
ColorBalance::usage = "\!\(\*RowBox[{\"ColorBalance\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) adjusts the colors in \!\(\*StyleBox[\"image\", \"TI\"]\) to achieve a balance that simulates the effect of neutral lighting.\n\!\(\*RowBox[{\"ColorBalance\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ref\", \"TI\"]}], \"]\"}]\) adjusts colors in \!\(\*StyleBox[\"image\", \"TI\"]\) so that the reference color specified by \!\(\*StyleBox[\"ref\", \"TI\"]\) is mapped to white. \n\!\(\*RowBox[{\"ColorBalance\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"ref\", \"TI\"], \"\[Rule]\", StyleBox[\"target\", \"TI\"]}]}], \"]\"}]\) maps the reference color \!\(\*StyleBox[\"ref\", \"TI\"]\) to \!\(\*StyleBox[\"target\", \"TI\"]\)."
ColorCombine::usage = "\!\(\*RowBox[{\"ColorCombine\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a multichannel image by combining the sequence of channels in the \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"ColorCombine\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"colorspace\", \"TI\"]}], \"]\"}]\) combines images that represent the color components specified by \!\(\*StyleBox[\"colorspace\", \"TI\"]\)."
ColorConvert::usage = "\!\(\*RowBox[{\"ColorConvert\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"colspace\", \"TI\"]}], \"]\"}]\) converts color specifications in \!\(\*StyleBox[\"expr\", \"TI\"]\) to refer to the color space represented by \!\(\*StyleBox[\"colspace\", \"TI\"]\)."
ColorCoverage::usage = "ColorCoverage is an option for DominantColors that specifies the minimum image coverage that each color cluster should have."
ColorDataFunction::usage = "\!\(\*RowBox[{\"ColorDataFunction\", \"[\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is a function that represents a color scheme. "
ColorData::usage = "\!\(\*RowBox[{\"ColorData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"scheme\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a function that generates colors in the named color scheme when applied to parameter values. \n\!\(\*RowBox[{\"ColorData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"scheme\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property of a color scheme.\n\!\(\*RowBox[{\"ColorData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"collection\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of color schemes in a named collection.\n\!\(\*RowBox[{\"ColorData\", \"[\", \"]\"}]\) gives a list of named collections of color schemes."
ColorDistance::usage = "\!\(\*RowBox[{\"ColorDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the approximate perceptual distance between color directives \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ColorDistance\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) gives color distances between elements of \!\(\*StyleBox[\"list\", \"TI\"]\) and \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"ColorDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives color distances between corresponding elements of \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ColorDistance\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) gives an image whose pixel values are color distance between pixels in \!\(\*StyleBox[\"image\", \"TI\"]\) and the color \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"ColorDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields an image giving the pixelwise color distance between \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ColorFunctionScaling::usage = "ColorFunctionScaling is an option for graphics functions that specifies whether arguments supplied to a color function should be scaled to lie between 0 and 1. "
ColorFunction::usage = "ColorFunction is an option for graphics functions that specifies a function to apply to determine colors of elements. "
Colorize::usage = "\!\(\*RowBox[{\"Colorize\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) generates an image from an integer matrix \!\(\*StyleBox[\"m\", \"TI\"]\), using colors for positive integers and black for non-positive integers.\n\!\(\*RowBox[{\"Colorize\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) replaces intensity values in \!\(\*StyleBox[\"image\", \"TI\"]\) with pseudocolor values."
ColorNegate::usage = "\!\(\*RowBox[{\"ColorNegate\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the negative of \!\(\*StyleBox[\"image\", \"TI\"]\), in which all colors have been negated.\n\!\(\*RowBox[{\"ColorNegate\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) gives the negative of a color."
ColorOutput::usage = "ColorOutput is an option for graphics functions that specifies the type of color output to produce. "
ColorProfileData::usage = "\!\(\*RowBox[{\"ColorProfileData\", \"[\", RowBox[{\"<>\", RowBox[{\",\", RowBox[{StyleBox[\"\\\"Description\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"desc\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \",\", RowBox[{StyleBox[\"\\\"DeviceColorSpace\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"device\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \",\", RowBox[{StyleBox[\"\\\"IndependentColorSpace\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"ics\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}]}]}], \"]\"}]\) represents an ICC color profile that can convert between the independent color space \"\!\(\*\nStyleBox[\"ics\", \"TI\"]\)\" and the device-dependent color space \"\!\(\*\nStyleBox[\"device\", \"TI\"]\)\"."
ColorQuantize::usage = "\!\(\*RowBox[{\"ColorQuantize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives an approximation to \!\(\*StyleBox[\"image\", \"TI\"]\) that uses only \!\(\*StyleBox[\"n\", \"TI\"]\) distinct colors."
ColorQ::usage = "\!\(\*RowBox[{\"ColorQ\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"color\", \"TI\"]\) is a valid color directive and False otherwise."
ColorReplace::usage = "\!\(\*RowBox[{\"ColorReplace\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"color\", \"TI\"]}], \"]\"}]\) finds regions in \!\(\*StyleBox[\"image\", \"TI\"]\) whose pixel values are similar to \!\(\*StyleBox[\"color\", \"TI\"]\) and replaces them with transparent pixels.\n\!\(\*RowBox[{\"ColorReplace\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"color\", \"TI\"], \"\[Rule]\", StyleBox[\"replacement\", \"TI\"]}]}], \"]\"}]\) replaces all pixels with the specified \!\(\*StyleBox[\"replacement\", \"TI\"]\) color.\n\!\(\*RowBox[{\"ColorReplace\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"color\", \"TI\"], \"\[Rule]\", StyleBox[\"replacement\", \"TI\"]}], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) replaces all pixels whose values are within a distance \!\(\*StyleBox[\"d\", \"TI\"]\) from \!\(\*StyleBox[\"color\", \"TI\"]\).\n\!\(\*RowBox[{\"ColorReplace\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"color\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"replacement\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) does multiple color replacements."
ColorRules::usage = "ColorRules is an option that specifies how colors of cells should be determined from values. "
ColorSelectorSettings::usage = "\!\(\*RowBox[{\"ColorSelectorSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{StyleBox[\"opt\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}], \"}\"}]}]\) is a global option that specifies settings for the \!\(\*StyleBox[\"Color\", \"DialogElementName\"]\) dialog box."
ColorSeparate::usage = "\!\(\*RowBox[{\"ColorSeparate\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a list of single-channel images corresponding to each of the color channels in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ColorSeparate\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"colorspace\", \"TI\"]}], \"]\"}]\) gives a list of images corresponding to the components of \!\(\*StyleBox[\"colorspace\", \"TI\"]\).\n\!\(\*RowBox[{\"ColorSeparate\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"channel\", \"TI\"]}], \"]\"}]\) returns a single-channel image containing the specified \!\(\*StyleBox[\"channel\", \"TI\"]\)."
ColorSetterBoxOptions::usage = "\!\(\*RowBox[{ColorSetterBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for ColorSetterBox objects."
ColorSetter::usage = "\!\(\*RowBox[{\"ColorSetter\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) represents a color setter which displays as a swatch of the specified color and when clicked brings up a system color picker dialog.\n\!\(\*RowBox[{\"ColorSetter\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}], \"]\"}]\) uses the dynamically updated current value of \!\(\*StyleBox[\"color\", \"TI\"]\), with the value of \!\(\*StyleBox[\"color\", \"TI\"]\) being reset if the color is modified.\n\!\(\*RowBox[{\"ColorSetter\", \"[\", \"]\"}]\) gives a color setter with initial color gray."
ColorSlider::usage = "\!\(\*RowBox[{\"ColorSlider\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) represents a color slider currently set to the color corresponding to \!\(\*StyleBox[\"color\", \"TI\"]\).\n\!\(\*RowBox[{\"ColorSlider\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}], \"]\"}]\) uses the dynamically updated current value of \!\(\*StyleBox[\"color\", \"TI\"]\), with the value of \!\(\*StyleBox[\"color\", \"TI\"]\) being reset if the color is modified.\n\!\(\*RowBox[{\"ColorSlider\", \"[\", \"]\"}]\) represents a color slider with an initial gray color."
ColorSpace::usage = "ColorSpace is an option for Image and related functions that specifies the color space to which color values refer."
ColorToneMapping::usage = "\!\(\*RowBox[{\"ColorToneMapping\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) applies a tone mapping to color values in \!\(\*StyleBox[\"image\", \"TI\"]\) so as to make variations of luminance visible even in small intervals of the dynamic range. \n\!\(\*RowBox[{\"ColorToneMapping\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) maps colors by compressing the overall range of luminance values by a factor \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"ColorToneMapping\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"range\", \"TI\"]}], \"]\"}]\) applies a mapping only to colors whose initial luminance lies in the specified range.\n\!\(\*RowBox[{\"ColorToneMapping\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}]}], \"]\"}]\) takes the specified range of colors and compresses their overall luminance values by a factor \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"ColorToneMapping\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"range\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"range\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses different compression factors \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for different ranges \!\(\*SubscriptBox[StyleBox[\"range\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"ColorToneMapping\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) uses the color compensation factor \!\(\*StyleBox[\"s\", \"TI\"]\) to correct for saturation distortion introduced during tone mapping."
ColumnAlignments::usage = "ColumnAlignments is an option for the low-level function GridBox that specifies how entries in each column should be aligned. "
ColumnForm::usage = "\!\(\*RowBox[{\"ColumnForm\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) prints as a column with \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) above \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc. \n\!\(\*RowBox[{\"ColumnForm\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"horiz\", \"TI\"]}], \"]\"}]\) specifies the horizontal alignment of each element. \n\!\(\*RowBox[{\"ColumnForm\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"horiz\", \"TI\"], \",\", StyleBox[\"vert\", \"TI\"]}], \"]\"}]\) also specifies the vertical alignment of the whole column. "
ColumnLines::usage = "ColumnLines is an option for the low-level function GridBox which specifies whether lines should be drawn between adjacent columns. "
ColumnsEqual::usage = "ColumnsEqual is an option for the low-level function GridBox which specifies whether all columns in the grid should be assigned equal width. "
ColumnSpacings::usage = "ColumnSpacings is an option for the low-level function GridBox which specifies the spaces in ems that should be inserted between adjacent columns. "
Column::usage = "\!\(\*RowBox[{\"Column\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is an object that formats with the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) arranged in a column, with \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) above \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc. \n\!\(\*RowBox[{\"Column\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"alignment\", \"TI\"]}], \"]\"}]\) aligns each element horizontally in the specified way. \n\!\(\*RowBox[{\"Column\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"alignment\", \"TI\"], \",\", StyleBox[\"spacing\", \"TI\"]}], \"]\"}]\) leaves the specified number of \!\(\*StyleBox[\"x\", \"TI\"]\)-heights of spacing between successive elements."
ColumnWidths::usage = "ColumnWidths is an option for the low-level function GridBox which specifies the widths to use for columns. "
Combinatorica`AcyclicQ::usage = "\!\(\*RowBox[{\"AcyclicQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is acyclic."
Combinatorica`AddEdges::usage = "\!\(\*RowBox[{\"AddEdges\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"edgeList\", \"TI\"]}], \"]\"}]\) gives graph \!\(\*StyleBox[\"g\", \"TI\"]\) with the new edges in \!\(\*StyleBox[\"edgeList\", \"TI\"]\) added. \!\(\*StyleBox[\"edgeList\", \"TI\"]\) can have the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]\) to add a single edge \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]\) or the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}]\), to add edges \!\(\*RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}]\) or the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}]\), where \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) can specify graphics information associated with \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]\) and \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}]\), respectively."
Combinatorica`AddEdge::usage = "\!\(\*RowBox[{\"AddEdge\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) returns a graph \!\(\*StyleBox[\"g\", \"TI\"]\) with the new edge \!\(\*StyleBox[\"e\", \"TI\"]\) added. \!\(\*StyleBox[\"e\", \"TI\"]\) can have the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]\) or the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"options\", \"TI\"]}], \"}\"}]\)."
Combinatorica`AddVertex::usage = "\!\(\*RowBox[{\"AddVertex\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) adds one disconnected vertex to graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"AddVertex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) adds to \!\(\*StyleBox[\"g\", \"TI\"]\) a vertex with coordinates specified by \!\(\*StyleBox[\"v\", \"TI\"]\)."
Combinatorica`AddVertices::usage = "\!\(\*RowBox[{\"AddVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) adds \!\(\*StyleBox[\"n\", \"TI\"]\) disconnected vertices to graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"AddVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"vList\", \"TI\"]}], \"]\"}]\) adds vertices in \!\(\*StyleBox[\"vList\", \"TI\"]\) to \!\(\*StyleBox[\"g\", \"TI\"]\). \!\(\*StyleBox[\"vList\", \"TI\"]\) contains embedding and graphics information and can have the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) or \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}], \"}\"}]\) or the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), where \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\), \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]\), and \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\) are point coordinates and \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are graphics information associated with vertices."
Combinatorica`Algorithm::usage = "Algorithm is an option that informs functions such as ShortestPath, VertexColoring, and VertexCover about which algorithm to use."
Combinatorica`AllPairsShortestPath::usage = "\!\(\*RowBox[{\"AllPairsShortestPath\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a matrix, where the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) entry is the length of a shortest path in \!\(\*StyleBox[\"g\", \"TI\"]\) between vertices \!\(\*StyleBox[\"i\", \"TI\"]\) and \!\(\*StyleBox[\"j\", \"TI\"]\). \n\!\(\*RowBox[{\"AllPairsShortestPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"Parent\"}], \"]\"}]\) returns a three-dimensional matrix with dimensions \!\(\*RowBox[{StyleBox[\"2\", \"TR\"], \"*\", RowBox[{\"V\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}], \"*\", RowBox[{\"V\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]}]\), in which the \!\(\*RowBox[{\"(\", RowBox[{\"1\", \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) entry is the length of a shortest path from \!\(\*StyleBox[\"i\", \"TI\"]\) to \!\(\*StyleBox[\"j\", \"TI\"]\) and the \!\(\*RowBox[{\"(\", RowBox[{\"2\", \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) entry is the predecessor of \!\(\*StyleBox[\"j\", \"TI\"]\) in a shortest path from \!\(\*StyleBox[\"i\", \"TI\"]\) to \!\(\*StyleBox[\"j\", \"TI\"]\)."
Combinatorica`AlternatingGroupIndex::usage = "\!\(\*RowBox[{\"AlternatingGroupIndex\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the cycle index of the alternating group of size \!\(\*StyleBox[\"n\", \"TI\"]\) permutations as a polynomial in the symbols \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]}], \"}\"}]\)."
Combinatorica`AlternatingPaths::usage = "\!\(\*RowBox[{\"AlternatingPaths\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"ME\", \"TI\"]}], \"]\"}]\) returns the alternating paths in graph \!\(\*StyleBox[\"g\", \"TI\"]\) with respect to the matching \!\(\*StyleBox[\"ME\", \"TI\"]\), starting at the vertices in the list \!\(\*StyleBox[\"start\", \"TI\"]\). The paths are returned in the form of a forest containing trees rooted at vertices in \!\(\*StyleBox[\"start\", \"TI\"]\)."
Combinatorica`AnimateGraph::usage = "\!\(\*RowBox[{\"AnimateGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) displays graph \!\(\*StyleBox[\"g\", \"TI\"]\) with each element in the list \!\(\*StyleBox[\"l\", \"TI\"]\) successively highlighted. Here \!\(\*StyleBox[\"l\", \"TI\"]\) is a list containing vertices and edges of \!\(\*StyleBox[\"g\", \"TI\"]\). An optional flag, which takes on the values All and One, can be used to inform the function about whether objects highlighted earlier will continue to be highlighted or not. The default value of flag is All. All the options allowed by the function Highlight are permitted by AnimateGraph, as well. See the usage message of Highlight for more details."
Combinatorica`AntiSymmetricQ::usage = "\!\(\*RowBox[{\"AntiSymmetricQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the adjacency matrix of \!\(\*StyleBox[\"g\", \"TI\"]\) represents an anti-symmetric binary relation."
Combinatorica`Approximate::usage = "Approximate is a value that the option Algorithm can take in calls to functions such as VertexCover, telling it to use an approximation algorithm."
Combinatorica`ApproximateVertexCover::usage = "\!\(\*RowBox[{\"ApproximateVertexCover\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) produces a vertex cover of graph \!\(\*StyleBox[\"g\", \"TI\"]\) whose size is guaranteed to be within twice the optimal size."
Combinatorica`ArticulationVertices::usage = "\!\(\*RowBox[{\"ArticulationVertices\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of all articulation vertices in graph \!\(\*StyleBox[\"g\", \"TI\"]\). These are vertices whose removal will disconnect the graph."
Combinatorica`Automorphisms::usage = "\!\(\*RowBox[{\"Automorphisms\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the automorphism group of the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`Backtrack::usage = "\!\(\*RowBox[{\"Backtrack\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"partialQ\", \"TI\"], \",\", StyleBox[\"solutionQ\", \"TI\"]}], \"]\"}]\) performs a backtrack search of the state space \!\(\*StyleBox[\"s\", \"TI\"]\), expanding a partial solution so long as \!\(\*StyleBox[\"partialQ\", \"TI\"]\) is True and returning the first complete solution, as identified by \!\(\*StyleBox[\"solutionQ\", \"TI\"]\)."
Combinatorica`BellmanFord::usage = "\!\(\*RowBox[{\"BellmanFord\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives a shortest-path spanning tree and associated distances from vertex \!\(\*StyleBox[\"v\", \"TI\"]\) of graph \!\(\*StyleBox[\"g\", \"TI\"]\). The shortest-path spanning tree is given by a list in which element \!\(\*StyleBox[\"i\", \"TI\"]\) is the predecessor of vertex \!\(\*StyleBox[\"i\", \"TI\"]\) in the shortest-path spanning tree. BellmanFord works correctly even when the edge weights are negative, provided there are no negative cycles."
Combinatorica`BiconnectedComponents::usage = "\!\(\*RowBox[{\"BiconnectedComponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of the biconnected components of graph \!\(\*StyleBox[\"g\", \"TI\"]\). If \!\(\*StyleBox[\"g\", \"TI\"]\) is directed, the underlying undirected graph is used."
Combinatorica`BiconnectedQ::usage = "\!\(\*RowBox[{\"BiconnectedQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is biconnected. If \!\(\*StyleBox[\"g\", \"TI\"]\) is directed, the underlying undirected graph is used."
Combinatorica`BinarySearch::usage = "\!\(\*RowBox[{\"BinarySearch\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) searches sorted list \!\(\*StyleBox[\"l\", \"TI\"]\) for key \!\(\*StyleBox[\"k\", \"TI\"]\) and gives the position of \!\(\*StyleBox[\"l\", \"TI\"]\) containing \!\(\*StyleBox[\"k\", \"TI\"]\), if \!\(\*StyleBox[\"k\", \"TI\"]\) is present in \!\(\*StyleBox[\"l\", \"TI\"]\). Otherwise, if \!\(\*StyleBox[\"k\", \"TI\"]\) is absent in \!\(\*StyleBox[\"l\", \"TI\"]\), the function returns \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"p\", \"TI\"], \"+\", RowBox[{\"1\", \"/\", \"2\"}]}], \")\"}]\) where \!\(\*StyleBox[\"k\", \"TI\"]\) falls between the elements of \!\(\*StyleBox[\"l\", \"TI\"]\) in positions \!\(\*StyleBox[\"p\", \"TI\"]\) and \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"+\", \"1\"}]\). \n\!\(\*RowBox[{\"BinarySearch\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gives the position of \!\(\*StyleBox[\"k\", \"TI\"]\) in the list obtained from \!\(\*StyleBox[\"l\", \"TI\"]\) by applying \!\(\*StyleBox[\"f\", \"TI\"]\) to each element in \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`BinarySubsets::usage = "\!\(\*RowBox[{\"BinarySubsets\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) gives all subsets of \!\(\*StyleBox[\"l\", \"TI\"]\) ordered according to the binary string defining each subset. For any positive integer \!\(\*StyleBox[\"n\", \"TI\"]\), \!\(\*RowBox[{\"BinarySubsets\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives all subsets of \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\) ordered according to the binary string defining each subset."
Combinatorica`BipartiteMatchingAndCover::usage = "\!\(\*RowBox[{\"BipartiteMatchingAndCover\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) takes a bipartite graph \!\(\*StyleBox[\"g\", \"TI\"]\) and returns a matching with maximum weight along with the dual vertex cover. If the graph is not weighted, it is assumed that all edge weights are 1."
Combinatorica`BipartiteMatching::usage = "\!\(\*RowBox[{\"BipartiteMatching\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of edges associated with a maximum matching in bipartite graph \!\(\*StyleBox[\"g\", \"TI\"]\). If the graph is edge weighted, then the function returns a matching with maximum total weight."
Combinatorica`BipartiteQ::usage = "\!\(\*RowBox[{\"BipartiteQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is bipartite."
Combinatorica`BooleanAlgebra::usage = "\!\(\*RowBox[{\"BooleanAlgebra\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a Hasse diagram for the Boolean algebra on \!\(\*StyleBox[\"n\", \"TI\"]\) elements. The function takes two options: Type and VertexLabel, with default values Undirected and False, respectively. When Type is set to Directed, the function produces the underlying directed acyclic graph. When VertexLabel is set to True, labels are produced for the vertices."
Combinatorica`BreadthFirstTraversal::usage = "\!\(\*RowBox[{\"BreadthFirstTraversal\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) performs a breadth-first traversal of graph \!\(\*StyleBox[\"g\", \"TI\"]\) starting from vertex \!\(\*StyleBox[\"v\", \"TI\"]\), and gives the breadth-first numbers of the vertices. \n\!\(\*RowBox[{RowBox[{RowBox[{RowBox[{\"BreadthFirstTraversal\", \"[\"}], StyleBox[\"g\", \"TI\"]}], \",\", StyleBox[\"v\", \"TI\"], \",\", \"Edge\"}], \"]\"}]\) returns the edges of the graph that are traversed by breadth-first traversal. \n\!\(\*RowBox[{RowBox[{RowBox[{RowBox[{\"BreadthFirstTraversal\", \"[\"}], StyleBox[\"g\", \"TI\"]}], \",\", StyleBox[\"v\", \"TI\"], \",\", \"Tree\"}], \"]\"}]\) returns the breadth-first search tree. \n\!\(\*RowBox[{RowBox[{\"BreadthFirstTraversal\", \"[\"}], StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", RowBox[{\"Level\", \"]\"}]}]\) returns the level number of the vertices."
Combinatorica`BrelazColoring::usage = "\!\(\*RowBox[{\"BrelazColoring\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns a vertex coloring in which vertices are greedily colored with the smallest available color in decreasing order of vertex degree."
Combinatorica`Brelaz::usage = "Brelaz is a value that the option Algorithm can take when used in the function VertexColoring."
Combinatorica`Bridges::usage = "\!\(\*RowBox[{\"Bridges\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of the bridges of graph \!\(\*StyleBox[\"g\", \"TI\"]\), where each bridge is an edge whose removal disconnects the graph."
Combinatorica`CageGraph::usage = "\!\(\*RowBox[{\"CageGraph\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives a smallest \!\(\*StyleBox[\"k\", \"TI\"]\)-regular graph of girth \!\(\*StyleBox[\"r\", \"TI\"]\) for certain small values of \!\(\*StyleBox[\"k\", \"TI\"]\) and \!\(\*StyleBox[\"r\", \"TI\"]\). For \!\(\*RowBox[{StyleBox[\"k\", \"TI\"], \"=\", \"3\"}]\), \!\(\*StyleBox[\"r\", \"TI\"]\) can be 3, 4, 5, 6, 7, 8, or 10. For \!\(\*RowBox[{StyleBox[\"k\", \"TI\"], \"=\", \"4\"}]\) or 5, \!\(\*StyleBox[\"r\", \"TI\"]\) can be 3, 4, 5, or 6.\n\!\(\*RowBox[{\"CageGraph\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives \!\(\*RowBox[{RowBox[{\"CageGraph\", \"[\", RowBox[{\"3\", \",\"}]}], StyleBox[\"r\", \"TI\"], \"]\"}]\). "
Combinatorica`CartesianProduct::usage = "\!\(\*RowBox[{\"CartesianProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the Cartesian product of lists \!\(\*SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
Combinatorica`ChangeEdges::usage = "\!\(\*RowBox[{\"ChangeEdges\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) replaces the edges of graph \!\(\*StyleBox[\"g\", \"TI\"]\) with the edges in \!\(\*StyleBox[\"e\", \"TI\"]\). \!\(\*StyleBox[\"e\", \"TI\"]\) can have the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) or the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"gr\", \"TR\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"gr\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), where \!\(\*RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) are endpoints of edges and \!\(\*RowBox[{SubscriptBox[StyleBox[\"gr\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"gr\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) are graphics information associated with edges."
Combinatorica`ChangeVertices::usage = "\!\(\*RowBox[{\"ChangeVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) replaces the vertices of graph \!\(\*StyleBox[\"g\", \"TI\"]\) with the vertices in the given list \!\(\*StyleBox[\"v\", \"TI\"]\). \!\(\*StyleBox[\"v\", \"TI\"]\) can have the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) or the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"gr\", \"TR\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"gr\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), where \!\(\*RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) are coordinates of points and \!\(\*RowBox[{SubscriptBox[StyleBox[\"gr\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"gr\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) are graphics information associated with vertices."
Combinatorica`ChromaticNumber::usage = "\!\(\*RowBox[{\"ChromaticNumber\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the chromatic number of the graph, which is the fewest number of colors necessary to color the graph."
Combinatorica`ChvatalGraph::usage = "ChvatalGraph returns a smallest triangle-free, 4-regular, 4-chromatic graph."
Combinatorica`CircularEmbedding::usage = "\!\(\*RowBox[{\"CircularEmbedding\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs a list of \!\(\*StyleBox[\"n\", \"TI\"]\) points equally spaced on a circle. \n\!\(\*RowBox[{\"CircularEmbedding\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) embeds the vertices of \!\(\*StyleBox[\"g\", \"TI\"]\) equally spaced on a circle."
Combinatorica`CircularVertices::usage = "\!\(\*RowBox[{\"CircularVertices\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs a list of \!\(\*StyleBox[\"n\", \"TI\"]\) points equally spaced on a circle. \n\!\(\*RowBox[{\"CircularVertices\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) embeds the vertices of \!\(\*StyleBox[\"g\", \"TI\"]\) equally spaced on a circle."
Combinatorica`CliqueQ::usage = "\!\(\*RowBox[{\"CliqueQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) yields True if the list of vertices \!\(\*StyleBox[\"c\", \"TI\"]\) defines a clique in graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`CoarserSetPartitionQ::usage = "\!\(\*RowBox[{\"CoarserSetPartitionQ\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) yields True if set partition \!\(\*StyleBox[\"b\", \"TI\"]\) is coarser than set partition \!\(\*StyleBox[\"a\", \"TI\"]\); that is, every block in \!\(\*StyleBox[\"a\", \"TI\"]\) is contained in some block in \!\(\*StyleBox[\"b\", \"TI\"]\)."
Combinatorica`CodeToLabeledTree::usage = "\!\(\*RowBox[{\"CodeToLabeledTree\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs the unique labeled tree on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices from the Pr\[UDoubleDot]fer code \!\(\*StyleBox[\"l\", \"TI\"]\), which consists of a list of \!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \"-\", \"2\"}]\) integers between 1 and \!\(\*StyleBox[\"n\", \"TI\"]\)."
Combinatorica`Cofactor::usage = "\!\(\*RowBox[{\"Cofactor\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"}\"}]}], \"]\"}]\) calculates the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) cofactor of matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
Combinatorica`CompleteBinaryTree::usage = "\!\(\*RowBox[{\"CompleteBinaryTree\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns a complete binary tree on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices."
Combinatorica`CompleteKPartiteGraph::usage = "\!\(\*RowBox[{\"CompleteKPartiteGraph\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"]\"}]\) creates a complete \!\(\*StyleBox[\"k\", \"TI\"]\)-partite graph of the prescribed shape, provided the \!\(\*StyleBox[\"k\", \"TI\"]\) arguments \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \" \"}]\) are positive integers. An option Type that takes on the values Directed or Undirected is allowed. The default setting for this option is \!\(\*RowBox[{\"Type\", \"->\", \"Undirected\"}]\)."
Combinatorica`CompleteQ::usage = "\!\(\*RowBox[{\"CompleteQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is complete. This means that between any pair of vertices there is an undirected edge or two directed edges going in opposite directions."
Combinatorica`Compositions::usage = "\!\(\*RowBox[{\"Compositions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a list of all compositions of integer \!\(\*StyleBox[\"n\", \"TI\"]\) into \!\(\*StyleBox[\"k\", \"TI\"]\) parts."
Combinatorica`ConnectedQ::usage = "\!\(\*RowBox[{\"ConnectedQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\) is connected. If \!\(\*StyleBox[\"g\", \"TI\"]\) is directed, the function returns True if the underlying undirected graph is connected. \n\!\(\*RowBox[{\"ConnectedQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"Strong\"}], \"]\"}]\) yields True if the directed graph \!\(\*StyleBox[\"g\", \"TI\"]\) is strongly connected.\n\!\(\*RowBox[{\"ConnectedQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"Weak\"}], \"]\"}]\) yields True if the directed graph \!\(\*StyleBox[\"g\", \"TI\"]\) is weakly connected."
Combinatorica`ConstructTableau::usage = "\!\(\*RowBox[{\"ConstructTableau\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) performs the bumping algorithm repeatedly on each element of permutation \!\(\*StyleBox[\"p\", \"TI\"]\), resulting in a distinct Young tableau."
Combinatorica`Contract::usage = "\!\(\*RowBox[{\"Contract\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the graph resulting from contracting the pair of vertices \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`CostOfPath::usage = "\!\(\*RowBox[{\"CostOfPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) sums up the weights of the edges in graph \!\(\*StyleBox[\"g\", \"TI\"]\) defined by the path \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`CoxeterGraph::usage = "CoxeterGraph gives a non-Hamiltonian graph with a high degree of symmetry such that there is a graph automorphism taking any path of length 3 to any other."
Combinatorica`CubeConnectedCycle::usage = "\!\(\*RowBox[{\"CubeConnectedCycle\", \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\) returns the graph obtained by replacing each vertex in a \!\(\*StyleBox[\"d\", \"TI\"]\)-dimensional hypercube by a cycle of length \!\(\*StyleBox[\"d\", \"TI\"]\). Cube-connected cycles share many properties with hypercubes, but have the additional desirable property that for \!\(\*RowBox[{StyleBox[\"d\", \"TI\"], \">\", \"1\"}]\) every vertex has degree 3."
Combinatorica`CubicalGraph::usage = "CubicalGraph returns the graph corresponding to the cube, a Platonic solid."
Combinatorica`Cut::usage = "Cut is a tag that can be used in a call to NetworkFlow to tell it to return the minimum cut."
Combinatorica`CycleIndex::usage = "\!\(\*RowBox[{\"CycleIndex\", \"[\", RowBox[{StyleBox[\"pg\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns the polynomial in \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", RowBox[{StyleBox[\"index\", \"TI\"], \"[\", StyleBox[\"pg\", \"TI\"], \"]\"}], \"]\"}]}]\) that is the cycle index of the permutation group \!\(\*StyleBox[\"pg\", \"TI\"]\). Here \!\(\*RowBox[{StyleBox[\"index\", \"TI\"], \"[\", StyleBox[\"pg\", \"TI\"], \"]\"}]\) refers to the length of each permutation in \!\(\*StyleBox[\"pg\", \"TI\"]\)."
Combinatorica`CycleStructure::usage = "\!\(\*RowBox[{\"CycleStructure\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns the monomial in \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", RowBox[{\"Length\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}], \"]\"}]}]\) that is the cycle structure of the permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`Cycle::usage = "\!\(\*RowBox[{\"Cycle\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs the cycle on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices, the 2-regular connected graph. An option Type that takes on values Directed or Undirected is allowed. The default setting is \!\(\*RowBox[{\"Type\", \"->\", \"Undirected\"}]\)."
Combinatorica`CyclicGroupIndex::usage = "\!\(\*RowBox[{\"CyclicGroupIndex\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns the cycle index of the cyclic group on \!\(\*StyleBox[\"n\", \"TI\"]\) symbols, expressed as a polynomial in \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]}]\)."
Combinatorica`Cyclic::usage = "Cyclic is an argument to the Polya-theoretic functions ListNecklaces, NumberOfNecklaces, and NecklacePolynomial, which count or enumerate distinct necklaces. Cyclic refers to the cyclic group acting on necklaces to make equivalent necklaces that can be obtained from each other by rotation."
Combinatorica`DeBruijnSequence::usage = "\!\(\*RowBox[{\"DeBruijnSequence\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns a De Bruijn sequence on the alphabet \!\(\*StyleBox[\"a\", \"TI\"]\), a shortest sequence in which every string of length \!\(\*StyleBox[\"n\", \"TI\"]\) on alphabet \!\(\*StyleBox[\"a\", \"TI\"]\) occurs as a contiguous subsequence."
Combinatorica`DegreeSequence::usage = "\!\(\*RowBox[{\"DegreeSequence\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the sorted degree sequence of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`DegreesOf2Neighborhood::usage = "\!\(\*RowBox[{\"DegreesOf2Neighborhood\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) returns the sorted list of degrees of vertices of graph \!\(\*StyleBox[\"g\", \"TI\"]\) within a distance of 2 from \!\(\*StyleBox[\"v\", \"TI\"]\)."
Combinatorica`Degrees::usage = "\!\(\*RowBox[{\"Degrees\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the degrees of vertices 1, 2, 3, \[Ellipsis] in that order."
Combinatorica`DeleteCycle::usage = "\!\(\*RowBox[{\"DeleteCycle\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) deletes a simple cycle \!\(\*StyleBox[\"c\", \"TI\"]\) from graph \!\(\*StyleBox[\"g\", \"TI\"]\). \!\(\*StyleBox[\"c\", \"TI\"]\) is specified as a sequence of vertices in which the first and last vertices are identical. \!\(\*StyleBox[\"g\", \"TI\"]\) can be directed or undirected. If \!\(\*StyleBox[\"g\", \"TI\"]\) does not contain \!\(\*StyleBox[\"c\", \"TI\"]\), it is returned unchanged; otherwise \!\(\*StyleBox[\"g\", \"TI\"]\) is returned with \!\(\*StyleBox[\"c\", \"TI\"]\) deleted."
Combinatorica`DeleteEdges::usage = "\!\(\*RowBox[{\"DeleteEdges\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"edgeList\", \"TI\"]}], \"]\"}]\) gives graph \!\(\*StyleBox[\"g\", \"TI\"]\) minus the list of edges \!\(\*StyleBox[\"edgeList\", \"TI\"]\). If \!\(\*StyleBox[\"g\", \"TI\"]\) is undirected, then the edges in \!\(\*StyleBox[\"edgeList\", \"TI\"]\) are treated as undirected edges; otherwise they are treated as directed edges. If there are multiple edges that qualify, then only one edge is deleted. \n\!\(\*RowBox[{RowBox[{\"DeleteEdges\", \"[\"}], StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"edgeList\", \"TI\"], \",\", RowBox[{\"All\", \"]\"}]}]\) will delete all edges that qualify. If only one edge is to be deleted, then \!\(\*StyleBox[\"edgeList\", \"TI\"]\) can have the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"}\"}]\); otherwise it has the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
Combinatorica`DeleteEdge::usage = "\!\(\*RowBox[{\"DeleteEdge\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) gives graph \!\(\*StyleBox[\"g\", \"TI\"]\) minus \!\(\*StyleBox[\"e\", \"TI\"]\). If \!\(\*StyleBox[\"g\", \"TI\"]\) is undirected, then \!\(\*StyleBox[\"e\", \"TI\"]\) is treated as an undirected edge; otherwise it is treated as a directed edge. If there are multiple edges between the specified vertices, only one edge is deleted. \n\!\(\*RowBox[{\"DeleteEdge\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"], \",\", \"All\"}], \"]\"}]\) will delete all edges between the specified pair of vertices. Using the tag Directed as a third argument in DeleteEdge is now obsolete."
Combinatorica`DeleteFromTableau::usage = "\!\(\*RowBox[{\"DeleteFromTableau\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) deletes the last element of row \!\(\*StyleBox[\"r\", \"TI\"]\) from Young tableau \!\(\*StyleBox[\"t\", \"TI\"]\)."
Combinatorica`DeleteVertex::usage = "\!\(\*RowBox[{\"DeleteVertex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) deletes a single vertex \!\(\*StyleBox[\"v\", \"TI\"]\) from graph \!\(\*StyleBox[\"g\", \"TI\"]\). Here \!\(\*StyleBox[\"v\", \"TI\"]\) is a vertex number."
Combinatorica`DeleteVertices::usage = "\!\(\*RowBox[{\"DeleteVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"vList\", \"TI\"]}], \"]\"}]\) deletes vertices in \!\(\*StyleBox[\"vList\", \"TI\"]\) from graph \!\(\*StyleBox[\"g\", \"TI\"]\). \!\(\*StyleBox[\"vList\", \"TI\"]\) has the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), where \!\(\*RowBox[{\" \", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]\) are vertex numbers."
Combinatorica`DepthFirstTraversal::usage = "\!\(\*RowBox[{\"DepthFirstTraversal\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) performs a depth-first traversal of graph \!\(\*StyleBox[\"g\", \"TI\"]\) starting from vertex \!\(\*StyleBox[\"v\", \"TI\"]\), and gives a list of vertices in the order in which they were encountered. \n\!\(\*RowBox[{\"DepthFirstTraversal\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", \"Edge\"}], \"]\"}]\) returns the edges of the graph that are traversed by the depth-first traversal in the order in which they are traversed. \n\!\(\*RowBox[{\"DepthFirstTraversal\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", \"Tree\"}], \"]\"}]\) returns the depth-first tree of the graph."
Combinatorica`DerangementQ::usage = "\!\(\*RowBox[{\"DerangementQ\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) tests whether permutation \!\(\*StyleBox[\"p\", \"TI\"]\) is a derangement, that is, a permutation without a fixed point."
Combinatorica`Derangements::usage = "\!\(\*RowBox[{\"Derangements\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) constructs all derangements of permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`Diameter::usage = "\!\(\*RowBox[{\"Diameter\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the diameter of graph \!\(\*StyleBox[\"g\", \"TI\"]\): the maximum length, among all pairs of vertices in \!\(\*StyleBox[\"g\", \"TI\"]\), of a shortest path between each pair."
Combinatorica`DihedralGroupIndex::usage = "\!\(\*RowBox[{\"DihedralGroupIndex\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns the cycle index of the dihedral group on \!\(\*StyleBox[\"n\", \"TI\"]\) symbols, expressed as a polynomial in \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]}]\)."
Combinatorica`Dihedral::usage = "Dihedral is an argument to the Polya-theoretic functions ListNecklaces, NumberOfNecklaces, and NecklacePolynomial, which count or enumerate distinct necklaces. \nDihedral refers to the dihedral group acting on necklaces to make equivalent necklaces that can be obtained from each other by a rotation or a flip."
Combinatorica`Dijkstra::usage = "\!\(\*RowBox[{\"Dijkstra\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives a shortest-path spanning tree and associated distances from vertex \!\(\*StyleBox[\"v\", \"TI\"]\) of graph \!\(\*StyleBox[\"g\", \"TI\"]\). The shortest-path spanning tree is given by a list in which element \!\(\*StyleBox[\"i\", \"TI\"]\) is the predecessor of vertex \!\(\*StyleBox[\"i\", \"TI\"]\) in the shortest-path spanning tree. Dijkstra does not work correctly when the edge weights are negative; BellmanFord should be used in this case."
Combinatorica`DilateVertices::usage = "\!\(\*RowBox[{\"DilateVertices\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) multiplies each coordinate of each vertex position in list \!\(\*StyleBox[\"v\", \"TI\"]\) by \!\(\*StyleBox[\"d\", \"TI\"]\), thus dilating the embedding. \n\!\(\*RowBox[{\"DilateVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) dilates the embedding of graph \!\(\*StyleBox[\"g\", \"TI\"]\) by the factor \!\(\*StyleBox[\"d\", \"TI\"]\)."
Combinatorica`Directed::usage = "Directed is an option value for Type."
Combinatorica`Distances::usage = "\!\(\*RowBox[{\"Distances\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) returns the distances in nondecreasing order from vertex \!\(\*StyleBox[\"v\", \"TI\"]\) to all vertices in \!\(\*StyleBox[\"g\", \"TI\"]\), treating \!\(\*StyleBox[\"g\", \"TI\"]\) as an unweighted graph."
Combinatorica`DistinctPermutations::usage = "\!\(\*RowBox[{\"DistinctPermutations\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) gives all permutations of the multiset described by list \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`Distribution::usage = "\!\(\*RowBox[{\"Distribution\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"set\", \"TI\"]}], \"]\"}]\) lists the frequency of each element of \!\(\*StyleBox[\"set\", \"TI\"]\) in list \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`DodecahedralGraph::usage = "DodecahedralGraph returns the graph corresponding to the dodecahedron, a Platonic solid."
Combinatorica`DominatingIntegerPartitionQ::usage = "\!\(\*RowBox[{\"DominatingIntegerPartitionQ\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) yields True if integer partition \!\(\*StyleBox[\"a\", \"TI\"]\) dominates integer partition \!\(\*StyleBox[\"b\", \"TI\"]\), that is, the sum of a size-\!\(\*StyleBox[\"t\", \"TI\"]\) prefix of \!\(\*StyleBox[\"a\", \"TI\"]\) is no smaller than the sum of a size-\!\(\*StyleBox[\"t\", \"TI\"]\) prefix of \!\(\*StyleBox[\"b\", \"TI\"]\) for every \!\(\*StyleBox[\"t\", \"TI\"]\)."
Combinatorica`DominationLattice::usage = "\!\(\*RowBox[{\"DominationLattice\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns a Hasse diagram of the partially ordered set on integer partitions of \!\(\*StyleBox[\"n\", \"TI\"]\) in which \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"<\", StyleBox[\"q\", \"TI\"]}]\) if \!\(\*StyleBox[\"q\", \"TI\"]\) dominates \!\(\*StyleBox[\"p\", \"TI\"]\). The function takes two options: Type and VertexLabel, with default values Undirected and False, respectively. When Type is set to Directed, the function produces the underlying directed acyclic graph. When VertexLabel is set to True, labels are produced for the vertices."
Combinatorica`DurfeeSquare::usage = "\!\(\*RowBox[{\"DurfeeSquare\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the number of rows involved in the Durfee square of partition \!\(\*StyleBox[\"p\", \"TI\"]\), the side of the largest-sized square contained within the Ferrers diagram of \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`EdgeChromaticNumber::usage = "\!\(\*RowBox[{\"EdgeChromaticNumber\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the fewest number of colors necessary to color each edge of graph \!\(\*StyleBox[\"g\", \"TI\"]\), so that no two edges incident on the same vertex have the same color."
Combinatorica`EdgeColoring::usage = "\!\(\*RowBox[{\"EdgeColoring\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) uses Brelaz's heuristic to find a good, but not necessarily minimal, edge coloring of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`EdgeColor::usage = "EdgeColor is an option that allows the user to associate colors with edges. Black is the default color. EdgeColor can be set as part of the graph data structure or in ShowGraph."
Combinatorica`EdgeDirection::usage = "EdgeDirection is an option that takes on values True or False, allowing the user to specify whether the graph is directed or not. EdgeDirection can be set as part of the graph data structure or in ShowGraph."
Combinatorica`EdgeLabelColor::usage = "EdgeLabelColor is an option that allows the user to associate different colors to edge labels. Black is the default color. EdgeLabelColor can be set as part of the graph data structure or in ShowGraph."
Combinatorica`EdgeLabelPosition::usage = "EdgeLabelPosition is an option that allows the user to place an edge label in a certain position relative to the midpoint of the edge. LowerLeft is the default value of this option. EdgeLabelPosition can be set as part of the graph data structure or in ShowGraph."
Combinatorica`EdgeLabel::usage = "EdgeLabel is an option that can take on values True or False, allowing the user to associate labels to edges. By default, there are no edge labels. The EdgeLabel option can be set as part of the graph data structure or in ShowGraph."
Combinatorica`Edges::usage = "\!\(\*RowBox[{\"Edges\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of edges in \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"Edges\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"All\"}], \"]\"}]\) gives the edges of \!\(\*StyleBox[\"g\", \"TI\"]\) along with the graphics options associated with each edge. \n\!\(\*RowBox[{\"Edges\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"EdgeWeight\"}], \"]\"}]\) returns the list of edges in \!\(\*StyleBox[\"g\", \"TI\"]\) along with their edge weights."
Combinatorica`Edge::usage = "Edge is an optional argument to inform certain functions to work with edges instead of vertices."
Combinatorica`EmptyGraph::usage = "\!\(\*RowBox[{\"EmptyGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) generates an empty graph on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices. An option Type that can take on values Directed or Undirected is provided. The default setting is \!\(\*RowBox[{\"Type\", \"->\", \"Undirected\"}]\)."
Combinatorica`EmptyQ::usage = "\!\(\*RowBox[{\"EmptyQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) contains no edges."
Combinatorica`EncroachingListSet::usage = "\!\(\*RowBox[{\"EncroachingListSet\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) constructs the encroaching list set associated with permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`EquivalenceClasses::usage = "\!\(\*RowBox[{\"EquivalenceClasses\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) identifies the equivalence classes among the elements of matrix \!\(\*StyleBox[\"r\", \"TI\"]\)."
Combinatorica`EquivalenceRelationQ::usage = "\!\(\*RowBox[{\"EquivalenceRelationQ\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) yields True if the matrix \!\(\*StyleBox[\"r\", \"TI\"]\) defines an equivalence relation. \n\!\(\*RowBox[{\"EquivalenceRelationQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) tests whether the adjacency matrix of graph \!\(\*StyleBox[\"g\", \"TI\"]\) defines an equivalence relation."
Combinatorica`Equivalences::usage = "\!\(\*RowBox[{\"Equivalences\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) lists the vertex equivalence classes between graphs \!\(\*StyleBox[\"g\", \"TI\"]\) and \!\(\*StyleBox[\"h\", \"TI\"]\) defined by their vertex degrees. \n\!\(\*RowBox[{\"Equivalences\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) lists the vertex equivalences for graph \!\(\*StyleBox[\"g\", \"TI\"]\) defined by the vertex degrees. \n\!\(\*RowBox[{\"Equivalences\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"]\"}]\) and \!\(\*RowBox[{\"Equivalences\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"]\"}]\) can also be used, where \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) are functions that compute other vertex invariants. It is expected that for each function \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), the call \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) returns the corresponding invariant at vertex \!\(\*StyleBox[\"v\", \"TI\"]\) in graph \!\(\*StyleBox[\"g\", \"TI\"]\). The functions \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) are evaluated in order, and the evaluation stops either when all functions have been evaluated or when an empty equivalence class is found. Three vertex invariants, DegreesOf2Neighborhood, NumberOf2Paths, and Distances are \!\(\*StyleBox[\"Combinatorica\", FontSlant -> \"Italic\"]\) functions and can be used to refine the equivalences."
Combinatorica`Euclidean::usage = "Euclidean is an option for SetEdgeWeights."
Combinatorica`EulerianCycle::usage = "\!\(\*RowBox[{\"EulerianCycle\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds an Eulerian cycle of \!\(\*StyleBox[\"g\", \"TI\"]\) if one exists."
Combinatorica`EulerianQ::usage = "\!\(\*RowBox[{\"EulerianQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is Eulerian, meaning there exists a tour that includes each edge exactly once."
Combinatorica`Eulerian::usage = "\!\(\*RowBox[{\"Eulerian\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the number of permutations of length \!\(\*StyleBox[\"n\", \"TI\"]\) with \!\(\*StyleBox[\"k\", \"TI\"]\) runs."
Combinatorica`ExactRandomGraph::usage = "\!\(\*RowBox[{\"ExactRandomGraph\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) constructs a random labeled graph of exactly \!\(\*StyleBox[\"e\", \"TI\"]\) edges and \!\(\*StyleBox[\"n\", \"TI\"]\) vertices."
Combinatorica`ExpandGraph::usage = "\!\(\*RowBox[{\"ExpandGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) expands graph \!\(\*StyleBox[\"g\", \"TI\"]\) to \!\(\*StyleBox[\"n\", \"TI\"]\) vertices by adding disconnected vertices. This is obsolete; use \!\(\*RowBox[{\"AddVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) instead."
Combinatorica`ExtractCycles::usage = "\!\(\*RowBox[{\"ExtractCycles\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a maximal list of edge-disjoint cycles in graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`FerrersDiagram::usage = "\!\(\*RowBox[{\"FerrersDiagram\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) draws a Ferrers diagram of integer partition \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`FindSet::usage = "\!\(\*RowBox[{\"FindSet\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the root of the set containing \!\(\*StyleBox[\"n\", \"TI\"]\) in union-find data structure \!\(\*StyleBox[\"s\", \"TI\"]\)."
Combinatorica`FiniteGraphs::usage = "FiniteGraphs produces a convenient list of all the interesting, finite, parameterless graphs built into \!\(\*StyleBox[\"Combinatorica\", FontSlant -> \"Italic\"]\)."
Combinatorica`FirstLexicographicTableau::usage = "\!\(\*RowBox[{\"FirstLexicographicTableau\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) constructs the first Young tableau with a shape described by partition \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`FolkmanGraph::usage = "FolkmanGraph returns a smallest graph that is edge-transitive but not vertex-transitive."
Combinatorica`FranklinGraph::usage = "FranklinGraph returns a 12-vertex graph that represents a 6-chromatic map on the Klein bottle. It is the sole counterexample to Heawood's map-coloring conjecture."
Combinatorica`FromAdjacencyLists::usage = "\!\(\*RowBox[{\"FromAdjacencyLists\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs an edge list representation for a graph from the given adjacency lists \!\(\*StyleBox[\"l\", \"TI\"]\), using a circular embedding. \n\!\(\*RowBox[{\"FromAdjacencyLists\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"v\", \"TI\"]\) as the embedding for the resulting graph. An option called Type that takes on the values Directed or Undirected can be used to affect the type of graph produced. The default value of Type is Undirected."
Combinatorica`FromAdjacencyMatrix::usage = "\!\(\*RowBox[{\"FromAdjacencyMatrix\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) constructs a graph from a given adjacency matrix \!\(\*StyleBox[\"m\", \"TI\"]\), using a circular embedding. \n\!\(\*RowBox[{\"FromAdjacencyMatrix\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"v\", \"TI\"]\) as the embedding for the resulting graph. An option Type that takes on the values Directed or Undirected can be used to affect the type of graph produced. The default value of Type is Undirected. \n\!\(\*RowBox[{\"FromAdjacencyMatrix\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", \"EdgeWeight\"}], \"]\"}]\) interprets the entries in \!\(\*StyleBox[\"m\", \"TI\"]\) as edge weights, with infinity representing missing edges, and from this constructs a weighted graph using a circular embedding. \n\!\(\*RowBox[{\"FromAdjacencyMatrix\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", \"EdgeWeight\"}], \"]\"}]\) uses \!\(\*StyleBox[\"v\", \"TI\"]\) as the embedding for the resulting graph. The option Type can be used along with the EdgeWeight tag."
Combinatorica`FromCycles::usage = "\!\(\*RowBox[{\"FromCycles\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the permutation that has the given cycle structure."
Combinatorica`FromInversionVector::usage = "\!\(\*RowBox[{\"FromInversionVector\", \"[\", StyleBox[\"v\", \"TI\"], \"]\"}]\) reconstructs the unique permutation with inversion vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
Combinatorica`FromOrderedPairs::usage = "\!\(\*RowBox[{\"FromOrderedPairs\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs an edge list representation from a list of ordered pairs \!\(\*StyleBox[\"l\", \"TI\"]\), using a circular embedding. \n\!\(\*RowBox[{\"FromOrderedPairs\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"v\", \"TI\"]\) as the embedding for the resulting graph. The option Type that takes on values Undirected or Directed can be used to affect the kind of graph produced. The default value of Type is Directed. \!\(\*RowBox[{\"Type\", \"->\", \"Undirected\"}]\) results in the underlying undirected graph."
Combinatorica`FromUnorderedPairs::usage = "\!\(\*RowBox[{\"FromUnorderedPairs\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs an edge list representation from a list of unordered pairs \!\(\*StyleBox[\"l\", \"TI\"]\), using a circular embedding.\n\!\(\*RowBox[{\"FromUnorderedPairs\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"v\", \"TI\"]\) as the embedding for the resulting graph. The option Type that takes on values Undirected or Directed can be used to affect the kind of graph produced."
Combinatorica`FruchtGraph::usage = "FruchtGraph returns the smallest 3-regular graph whose automorphism group consists of only the identity."
Combinatorica`FunctionalGraph::usage = "\!\(\*RowBox[{\"FunctionalGraph\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) takes a set \!\(\*StyleBox[\"v\", \"TI\"]\) and a function \!\(\*StyleBox[\"f\", \"TI\"]\) from \!\(\*StyleBox[\"v\", \"TI\"]\) to \!\(\*StyleBox[\"v\", \"TI\"]\) and constructs a directed graph with vertex set \!\(\*StyleBox[\"v\", \"TI\"]\) and edges \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]}], \"}\"}]\) for each \!\(\*StyleBox[\"x\", \"TI\"]\) in \!\(\*StyleBox[\"v\", \"TI\"]\). \n\!\(\*RowBox[{\"FunctionalGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) constructs a graph with vertex set \!\(\*StyleBox[\"v\", \"TI\"]\) and edge set \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]}], \"}\"}]\) for each \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). An option called Type that takes on the values Directed and Undirected is allowed. \!\(\*RowBox[{\"Type\", \"->\", \"Directed\"}]\) is the default, while \!\(\*RowBox[{\"Type\", \"->\", \"Undirected\"}]\) returns the corresponding underlying undirected graph. \n\!\(\*RowBox[{\"FunctionalGraph\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) takes a nonnegative integer \!\(\*StyleBox[\"n\", \"TI\"]\) and a function \!\(\*StyleBox[\"f\", \"TI\"]\) from \!\(\*RowBox[{\"{\", RowBox[{\"0\", \",\", \"1\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"n\", \"TI\"], \"-\", \"1\"}]}], \"}\"}]\) onto itself and produces the directed graph with vertex set \!\(\*RowBox[{\"{\", RowBox[{\"0\", \",\", \"1\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"n\", \"TI\"], \"-\", \"1\"}]}], \"}\"}]\) and edge set \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]}], \"}\"}]\) for each vertex \!\(\*StyleBox[\"x\", \"TI\"]\)."
Combinatorica`GeneralizedPetersenGraph::usage = "\!\(\*RowBox[{\"GeneralizedPetersenGraph\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns the generalized Petersen graph, for integers \!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \">\", \"1\"}]\) and \!\(\*RowBox[{StyleBox[\"k\", \"TI\"], \">\", \"0\"}]\), which is the graph with vertices \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\) and \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\) and edges \!\(\*RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[SubscriptBox[StyleBox[\"u\", \"TI\"], RowBox[{\"i\", StyleBox[\"+\", \"TR\"], StyleBox[\"1\", \"TR\"]}]], \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{\"i\", StyleBox[\"+\", \"TR\"], \"k\"}]], \"TI\"]}], \"}\"}]}]\), and \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\). The Petersen graph is identical to the generalized Petersen graph with \!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \"\[LongEqual]\", \"5\"}]\) and \!\(\*RowBox[{StyleBox[\"k\", \"TI\"], \"\[LongEqual]\", \"2\"}]\)."
Combinatorica`GetEdgeLabels::usage = "\!\(\*RowBox[{\"GetEdgeLabels\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the list of labels of the edges of \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{RowBox[{RowBox[{RowBox[{\"GetEdgeLabels\", \"[\"}], StyleBox[\"g\", \"TI\"]}], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) returns the list of labels in graph \!\(\*StyleBox[\"g\", \"TI\"]\) of the edges in \!\(\*StyleBox[\"e\", \"TI\"]\)."
Combinatorica`GetEdgeWeights::usage = "\!\(\*RowBox[{\"GetEdgeWeights\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the list of weights of the edges of \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"GetEdgeWeights\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) returns the list of weights in graph \!\(\*StyleBox[\"g\", \"TI\"]\) of the edges in \!\(\*StyleBox[\"e\", \"TI\"]\)."
Combinatorica`GetVertexLabels::usage = "\!\(\*RowBox[{\"GetVertexLabels\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the list of labels of vertices of \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"GetVertexLabels\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) returns the list of labels in graph \!\(\*StyleBox[\"g\", \"TI\"]\) of the vertices specified in list \!\(\*StyleBox[\"v\", \"TI\"]\)."
Combinatorica`GetVertexWeights::usage = "\!\(\*RowBox[{\"GetVertexWeights\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the list of weights of vertices of \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"GetVertexWeights\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) returns the list of weights in graph \!\(\*StyleBox[\"g\", \"TI\"]\) of the vertices in \!\(\*StyleBox[\"v\", \"TI\"]\)."
Combinatorica`Girth::usage = "\!\(\*RowBox[{\"Girth\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the length of a shortest cycle in a simple graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`GraphicQ::usage = "\!\(\*RowBox[{\"GraphicQ\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) yields True if the list of integers \!\(\*StyleBox[\"s\", \"TI\"]\) is a graphic sequence, and thus represents a degree sequence of some graph."
Combinatorica`GraphJoin::usage = "\!\(\*RowBox[{\"GraphJoin\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"]\"}]\) constructs the join of graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and so on. This is the graph obtained by adding all possible edges between different graphs to the graph union of \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
Combinatorica`GraphOptions::usage = "\!\(\*RowBox[{\"GraphOptions\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the display options associated with \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"GraphOptions\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) returns the display options associated with vertex \!\(\*StyleBox[\"v\", \"TI\"]\) in \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"GraphOptions\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) returns the display options associated with edge \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]\) in \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`GraphPolynomial::usage = "\!\(\*RowBox[{\"GraphPolynomial\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns a polynomial in \!\(\*StyleBox[\"x\", \"TI\"]\) in which the coefficient of \!\(\*SuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"m\", \"TI\"]]\) is the number of nonisomorphic graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and \!\(\*StyleBox[\"m\", \"TI\"]\) edges. \n\!\(\*RowBox[{\"GraphPolynomial\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", \"Directed\"}], \"]\"}]\) returns a polynomial in \!\(\*StyleBox[\"x\", \"TI\"]\) in which the coefficient of \!\(\*SuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"m\", \"TI\"]]\) is the number of nonisomorphic directed graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and \!\(\*StyleBox[\"m\", \"TI\"]\) edges."
Combinatorica`GraphProduct::usage = "\!\(\*RowBox[{\"GraphProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) constructs the product of graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and so forth."
Combinatorica`GraphSum::usage = "\!\(\*RowBox[{\"GraphSum\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) constructs the graph resulting from joining the edge lists of graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and so forth."
Combinatorica`GrayCodeKSubsets::usage = "\!\(\*RowBox[{\"GrayCodeKSubsets\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) generates \!\(\*StyleBox[\"k\", \"TI\"]\)-subsets of \!\(\*StyleBox[\"l\", \"TI\"]\) in Gray code order."
Combinatorica`GrayCodeSubsets::usage = "\!\(\*RowBox[{\"GrayCodeSubsets\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs a binary reflected Gray code on set \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`GrayCode::usage = "\!\(\*RowBox[{\"GrayCode\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs a binary reflected Gray code on set \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`GrayGraph::usage = "GrayGraph returns a 3-regular, 54-vertex graph that is edge-transitive but not vertex-transitive\[LongDash]the smallest known such example."
Combinatorica`Greedy::usage = "Greedy is a value that the option Algorithm can take in calls to functions such as VertexCover, telling the function to use a greedy algorithm."
Combinatorica`GreedyVertexCover::usage = "\!\(\*RowBox[{\"GreedyVertexCover\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns a vertex cover of graph \!\(\*StyleBox[\"g\", \"TI\"]\) constructed using the greedy algorithm. This is a natural heuristic for constructing a vertex cover, but it can produce poor vertex covers."
Combinatorica`GroetzschGraph::usage = "GroetzschGraph returns the smallest triangle-free graph with chromatic number 4. This is identical to \!\(\*RowBox[{\"MycielskiGraph\", \"[\", \"4\", \"]\"}]\)."
Combinatorica`GrotztschGraph::usage = "GrotztschGraph returns the smallest triangle-free graph with chromatic number 4. This is identical to \!\(\*RowBox[{\"MycielskiGraph\", \"[\", \"4\", \"]\"}]\)."
Combinatorica`HamiltonianCycle::usage = "\!\(\*RowBox[{\"HamiltonianCycle\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a Hamiltonian cycle in graph \!\(\*StyleBox[\"g\", \"TI\"]\) if one exists. \n\!\(\*RowBox[{\"HamiltonianCycle\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"All\"}], \"]\"}]\) gives all Hamiltonian cycles of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`HamiltonianPath::usage = "\!\(\*RowBox[{\"HamiltonianPath\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a Hamiltonian path in graph \!\(\*StyleBox[\"g\", \"TI\"]\) if one exists. \n\!\(\*RowBox[{\"HamiltonianPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"All\"}], \"]\"}]\) gives all Hamiltonian paths of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`HamiltonianQ::usage = "\!\(\*RowBox[{\"HamiltonianQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if there exists a Hamiltonian cycle in graph \!\(\*StyleBox[\"g\", \"TI\"]\), or in other words, if there exists a cycle that visits each vertex exactly once."
Combinatorica`Harary::usage = "\!\(\*RowBox[{\"Harary\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) constructs the minimal \!\(\*StyleBox[\"k\", \"TI\"]\)-connected graph on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices."
Combinatorica`HasseDiagram::usage = "\!\(\*RowBox[{\"HasseDiagram\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) constructs a Hasse diagram of the relation defined by directed acyclic graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`Heapify::usage = "\!\(\*RowBox[{\"Heapify\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) builds a heap from permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`HeapSort::usage = "\!\(\*RowBox[{\"HeapSort\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) performs a heap sort on the items of list \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`HeawoodGraph::usage = "HeawoodGraph returns a smallest \!\(\*RowBox[{\"(\", RowBox[{\"6\", \",\", \"3\"}], \")\"}]\)-cage, a 3-regular graph with girth 6."
Combinatorica`HerschelGraph::usage = "HerschelGraph returns a graph object that represents a Herschel graph."
Combinatorica`HideCycles::usage = "\!\(\*RowBox[{\"HideCycles\", \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) canonically encodes the cycle structure \!\(\*StyleBox[\"c\", \"TI\"]\) into a unique permutation."
Combinatorica`HighlightedEdgeColors::usage = "HighlightedEdgeColors is an option to Highlight that determines which colors are used for the highlighted edges."
Combinatorica`HighlightedEdgeStyle::usage = "HighlightedEdgeStyle is an option to Highlight that determines how the highlighted edges are drawn."
Combinatorica`HighlightedVertexColors::usage = "HighlightedVertexColors is an option to Highlight that determines which colors are used for the highlighted vertices."
Combinatorica`HighlightedVertexStyle::usage = "HighlightedVertexStyle is an option to Highlight that determines how the highlighted vertices are drawn."
Combinatorica`Highlight::usage = "\!\(\*RowBox[{\"Highlight\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) displays \!\(\*StyleBox[\"g\", \"TI\"]\) with elements in \!\(\*StyleBox[\"p\", \"TI\"]\) highlighted. The second argument \!\(\*StyleBox[\"p\", \"TI\"]\) has the form \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), where the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are disjoint subsets of vertices and edges of \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`Hypercube::usage = "\!\(\*RowBox[{\"Hypercube\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs an \!\(\*StyleBox[\"n\", \"TI\"]\)-dimensional hypercube."
Combinatorica`IcosahedralGraph::usage = "IcosahedralGraph returns the graph corresponding to the icosahedron, a Platonic solid."
Combinatorica`IdenticalQ::usage = "\!\(\*RowBox[{\"IdenticalQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) yields True if graphs \!\(\*StyleBox[\"g\", \"TI\"]\) and \!\(\*StyleBox[\"h\", \"TI\"]\) have identical edge lists, even though the associated graphics information need not be the same."
Combinatorica`IdentityPermutation::usage = "\!\(\*RowBox[{\"IdentityPermutation\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the size-\!\(\*StyleBox[\"n\", \"TI\"]\) identity permutation."
Combinatorica`InDegree::usage = "\!\(\*RowBox[{\"InDegree\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns the in-degree of vertex \!\(\*StyleBox[\"n\", \"TI\"]\) in directed graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"InDegree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the sequence of in-degrees of the vertices in directed graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`IndependentSetQ::usage = "\!\(\*RowBox[{\"IndependentSetQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) yields True if the vertices in list \!\(\*StyleBox[\"i\", \"TI\"]\) define an independent set in graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`Index::usage = "\!\(\*RowBox[{\"Index\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the index of permutation \!\(\*StyleBox[\"p\", \"TI\"]\), the sum of all subscripts \!\(\*StyleBox[\"j\", \"TI\"]\) such that \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"\[LeftDoubleBracket]\", StyleBox[\"j\", \"TI\"], \"\[RightDoubleBracket]\"}]\) is greater than \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"\[LeftDoubleBracket]\", RowBox[{StyleBox[\"j\", \"TI\"], \"+\", \"1\"}], \"\[RightDoubleBracket]\"}]\)."
Combinatorica`InduceSubgraph::usage = "\!\(\*RowBox[{\"InduceSubgraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) constructs the subgraph of graph \!\(\*StyleBox[\"g\", \"TI\"]\) induced by the list of vertices \!\(\*StyleBox[\"s\", \"TI\"]\)."
Combinatorica`InitializeUnionFind::usage = "\!\(\*RowBox[{\"InitializeUnionFind\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) initializes a union-find data structure for \!\(\*StyleBox[\"n\", \"TI\"]\) elements."
Combinatorica`InsertIntoTableau::usage = "\!\(\*RowBox[{\"InsertIntoTableau\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) inserts integer \!\(\*StyleBox[\"e\", \"TI\"]\) into Young tableau \!\(\*StyleBox[\"t\", \"TI\"]\) using the bumping algorithm. \n\!\(\*RowBox[{\"InsertIntoTableau\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", \"All\"}], \"]\"}]\) inserts \!\(\*StyleBox[\"e\", \"TI\"]\) into Young tableau \!\(\*StyleBox[\"t\", \"TI\"]\) and returns the new tableau as well as the row whose size is expanded as a result of the insertion."
Combinatorica`IntervalGraph::usage = "\!\(\*RowBox[{\"IntervalGraph\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs the interval graph defined by the list of intervals \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`Invariants::usage = "Invariants is an option to the functions Isomorphism and IsomorphicQ that informs these functions about which vertex invariants to use in computing equivalences between vertices."
Combinatorica`InversionPoset::usage = "\!\(\*RowBox[{\"InversionPoset\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns a Hasse diagram of the partially ordered set on size-\!\(\*StyleBox[\"n\", \"TI\"]\) permutations in which \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"<\", StyleBox[\"q\", \"TI\"]}]\) if \!\(\*StyleBox[\"q\", \"TI\"]\) can be obtained from \!\(\*StyleBox[\"p\", \"TI\"]\) by an adjacent transposition that places the larger element before the smaller."
Combinatorica`Inversions::usage = "\!\(\*RowBox[{\"Inversions\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) counts the number of inversions in permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`InvolutionQ::usage = "\!\(\*RowBox[{\"InvolutionQ\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) yields True if permutation \!\(\*StyleBox[\"p\", \"TI\"]\) is its own inverse."
Combinatorica`Involutions::usage = "\!\(\*RowBox[{\"Involutions\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) gives the list of involutions of the elements in the list \!\(\*StyleBox[\"l\", \"TI\"]\). \n\!\(\*RowBox[{\"Involutions\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", \"Cycles\"}], \"]\"}]\) gives the involutions in their cycle representation. \n\!\(\*RowBox[{\"Involution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives size-\!\(\*StyleBox[\"n\", \"TI\"]\) involutions. \n\!\(\*RowBox[{\"Involutions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", \"Cycles\"}], \"]\"}]\) gives size-\!\(\*StyleBox[\"n\", \"TI\"]\) involutions in their cycle representation."
Combinatorica`IsomorphicQ::usage = "\!\(\*RowBox[{\"IsomorphicQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) yields True if graphs \!\(\*StyleBox[\"g\", \"TI\"]\) and \!\(\*StyleBox[\"h\", \"TI\"]\) are isomorphic. "
Combinatorica`IsomorphismQ::usage = "\!\(\*RowBox[{\"IsomorphismQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) tests if permutation \!\(\*StyleBox[\"p\", \"TI\"]\) defines an isomorphism between graphs \!\(\*StyleBox[\"g\", \"TI\"]\) and \!\(\*StyleBox[\"h\", \"TI\"]\)."
Combinatorica`Isomorphism::usage = "\!\(\*RowBox[{\"Isomorphism\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) gives an isomorphism between graphs \!\(\*StyleBox[\"g\", \"TI\"]\) and \!\(\*StyleBox[\"h\", \"TI\"]\) if one exists. \n\!\(\*RowBox[{\"Isomorphism\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", \"All\"}], \"]\"}]\) gives all isomorphisms between graphs \!\(\*StyleBox[\"g\", \"TI\"]\) and \!\(\*StyleBox[\"h\", \"TI\"]\). \n\!\(\*RowBox[{\"Isomorphism\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the automorphism group of \!\(\*StyleBox[\"g\", \"TI\"]\). "
Combinatorica`Josephus::usage = "\!\(\*RowBox[{\"Josephus\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) generates the inverse of the permutation defined by executing every \!\(\*StyleBox[\"m\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) member in a circle of \!\(\*StyleBox[\"n\", \"TI\"]\) members."
Combinatorica`KnightsTourGraph::usage = "\!\(\*RowBox[{\"KnightsTourGraph\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns a graph with \!\(\*StyleBox[RowBox[{\"m\", \"\[VeryThinSpace]\", \"n\"}], \"TI\"]\) vertices in which each vertex represents a square in an \!\(\*StyleBox[\"m\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) chessboard, and each edge corresponds to a legal move by a knight from one square to another."
Combinatorica`KSetPartitions::usage = "\!\(\*RowBox[{\"KSetPartitions\", \"[\", RowBox[{StyleBox[\"set\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns the list of set partitions of \!\(\*StyleBox[\"set\", \"TI\"]\) with \!\(\*StyleBox[\"k\", \"TI\"]\) blocks. \n\!\(\*RowBox[{\"KSetPartitions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns the list of set partitions of \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) with \!\(\*StyleBox[\"k\", \"TI\"]\) blocks. If all set partitions of a set are needed, use the function SetPartitions."
Combinatorica`KSubsetGroupIndex::usage = "\!\(\*RowBox[{\"KSubsetGroupIndex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns the cycle index of the \!\(\*StyleBox[\"k\", \"TI\"]\)-subset group on \!\(\*StyleBox[\"s\", \"TI\"]\) expressed as a polynomial in \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\). This function also takes the optional argument Type, which tells the function whether the elements of \!\(\*StyleBox[\"s\", \"TI\"]\) should be treated as sets or tuples."
Combinatorica`KSubsetGroup::usage = "\!\(\*RowBox[{\"KSubsetGroup\", \"[\", RowBox[{StyleBox[\"pg\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) returns the group induced by a permutation group \!\(\*StyleBox[\"pg\", \"TI\"]\) on the set \!\(\*StyleBox[\"s\", \"TI\"]\) of \!\(\*StyleBox[\"k\", \"TI\"]\)-subsets of \!\(\*RowBox[{\"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\), where \!\(\*StyleBox[\"n\", \"TI\"]\) is the index of \!\(\*StyleBox[\"pg\", \"TI\"]\). The optional argument Type can be Ordered or Unordered and, depending on the value of \!\(\*RowBox[{\"Type\", StyleBox[\"s\", \"TI\"]}]\), is treated as a set of \!\(\*StyleBox[\"k\", \"TI\"]\)-subsets or \!\(\*StyleBox[\"k\", \"TI\"]\)-tuples."
Combinatorica`KSubsets::usage = "\!\(\*RowBox[{\"KSubsets\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives all subsets of set \!\(\*StyleBox[\"l\", \"TI\"]\) containing exactly \!\(\*StyleBox[\"k\", \"TI\"]\) elements, ordered lexicographically."
Combinatorica`LabeledTreeToCode::usage = "\!\(\*RowBox[{\"LabeledTreeToCode\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) reduces the tree \!\(\*StyleBox[\"g\", \"TI\"]\) to its Pr\[UDoubleDot]fer code."
Combinatorica`LastLexicographicTableau::usage = "\!\(\*RowBox[{\"LastLexicographicTableau\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) constructs the last Young tableau with shape described by partition \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`LeviGraph::usage = "LeviGraph returns the unique \!\(\*RowBox[{\"(\", RowBox[{\"8\", \",\", \"3\"}], \")\"}]\)-cage, a 3-regular graph whose girth is 8."
Combinatorica`LexicographicPermutations::usage = "\!\(\*RowBox[{\"LexicographicPermutations\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs all permutations of list \!\(\*StyleBox[\"l\", \"TI\"]\) in lexicographic order."
Combinatorica`LexicographicSubsets::usage = "\!\(\*RowBox[{\"LexicographicSubsets\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) gives all subsets of set \!\(\*StyleBox[\"l\", \"TI\"]\) in lexicographic order. \n\!\(\*RowBox[{\"LexicographicSubsets\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns all subsets of \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\) in lexicographic order."
Combinatorica`ListGraphs::usage = "\!\(\*RowBox[{\"ListGraphs\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) returns all nonisomorphic undirected graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and \!\(\*StyleBox[\"m\", \"TI\"]\) edges. \n\!\(\*RowBox[{\"ListGraphs\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", \"Directed\"}], \"]\"}]\) returns all nonisomorphic directed graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and \!\(\*StyleBox[\"m\", \"TI\"]\) edges. \n\!\(\*RowBox[{\"ListGraphs\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns all nonisomorphic undirected graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices. \n\!\(\*RowBox[{\"ListGraphs\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", \"Directed\"}], \"]\"}]\) returns all nonisomorphic directed graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices."
Combinatorica`ListNecklaces::usage = "\!\(\*RowBox[{\"ListNecklaces\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", \"Cyclic\"}], \"]\"}]\) returns all distinct necklaces whose beads are colored by colors from \!\(\*StyleBox[\"c\", \"TI\"]\). Here \!\(\*StyleBox[\"c\", \"TI\"]\) is a list of \!\(\*StyleBox[\"n\", \"TI\"]\) not necessarily distinct colors, and two colored necklaces are considered equivalent if one can be obtained by rotating the other. \n\!\(\*RowBox[{RowBox[{RowBox[{RowBox[{\"ListNecklaces\", \"[\"}], StyleBox[\"n\", \"TI\"]}], \",\", StyleBox[\"c\", \"TI\"], \",\", \"Dihedral\"}], \"]\"}]\) is similar except that two necklaces are considered equivalent if one can be obtained from the other by a rotation or a flip."
Combinatorica`LNorm::usage = "\!\(\*RowBox[{\"LNorm\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) is a value that the option WeightingFunction, used in the function SetEdgeWeights, can take. Here \!\(\*StyleBox[\"p\", \"TI\"]\) can be any integer or Infinity."
Combinatorica`LongestIncreasingSubsequence::usage = "\!\(\*RowBox[{\"LongestIncreasingSubsequence\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) finds the longest increasing scattered subsequence of permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`LoopPosition::usage = "LoopPosition is an option to ShowGraph whose values tell ShowGraph where to position a loop around a vertex. This option can take on values UpperLeft, UpperRight, LowerLeft, and LowerRight."
Combinatorica`LowerLeft::usage = "LowerLeft is a value that options VertexNumberPosition, VertexLabelPosition, and EdgeLabelPosition can take on in ShowGraph."
Combinatorica`LowerRight::usage = "LowerRight is a value that options VertexNumberPosition, VertexLabelPosition, and EdgeLabelPosition can take on in ShowGraph."
Combinatorica`MakeDirected::usage = "\!\(\*RowBox[{\"MakeDirected\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) constructs a directed graph from a given undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\) by replacing each undirected edge in \!\(\*StyleBox[\"g\", \"TI\"]\) by two directed edges pointing in opposite directions. "
Combinatorica`MakeGraph::usage = "\!\(\*RowBox[{\"MakeGraph\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) constructs the graph with vertices corresponding to \!\(\*StyleBox[\"v\", \"TI\"]\) and edges between all pairs of vertices \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) in \!\(\*StyleBox[\"v\", \"TI\"]\) for which the binary relation defined by the Boolean function \!\(\*StyleBox[\"f\", \"TI\"]\) is True."
Combinatorica`MakeSimple::usage = "\!\(\*RowBox[{\"MakeSimple\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the undirected graph free of multiple edges and self-loops that is derived from graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`MakeUndirected::usage = "\!\(\*RowBox[{\"MakeUndirected\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the underlying undirected graph of the given directed graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`MaximalMatching::usage = "\!\(\*RowBox[{\"MaximalMatching\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of edges associated with a maximal matching of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`MaximumAntichain::usage = "\!\(\*RowBox[{\"MaximumAntichain\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a largest set of unrelated vertices in partial order \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`MaximumClique::usage = "\!\(\*RowBox[{\"MaximumClique\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a largest clique in graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"MaximumClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns a \!\(\*StyleBox[\"k\", \"TI\"]\)-clique, if such a thing exists in \!\(\*StyleBox[\"g\", \"TI\"]\); otherwise it returns \!\(\*RowBox[{\"{\", \"}\"}]\)."
Combinatorica`MaximumIndependentSet::usage = "\!\(\*RowBox[{\"MaximumIndependentSet\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a largest independent set of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`MaximumSpanningTree::usage = "\!\(\*RowBox[{\"MaximumSpanningTree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) uses Kruskal's algorithm to find a maximum spanning tree of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`McGeeGraph::usage = "McGeeGraph returns the unique \!\(\*RowBox[{\"(\", RowBox[{\"7\", \",\", \"3\"}], \")\"}]\)-cage, a 3-regular graph with girth 7."
Combinatorica`MeredithGraph::usage = "MeredithGraph returns a 4-regular, 4-connected graph that is not Hamiltonian, providing a counterexample to a conjecture by C. St. J. A. Nash-Williams."
Combinatorica`MinimumChainPartition::usage = "\!\(\*RowBox[{\"MinimumChainPartition\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) partitions partial-order \!\(\*StyleBox[\"g\", \"TI\"]\) into a minimum number of chains."
Combinatorica`MinimumChangePermutations::usage = "\!\(\*RowBox[{\"MinimumChangePermutations\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs all permutations of list \!\(\*StyleBox[\"l\", \"TI\"]\) such that adjacent permutations differ by only one transposition."
Combinatorica`MinimumSpanningTree::usage = "\!\(\*RowBox[{\"MinimumSpanningTree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) uses Kruskal's algorithm to find a minimum spanning tree of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`MinimumVertexColoring::usage = "\!\(\*RowBox[{\"MinimumVertexColoring\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns a minimum vertex coloring of \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"MinimumVertexColoring\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns a \!\(\*StyleBox[\"k\", \"TI\"]\)-coloring of \!\(\*StyleBox[\"g\", \"TI\"]\), if one exists."
Combinatorica`MinimumVertexCover::usage = "\!\(\*RowBox[{\"MinimumVertexCover\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a minimum vertex cover of graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Combinatorica`MultipleEdgesQ::usage = "\!\(\*RowBox[{\"MultipleEdgesQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"g\", \"TI\"]\) has multiple edges between pairs of vertices. It yields False otherwise."
Combinatorica`MultiplicationTable::usage = "\!\(\*RowBox[{\"MultiplicationTable\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) constructs the complete transition table defined by the binary relation function \!\(\*StyleBox[\"f\", \"TI\"]\) on the elements of list \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`M::usage = "\!\(\*RowBox[{\"M\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the number of edges in the graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"M\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"Directed\"}], \"]\"}]\) is obsolete because \!\(\*RowBox[{\"M\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) works for directed as well as undirected graphs."
Combinatorica`MycielskiGraph::usage = "\!\(\*RowBox[{\"MycielskiGraph\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]\) returns a triangle-free graph with chromatic number \!\(\*StyleBox[\"k\", \"TI\"]\), for any positive integer \!\(\*StyleBox[\"k\", \"TI\"]\)."
Combinatorica`NecklacePolynomial::usage = "\!\(\*RowBox[{\"NecklacePolynomial\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", \"Cyclic\"}], \"]\"}]\) returns a polynomial in the colors in \!\(\*StyleBox[\"c\", \"TI\"]\) whose coefficients represent numbers of ways of coloring an \!\(\*StyleBox[\"n\", \"TI\"]\)-bead necklace with colors chosen from \!\(\*StyleBox[\"c\", \"TI\"]\), assuming that two colorings are equivalent if one can be obtained from the other by a rotation. \n\!\(\*RowBox[{\"NecklacePolynomial\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", \"Dihedral\"}], \"]\"}]\) is different in that it considers two colorings equivalent if one can be obtained from the other by a rotation or a flip or both."
Combinatorica`Neighborhood::usage = "\!\(\*RowBox[{\"Neighborhood\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns the subset of vertices in \!\(\*StyleBox[\"g\", \"TI\"]\) that are at a distance of \!\(\*StyleBox[\"k\", \"TI\"]\) or less from vertex \!\(\*StyleBox[\"v\", \"TI\"]\). \n\!\(\*RowBox[{\"Neighborhood\", \"[\", RowBox[{StyleBox[\"al\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) behaves identically, except that it takes as input an adjacency list \!\(\*StyleBox[\"al\", \"TI\"]\)."
Combinatorica`NetworkFlowEdges::usage = "\!\(\*RowBox[{\"NetworkFlowEdges\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"sink\", \"TI\"]}], \"]\"}]\) returns the edges of the graph with positive flow, showing the distribution of a maximum flow from \!\(\*StyleBox[\"source\", \"TI\"]\) to \!\(\*StyleBox[\"sink\", \"TI\"]\) in graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`NetworkFlow::usage = "\!\(\*RowBox[{\"NetworkFlow\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"sink\", \"TI\"]}], \"]\"}]\) returns the value of a maximum flow through graph \!\(\*StyleBox[\"g\", \"TI\"]\) from \!\(\*StyleBox[\"source\", \"TI\"]\) to \!\(\*StyleBox[\"sink\", \"TI\"]\). \n\!\(\*RowBox[{\"NetworkFlow\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"sink\", \"TI\"], \",\", \"Edge\"}], \"]\"}]\) returns the edges in \!\(\*StyleBox[\"g\", \"TI\"]\) that have positive flow, along with their flows, in a maximum flow from \!\(\*StyleBox[\"source\", \"TI\"]\) to \!\(\*StyleBox[\"sink\", \"TI\"]\). \n\!\(\*RowBox[{\"NetworkFlow\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"sink\", \"TI\"], \",\", \"Cut\"}], \"]\"}]\) returns a minimum cut between \!\(\*StyleBox[\"source\", \"TI\"]\) and \!\(\*StyleBox[\"sink\", \"TI\"]\). \n\!\(\*RowBox[{\"NetworkFlow\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"sink\", \"TI\"], \",\", \"All\"}], \"]\"}]\) returns the adjacency list of \!\(\*StyleBox[\"g\", \"TI\"]\) along with flows on each edge in a maximum flow from \!\(\*StyleBox[\"source\", \"TI\"]\) to \!\(\*StyleBox[\"sink\", \"TI\"]\)."
Combinatorica`NextBinarySubset::usage = "\!\(\*RowBox[{\"NextBinarySubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) constructs the subset of \!\(\*StyleBox[\"l\", \"TI\"]\) following subset \!\(\*StyleBox[\"s\", \"TI\"]\) in the order obtained by interpreting subsets as binary string representations of integers."
Combinatorica`NextComposition::usage = "\!\(\*RowBox[{\"NextComposition\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs the integer composition that follows \!\(\*StyleBox[\"l\", \"TI\"]\) in a canonical order."
Combinatorica`NextGrayCodeSubset::usage = "\!\(\*RowBox[{\"NextGrayCodeSubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) constructs the successor of \!\(\*StyleBox[\"s\", \"TI\"]\) in the Gray code of set \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`NextKSubset::usage = "\!\(\*RowBox[{\"NextKSubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-subset of list \!\(\*StyleBox[\"l\", \"TI\"]\), following the \!\(\*StyleBox[\"k\", \"TI\"]\)-subset \!\(\*StyleBox[\"s\", \"TI\"]\) in lexicographic order."
Combinatorica`NextLexicographicSubset::usage = "\!\(\*RowBox[{\"NextLexicographicSubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the lexicographic successor of subset \!\(\*StyleBox[\"s\", \"TI\"]\) of set \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`NextPartition::usage = "\!\(\*RowBox[{\"NextPartition\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the integer partition following \!\(\*StyleBox[\"p\", \"TI\"]\) in reverse lexicographic order."
Combinatorica`NextPermutation::usage = "\!\(\*RowBox[{\"NextPermutation\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the permutation following \!\(\*StyleBox[\"p\", \"TI\"]\) in lexicographic order."
Combinatorica`NextSubset::usage = "\!\(\*RowBox[{\"NextSubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) constructs the subset of \!\(\*StyleBox[\"l\", \"TI\"]\) following subset \!\(\*StyleBox[\"s\", \"TI\"]\) in canonical order."
Combinatorica`NextTableau::usage = "\!\(\*RowBox[{\"NextTableau\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) gives the tableau of shape \!\(\*StyleBox[\"t\", \"TI\"]\), following \!\(\*StyleBox[\"t\", \"TI\"]\) in lexicographic order."
Combinatorica`NoMultipleEdges::usage = "NoMultipleEdges is an option value for Type."
Combinatorica`NonLineGraphs::usage = "NonLineGraphs returns a graph whose connected components are the nine graphs whose presence as a vertex-induced subgraph in a graph \!\(\*StyleBox[\"g\", \"TI\"]\) makes \!\(\*StyleBox[\"g\", \"TI\"]\) a nonline graph."
Combinatorica`NoPerfectMatchingGraph::usage = "NoPerfectMatchingGraph returns a connected graph with 16 vertices that contains no perfect matching."
Combinatorica`NormalDashed::usage = "NormalDashed is a value that the option EdgeStyle can take on in the graph data structure or in ShowGraph."
Combinatorica`NormalizeVertices::usage = "\!\(\*RowBox[{\"NormalizeVertices\", \"[\", StyleBox[\"v\", \"TI\"], \"]\"}]\) gives a list of vertices with a similar embedding as \!\(\*StyleBox[\"v\", \"TI\"]\), but with the coordinates of all points scaled to be between 0 and 1."
Combinatorica`NoSelfLoops::usage = "NoSelfLoops is an option value for Type."
Combinatorica`NthPair::usage = "\!\(\*RowBox[{\"NthPair\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) unordered pair of distinct positive integers, when sequenced to minimize the size of the larger integer. Pairs that have the same larger integer are sequenced in increasing order of their smaller integer."
Combinatorica`NthPermutation::usage = "\!\(\*RowBox[{\"NthPermutation\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) lexicographic permutation of list \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`NthSubset::usage = "\!\(\*RowBox[{\"NthSubset\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) subset of list \!\(\*StyleBox[\"l\", \"TI\"]\) in canonical order."
Combinatorica`NumberOf2Paths::usage = "\!\(\*RowBox[{\"NumberOf2Paths\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) returns a sorted list that contains the number of paths of length 2 to different vertices of \!\(\*StyleBox[\"g\", \"TI\"]\) from \!\(\*StyleBox[\"v\", \"TI\"]\)."
Combinatorica`NumberOfCompositions::usage = "\!\(\*RowBox[{\"NumberOfCompositions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) counts the number of distinct compositions of integer \!\(\*StyleBox[\"n\", \"TI\"]\) into \!\(\*StyleBox[\"k\", \"TI\"]\) parts."
Combinatorica`NumberOfDerangements::usage = "\!\(\*RowBox[{\"NumberOfDerangements\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) counts the derangements on \!\(\*StyleBox[\"n\", \"TI\"]\) elements, that is, the permutations without any fixed points."
Combinatorica`NumberOfDirectedGraphs::usage = "\!\(\*RowBox[{\"NumberOfDirectedGraphs\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns the number of nonisomorphic directed graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices. \n\!\(\*RowBox[{\"NumberOfDirectedGraphs\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) returns the number of nonisomorphic directed graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and \!\(\*StyleBox[\"m\", \"TI\"]\) edges."
Combinatorica`NumberOfGraphs::usage = "\!\(\*RowBox[{\"NumberOfGraphs\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns the number of nonisomorphic undirected graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices. \n\!\(\*RowBox[{\"NumberOfGraphs\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) returns the number of nonisomorphic undirected graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and \!\(\*StyleBox[\"m\", \"TI\"]\) edges."
Combinatorica`NumberOfInvolutions::usage = "\!\(\*RowBox[{\"NumberOfInvolutions\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) counts the number of involutions on \!\(\*StyleBox[\"n\", \"TI\"]\) elements."
Combinatorica`NumberOfKPaths::usage = "\!\(\*RowBox[{\"NumberOfKPaths\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns a sorted list that contains the number of paths of length \!\(\*StyleBox[\"k\", \"TI\"]\) to different vertices of \!\(\*StyleBox[\"g\", \"TI\"]\) from \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"NumberOfKPaths\", \"[\", RowBox[{StyleBox[\"al\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) behaves identically, except that it takes an adjacency list \!\(\*StyleBox[\"al\", \"TI\"]\) as input."
Combinatorica`NumberOfNecklaces::usage = "\!\(\*RowBox[{\"NumberOfNecklaces\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"nc\", \"TI\"], \",\", \"Cyclic\"}], \"]\"}]\) returns the number of distinct ways in which an \!\(\*StyleBox[\"n\", \"TI\"]\)-bead necklace can be colored with \!\(\*StyleBox[\"nc\", \"TI\"]\) colors, assuming that two colorings are equivalent if one can be obtained from the other by a rotation. \n\!\(\*RowBox[{\"NumberOfNecklaces\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"nc\", \"TI\"], \",\", \"Dihedral\"}], \"]\"}]\) returns the number of distinct ways in which an \!\(\*StyleBox[\"n\", \"TI\"]\)-bead necklace can be colored with \!\(\*StyleBox[\"nc\", \"TI\"]\) colors, assuming that two colorings are equivalent if one can be obtained from the other by a rotation or a flip."
Combinatorica`NumberOfPartitions::usage = "\!\(\*RowBox[{\"NumberOfPartitions\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) counts the number of integer partitions of \!\(\*StyleBox[\"n\", \"TI\"]\)."
Combinatorica`NumberOfPermutationsByCycles::usage = "\!\(\*RowBox[{\"NumberOfPermutationsByCycles\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the number of permutations of length \!\(\*StyleBox[\"n\", \"TI\"]\) with exactly \!\(\*StyleBox[\"m\", \"TI\"]\) cycles."
Combinatorica`NumberOfPermutationsByInversions::usage = "\!\(\*RowBox[{\"NumberOfPermutationsByInversions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the number of permutations of length \!\(\*StyleBox[\"n\", \"TI\"]\) with exactly \!\(\*StyleBox[\"k\", \"TI\"]\) inversions. \n\!\(\*RowBox[{\"NumberOfPermutationsByInversions\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a table of the number of length-\!\(\*StyleBox[\"n\", \"TI\"]\) permutations with \!\(\*StyleBox[\"k\", \"TI\"]\) inversions, for all \!\(\*StyleBox[\"k\", \"TI\"]\)."
Combinatorica`NumberOfPermutationsByType::usage = "\!\(\*RowBox[{\"NumberOfPermutationsByTypes\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) gives the number of permutations of type \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`NumberOfSpanningTrees::usage = "\!\(\*RowBox[{\"NumberOfSpanningTrees\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the number of labeled spanning trees of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`NumberOfTableaux::usage = "\!\(\*RowBox[{\"NumberOfTableaux\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) uses the hook length formula to count the number of Young tableaux with shape defined by partition \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`OctahedralGraph::usage = "OctahedralGraph returns the graph corresponding to the octahedron, a Platonic solid."
Combinatorica`OddGraph::usage = "\!\(\*RowBox[{\"OddGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns the graph whose vertices are the size \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"n\", \"TI\"], \"-\", \"1\"}], \")\"}]\) subsets of a size \!\(\*RowBox[{\"(\", RowBox[{\"2\", StyleBox[\"n\", \"TI\"], \"\[Dash]\", \"1\"}], \")\"}]\) set and whose edges connect pairs of vertices that correspond to disjoint subsets. "
Combinatorica`One::usage = "One is a tag used in several functions to inform the functions that only one object need be considered or only one solution be produced, as opposed to all objects or all solutions."
Combinatorica`Optimum::usage = "Optimum is a value that the option Algorithm can take on when used in functions VertexColoring and VertexCover."
Combinatorica`OrbitInventory::usage = "\!\(\*RowBox[{\"OrbitInventory\", \"[\", RowBox[{StyleBox[\"ci\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) returns the value of the cycle index \!\(\*StyleBox[\"ci\", \"TI\"]\) when each formal variable \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", StyleBox[\"i\", \"TI\"], \"]\"}]\) is replaced by \!\(\*StyleBox[\"w\", \"TI\"]\). \n\!\(\*RowBox[{\"OrbitInventory\", \"[\", RowBox[{StyleBox[\"ci\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"weights\", \"TI\"]}], \"]\"}]\) returns the inventory of orbits induced on a set of functions by the action of a group with cycle index \!\(\*StyleBox[\"ci\", \"TI\"]\). It is assumed that each element in the range of the functions is assigned a weight in list \!\(\*StyleBox[\"weights\", \"TI\"]\)."
Combinatorica`OrbitRepresentatives::usage = "\!\(\*RowBox[{\"OrbitRepresentatives\", \"[\", RowBox[{StyleBox[\"pg\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns a representative of each orbit of \!\(\*StyleBox[\"x\", \"TI\"]\) induced by the action of the group \!\(\*StyleBox[\"pg\", \"TI\"]\) on \!\(\*StyleBox[\"x\", \"TI\"]\)."
Combinatorica`Orbits::usage = "\!\(\*RowBox[{\"Orbits\", \"[\", RowBox[{StyleBox[\"pg\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns the orbits of \!\(\*StyleBox[\"x\", \"TI\"]\) induced by the action of the group \!\(\*StyleBox[\"pg\", \"TI\"]\) on \!\(\*StyleBox[\"x\", \"TI\"]\)."
Combinatorica`Ordered::usage = "Ordered is an option to the functions KSubsetGroup and KSubsetGroupIndex that tells the functions whether they should treat the input as sets or tuples."
Combinatorica`OrientGraph::usage = "\!\(\*RowBox[{\"OrientGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) assigns a direction to each edge of a bridgeless, undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\), so that the graph is strongly connected."
Combinatorica`OutDegree::usage = "\!\(\*RowBox[{\"OutDegree\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns the out-degree of vertex \!\(\*StyleBox[\"n\", \"TI\"]\) in directed graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"OutDegree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the sequence of out-degrees of the vertices in directed graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`PairGroupIndex::usage = "\!\(\*RowBox[{\"PairGroupIndex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns the cycle index of the pair group induced by \!\(\*StyleBox[\"g\", \"TI\"]\) as a polynomial in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}]\), \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}]\), \[Ellipsis].\n\!\(\*RowBox[{\"PairGroupIndex\", \"[\", RowBox[{StyleBox[\"ci\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) takes the cycle index \!\(\*StyleBox[\"ci\", \"TI\"]\) of a group \!\(\*StyleBox[\"g\", \"TI\"]\) with formal variables \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}]\), \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}]\), \[Ellipsis], and returns the cycle index of the pair group induced by \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"PairGroupIndex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", \"Ordered\"}], \"]\"}]\) returns the cycle index of the ordered pair group induced by \!\(\*StyleBox[\"g\", \"TI\"]\) as a polynomial in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}]\), \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}]\), \[Ellipsis].\n\!\(\*RowBox[{\"PairGroupIndex\", \"[\", RowBox[{StyleBox[\"ci\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", \"Ordered\"}], \"]\"}]\) takes the cycle index \!\(\*StyleBox[\"ci\", \"TI\"]\) of a group \!\(\*StyleBox[\"g\", \"TI\"]\) with formal variables \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}]\), \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}]\), \[Ellipsis], and returns the cycle index of the ordered pair group induced by \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`PairGroup::usage = "\!\(\*RowBox[{\"PairGroup\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the group induced on 2-sets by the permutation group \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"PairGroup\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"Ordered\"}], \"]\"}]\) returns the group induced on ordered pairs with distinct elements by the permutation group \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`ParentsToPaths::usage = "\!\(\*RowBox[{\"ParentsToPaths\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) takes a list of parents \!\(\*StyleBox[\"l\", \"TI\"]\) and returns the path from \!\(\*StyleBox[\"i\", \"TI\"]\) to \!\(\*StyleBox[\"j\", \"TI\"]\) encoded in the parent list. \n\!\(\*RowBox[{\"ParentsToPaths\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) returns the paths from \!\(\*StyleBox[\"i\", \"TI\"]\) to all vertices."
Combinatorica`Parent::usage = "Parent is a tag used as an argument to the function AllPairsShortestPath in order to inform this function that information about parents in the shortest paths is also wanted."
Combinatorica`PartialOrderQ::usage = "\!\(\*RowBox[{\"PartialOrderQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the binary relation defined by edges of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a partial order, meaning it is transitive, reflexive and antisymmetric. \n\!\(\*RowBox[{\"PartialOrderQ\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) yields True if the binary relation defined by the square matrix \!\(\*StyleBox[\"r\", \"TI\"]\) is a partial order."
Combinatorica`PartitionLattice::usage = "\!\(\*RowBox[{\"PartitionLattice\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns a Hasse diagram of the partially ordered set on set partitions of 1 through \!\(\*StyleBox[\"n\", \"TI\"]\) in which \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"<\", StyleBox[\"q\", \"TI\"]}]\) if \!\(\*StyleBox[\"q\", \"TI\"]\) is finer than \!\(\*StyleBox[\"p\", \"TI\"]\), that is, each block in \!\(\*StyleBox[\"q\", \"TI\"]\) is contained in some block in \!\(\*StyleBox[\"p\", \"TI\"]\). "
Combinatorica`PartitionQ::usage = "\!\(\*RowBox[{\"PartitionQ\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"p\", \"TI\"]\) is an integer partition. \n\!\(\*RowBox[{\"PartitionQ\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) yields True if \!\(\*StyleBox[\"p\", \"TI\"]\) is a partition of \!\(\*StyleBox[\"n\", \"TI\"]\)."
Combinatorica`Partitions::usage = "\!\(\*RowBox[{\"Partitions\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs all partitions of integer \!\(\*StyleBox[\"n\", \"TI\"]\) in reverse lexicographic order. \n\!\(\*RowBox[{\"Partitions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) constructs all partitions of the integer \!\(\*StyleBox[\"n\", \"TI\"]\) with maximum part at most \!\(\*StyleBox[\"k\", \"TI\"]\), in reverse lexicographic order."
Combinatorica`PathConditionGraph::usage = "PathConditionGraph is obsolete. This functionality is no longer supported in \!\(\*StyleBox[\"Combinatorica\", FontSlant -> \"Italic\"]\)."
Combinatorica`PerfectQ::usage = "\!\(\*RowBox[{\"PerfectQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"g\", \"TI\"]\) is a perfect graph, meaning that for every induced subgraph of \!\(\*StyleBox[\"g\", \"TI\"]\), the size of a largest clique equals the chromatic number."
Combinatorica`PermutationGraph::usage = "\!\(\*RowBox[{\"PermutationGraph\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the permutation graph for the permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`PermutationGroupQ::usage = "\!\(\*RowBox[{\"PermutationGroupQ\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) yields True if the list of permutations \!\(\*StyleBox[\"l\", \"TI\"]\) forms a permutation group."
Combinatorica`PermutationQ::usage = "\!\(\*RowBox[{\"PermutationQ\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"p\", \"TI\"]\) is a list representing a permutation and False otherwise."
Combinatorica`PermutationToTableaux::usage = "\!\(\*RowBox[{\"PermutationToTableaux\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) returns the tableaux pair that can be constructed from \!\(\*StyleBox[\"p\", \"TI\"]\) using the Robinson\[Dash]Schensted\[Dash]Knuth correspondence."
Combinatorica`PermutationType::usage = "\!\(\*RowBox[{\"PermutationType\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) returns the type of permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`PermutationWithCycle::usage = "\!\(\*RowBox[{\"PermutationWithCycle\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a size \!\(\*StyleBox[\"n\", \"TI\"]\) permutation in which \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) is a cycle and all other elements are fixed points."
Combinatorica`PermuteSubgraph::usage = "\!\(\*RowBox[{\"PermuteSubgraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) permutes the vertices of a subgraph of \!\(\*StyleBox[\"g\", \"TI\"]\) induced by \!\(\*StyleBox[\"p\", \"TI\"]\) according to \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`PlanarQ::usage = "\!\(\*RowBox[{\"PlanarQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is planar, meaning it can be drawn in the plane so no two edges cross."
Combinatorica`PointsAndLines::usage = "PointsAndLines is now obsolete."
Combinatorica`Polya::usage = "\!\(\*RowBox[{\"Polya\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) returns the polynomial giving the number of colorings, with \!\(\*StyleBox[\"m\", \"TI\"]\) colors, of a structure defined by the permutation group \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`PseudographQ::usage = "\!\(\*RowBox[{\"PseudographQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a pseudograph, meaning it contains self-loops."
Combinatorica`RadialEmbedding::usage = "\!\(\*RowBox[{\"RadialEmbedding\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) constructs a radial embedding of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) in which vertices are placed on concentric circles around \!\(\*StyleBox[\"v\", \"TI\"]\) depending on their distance from \!\(\*StyleBox[\"v\", \"TI\"]\). \n\!\(\*RowBox[{\"RadialEmbedding\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) constructs a radial embedding of graph \!\(\*StyleBox[\"g\", \"TI\"]\), radiating from the center of the graph."
Combinatorica`RandomComposition::usage = "\!\(\*RowBox[{\"RandomComposition\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) constructs a random composition of integer \!\(\*StyleBox[\"n\", \"TI\"]\) into \!\(\*StyleBox[\"k\", \"TI\"]\) parts."
Combinatorica`RandomHeap::usage = "\!\(\*RowBox[{\"RandomHeap\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs a random heap on \!\(\*StyleBox[\"n\", \"TI\"]\) elements."
Combinatorica`RandomKSetPartition::usage = "\!\(\*RowBox[{\"RandomKSetPartition\", \"[\", RowBox[{StyleBox[\"set\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns a random set partition of \!\(\*StyleBox[\"set\", \"TI\"]\) with \!\(\*StyleBox[\"k\", \"TI\"]\) blocks. \n\!\(\*RowBox[{\"RandomKSetPartition\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns a random set partition of the first \!\(\*StyleBox[\"n\", \"TI\"]\) natural numbers into \!\(\*StyleBox[\"k\", \"TI\"]\) blocks."
Combinatorica`RandomKSubset::usage = "\!\(\*RowBox[{\"RandomKSubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a random subset of set \!\(\*StyleBox[\"l\", \"TI\"]\) with exactly \!\(\*StyleBox[\"k\", \"TI\"]\) elements."
Combinatorica`RandomPartition::usage = "\!\(\*RowBox[{\"RandomPartition\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs a random partition of integer \!\(\*StyleBox[\"n\", \"TI\"]\)."
Combinatorica`RandomPermutation1::usage = "RandomPermutation1 is now obsolete. Use RandomPermutation instead."
Combinatorica`RandomPermutation2::usage = "RandomPermutation2 is now obsolete. Use RandomPermutation instead."
Combinatorica`RandomRGF::usage = "\!\(\*RowBox[{\"RandomRGF\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns a random restricted growth function (RGF) defined on the first \!\(\*StyleBox[\"n\", \"TI\"]\) natural numbers. \n\!\(\*RowBox[{\"RandomRGF\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns a random RGF defined on the first \!\(\*StyleBox[\"n\", \"TI\"]\) natural numbers having maximum element equal to \!\(\*StyleBox[\"k\", \"TI\"]\)."
Combinatorica`RandomSetPartition::usage = "\!\(\*RowBox[{\"RandomSetPartition\", \"[\", StyleBox[\"set\", \"TI\"], \"]\"}]\) returns a random set partition of \!\(\*StyleBox[\"set\", \"TI\"]\). \n\!\(\*RowBox[{\"RandomSetPartition\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns a random set partition of the first \!\(\*StyleBox[\"n\", \"TI\"]\) natural numbers."
Combinatorica`RandomSubset::usage = "\!\(\*RowBox[{\"RandomSubset\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) creates a random subset of set \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`RandomTableau::usage = "\!\(\*RowBox[{\"RandomTableau\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) constructs a random Young tableau of shape \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`RandomTree::usage = "\!\(\*RowBox[{\"RandomTree\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs a random labeled tree on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices."
Combinatorica`RandomVertices::usage = "\!\(\*RowBox[{\"RandomVertices\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) assigns a random embedding to graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`RankBinarySubset::usage = "\!\(\*RowBox[{\"RankBinarySubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the rank of subset \!\(\*StyleBox[\"s\", \"TI\"]\) of set \!\(\*StyleBox[\"l\", \"TI\"]\) in the ordering of subsets of \!\(\*StyleBox[\"l\", \"TI\"]\), obtained by interpreting these subsets as binary string representations of integers."
Combinatorica`RankedEmbedding::usage = "\!\(\*RowBox[{\"RankedEmbedding\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) takes a set partition \!\(\*StyleBox[\"l\", \"TI\"]\) of vertices \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\) and returns an embedding of the vertices in the plane such that the vertices in each block occur on a vertical line with block 1 vertices on the leftmost line, block 2 vertices in the next line, and so on. \n\!\(\*RowBox[{\"RankedEmbedding\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) takes a graph \!\(\*StyleBox[\"g\", \"TI\"]\) and a set partition \!\(\*StyleBox[\"l\", \"TI\"]\) of the vertices of \!\(\*StyleBox[\"g\", \"TI\"]\) and returns the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with vertices embedded according to \!\(\*RowBox[{\"RankedEmbedding\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\). \n\!\(\*RowBox[{\"RankedEmbedding\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) takes a graph \!\(\*StyleBox[\"g\", \"TI\"]\) and a set \!\(\*StyleBox[\"s\", \"TI\"]\) of vertices of \!\(\*StyleBox[\"g\", \"TI\"]\) and returns a ranked embedding of \!\(\*StyleBox[\"g\", \"TI\"]\) in which vertices in \!\(\*StyleBox[\"s\", \"TI\"]\) are in block 1, vertices at distance 1 from any vertex in block 1 are in block 2, and so on."
Combinatorica`RankGraph::usage = "\!\(\*RowBox[{\"RankGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) partitions the vertices into classes based on the shortest geodesic distance to a member of list \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`RankGrayCodeSubset::usage = "\!\(\*RowBox[{\"RankGrayCodeSubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the rank of subset \!\(\*StyleBox[\"s\", \"TI\"]\) of set \!\(\*StyleBox[\"l\", \"TI\"]\) in the Gray code ordering of the subsets of \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`RankKSetPartition::usage = "\!\(\*RowBox[{\"RankKSetPartition\", \"[\", RowBox[{StyleBox[\"sp\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) ranks \!\(\*StyleBox[\"sp\", \"TI\"]\) in the list of all \!\(\*StyleBox[\"k\", \"TI\"]\)-block set partitions of \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"RankSetPartition\", \"[\", StyleBox[\"sp\", \"TI\"], \"]\"}]\) ranks \!\(\*StyleBox[\"sp\", \"TI\"]\) in the list of all \!\(\*StyleBox[\"k\", \"TI\"]\)-block set partitions of the set of elements that appear in any subset in \!\(\*StyleBox[\"sp\", \"TI\"]\)."
Combinatorica`RankKSubset::usage = "\!\(\*RowBox[{\"RankKSubset\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) gives the rank of \!\(\*StyleBox[\"k\", \"TI\"]\)-subset \!\(\*StyleBox[\"s\", \"TI\"]\) of set \!\(\*StyleBox[\"l\", \"TI\"]\) in the lexicographic ordering of the \!\(\*StyleBox[\"k\", \"TI\"]\)-subsets of \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`RankPermutation::usage = "\!\(\*RowBox[{\"RankPermutation\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the rank of permutation \!\(\*StyleBox[\"p\", \"TI\"]\) in lexicographic order."
Combinatorica`RankRGF::usage = "\!\(\*RowBox[{\"RankRGF\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) returns the rank of a restricted growth function (RGF) \!\(\*StyleBox[\"f\", \"TI\"]\) in the lexicographic order of all RGFs."
Combinatorica`RankSetPartition::usage = "\!\(\*RowBox[{\"RankSetPartition\", \"[\", RowBox[{StyleBox[\"sp\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) ranks \!\(\*StyleBox[\"sp\", \"TI\"]\) in the list of all set partitions of set \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"RankSetPartition\", \"[\", StyleBox[\"sp\", \"TI\"], \"]\"}]\) ranks \!\(\*StyleBox[\"sp\", \"TI\"]\) in the list of all set partitions of the set of elements that appear in any subset in \!\(\*StyleBox[\"sp\", \"TI\"]\)."
Combinatorica`RankSubset::usage = "\!\(\*RowBox[{\"RankSubset\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the rank, in canonical order, of subset \!\(\*StyleBox[\"s\", \"TI\"]\) of set \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`ReadGraph::usage = "\!\(\*RowBox[{\"ReadGraph\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) reads a graph represented as edge lists from file \!\(\*StyleBox[\"f\", \"TI\"]\) and returns a graph object."
Combinatorica`RealizeDegreeSequence::usage = "\!\(\*RowBox[{\"RealizeDegreeSequence\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) constructs a semirandom graph with degree sequence \!\(\*StyleBox[\"s\", \"TI\"]\)."
Combinatorica`ReflexiveQ::usage = "\!\(\*RowBox[{\"ReflexiveQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the adjacency matrix of \!\(\*StyleBox[\"g\", \"TI\"]\) represents a reflexive binary relation."
Combinatorica`RegularGraph::usage = "\!\(\*RowBox[{\"RegularGraph\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) constructs a semirandom \!\(\*StyleBox[\"k\", \"TI\"]\)-regular graph on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices, if such a graph exists."
Combinatorica`RegularQ::usage = "\!\(\*RowBox[{\"RegularQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"g\", \"TI\"]\) is a regular graph."
Combinatorica`RemoveMultipleEdges::usage = "\!\(\*RowBox[{\"RemoveMultipleEdges\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the graph obtained by deleting multiple edges from \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`RemoveSelfLoops::usage = "\!\(\*RowBox[{\"RemoveSelfLoops\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the graph obtained by deleting self-loops in \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`ResidualFlowGraph::usage = "\!\(\*RowBox[{\"ResidualFlowGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"flow\", \"TI\"]}], \"]\"}]\) returns the directed residual flow graph for graph \!\(\*StyleBox[\"g\", \"TI\"]\) with respect to \!\(\*StyleBox[\"flow\", \"TI\"]\)."
Combinatorica`RevealCycles::usage = "\!\(\*RowBox[{\"RevealCycles\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) unveils the canonical hidden cycle structure of permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`ReverseEdges::usage = "\!\(\*RowBox[{\"ReverseEdges\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) flips the directions of all edges in a directed graph."
Combinatorica`RGFQ::usage = "\!\(\*RowBox[{\"RGFQ\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"l\", \"TI\"]\) is a restricted growth function. It yields False otherwise."
Combinatorica`RGFs::usage = "\!\(\*RowBox[{\"RGFs\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) lists all restricted growth functions on the first \!\(\*StyleBox[\"n\", \"TI\"]\) natural numbers in lexicographic order."
Combinatorica`RGFToSetPartition::usage = "\!\(\*RowBox[{\"RGFToSetPartition\", \"[\", RowBox[{StyleBox[\"rgf\", \"TI\"], \",\", StyleBox[\"set\", \"TI\"]}], \"]\"}]\) converts the restricted growth function \!\(\*StyleBox[\"rgf\", \"TI\"]\) into the corresponding set partition of \!\(\*StyleBox[\"set\", \"TI\"]\). "
Combinatorica`RobertsonGraph::usage = "RobertsonGraph returns a 19-vertex graph that is the unique \!\(\*RowBox[{\"(\", RowBox[{\"4\", \",\", \"5\"}], \")\"}]\)-cage graph."
Combinatorica`RootedEmbedding::usage = "\!\(\*RowBox[{\"RootedEmbedding\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) constructs a rooted embedding of graph \!\(\*StyleBox[\"g\", \"TI\"]\) with vertex \!\(\*StyleBox[\"v\", \"TI\"]\) as the root. \n\!\(\*RowBox[{\"RootedEmbedding\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) constructs a rooted embedding with a center of \!\(\*StyleBox[\"g\", \"TI\"]\) as the root."
Combinatorica`RotateVertices::usage = "\!\(\*RowBox[{\"RotateVertices\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) rotates each vertex position in list \!\(\*StyleBox[\"v\", \"TI\"]\) by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians about the origin \!\(\*RowBox[{\"(\", RowBox[{\"0\", \",\", \"0\"}], \")\"}]\). \n\!\(\*RowBox[{\"RotateVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) rotates the embedding of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians about the origin \!\(\*RowBox[{\"(\", RowBox[{\"0\", \",\", \"0\"}], \")\"}]\). "
Combinatorica`Runs::usage = "\!\(\*RowBox[{\"Runs\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) partitions \!\(\*StyleBox[\"p\", \"TI\"]\) into contiguous increasing subsequences."
Combinatorica`SamenessRelation::usage = "\!\(\*RowBox[{\"SamenessRelation\", \"[\", StyleBox[\"l\", \"TI\"], \"]\"}]\) constructs a binary relation from a list \!\(\*StyleBox[\"l\", \"TI\"]\) of permutations, which is an equivalence relation if \!\(\*StyleBox[\"l\", \"TI\"]\) is a permutation group."
Combinatorica`SelectionSort::usage = "\!\(\*RowBox[{\"SelectionSort\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) sorts list \!\(\*StyleBox[\"l\", \"TI\"]\) using ordering function \!\(\*StyleBox[\"f\", \"TI\"]\)."
Combinatorica`SelfComplementaryQ::usage = "\!\(\*RowBox[{\"SelfComplementaryQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is self-complementary, meaning it is isomorphic to its complement."
Combinatorica`SelfLoopsQ::usage = "\!\(\*RowBox[{\"SelfLoopsQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) has self-loops."
Combinatorica`SetEdgeLabels::usage = "\!\(\*RowBox[{\"SetEdgeLabels\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) assigns the labels in \!\(\*StyleBox[\"l\", \"TI\"]\) to edges of \!\(\*StyleBox[\"g\", \"TI\"]\). "
Combinatorica`SetEdgeWeights::usage = "\!\(\*RowBox[{\"SetEdgeWeights\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) assigns random real weights in the range \!\(\*RowBox[{\"[\", RowBox[{\"0\", \",\", \"1\"}], \"]\"}]\) to edges in \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"SetEdgeWeights\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) assigns edge weights to the edges in the edge list \!\(\*StyleBox[\"e\", \"TI\"]\). \n\!\(\*RowBox[{\"SetEdgeWeights\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) assigns the weights in the weight list \!\(\*StyleBox[\"w\", \"TI\"]\) to the edges of \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"SetEdgeWeights\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) assigns the weights in the weight list \!\(\*StyleBox[\"w\", \"TI\"]\) to the edges in edge list \!\(\*StyleBox[\"e\", \"TI\"]\)."
Combinatorica`SetGraphOptions::usage = "\!\(\*RowBox[{\"SetGraphOptions\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) returns \!\(\*StyleBox[\"g\", \"TI\"]\) with the options \!\(\*StyleBox[\"opts\", \"TI\"]\) set. \n\!\(\*RowBox[{\"SetGraphOptions\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"opts\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"opts\", \"TI\"]]}], \"]\"}]\) returns the graph with the options \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"opts\", \"TI\"]]\) set for vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], \"2\"]\), \[Ellipsis] and the options \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"opts\", \"TI\"]]\) set for the graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"SetGraphOptions\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"opts\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"opts\", \"TI\"]]}], \"]\"}]\) with edges \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] works similarly. \n\!\(\*RowBox[{\"SetGraphOptions\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elements\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"opts\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elements\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"opts\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], RowBox[{\"}\", \",\"}], StyleBox[\"opts\", \"TI\"]}]}]}]}], \"]\"}]\) returns \!\(\*StyleBox[\"g\", \"TI\"]\) with the options \!\(\*SubscriptBox[StyleBox[\"opts\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) set for the elements in the sequence \!\(\*SubscriptBox[StyleBox[\"elements\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), the options \!\(\*SubscriptBox[StyleBox[\"opts\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) set for the elements in the sequence \!\(\*SubscriptBox[StyleBox[\"elements\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and so on. "
Combinatorica`SetPartitionListViaRGF::usage = "\!\(\*RowBox[{\"SetPartitionListViaRGF\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) lists all set partitions of the first \!\(\*StyleBox[\"n\", \"TI\"]\) natural numbers by first listing all restricted growth functions (RGFs) on these and then mapping the RGFs to corresponding set partitions. \n\!\(\*RowBox[{\"SetPartitionListViaRGF\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) lists all RGFs on the first \!\(\*StyleBox[\"n\", \"TI\"]\) natural numbers whose maximum element is \!\(\*StyleBox[\"k\", \"TI\"]\) and then maps these RGFs into the corresponding set partitions, all of which contain exactly \!\(\*StyleBox[\"k\", \"TI\"]\) blocks."
Combinatorica`SetPartitionQ::usage = "\!\(\*RowBox[{\"SetPartitionQ\", \"[\", RowBox[{StyleBox[\"sp\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) determines if \!\(\*StyleBox[\"sp\", \"TI\"]\) is a set partition of set \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"SetPartitionQ\", \"[\", StyleBox[\"sp\", \"TI\"], \"]\"}]\) tests if \!\(\*StyleBox[\"sp\", \"TI\"]\) is a set of disjoint sets."
Combinatorica`SetPartitions::usage = "\!\(\*RowBox[{\"SetPartitions\", \"[\", StyleBox[\"set\", \"TI\"], \"]\"}]\) returns the list of set partitions of \!\(\*StyleBox[\"set\", \"TI\"]\). \n\!\(\*RowBox[{\"SetPartitions\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns the list of set partitions of \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\)."
Combinatorica`SetPartitionToRGF::usage = "\!\(\*RowBox[{\"SetPartitionToRGF\", \"[\", RowBox[{StyleBox[\"sp\", \"TI\"], \",\", StyleBox[\"set\", \"TI\"]}], \"]\"}]\) converts the set partition \!\(\*StyleBox[\"sp\", \"TI\"]\) of \!\(\*StyleBox[\"set\", \"TI\"]\) into the corresponding restricted growth function. "
Combinatorica`SetVertexLabels::usage = "\!\(\*RowBox[{\"SetVertexLabels\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) assigns the labels in \!\(\*StyleBox[\"l\", \"TI\"]\) to vertices of \!\(\*StyleBox[\"g\", \"TI\"]\). "
Combinatorica`SetVertexWeights::usage = "\!\(\*RowBox[{\"SetVertexWeights\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) assigns random real weights in the range \!\(\*RowBox[{\"[\", RowBox[{\"0\", \",\", \"1\"}], \"]\"}]\) to vertices in \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"SetVertexWeights\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) assigns the weights in the weight list \!\(\*StyleBox[\"w\", \"TI\"]\) to the vertices of \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"SetVertexWeights\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"vs\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) assigns the weights in the weight list \!\(\*StyleBox[\"w\", \"TI\"]\) to the vertices in the vertex list \!\(\*StyleBox[\"vs\", \"TI\"]\)."
Combinatorica`ShakeGraph::usage = "\!\(\*RowBox[{\"ShakeGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) performs a random perturbation of the vertices of graph \!\(\*StyleBox[\"g\", \"TI\"]\), with each vertex moving, at most, a distance \!\(\*StyleBox[\"d\", \"TI\"]\) from its original position."
Combinatorica`ShortestPathSpanningTree::usage = "\!\(\*RowBox[{\"ShortestPathSpanningTree\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) constructs a shortest-path spanning tree rooted at \!\(\*StyleBox[\"v\", \"TI\"]\), so that a shortest path in graph \!\(\*StyleBox[\"g\", \"TI\"]\) from \!\(\*StyleBox[\"v\", \"TI\"]\) to any other vertex is a path in the tree. "
Combinatorica`ShortestPath::usage = "\!\(\*RowBox[{\"ShortestPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"]}], \"]\"}]\) finds a shortest path between vertices \!\(\*StyleBox[\"start\", \"TI\"]\) and \!\(\*StyleBox[\"end\", \"TI\"]\) in graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Combinatorica`ShowGraphArray::usage = "\!\(\*RowBox[{\"ShowGraphArray\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \"]\"}]\) displays a row of graphs. \n\!\(\*RowBox[{\"ShowGraphArray\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \"]\"}]\) displays a two-dimensional table of graphs."
Combinatorica`ShowGraph::usage = "\!\(\*RowBox[{\"ShowGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) displays the graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"ShowGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"Directed\"}], \"]\"}]\) is obsolete and it is currently identical to \!\(\*RowBox[{\"ShowGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\). "
Combinatorica`ShowLabeledGraph::usage = "\!\(\*RowBox[{\"ShowLabeledGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) displays graph \!\(\*StyleBox[\"g\", \"TI\"]\) according to its embedding, with each vertex labeled with its vertex number.\n\!\(\*RowBox[{\"ShowLabeledGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) uses the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) element of list \!\(\*StyleBox[\"l\", \"TI\"]\) as the label for vertex \!\(\*StyleBox[\"i\", \"TI\"]\)."
Combinatorica`ShuffleExchangeGraph::usage = "\!\(\*RowBox[{\"ShuffleExchangeGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns the \!\(\*StyleBox[\"n\", \"TI\"]\)-dimensional shuffle-exchange graph whose vertices are length \!\(\*StyleBox[\"n\", \"TI\"]\) binary strings with an edge from \!\(\*StyleBox[\"w\", \"TI\"]\) to \!\(\*SuperscriptBox[StyleBox[\"w\", \"TI\"], \"\[Prime]\", MultilineFunction -> None]\) if: (1) \!\(\*SuperscriptBox[StyleBox[\"w\", \"TI\"], \"\[Prime]\", MultilineFunction -> None]\) differs from \!\(\*SuperscriptBox[StyleBox[\"w\", \"TI\"], \"\[Prime]\", MultilineFunction -> None]\) in its last bit; or (2) \!\(\*SuperscriptBox[StyleBox[\"w\", \"TI\"], \"\[Prime]\", MultilineFunction -> None]\) is obtained from \!\(\*StyleBox[\"w\", \"TI\"]\) by a cyclic shift left or a cyclic shift right. "
Combinatorica`SignaturePermutation::usage = "\!\(\*RowBox[{\"SignaturePermutation\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the signature of permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`SimpleQ::usage = "\!\(\*RowBox[{\"SimpleQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"g\", \"TI\"]\) is a simple graph, meaning it has no multiple edges and contains no self-loops."
Combinatorica`SmallestCyclicGroupGraph::usage = "SmallestCyclicGroupGraph returns a smallest nontrivial graph whose automorphism group is cyclic."
Combinatorica`Spectrum::usage = "\!\(\*RowBox[{\"Spectrum\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the eigenvalues of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`SpringEmbedding::usage = "\!\(\*RowBox[{\"SpringEmbedding\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) beautifies the embedding of graph \!\(\*StyleBox[\"g\", \"TI\"]\) by modeling the embedding as a system of springs. \n\!\(\*RowBox[{\"SpringEmbedding\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"step\", \"TI\"], \",\", StyleBox[\"increment\", \"TI\"]}], \"]\"}]\) can be used to refine the algorithm. "
Combinatorica`StableMarriage::usage = "\!\(\*RowBox[{\"StableMarriage\", \"[\", RowBox[{StyleBox[\"mpref\", \"TI\"], \",\", StyleBox[\"fpref\", \"TI\"]}], \"]\"}]\) finds the male optimal stable marriage defined by lists of permutations describing male and female preferences."
Combinatorica`StirlingFirst::usage = "\!\(\*RowBox[{\"StirlingFirst\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns the Stirling number of the first kind."
Combinatorica`StirlingSecond::usage = "\!\(\*RowBox[{\"StirlingSecond\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns the Stirling number of the second kind."
Combinatorica`Strings::usage = "\!\(\*RowBox[{\"Strings\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) constructs all possible combinatorial strings of length \!\(\*StyleBox[\"n\", \"TI\"]\) from the elements of list \!\(\*StyleBox[\"l\", \"TI\"]\)."
Combinatorica`StronglyConnectedComponents::usage = "\!\(\*RowBox[{\"StronglyConnectedComponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the strongly connected components of directed graph \!\(\*StyleBox[\"g\", \"TI\"]\) as lists of vertices."
Combinatorica`Strong::usage = "Strong is an option to ConnectedQ that seeks to determine if a directed graph is strongly connected."
Combinatorica`SymmetricGroupIndex::usage = "\!\(\*RowBox[{\"SymmetricGroupIndex\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) returns the cycle index of the symmetric group on \!\(\*StyleBox[\"n\", \"TI\"]\) symbols, expressed as a polynomial in \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", \"2\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]}]\)."
Combinatorica`SymmetricQ::usage = "\!\(\*RowBox[{\"SymmetricQ\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) tests if a given square matrix \!\(\*StyleBox[\"r\", \"TI\"]\) represents a symmetric relation. \n\!\(\*RowBox[{\"SymmetricQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) tests if the edges of a given graph represent a symmetric relation."
Combinatorica`TableauClasses::usage = "\!\(\*RowBox[{\"TableauClasses\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) partitions the elements of permutation \!\(\*StyleBox[\"p\", \"TI\"]\) into classes, according to their initial columns during Young tableaux construction."
Combinatorica`TableauQ::usage = "\!\(\*RowBox[{\"TableauQ\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) yields True if and only if \!\(\*StyleBox[\"t\", \"TI\"]\) represents a Young tableau."
Combinatorica`TableauxToPermutation::usage = "\!\(\*RowBox[{\"TableauxToPermutation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) constructs the unique permutation associated with Young tableaux \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), where both tableaux have the same shape."
Combinatorica`Tableaux::usage = "\!\(\*RowBox[{\"Tableaux\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) constructs all tableaux having a shape given by integer partition \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`TetrahedralGraph::usage = "TetrahedralGraph returns the graph corresponding to the tetrahedron, a Platonic solid."
Combinatorica`ThickDashed::usage = "ThickDashed is a value that the option EdgeStyle can take on in the graph data structure or in ShowGraph."
Combinatorica`ThinDashed::usage = "ThinDashed is a value that the option EdgeStyle can take on in the graph data structure or in ShowGraph."
Combinatorica`ThomassenGraph::usage = "ThomassenGraph returns a hypotraceable graph, a graph G that has no Hamiltonian path but whose subgraph \!\(\*RowBox[{StyleBox[\"G\", \"TI\"], \"-\", StyleBox[\"v\", \"TI\"]}]\) for every vertex \!\(\*StyleBox[\"v\", \"TI\"]\) has a Hamiltonian path."
Combinatorica`ToAdjacencyLists::usage = "\!\(\*RowBox[{\"ToAdjacencyLists\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) constructs an adjacency list representation for graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"ToAdjacencyLists\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"EdgeWeight\"}], \"]\"}]\) returns an adjacency list representation along with edge weights."
Combinatorica`ToAdjacencyMatrix::usage = "\!\(\*RowBox[{\"ToAdjacencyMatrix\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) constructs an adjacency matrix representation for graph \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{RowBox[{RowBox[{RowBox[{\"ToAdjacencyMatrix\", \"[\"}], StyleBox[\"g\", \"TI\"]}], \",\", \"EdgeWeight\"}], \"]\"}]\) returns edge weights as entries of the adjacency matrix with Infinity representing missing edges."
Combinatorica`ToCanonicalSetPartition::usage = "\!\(\*RowBox[{\"ToCanonicalSetPartition\", \"[\", RowBox[{StyleBox[\"sp\", \"TI\"], \",\", StyleBox[\"set\", \"TI\"]}], \"]\"}]\) reorders \!\(\*StyleBox[\"sp\", \"TI\"]\) into a canonical order with respect to \!\(\*StyleBox[\"set\", \"TI\"]\). \n\!\(\*RowBox[{\"ToCanonicalSetPartition\", \"[\", StyleBox[\"sp\", \"TI\"], \"]\"}]\) reorders \!\(\*StyleBox[\"sp\", \"TI\"]\) into canonical order, assuming that \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) knows the underlying order on the set for which \!\(\*StyleBox[\"sp\", \"TI\"]\) is a set partition."
Combinatorica`ToCycles::usage = "\!\(\*RowBox[{\"ToCycles\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the cycle structure of permutation \!\(\*StyleBox[\"p\", \"TI\"]\) as a list of cyclic permutations."
Combinatorica`ToInversionVector::usage = "\!\(\*RowBox[{\"ToInversionVector\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the inversion vector associated with permutation \!\(\*StyleBox[\"p\", \"TI\"]\)."
Combinatorica`ToOrderedPairs::usage = "\!\(\*RowBox[{\"ToOrderedPairs\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) constructs a list of ordered pairs representing the edges of the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Combinatorica`ToUnorderedPairs::usage = "\!\(\*RowBox[{\"ToUnorderedPairs\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) constructs a list of unordered pairs representing the edges of graph \!\(\*StyleBox[\"g\", \"TI\"]\). Each edge, directed or undirected, results in a pair in which the smaller vertex appears first. "
Combinatorica`TransitiveClosure::usage = "\!\(\*RowBox[{\"TransitiveClosure\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds the transitive closure of graph \!\(\*StyleBox[\"g\", \"TI\"]\), the supergraph of \!\(\*StyleBox[\"g\", \"TI\"]\) that contains edge \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) if and only if there is a path from \!\(\*StyleBox[\"x\", \"TI\"]\) to \!\(\*StyleBox[\"y\", \"TI\"]\)."
Combinatorica`TransitiveQ::usage = "\!\(\*RowBox[{\"TransitiveQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) defines a transitive relation."
Combinatorica`TransitiveReduction::usage = "\!\(\*RowBox[{\"TransitiveReduction\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a smallest graph that has the same transitive closure as \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`TranslateVertices::usage = "\!\(\*RowBox[{\"TranslateVertices\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]}], \"]\"}]\) adds the vector \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to the vertex embedding location of each vertex in list \!\(\*StyleBox[\"v\", \"TI\"]\). \n\!\(\*RowBox[{\"TranslateVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]}], \"]\"}]\) translates the embedding of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) by the vector \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\)."
Combinatorica`TransposePartition::usage = "\!\(\*RowBox[{\"TransposePartition\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) reflects a partition \!\(\*StyleBox[\"p\", \"TI\"]\) of \!\(\*StyleBox[\"k\", \"TI\"]\) parts along the main diagonal, creating a partition with maximum part \!\(\*StyleBox[\"k\", \"TI\"]\)."
Combinatorica`TransposeTableau::usage = "\!\(\*RowBox[{\"TransposeTableau\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) reflects a Young tableau \!\(\*StyleBox[\"t\", \"TI\"]\) along the main diagonal, creating a different tableau."
Combinatorica`TravelingSalesmanBounds::usage = "\!\(\*RowBox[{\"TravelingSalesmanBounds\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives upper and lower bounds on a minimum-cost traveling salesman tour of graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`TravelingSalesman::usage = "\!\(\*RowBox[{\"TravelingSalesman\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds an optimal traveling salesman tour in graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`TreeIsomorphismQ::usage = "\!\(\*RowBox[{\"TreeIsomorphismQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if the trees \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are isomorphic. It yields False otherwise."
Combinatorica`TreeQ::usage = "\!\(\*RowBox[{\"TreeQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a tree."
Combinatorica`TreeToCertificate::usage = "\!\(\*RowBox[{\"TreeToCertificate\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) returns a binary string that is a certificate for the tree \!\(\*StyleBox[\"t\", \"TI\"]\) such that trees have the same certificate if and only if they are isomorphic."
Combinatorica`Tree::usage = "Tree is an option that informs certain functions that the user wants the output to be a tree."
Combinatorica`TriangleInequalityQ::usage = "\!\(\*RowBox[{\"TriangleInequalityQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the weights assigned to the edges of graph \!\(\*StyleBox[\"g\", \"TI\"]\) satisfy the triangle inequality."
Combinatorica`Turan::usage = "\!\(\*RowBox[{\"Turan\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) constructs the Tur\[AAcute]n graph, the extremal graph on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices that does not contain \!\(\*RowBox[{\"CompleteGraph\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\)."
Combinatorica`TutteGraph::usage = "TutteGraph returns the Tutte graph, the first known example of a 3-connected, 3-regular, planar graph that is non-Hamiltonian."
Combinatorica`TwoColoring::usage = "\!\(\*RowBox[{\"TwoColoring\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a two-coloring of graph \!\(\*StyleBox[\"g\", \"TI\"]\) if \!\(\*StyleBox[\"g\", \"TI\"]\) is bipartite. It returns a list of the labels 1 and 2 corresponding to the vertices. "
Combinatorica`UndirectedQ::usage = "\!\(\*RowBox[{\"UndirectedQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if graph \!\(\*StyleBox[\"g\", \"TI\"]\) is undirected."
Combinatorica`Undirected::usage = "Undirected is an option to inform certain functions that the graph is undirected."
Combinatorica`UnionSet::usage = "\!\(\*RowBox[{\"UnionSet\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) merges the sets containing \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\) in union-find data structure \!\(\*StyleBox[\"s\", \"TI\"]\)."
Combinatorica`Uniquely3ColorableGraph::usage = "Uniquely3ColorableGraph returns a 12-vertex, triangle-free graph with chromatic number 3 that is uniquely 3-colorable."
Combinatorica`UnitransitiveGraph::usage = "UnitransitiveGraph returns a 20-vertex, 3-unitransitive graph, discovered by Coxeter, that is not isomorphic to a 4-cage or a 5-cage."
Combinatorica`UnrankBinarySubset::usage = "\!\(\*RowBox[{\"UnrankBinarySubset\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) subset of list \!\(\*StyleBox[\"l\", \"TI\"]\), listed in increasing order of integers corresponding to the binary representations of the subsets."
Combinatorica`UnrankGrayCodeSubset::usage = "\!\(\*RowBox[{\"UnrankGrayCodeSubset\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) subset of list \!\(\*StyleBox[\"l\", \"TI\"]\), listed in Gray code order."
Combinatorica`UnrankKSetPartition::usage = "\!\(\*RowBox[{\"UnrankSetPartition\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-block set partition of \!\(\*StyleBox[\"s\", \"TI\"]\) with rank \!\(\*StyleBox[\"r\", \"TI\"]\). \n\!\(\*RowBox[{\"UnrankSetPartition\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-block set partition of \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\) with rank \!\(\*StyleBox[\"r\", \"TI\"]\)."
Combinatorica`UnrankKSubset::usage = "\!\(\*RowBox[{\"UnrankKSubset\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"m\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) \!\(\*StyleBox[\"k\", \"TI\"]\)-subset of set \!\(\*StyleBox[\"l\", \"TI\"]\), listed in lexicographic order."
Combinatorica`UnrankPermutation::usage = "\!\(\*RowBox[{\"UnrankPermutation\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) permutation in the lexicographic list of permutations of list \!\(\*StyleBox[\"l\", \"TI\"]\). \n\!\(\*RowBox[{\"UnrankPermutation\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) permutation in the lexicographic list of permutations of \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\)."
Combinatorica`UnrankRGF::usage = "\!\(\*RowBox[{\"UnrankRGF\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns a restricted growth function defined on the first \!\(\*StyleBox[\"n\", \"TI\"]\) natural numbers whose rank is \!\(\*StyleBox[\"r\", \"TI\"]\)."
Combinatorica`UnrankSetPartition::usage = "\!\(\*RowBox[{\"UnrankSetPartition\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"set\", \"TI\"]}], \"]\"}]\) finds a set partition of \!\(\*StyleBox[\"set\", \"TI\"]\) with rank \!\(\*StyleBox[\"r\", \"TI\"]\). \n\!\(\*RowBox[{\"UnrankSetPartition\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds a set partition of \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\) with rank \!\(\*StyleBox[\"r\", \"TI\"]\)."
Combinatorica`UnrankSubset::usage = "\!\(\*RowBox[{\"UnrankSubset\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) subset of list \!\(\*StyleBox[\"l\", \"TI\"]\), listed in some canonical order."
Combinatorica`UnweightedQ::usage = "\!\(\*RowBox[{\"UnweightedQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if all edge weights are 1 and False otherwise."
Combinatorica`UpperLeft::usage = "UpperLeft is a value that options VertexNumberPosition, VertexLabelPosition, and EdgeLabelPosition can take on in ShowGraph."
Combinatorica`UpperRight::usage = "UpperRight is a value that options VertexNumberPosition, VertexLabelPosition, and EdgeLabelPosition can take on in ShowGraph."
Combinatorica`VertexColoring::usage = "\!\(\*RowBox[{\"VertexColoring\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) uses Brelaz's heuristic to find a good, but not necessarily minimal, vertex coloring of graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Combinatorica`VertexColor::usage = "VertexColor is an option that allows the user to associate colors with vertices. "
Combinatorica`VertexConnectivityGraph::usage = "\!\(\*RowBox[{\"VertexConnectivityGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns a directed graph that contains an edge corresponding to each vertex in \!\(\*StyleBox[\"g\", \"TI\"]\) and in which edge-disjoint paths correspond to vertex-disjoint paths in \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`VertexCover::usage = "\!\(\*RowBox[{\"VertexCover\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns a vertex cover of the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Combinatorica`VertexLabelColor::usage = "VertexLabelColor is an option that allows the user to associate different colors to vertex labels."
Combinatorica`VertexLabelPosition::usage = "VertexLabelPosition is an option that allows the user to place a vertex label in a certain position relative to the vertex. "
Combinatorica`VertexLabel::usage = "VertexLabel is an option that can take on values True or False, allowing the user to set and display vertex labels. "
Combinatorica`VertexNumberColor::usage = "VertexNumberColor is an option that can be used in ShowGraph to associate different colors to vertex numbers. "
Combinatorica`VertexNumberPosition::usage = "VertexNumberPosition is an option that can be used in ShowGraph to display a vertex number in a certain position relative to the vertex. "
Combinatorica`VertexNumber::usage = "VertexNumber is an option that can take on values True or False. This can be used in ShowGraph to display or suppress vertex numbers. "
Combinatorica`V::usage = "\!\(\*RowBox[{\"V\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the order or number of vertices of the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Combinatorica`WaltherGraph::usage = "WaltherGraph returns the Walther graph."
Combinatorica`Weak::usage = "Weak is an option to ConnectedQ that seeks to determine if a directed graph is weakly connected."
Combinatorica`WeightingFunction::usage = "WeightingFunction is an option to the functions SetEdgeWeights and SetVertexWeights that tells the functions how to compute edge weights and vertex weights, respectively. "
Combinatorica`WeightRange::usage = "WeightRange is an option to the functions SetEdgeWeights and SetVertexWeights that gives the range for these weights. "
Combinatorica`Wheel::usage = "\!\(\*RowBox[{\"Wheel\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) constructs a wheel on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices, which is the join of \!\(\*RowBox[{\"CompleteGraph\", \"[\", StyleBox[\"1\", \"TR\"], \"]\"}]\) and \!\(\*RowBox[{\"Cycle\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \"-\", StyleBox[\"1\", \"TR\"]}], \"]\"}]\)."
Combinatorica`WriteGraph::usage = "\!\(\*RowBox[{\"WriteGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) writes graph \!\(\*StyleBox[\"g\", \"TI\"]\) to file \!\(\*StyleBox[\"f\", \"TI\"]\) using an edge list representation."
Combinatorica`Zoom::usage = "\!\(\*RowBox[{\"Zoom\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \"]\"}]\) is a value that the PlotRange option can take on in ShowGraph. Setting PlotRange to this value zooms the display to contain the specified subset of vertices \!\(\*StyleBox[\"i\", \"TI\"]\), \!\(\*StyleBox[\"j\", \"TI\"]\), \!\(\*StyleBox[\"k\", \"TI\"]\), \[Ellipsis]."
CombinerFunction::usage = "CombinerFunction is an option for template functions that specifies how fragments should be assembled to give the result of applying a template."
CometData::usage = "\!\(\*RowBox[{\"CometData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the comet \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"CometData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified comet entities.\n\!\(\*RowBox[{\"CometData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
CommonDefaultFormatTypes::usage = "\!\(\*RowBox[{\"CommonDefaultFormatTypes\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies default formats for newly created cells."
CommonestFilter::usage = "\!\(\*RowBox[{\"CommonestFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) transforms \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing each pixel with the most common pixel value in its range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood.\n\!\(\*RowBox[{\"CommonestFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies commonest filtering to an array of data."
Commonest::usage = "\!\(\*RowBox[{\"Commonest\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a list of the elements that are the most common in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Commonest\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of the \!\(\*StyleBox[\"n\", \"TI\"]\) most common elements in \!\(\*StyleBox[\"list\", \"TI\"]\)."
CommonName::usage = "\!\(\*RowBox[{\"CommonName\", \"[\", StyleBox[\"entity\", \"TI\"], \"]\"}]\) gives the common name for the entity specified by \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"CommonName\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the common name for \!\(\*SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
CommonUnits::usage = "\!\(\*RowBox[{\"CommonUnits\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) converts \!\(\*SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"n\", \"TI\"]]\) to common units across compatible dimensions."
CommunityBoundaryStyle::usage = "CommunityBoundaryStyle is an option to CommunityGraphPlot that specifies how to style community boundaries."
CommunityGraphPlot::usage = "\!\(\*RowBox[{\"CommunityGraphPlot\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) generates a plot showing the community structure of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"CommunityGraphPlot\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates a plot for the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with communities \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), \[Ellipsis] .\n\!\(\*RowBox[{\"CommunityGraphPlot\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates a plot with highlighting features defined by the symbol wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]]\).\n\!\(\*RowBox[{\"CommunityGraphPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) generates a plot for a graph in which vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"ik\", \"TI\"]]\) is connected to vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"jk\", \"TI\"]]\).\n\!\(\*RowBox[{\"CommunityGraphPlot\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) generates a plot for a graph represented by the adjacency matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
CommunityLabels::usage = "CommunityLabels is an option to CommunityGraphPlot that controls what labels and placement to use for communities. "
CommunityRegionStyle::usage = "CommunityRegionStyle is an option to CommunityGraphPlot that specifies how to style community regions."
CompanyData::usage = "\!\(\*RowBox[{\"CompanyData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the company \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"CompanyData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified company entities.\n\!\(\*RowBox[{\"CompanyData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
CompatibleUnitQ::usage = "\!\(\*RowBox[{\"CompatibleUnitQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether \!\(\*SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) have compatible units."
CompilationOptions::usage = "CompilationOptions is an option for Compile that specifies settings for the compilation process. "
CompilationTarget::usage = "CompilationTarget is an option for Compile that specifies the target runtime for the compiled function. "
CompiledFunctionTools`CompilePrint::usage = "\!\(\*RowBox[{\"CompilePrint\", \"[\", StyleBox[\"cfun\", \"TI\"], \"]\"}]\) prints a human readable form of a compiled function."
CompiledFunction::usage = "\!\(\*RowBox[{\"CompiledFunction\", \"[\", StyleBox[\"args\[Ellipsis]\", \"TI\"], \"]\"}]\) represents compiled code for evaluating a compiled function. "
Compiled::usage = "Compiled is an option for various numerical and plotting functions which specifies whether the expressions they work with should automatically be compiled. "
Compile::usage = "\!\(\*RowBox[{\"Compile\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) creates a compiled function that evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) assuming numerical values of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Compile\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) assumes that \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is of a type that matches \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Compile\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) assumes that \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is a rank \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) array of objects, each of a type that matches \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Compile\", \"[\", RowBox[{StyleBox[\"vars\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) assumes that subexpressions in \!\(\*StyleBox[\"expr\", \"TI\"]\) that match \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are of types that match \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
Complement::usage = "\!\(\*RowBox[{\"Complement\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"all\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the elements in \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"all\", \"TI\"]]\) that are not in any of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
CompleteGraphQ::usage = "\!\(\*RowBox[{\"CompleteGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a complete graph, and False otherwise.\n\!\(\*RowBox[{\"CompleteGraphQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"vlist\", \"TI\"]}], \"]\"}]\) yields True if the subgraph induced by \!\(\*StyleBox[\"vlist\", \"TI\"]\) is a complete graph, and False otherwise."
CompleteGraph::usage = "\!\(\*RowBox[{\"CompleteGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the complete graph with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices \!\(\*SubscriptBox[StyleBox[\"K\", \"TI\"], StyleBox[\"n\", \"TI\"]]\).\n\!\(\*RowBox[{\"CompleteGraph\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the complete \!\(\*StyleBox[\"k\", \"TI\"]\)-partite graph with \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"+\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"+\", \"\[CenterEllipsis]\", \"+\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]}]\) vertices \!\(\*SubscriptBox[StyleBox[\"K\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], \"2\"], \",\", \"\[Ellipsis]\", \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]}]]\)."
CompleteKaryTree::usage = "\!\(\*RowBox[{\"CompleteKaryTree\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the complete binary tree with \!\(\*StyleBox[\"n\", \"TI\"]\) levels.\n\!\(\*RowBox[{\"CompleteKaryTree\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the complete \!\(\*StyleBox[\"k\", \"TI\"]\)-ary tree with \!\(\*StyleBox[\"n\", \"TI\"]\) levels."
Complexes::usage = "Complexes represents the domain of complex numbers, as in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], StyleBox[\"\[Element]\", \"TR\"], \"Complexes\"}]\). "
ComplexExpand::usage = "\!\(\*RowBox[{\"ComplexExpand\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands \!\(\*StyleBox[\"expr\", \"TI\"]\) assuming that all variables are real. \n\!\(\*RowBox[{\"ComplexExpand\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) expands \!\(\*StyleBox[\"expr\", \"TI\"]\) assuming that variables matching any of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are complex. "
ComplexInfinity::usage = "ComplexInfinity represents a quantity with infinite magnitude, but undetermined complex phase. "
ComplexityFunction::usage = "ComplexityFunction is an option for Simplify and other functions which gives a function to rank the complexity of different forms of an expression. "
Complex::usage = "Complex is the head used for complex numbers. "
ComponentMeasurements::usage = "\!\(\*RowBox[{\"ComponentMeasurements\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) computes the values of property \!\(\*StyleBox[\"prop\", \"TI\"]\) for each component of a label matrix \!\(\*StyleBox[\"m\", \"TI\"]\) that consists of identical elements.\n\!\(\*RowBox[{\"ComponentMeasurements\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses the connectivity of nonzero pixels in \!\(\*StyleBox[\"image\", \"TI\"]\) to compute the label matrix.\n\!\(\*RowBox[{\"ComponentMeasurements\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"image\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses label matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and corresponding pixel values of \!\(\*StyleBox[\"image\", \"TI\"]\) to compute properties.\n\!\(\*RowBox[{\"ComponentMeasurements\", \"[\", RowBox[{StyleBox[\"input\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) only returns measurements that satisfy a criterion \!\(\*StyleBox[\"crit\", \"TI\"]\).\n\!\(\*RowBox[{\"ComponentMeasurements\", \"[\", RowBox[{StyleBox[\"input\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"crit\", \"TI\"], \",\", StyleBox[\" \", \"TI\"], StyleBox[\"format\", \"TI\"]}], \"]\"}]\) formats the result according to the output specification \!\(\*StyleBox[\"format\", \"TI\"]\)."
ComposeList::usage = "\!\(\*RowBox[{\"ComposeList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) generates a list of the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). "
ComposeSeries::usage = "\!\(\*RowBox[{\"ComposeSeries\", \"[\", RowBox[{SubscriptBox[StyleBox[\"series\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"series\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) composes several power series. "
CompositeQ::usage = "\!\(\*RowBox[{\"CompositeQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a composite number, and yields False otherwise. "
Composition::usage = "\!\(\*RowBox[{\"Composition\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a composition of the functions \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"3\", \"TR\"]]\), \[Ellipsis]. "
CompoundElement::usage = "\!\(\*RowBox[{\"CompoundElement\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a form or interpreter specification for a list of fields or inputs that gives a list of results.\n\!\(\*RowBox[{\"CompoundElement\", \"[\", RowBox[{\"<|\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"|>\"}], \"]\"}]\) represents a form or interpreter specification that gives an association of results."
CompoundExpression::usage = "\!\(\*RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \";\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \";\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) evaluates the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in turn, giving the last one as the result. "
CompoundPoissonDistribution::usage = "\!\(\*RowBox[{\"CompoundPoissonDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) represents a compound Poisson distribution with rate parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\) and jump size distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
CompoundPoissonProcess::usage = "\!\(\*RowBox[{\"CompoundPoissonProcess\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"jdist\", \"TI\"]}], \"]\"}]\) represents a compound Poisson process with rate parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\) and jump size distribution \!\(\*StyleBox[\"jdist\", \"TI\"]\)."
CompoundRenewalProcess::usage = "\!\(\*RowBox[{\"CompoundRenewalProcess\", \"[\", RowBox[{StyleBox[\"rdist\", \"TI\"], \",\", StyleBox[\"jdist\", \"TI\"]}], \"]\"}]\) represents a compound renewal process with renewal-time distribution \!\(\*StyleBox[\"rdist\", \"TI\"]\) and jump size distribution \!\(\*StyleBox[\"jdist\", \"TI\"]\)."
Compress::usage = "\!\(\*RowBox[{\"Compress\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives a compressed representation of \!\(\*StyleBox[\"expr\", \"TI\"]\) as a string. "
ComputationalGeometry`AllPoints::usage = "AllPoints is an option to ConvexHull that specifies whether all distinct points on the hull are returned or only the minimum set of points needed to define the hull is returned."
ComputationalGeometry`BoundedDiagram::usage = "\!\(\*RowBox[{\"BoundedDiagram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields the bounded Voronoi diagram of the points \!\(\*RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]\), where the bound is the convex polygon formed from the points \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"BoundedDiagram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) takes \!\(\*StyleBox[\"val\", \"TI\"]\) to be the Delaunay triangulation vertex adjacency list.\n\!\(\*RowBox[{\"BoundedDiagram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"hull\", \"TI\"]}], \"]\"}]\) takes \!\(\*StyleBox[\"hull\", \"TI\"]\) to be the convex hull index list."
ComputationalGeometry`ConvexHullArea::usage = "\!\(\*RowBox[{\"ConvexHullArea\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"}\"}], \"]\"}]\) gives the area of the convex hull of the bivariate data."
ComputationalGeometry`ConvexHullMedian::usage = "\!\(\*RowBox[{\"ConvexHullMedian\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"}\"}], \"]\"}]\) estimates the median to be the mean of the bivariate data points lying on the innermost layer of the convex layers of the data."
ComputationalGeometry`ConvexHull::usage = "\!\(\*RowBox[{\"ConvexHull\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) yields the planar convex hull of the points \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), represented as a list of point indices arranged in counterclockwise order."
ComputationalGeometry`DelaunayTriangulationQ::usage = "\!\(\*RowBox[{\"DelaunayTriangulationQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) gives True if the triangulation of the points \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) represented by the vertex adjacency list \!\(\*StyleBox[\"val\", \"TI\"]\) is a Delaunay triangulation and False otherwise. \n\!\(\*RowBox[{\"DelaunayTriangulationQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"hull\", \"TI\"]}], \"]\"}]\) takes \!\(\*StyleBox[\"hull\", \"TI\"]\) to be the convex hull index list."
ComputationalGeometry`DelaunayTriangulation::usage = "\!\(\*RowBox[{\"DelaunayTriangulation\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) yields the planar Delaunay triangulation of the points \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
ComputationalGeometry`DiagramPlot::usage = "\!\(\*RowBox[{\"DiagramPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the Voronoi diagram of the points \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"DiagramPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) plots the points \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), as well as the diagram described by the vertices \!\(\*RowBox[{SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) and the vertex adjacency list \!\(\*StyleBox[\"val\", \"TI\"]\)."
ComputationalGeometry`Hull::usage = "Hull is an option to DelaunayTriangulation that specifies whether the convex hull \!\(\*StyleBox[\"hull\", \"TI\"]\) is to be returned in addition to the vertex adjacency list \!\(\*StyleBox[\"val\", \"TI\"]\) describing the triangulation. "
ComputationalGeometry`LabelPoints::usage = "LabelPoints is an option to DiagramPlot and PlanarGraphPlot that specifies whether to label points according to their position in the input list."
ComputationalGeometry`NearestNeighbor::usage = "\!\(\*RowBox[{\"NearestNeighbor\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) is an obsolete function."
ComputationalGeometry`PlanarGraphPlot::usage = "\!\(\*RowBox[{\"PlanarGraphPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the Delaunay triangulation of the points \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"PlanarGraphPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) plots the points \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) as well as the planar graph described by the vertex adjacency list or circuit \!\(\*StyleBox[\"g\", \"TI\"]\)."
ComputationalGeometry`Ray::usage = "\!\(\*RowBox[{\"Ray\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) is an object representing the infinite ray beginning at \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]\) in the direction of the point \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\)."
ComputationalGeometry`TileAreas::usage = "\!\(\*RowBox[{\"TileAreas\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) finds the areas of the tiles centered on \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) and having vertices \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) as stipulated by the vertex adjacency list \!\(\*StyleBox[\"val\", \"TI\"]\)."
ComputationalGeometry`TriangularSurfacePlot::usage = "\!\(\*RowBox[{\"TriangularSurfacePlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the surface according to the Delaunay triangulation established by projecting the points onto the \!\(\*StyleBox[\"x\", \"TI\"]\)-\!\(\*StyleBox[\"y\", \"TI\"]\) plane.\n\!\(\*RowBox[{\"TriangularSurfacePlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the surface according to the triangulation given by the vertex adjacency list \!\(\*StyleBox[\"val\", \"TI\"]\)."
ComputationalGeometry`TrimPoints::usage = "TrimPoints is an option to DiagramPlot that specifies which diagram outlier vertex lies on the PlotRange limit."
ComputationalGeometry`VoronoiDiagram::usage = "\!\(\*RowBox[{\"VoronoiDiagram\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) yields the planar Voronoi diagram of the points \!\(\*RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\).\n\!\(\*RowBox[{\"VoronoiDiagram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) takes \!\(\*StyleBox[\"val\", \"TI\"]\) to be the Delaunay triangulation vertex adjacency list.\n\!\(\*RowBox[{\"VoronoiDiagram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"hull\", \"TI\"]}], \"]\"}]\) takes \!\(\*StyleBox[\"hull\", \"TI\"]\) to be the convex hull index list."
ComputerArithmetic`Arithmetic::usage = "\!\(\*RowBox[{RowBox[{\"Arithmetic\", \"[\"}], \"]\"}]\) gives a list containing the number of digits of precision, the base, and the options and option values of the arithmetic currently in effect."
ComputerArithmetic`ComputerNumber::usage = "\!\(\*RowBox[{\"ComputerNumber\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the ComputerNumber object equivalent to the ordinary number \!\(\*StyleBox[\"x\", \"TI\"]\) in the arithmetic currently in effect.\n\!\(\*RowBox[{\"ComputerNumber\", \"[\", RowBox[{StyleBox[\"sign\", \"TI\"], \",\", StyleBox[\"mantissa\", \"TI\"], \",\", StyleBox[\"exp\", \"TI\"]}], \"]\"}]\) gives the ComputerNumber object whose value is \!\(\*RowBox[{StyleBox[\"sign\", \"TI\"], StyleBox[\" \", \"TI\"], StyleBox[\"mantissa\", \"TI\"], StyleBox[\" \", \"TI\"], SuperscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"exp\", \"TI\"]]}]\), where \!\(\*StyleBox[\"b\", \"TI\"]\) is the base in the arithmetic currently in effect.\n\!\(\*RowBox[{\"ComputerNumber\", \"[\", RowBox[{StyleBox[\"sign\", \"TI\"], \",\", StyleBox[\"mantissa\", \"TI\"], \",\", StyleBox[\"exp\", \"TI\"], \",\", StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) is the complete data object that makes up a computer number."
ComputerArithmetic`ExponentRange::usage = "ExponentRange is an option to SetArithmetic that specifies the range of exponents that are to be allowed."
ComputerArithmetic`IdealDivide::usage = "\!\(\*RowBox[{\"IdealDivide\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) gives the correctly rounded result of \!\(\*StyleBox[\"x\", \"TI\"]\) divided by \!\(\*StyleBox[\"y\", \"TI\"]\) involving a single rounding error."
ComputerArithmetic`IdealDivision::usage = "IdealDivision is an option to SetArithmetic that specifies whether $PreRead should be used to translate the default / division operator to use IdealDivide."
ComputerArithmetic`MachineError::usage = "\!\(\*RowBox[{\"MachineError\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"->\", StyleBox[\"a\", \"TI\"]}]}], \"]\"}]\) gives the error involved in evaluating \!\(\*StyleBox[\"f\", \"TI\"]\) at \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", StyleBox[\"a\", \"TI\"]}]\) using machine arithmetic."
ComputerArithmetic`MicroscopePlot::usage = "\!\(\*RowBox[{\"MicroscopePlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}]}], \"]\"}]\) plots the expression \!\(\*StyleBox[\"f\", \"TI\"]\) in a small neighborhood of \!\(\*StyleBox[\"a\", \"TI\"]\) using machine arithmetic.\n\!\(\*RowBox[{\"MicroscopePlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) plots \!\(\*StyleBox[\"f\", \"TI\"]\) from \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"-\", StyleBox[\"n\", \"TI\"]}]\) ulps to \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"+\", StyleBox[\"n\", \"TI\"]}]\) ulps."
ComputerArithmetic`MicroscopicErrorPlot::usage = "\!\(\*RowBox[{\"MicroscopicErrorPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}]}], \"]\"}]\) plots the error incurred by using machine arithmetic to evaluate the expression \!\(\*StyleBox[\"f\", \"TI\"]\) in a small neighborhood of \!\(\*StyleBox[\"a\", \"TI\"]\).\n\!\(\*RowBox[{\"MicroscopicErrorPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) plots the error from \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"-\", StyleBox[\"n\", \"TI\"]}]\) ulps to \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"+\", StyleBox[\"n\", \"TI\"]}]\) ulps."
ComputerArithmetic`MixedMode::usage = "MixedMode is an option to SetArithmetic that specifies whether mixed-mode arithmetic is to be allowed."
ComputerArithmetic`NaN::usage = "NaN is the symbol used by the functions in the Computer Arithmetic Package to represent a nonrepresentable number."
ComputerArithmetic`RoundingRule::usage = "RoundingRule is an option to SetArithmetic that specifies the rounding scheme to use."
ComputerArithmetic`RoundToEven::usage = "RoundToEven is a setting for the option RoundingRule of SetArithmetic that specifies rounding to the nearest representable number and, in the case of a tie, rounding to the one represented by an even mantissa."
ComputerArithmetic`RoundToInfinity::usage = "RoundToInfinity is a setting for the option RoundingRule of SetArithmetic that specifies rounding to the nearest representable number and, in the case of a tie, rounding away from 0."
ComputerArithmetic`SetArithmetic::usage = "\!\(\*RowBox[{\"SetArithmetic\", \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\) sets the number of digits of precision \!\(\*StyleBox[\"d\", \"TI\"]\) to be used in ComputerNumber objects.\n\!\(\*RowBox[{\"SetArithmetic\", \"[\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) sets the number of digits of precision \!\(\*StyleBox[\"d\", \"TI\"]\) and the base \!\(\*StyleBox[\"b\", \"TI\"]\) to be used in ComputerNumber objects."
ComputerArithmetic`Truncation::usage = "Truncation is a setting for the option RoundingRule of SetArithmetic that specifies rounding by discarding excess digits."
ComputerArithmetic`Ulps::usage = "Ulps is a unit of error in machine arithmetic. "
ComputerArithmetic`Ulp::usage = "\!\(\*RowBox[{\"Ulp\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the size of an ulp for numbers near \!\(\*StyleBox[\"x\", \"TI\"]\)."
ConditionalExpression::usage = "\!\(\*RowBox[{\"ConditionalExpression\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"cond\", \"TI\"]}], \"]\"}]\) is a symbolic construct that represents the expression \!\(\*StyleBox[\"expr\", \"TI\"]\) when the condition \!\(\*StyleBox[\"cond\", \"TI\"]\) is True."
Conditioned::usage = "\!\(\*RowBox[{\"Conditioned\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"cond\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"\[Conditioned]\", StyleBox[\"cond\", \"TI\"]}]\) represents \!\(\*StyleBox[\"expr\", \"TI\"]\) conditioned by the predicate \!\(\*StyleBox[\"cond\", \"TI\"]\)."
Condition::usage = "\!\(\*RowBox[{StyleBox[\"patt\", \"TI\"], \"/;\", StyleBox[\"test\", \"TI\"]}]\) is a pattern which matches only if the evaluation of \!\(\*StyleBox[\"test\", \"TI\"]\) yields True. \n\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \":>\", RowBox[{StyleBox[\"rhs\", \"TI\"], \"/;\", StyleBox[\"test\", \"TI\"]}]}]\) represents a rule which applies only if the evaluation of \!\(\*StyleBox[\"test\", \"TI\"]\) yields True. \n\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \":=\", RowBox[{StyleBox[\"rhs\", \"TI\"], \"/;\", StyleBox[\"test\", \"TI\"]}]}]\) is a definition to be used only if \!\(\*StyleBox[\"test\", \"TI\"]\) yields True. "
Cone::usage = "\!\(\*RowBox[{\"Cone\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a cone with a base of radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at \!\(\*RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \")\"}]\) and a tip at \!\(\*RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \")\"}]\). \n\!\(\*RowBox[{\"Cone\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}], \"]\"}]\) represents a cone with a base of radius 1."
ConfidenceLevel::usage = "ConfidenceLevel is an option for LinearModelFit and other fitting functions that specifies the level to use in various confidence and prediction intervals and bands."
ConfidenceRange::usage = "ConfidenceRange is an option for SurvivalModelFit and other functions that specifies the range over which simultaneous confidence intervals and bands are computed."
ConfidenceTransform::usage = "ConfidenceTransform is an option for functions such as SurvivalModelFit that specifies the transformation used for confidence intervals and bands."
ConfigurationPath::usage = "ConfigurationPath is a global option that specifies which directories are searched for systemwide configuration information."
ConformImages::usage = "\!\(\*RowBox[{\"ConformImages\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) returns a list of images where all \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are made to have conforming properties, including dimensions, data type, color space, and interleaving.\n\!\(\*RowBox[{\"ConformImages\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"spec\", \"TI\"]}], \"]\"}]\) returns all images of the specified \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"ConformImages\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"fitting\", \"TI\"]}], \"]\"}]\) resizes images using the specified \!\(\*StyleBox[\"fitting\", \"TI\"]\) method."
Congruent::usage = "\!\(\*RowBox[{\"Congruent\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\", FontSize -> 10]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Congruent]\", StyleBox[\"y\", \"TI\"], \"\[Congruent]\", \"\[Ellipsis]\"}]\)."
ConicHullRegion::usage = "\!\(\*RowBox[{\"ConicHullRegion\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"m\", StyleBox[\"+\", FontSlant -> \"Plain\"], StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]]}], \"}\"}], \"]\"}]\) represents the \!\(\*StyleBox[\"m\", \"TI\"]\)-dimensional affine hull region passing through points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"ConicHullRegion\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the \!\(\*StyleBox[\"m\", \"TI\"]\)-dimensional affine hull region passing through the point \!\(\*StyleBox[\"p\", \"TI\"]\) and parallel to \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"ConicHullRegion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"m\", StyleBox[\"+\", FontSlant -> \"Plain\"], StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the \!\(\*StyleBox[\"m\", \"TI\"]\)-dimensional affine hull plus the conic hull generated by the vectors \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]]\).\n\!\(\*RowBox[{\"ConicHullRegion\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the \!\(\*StyleBox[\"m\", \"TI\"]\)-dimensional affine hull plus the conic hull generated by the vectors \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]]\)."
ConjugateTranspose::usage = "\!\(\*RowBox[{\"ConjugateTranspose\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) or \!\(\*SuperscriptBox[StyleBox[\"m\", \"TI\"], \"\[ConjugateTranspose]\"]\) gives the conjugate transpose of \!\(\*StyleBox[\"m\", \"TI\"]\). "
Conjugate::usage = "\!\(\*RowBox[{\"Conjugate\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"z\", \"TI\"], \"\[Conjugate]\"}]\) gives the complex conjugate of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
Conjunction::usage = "\!\(\*RowBox[{\"Conjunction\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the conjunction of \!\(\*StyleBox[\"expr\", \"TI\"]\) over all choices of the Boolean variables \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ConnectedComponents::usage = "\!\(\*RowBox[{\"ConnectedComponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the connected components of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"ConnectedComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the connected components that include at least one of the vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"ConnectedComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives the connected components that include a vertex that matches the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"ConnectedComponents\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
ConnectedGraphQ::usage = "\!\(\*RowBox[{\"ConnectedGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is connected, and False otherwise."
ConnectedMeshComponents::usage = "\!\(\*RowBox[{\"ConnectedMeshComponents\", \"[\", StyleBox[\"mr\", \"TI\"], \"]\"}]\) gives a list \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) of disjoint path connected meshed regions."
ConnectLibraryCallbackFunction::usage = "\!\(\*RowBox[{\"ConnectLibraryCallbackFunction\", \"[\", RowBox[{StyleBox[\"mname\", \"TI\"], \",\", StyleBox[\"cf\", \"TI\"]}], \"]\"}]\) connects a CompiledFunction \!\(\*StyleBox[\"cf\", \"TI\"]\) with the library callback manager with name \!\(\*StyleBox[\"mname\", \"TI\"]\)."
ConnesWindow::usage = "\!\(\*RowBox[{\"ConnesWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Connes window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"ConnesWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
ConoverTest::usage = "\!\(\*RowBox[{\"ConoverTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the variances of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"ConoverTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[SubsuperscriptBox[\"\[Sigma]\", \"0\", \"2\"], \"TR\"]}], \"]\"}]\) tests a dispersion measure against \!\(\*StyleBox[SubsuperscriptBox[\"\[Sigma]\", \"0\", \"2\"], \"TR\"]\).\n\!\(\*RowBox[{\"ConoverTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[SubsuperscriptBox[\"\[Sigma]\", \"0\", \"2\"], \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
ConstantArray::usage = "\!\(\*RowBox[{\"ConstantArray\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates a list of \!\(\*StyleBox[\"n\", \"TI\"]\) copies of the element \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"ConstantArray\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates an \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Cross]\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Cross]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) array of nested lists containing copies of the element \!\(\*StyleBox[\"c\", \"TI\"]\)."
ConstantImage::usage = "\!\(\*RowBox[{\"ConstantImage\", \"[\", RowBox[{StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) gives an image of the specified \!\(\*StyleBox[\"size\", \"TI\"]\) with constant pixel values of \!\(\*StyleBox[\"val\", \"TI\"]\).\n\!\(\*RowBox[{\"ConstantImage\", \"[\", RowBox[{StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives an image converted to the specified type."
ConstantRegionQ::usage = "\!\(\*RowBox[{\"ConstantRegionQ\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives True if the \!\(\*StyleBox[\"reg\", \"TI\"]\) is a constant region and False otherwise."
Constants::usage = "Constants is an option for Dt which gives a list of objects to be taken as constants. "
Constant::usage = "Constant is an attribute that indicates zero derivative of a symbol with respect to all parameters. "
ConstellationData::usage = "\!\(\*RowBox[{\"ConstellationData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the constellation \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"ConstellationData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified constellation entities.\n\!\(\*RowBox[{\"ConstellationData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
Containing::usage = "\!\(\*RowBox[{\"Containing\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"outer\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"inner\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents an object of type \!\(\*StyleBox[\"outer\", \"TI\"]\) containing objects of type \!\(\*StyleBox[\"inner\", \"TI\"]\)."
ContainsAll::usage = "\!\(\*RowBox[{\"ContainsAll\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) contains all of the elements of \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ContainsAll\", \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}]\) is an operator form that yields True when the object to which it is applied contains all of the elements of \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ContainsAny::usage = "\!\(\*RowBox[{\"ContainsAny\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) contains any of the elements of \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ContainsAny\", \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}]\) is an operator form that yields True when the object to which it is applied contains any of the elements in \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ContainsExactly::usage = "\!\(\*RowBox[{\"ContainsExactly\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) contains exactly the same elements as \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ContainsExactly\", \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}]\) is an operator form that yields True when the object to which it is applied contains exactly the same elements as \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ContainsNone::usage = "\!\(\*RowBox[{\"ContainsNone\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) contains none of the elements in \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ContainsNone\", \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}]\) is an operator form that yields True when the object to which it is applied contains none of the elements of \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ContainsOnly::usage = "\!\(\*RowBox[{\"ContainsOnly\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) contains only elements that appear in \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ContainsOnly\", \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}]\) is an operator form that yields True when the object to which it is applied contains only elements that appear in \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ContentObject::usage = "\!\(\*RowBox[{\"ContentObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a content object whose content is \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"ContentObject\", \"[\", RowBox[{\"File\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}]\) gives a content object whose content is stored in the specified file."
ContentPadding::usage = "ContentPadding is an option for objects that can be displayed with frames that specifies whether the vertical margins should shrink wrap tightly around the contents."
ContentSelectable::usage = "ContentSelectable is an option to constructs such as Inset, Graphics, and GraphicsGroup that specifies whether and how content within them should be selectable. "
ContentSize::usage = "ContentSize is an option for Manipulate and other functions that specifies the size of the content area to use."
Contexts::usage = "\!\(\*RowBox[{\"Contexts\", \"[\", \"]\"}]\) gives a list of all contexts. \n\!\(\*RowBox[{\"Contexts\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the contexts that match the string. "
ContextToFileName::usage = "\!\(\*RowBox[{\"ContextToFileName\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the string specifying the file name that is by convention associated with a particular context."
Context::usage = "\!\(\*RowBox[{\"Context\", \"[\", \"]\"}]\) gives the current context. \n\!\(\*RowBox[{\"Context\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) gives the context in which a symbol appears. "
ContinuedFractionK::usage = "\!\(\*RowBox[{\"ContinuedFractionK\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the continued fraction \!\(\*RowBox[{SubsuperscriptBox[\"\[CapitalKappa]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]]}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"f\", \"TI\"], \"/\", StyleBox[\"g\", \"TI\"]}]}]\).\n\!\(\*RowBox[{\"ContinuedFractionK\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the continued fraction \!\(\*RowBox[{SubsuperscriptBox[\"\[CapitalKappa]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]]}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{\"1\", \"/\", StyleBox[\"g\", \"TI\"]}]}]\)."
ContinuedFraction::usage = "\!\(\*RowBox[{\"ContinuedFraction\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates a list of the first \!\(\*StyleBox[\"n\", \"TI\"]\) terms in the continued fraction representation of\[NonBreakingSpace]\!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"ContinuedFraction\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) generates a list of all terms that can be obtained given the precision of\[NonBreakingSpace]\!\(\*StyleBox[\"x\", \"TI\"]\). "
Continue::usage = "\!\(\*RowBox[{\"Continue\", \"[\", \"]\"}]\) exits to the nearest enclosing Do, For, or While in a procedural program. "
ContinuousAction::usage = "ContinuousAction is an option for Manipulate, Slider, and related functions that specifies whether action should be taken continuously while controls are being moved."
ContinuousMarkovProcess::usage = "\!\(\*RowBox[{\"ContinuousMarkovProcess\", \"[\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents a continuous-time finite-state Markov process with transition rate matrix \!\(\*StyleBox[\"q\", \"TI\"]\) and initial state \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"ContinuousMarkovProcess\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents a Markov process with initial state probability vector \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"ContinuousMarkovProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a Markov process with transition matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and transition rates \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\).\n\!\(\*RowBox[{\"ContinuousMarkovProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) represents a Markov process transition rate matrix from the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
ContinuousTask::usage = "\!\(\*RowBox[{\"ContinuousTask\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents a task in which \!\(\*StyleBox[\"expr\", \"TI\"]\) is continuously reevaluated.\n\!\(\*RowBox[{\"ContinuousTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"]}], \"]\"}]\) represents a task in which \!\(\*StyleBox[\"expr\", \"TI\"]\) is continuously reevaluated until the time specified by \!\(\*StyleBox[\"end\", \"TI\"]\).\n\!\(\*RowBox[{\"ContinuousTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"tspan\", \"TI\"]}], \"]\"}]\) represents a task in which \!\(\*StyleBox[\"expr\", \"TI\"]\) is continuously reevaluated over the time span \!\(\*StyleBox[\"tspan\", \"TI\"]\)."
ContinuousTimeModelQ::usage = "\!\(\*RowBox[{\"ContinuousTimeModelQ\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"lsys\", \"TI\"]\) is a continuous-time systems model, and False otherwise."
ContinuousWaveletData::usage = "\!\(\*RowBox[{\"ContinuousWaveletData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"oct\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"voc\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \"->\", SubscriptBox[StyleBox[\"coef\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"wave\", \"TI\"]}], \"]\"}]\) yields a continuous wavelet data object with wavelet coefficients \!\(\*SubscriptBox[StyleBox[\"coef\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to octave and voice \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"oct\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"voc\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) and wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\)."
ContinuousWaveletTransform::usage = "\!\(\*RowBox[{\"ContinuousWaveletTransform\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the continuous wavelet transform of a list of values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ContinuousWaveletTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"]}], \"]\"}]\) gives the continuous wavelet transform using the wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\).\n\!\(\*RowBox[{\"ContinuousWaveletTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"], StyleBox[\",\", \"TI\"], RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{StyleBox[\"noct\", \"TI\"], \",\", StyleBox[\"nvoc\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the continuous wavelet transform using \!\(\*StyleBox[\"noct\", \"TI\"]\) octaves with \!\(\*StyleBox[\"nvoc\", \"TI\"]\) voices per octave.\n\!\(\*RowBox[{\"ContinuousWaveletTransform\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the continuous wavelet transform of sampled sound."
ContourDetect::usage = "\!\(\*RowBox[{\"ContourDetect\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a binary image in which white pixels correspond to the zeros and zero crossings in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ContourDetect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"delta\", \"TI\"]}], \"]\"}]\) treats values in \!\(\*StyleBox[\"image\", \"TI\"]\) that are smaller in absolute value than \!\(\*StyleBox[\"delta\", \"TI\"]\) as zero.\n\!\(\*RowBox[{\"ContourDetect\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a binary sparse array in which 1 corresponds to zeros and zero crossings in \!\(\*StyleBox[\"array\", \"TI\"]\). "
ContourGraphics::usage = "\!\(\*RowBox[{\"ContourGraphics\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) is a representation of a contour plot. "
ContourLabels::usage = "ContourLabels is an option for contour plots that specifies how to label contours. "
ContourLines::usage = "ContourLines is an option for contour plots that specifies whether to draw explicit contour lines. "
ContourPlot3D::usage = "\!\(\*RowBox[{\"ContourPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) produces a three-dimensional contour plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\). \n\!\(\*RowBox[{\"ContourPlot3D\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"==\", StyleBox[\"g\", \"TI\"]}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots the contour surface for which \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"=\", StyleBox[\"g\", \"TI\"]}]\). "
ContourPlot::usage = "\!\(\*RowBox[{\"ContourPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a contour plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{\"ContourPlot\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"==\", StyleBox[\"g\", \"TI\"]}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots contour lines for which \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"=\", StyleBox[\"g\", \"TI\"]}]\). \n\!\(\*RowBox[{\"ContourPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"==\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"==\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots several contour lines. \n\!\(\*RowBox[{\"ContourPlot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes the variables \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\). "
ContourShading::usage = "ContourShading is an option for contour plots that specifies how the regions between contour lines should be shaded. "
ContourStyle::usage = "ContourStyle is an option for contour plots that specifies the style in which contour lines or surfaces should be drawn. "
Contours::usage = "Contours is an option for contour plots that specifies the contours to draw. "
ContraharmonicMean::usage = "\!\(\*RowBox[{\"ContraharmonicMean\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the contraharmonic mean of the values in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"ContraharmonicMean\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the order \!\(\*StyleBox[\"p\", \"TI\"]\) Lehmer contraharmonic mean."
ControlActive::usage = "\!\(\*RowBox[{\"ControlActive\", \"[\", RowBox[{StyleBox[\"act\", \"TI\"], \",\", StyleBox[\"norm\", \"TI\"]}], \"]\"}]\) evaluates to \!\(\*StyleBox[\"act\", \"TI\"]\) if a control that affects \!\(\*StyleBox[\"act\", \"TI\"]\) is actively being used, and to \!\(\*StyleBox[\"norm\", \"TI\"]\) otherwise."
ControllabilityGramian::usage = "\!\(\*RowBox[{\"ControllabilityGramian\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) gives the controllability Gramian of the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
ControllabilityMatrix::usage = "\!\(\*RowBox[{\"ControllabilityMatrix\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) gives the controllability matrix of the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
ControllableDecomposition::usage = "\!\(\*RowBox[{\"ControllableDecomposition\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) yields the controllable subsystem of the state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\).\n\!\(\*RowBox[{\"ControllableDecomposition\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) specifies the new state variables \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ControllableModelQ::usage = "\!\(\*RowBox[{\"ControllableModelQ\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) yields True if the state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\) is controllable, and False otherwise.\n\!\(\*RowBox[{\"ControllableModelQ\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"sub\", \"TI\"]}], \"}\"}], \"]\"}]\) yields True if the subsystem \!\(\*StyleBox[\"sub\", \"TI\"]\) is controllable."
ControllerInformation::usage = "\!\(\*RowBox[{\"ControllerInformation\", \"[\", \"]\"}]\) gives dynamically updated information on currently connected controller devices."
ControllerLinking::usage = "ControllerLinking is an option for Manipulate, Graphics3D, Plot3D, and related functions that specifies whether to allow interactive control by external controllers."
ControllerManipulate::usage = "\!\(\*RowBox[{\"ControllerManipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a version of \!\(\*StyleBox[\"expr\", \"TI\"]\) set up to allow interactive manipulation of the value of \!\(\*StyleBox[\"u\", \"TI\"]\) using an external controller device.\n\!\(\*RowBox[{\"ControllerManipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"du\", \"TI\"]}], \"}\"}]}], \"]\"}]\) allows the value of \!\(\*StyleBox[\"u\", \"TI\"]\) to vary between \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) in steps \!\(\*StyleBox[\"du\", \"TI\"]\). \n\!\(\*RowBox[{\"ControllerManipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"init\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the initial value of \!\(\*StyleBox[\"u\", \"TI\"]\) to be \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"init\", \"TI\"]]\). \n\!\(\*RowBox[{\"ControllerManipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) allows \!\(\*StyleBox[\"u\", \"TI\"]\) to take on discrete values \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. \n\!\(\*RowBox[{\"ControllerManipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) allows each of the \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), \[Ellipsis] to be manipulated by the external controller device. \n\!\(\*RowBox[{\"ControllerManipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"u\", \"TI\"]], \"\[Rule]\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"v\", \"TI\"]], \"\[Rule]\", RowBox[{\"{\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) links the parameters to the specified controllers on the external controller device."
ControllerMethod::usage = "ControllerMethod is an option for Manipulate, Graphics3D, Plot3D, and related functions that specifies the default way that controls on an external controller device should apply."
ControllerPath::usage = "ControllerPath is an option that gives a list of external controllers or classes of controllers to try for functions such as ControllerState, Manipulate, and Graphics3D."
ControllerState::usage = "\!\(\*RowBox[{\"ControllerState\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"c\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the state of the control \!\(\*StyleBox[\"c\", \"TI\"]\) for the first connected controller device on which it is supported.\n\!\(\*RowBox[{\"ControllerState\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"c\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"c\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the states of several controls.\n\!\(\*RowBox[{\"ControllerState\", \"[\", RowBox[{StyleBox[\"id\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"c\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the state of control \!\(\*StyleBox[\"c\", \"TI\"]\) for controller devices with the specified identifier.\n\!\(\*RowBox[{\"ControllerState\", \"[\", RowBox[{StyleBox[\"id\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"c\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"c\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the states of several controls for several controller devices."
ControlPlacement::usage = "ControlPlacement is an option for Manipulate, TabView, and other control objects that specifies where controls should be placed."
ControlsRendering::usage = "ControlsRendering is a Style option that specifies how controls should be rendered."
ControlType::usage = "ControlType is an option for Manipulate and related functions that specifies what type of controls should be displayed."
Control::usage = "\!\(\*RowBox[{\"Control\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"}\"}], \"]\"}]\) represents an interactive control for the variable \!\(\*StyleBox[\"u\", \"TI\"]\) in the domain \!\(\*StyleBox[\"dom\", \"TI\"]\), with the type of control chosen to be appropriate for the domain specified.\n\!\(\*RowBox[{\"Control\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"init\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"dom\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a control with initial value \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"init\", \"TI\"]]\)."
Convergents::usage = "\!\(\*RowBox[{\"Convergents\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a list of the convergents corresponding to the continued fraction terms \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Convergents\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"n\", \"TI\"]\) convergents for a number \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"Convergents\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives if possible all convergents leading to the number \!\(\*StyleBox[\"x\", \"TI\"]\)."
ConversionOptions::usage = "ConversionOptions is an option to Import and Export used to pass special options to a particular format."
ConversionRules::usage = "ConversionRules is an option for Cell that can be set to a list of rules specifying how the contents of the cell are to be converted to external formats. "
ConvertToPostScriptPacket::usage = "ConvertToPostScriptPacket is an internal symbol used for formatting."
ConvexHullMesh::usage = "\!\(\*RowBox[{\"ConvexHullMesh\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a BoundaryMeshRegion representing the convex hull from the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
Convolve::usage = "\!\(\*RowBox[{\"Convolve\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) gives the convolution with respect to \!\(\*StyleBox[\"x\", \"TI\"]\) of the expressions \!\(\*StyleBox[\"f\", \"TI\"]\) and \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"Convolve\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional convolution."
ConwayGroupCo1::usage = "\!\(\*RowBox[{\"ConwayGroupCo1\", \"[\", \"]\"}]\) represents the sporadic simple Conway group \!\(\*SubscriptBox[\"Co\", StyleBox[\"1\", \"TR\"]]\)."
ConwayGroupCo2::usage = "\!\(\*RowBox[{\"ConwayGroupCo2\", \"[\", \"]\"}]\) represents the sporadic simple Conway group \!\(\*SubscriptBox[\"Co\", StyleBox[\"2\", \"TR\"]]\)."
ConwayGroupCo3::usage = "\!\(\*RowBox[{\"ConwayGroupCo3\", \"[\", \"]\"}]\) represents the sporadic simple Conway group \!\(\*SubscriptBox[\"Co\", StyleBox[\"3\", \"TR\"]]\)."
CoordinateBoundingBoxArray::usage = "\!\(\*RowBox[{CoordinateBoundingBoxArray, \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \"]\"}]\) generates an array of \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) coordinates with integer steps in each dimension.\n\!\(\*RowBox[{CoordinateBoundingBoxArray, \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses step \!\(\*StyleBox[\"d\", \"TI\"]\) in each dimension.\n\!\(\*RowBox[{CoordinateBoundingBoxArray, \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dx\", \"TI\"]\), \!\(\*StyleBox[\"dy\", \"TI\"]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in successive dimensions.\n\!\(\*RowBox[{CoordinateBoundingBoxArray, \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"Into\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]}], \"]\"}]\) divides into \!\(\*StyleBox[\"n\", \"TI\"]\) equal steps in each dimension.\n\!\(\*RowBox[{CoordinateBoundingBoxArray, \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"steps\", \"TI\"], \",\", StyleBox[\"offsets\", \"TI\"]}], \"]\"}]\) specifies offsets to use for each coordinate point.\n\!\(\*RowBox[{CoordinateBoundingBoxArray, \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"steps\", \"TI\"], \",\", StyleBox[\"offsets\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) expands the array by \!\(\*StyleBox[\"k\", \"TI\"]\) elements in every direction. "
CoordinateBoundingBox::usage = "\!\(\*RowBox[{CoordinateBoundingBox, \"[\", StyleBox[\"coords\", \"TI\"], \"]\"}]\) gives the corners \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]\) of the bounding box of the region defined by \!\(\*StyleBox[\"coords\", \"TI\"]\).\n\!\(\*RowBox[{CoordinateBoundingBox, \"[\", RowBox[{StyleBox[\"coords\", \"TI\"], \",\", StyleBox[\"\[Delta]\", \"TR\"]}], \"]\"}]\) pads the region by \[Delta] in each direction.\n\!\(\*RowBox[{CoordinateBoundingBox, \"[\", RowBox[{StyleBox[\"coords\", \"TI\"], \",\", RowBox[{\"Scaled\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]}], \"]\"}]\) pads by the scaled amount \!\(\*StyleBox[\"s\", \"TI\"]\) in each direction.\n\!\(\*RowBox[{CoordinateBoundingBox, \"[\", RowBox[{StyleBox[\"coords\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) pads by \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in successive dimensions. \n\!\(\*RowBox[{CoordinateBoundingBox, \"[\", RowBox[{StyleBox[\"coords\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \"min\"}], \"TI\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \"max\"}], \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \"min\"}], \"TI\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \"max\"}], \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"-\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \"min\"}], \"TI\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"-\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \"min\"}], \"TI\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"+\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \"max\"}], \"TI\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"+\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \"max\"}], \"TI\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) "
CoordinateBoundsArray::usage = "\!\(\*RowBox[{\"CoordinateBoundsArray\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates an array of \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) coordinates with integer steps in each dimension.\n\!\(\*RowBox[{\"CoordinateBoundsArray\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"xrange\", \"TI\"], \",\", StyleBox[\"yrange\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses step \!\(\*StyleBox[\"d\", \"TI\"]\) in each dimension.\n\!\(\*RowBox[{\"CoordinateBoundsArray\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"xrange\", \"TI\"], \",\", StyleBox[\"yrange\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dx\", \"TI\"]\), \!\(\*StyleBox[\"dy\", \"TI\"]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in successive dimensions.\n\!\(\*RowBox[{\"CoordinateBoundsArray\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"xrange\", \"TI\"], \",\", StyleBox[\"yrange\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"Into\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]}], \"]\"}]\) divides into \!\(\*StyleBox[\"n\", \"TI\"]\) equal steps in each dimension.\n\!\(\*RowBox[{\"CoordinateBoundsArray\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"xrange\", \"TI\"], \",\", StyleBox[\"yrange\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"steps\", \"TI\"], \",\", StyleBox[\"offsets\", \"TI\"]}], \"]\"}]\) specifies offsets to use for each coordinate point.\n\!\(\*RowBox[{\"CoordinateBoundsArray\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"xrange\", \"TI\"], \",\", StyleBox[\"yrange\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"steps\", \"TI\"], \",\", StyleBox[\"offsets\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) expands the array by \!\(\*StyleBox[\"k\", \"TI\"]\) elements in every direction. "
CoordinateBounds::usage = "\!\(\*RowBox[{\"CoordinateBounds\", \"[\", StyleBox[\"coords\", \"TI\"], \"]\"}]\) gives a list \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) of the bounds in each dimension of the region defined by \!\(\*StyleBox[\"coords\", \"TI\"]\). \n\!\(\*RowBox[{\"CoordinateBounds\", \"[\", RowBox[{StyleBox[\"coords\", \"TI\"], \",\", StyleBox[\"\[Delta]\", \"TR\"]}], \"]\"}]\) pads the ranges of coordinates by \!\(\*RowBox[{\"\[PlusMinus]\", StyleBox[\"\[Delta]\", \"TR\"]}]\) in each dimension.\n\!\(\*RowBox[{\"CoordinateBounds\", \"[\", RowBox[{StyleBox[\"coords\", \"TI\"], \",\", RowBox[{\"Scaled\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]}], \"]\"}]\) pads by the scaled amount \!\(\*StyleBox[\"s\", \"TI\"]\) in each dimension.\n\!\(\*RowBox[{\"CoordinateBounds\", \"[\", RowBox[{StyleBox[\"coords\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) pads by \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in successive dimensions. \n\!\(\*RowBox[{RowBox[{\"CoordinateBounds\", \"[\", RowBox[{StyleBox[\"coords\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \"min\"}], \"TI\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \"max\"}], \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \"min\"}], \"TI\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \"max\"}], \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"-\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \"min\"}], \"TI\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"+\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \"max\"}], \"TI\"]]}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"-\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \"min\"}], \"TI\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"+\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \"max\"}], \"TI\"]]}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)"
CoordinateChartData::usage = "\!\(\*RowBox[{\"CoordinateChartData\", \"[\", RowBox[{StyleBox[\"chart\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for \!\(\*StyleBox[\"chart\", \"TI\"]\).\n\!\(\*RowBox[{\"CoordinateChartData\", \"[\", RowBox[{StyleBox[\"chart\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the value of the specified property for \!\(\*StyleBox[\"chart\", \"TI\"]\) evaluated at the point \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\)."
CoordinatesToolOptions::usage = "CoordinatesToolOptions is an option for Graphics that gives values of options associated with the \!\(\*StyleBox[\"Get Coordinates\", \"MenuName\"]\) tool."
CoordinateTransformData::usage = "\!\(\*RowBox[{\"CoordinateTransformData\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the coordinate transformation \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"CoordinateTransformData\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the value of the property evaluated at the point \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\)."
CoordinateTransform::usage = "\!\(\*RowBox[{\"CoordinateTransform\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"pt\", \"TI\"]}], \"]\"}]\) performs the coordinate transformation \!\(\*StyleBox[\"t\", \"TI\"]\) on the point \!\(\*StyleBox[\"pt\", \"TI\"]\).\n\!\(\*RowBox[{\"CoordinateTransform\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) transforms several points."
CoprimeQ::usage = "\!\(\*RowBox[{\"CoprimeQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are relatively prime, and yields False otherwise. \n\!\(\*RowBox[{\"CoprimeQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields True if all pairs of the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are relatively prime, and yields False otherwise. "
Coproduct::usage = "\!\(\*RowBox[{\"Coproduct\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Coproduct]\", StyleBox[\"y\", \"TI\"], \"\[Coproduct]\", \"\[Ellipsis]\"}]\)."
CopulaDistribution::usage = "\!\(\*RowBox[{\"CopulaDistribution\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a copula distribution with kernel distribution \!\(\*StyleBox[\"ker\", \"TI\"]\) and marginal distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] ."
Copyable::usage = "Copyable is an option for Cell that specifies whether a cell can be copied interactively using the front end. "
CopyDatabin::usage = "\!\(\*RowBox[{\"CopyDatabin\", \"[\", StyleBox[\"bin\", \"TI\"], \"]\"}]\) creates a copy of a databin.\n\!\(\*RowBox[{\"CopyDatabin\", \"[\", RowBox[{StyleBox[\"bin\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) creates a copy with the specified options."
CopyDirectory::usage = "\!\(\*RowBox[{\"CopyDirectory\", \"[\", RowBox[{SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) copies the directory \!\(\*SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
CopyFile::usage = "\!\(\*RowBox[{\"CopyFile\", \"[\", RowBox[{SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) copies \!\(\*SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
CopyToClipboard::usage = "\!\(\*RowBox[{\"CopyToClipboard\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) replaces the contents of the clipboard with \!\(\*StyleBox[\"expr\", \"TI\"]\)."
CornerFilter::usage = "\!\(\*RowBox[{\"CornerFilter\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) computes a measure for the presence of a corner for each pixel in \!\(\*StyleBox[\"image\", \"TI\"]\) and returns the result as an intensity image.\n\!\(\*RowBox[{\"CornerFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) detects corners at a pixel range \!\(\*StyleBox[\"r\", \"TI\"]\)."
CornerNeighbors::usage = "CornerNeighbors is an option for various array and image processing functions that specifies whether diagonally adjacent corners should be considered neighbors of particular elements. "
CorrelationDistance::usage = "\!\(\*RowBox[{\"CorrelationDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the correlation coefficient distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
CorrelationFunction::usage = "\!\(\*RowBox[{\"CorrelationFunction\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) estimates the correlation function at lags \!\(\*StyleBox[\"hspec\", \"TI\"]\) from \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"CorrelationFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) represents the correlation function at lags \!\(\*StyleBox[\"hspec\", \"TI\"]\) for the random process \!\(\*StyleBox[\"proc\", \"TI\"]\). \n\!\(\*RowBox[{\"CorrelationFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents the correlation function at times \!\(\*StyleBox[\"s\", \"TI\"]\) and \!\(\*StyleBox[\"t\", \"TI\"]\) for the random process \!\(\*StyleBox[\"proc\", \"TI\"]\). "
CorrelationTest::usage = "\!\(\*RowBox[{\"CorrelationTest\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) tests whether the correlation coefficient for a bivariate population is zero.\n\!\(\*RowBox[{\"CorrelationTest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"\[Rho]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) tests whether the correlation coefficient is \!\(\*SubscriptBox[StyleBox[\"\[Rho]\", \"TR\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"CorrelationTest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) tests whether the correlation coefficients for two populations are equal.\n\!\(\*RowBox[{\"CorrelationTest\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], StyleBox[\",\", \"TI\"], StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
Correlation::usage = "\!\(\*RowBox[{\"Correlation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the correlation between the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"Correlation\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the correlation matrix for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"Correlation\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the correlation matrix for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"Correlation\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the correlation matrix for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"Correlation\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) correlation for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). "
CoshIntegral::usage = "\!\(\*RowBox[{\"CoshIntegral\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the hyperbolic cosine integral \!\(\*RowBox[{\"Chi\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
Cosh::usage = "\!\(\*RowBox[{\"Cosh\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the hyperbolic cosine of \!\(\*StyleBox[\"z\", \"TI\"]\). "
CosineDistance::usage = "\!\(\*RowBox[{\"CosineDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the angular cosine distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
CosineWindow::usage = "\!\(\*RowBox[{\"CosineWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a cosine window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"CosineWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the exponent \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
CosIntegral::usage = "\!\(\*RowBox[{\"CosIntegral\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the cosine integral function \!\(\*RowBox[{\"Ci\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
Cos::usage = "\!\(\*RowBox[{\"Cos\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the cosine of \!\(\*StyleBox[\"z\", \"TI\"]\). "
Coth::usage = "\!\(\*RowBox[{\"Coth\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the hyperbolic cotangent of \!\(\*StyleBox[\"z\", \"TI\"]\). "
Cot::usage = "\!\(\*RowBox[{\"Cot\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the cotangent of \!\(\*StyleBox[\"z\", \"TI\"]\). "
CountDistinctBy::usage = "\!\(\*RowBox[{\"CountDistinctBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gives the number of distinct values of \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) that occur.\n\!\(\*RowBox[{\"CountDistinctBy\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of CountDistinctBy that can be applied to an expression."
CountDistinct::usage = "\!\(\*RowBox[{\"CountDistinct\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the number of distinct elements that appear in \!\(\*StyleBox[\"list\", \"TI\"]\)."
CounterAssignments::usage = "CounterAssignments is an option for selections that sets the value of a specified counter."
CounterBoxOptions::usage = "\!\(\*RowBox[{CounterBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for CounterBox objects."
CounterFunction::usage = "CounterFunction is an option for counters that specifies the symbols used to display the value of the counter."
CounterIncrements::usage = "CounterIncrements is an option for selections that specifies whether the value of a specified counter is incremented by one."
CounterStyleMenuListing::usage = "CounterStyleMenuListing is an option for cells that specifies what counter styles are listed in the \!\(\*StyleBox[\"Counter\", \"DialogElementName\"]\) popup menu of the \!\(\*StyleBox[\"Create Automatic Numbering Object\", \"DialogElementName\"]\) dialog box."
CountRoots::usage = "\!\(\*RowBox[{\"CountRoots\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the number of real roots of the polynomial \!\(\*StyleBox[\"poly\", \"TI\"]\) in \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"CountRoots\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the number of roots between \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\). "
CountryData::usage = "\!\(\*RowBox[{\"CountryData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"tag\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the country, country-like entity, or group of countries specified by \"\!\(\*\nStyleBox[\"tag\", \"TI\"]\)\".\n\!\(\*RowBox[{\"CountryData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"tag\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"dates\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives time series for certain economic and other properties."
CountsBy::usage = "\!\(\*RowBox[{\"CountsBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gives an association whose keys are the distinct values of the \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\), and whose values give the number of times these \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) values appear.\n\!\(\*RowBox[{\"CountsBy\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of CountsBy that can be applied to an expression."
Counts::usage = "\!\(\*RowBox[{\"Counts\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives an association whose keys are the distinct elements of \!\(\*StyleBox[\"list\", \"TI\"]\), and whose values give the number of times those elements appear in \!\(\*StyleBox[\"list\", \"TI\"]\)."
Count::usage = "\!\(\*RowBox[{\"Count\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) gives the number of elements in \!\(\*StyleBox[\"list\", \"TI\"]\) that match \!\(\*StyleBox[\"pattern\", \"TI\"]\). \n\!\(\*RowBox[{\"Count\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) gives the total number of subexpressions matching \!\(\*StyleBox[\"pattern\", \"TI\"]\) that appear at the levels in \!\(\*StyleBox[\"expr\", \"TI\"]\) specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"Count\", \"[\", StyleBox[\"pattern\", \"TI\"], \"]\"}]\) represents an operator form of Count that can be applied to an expression."
CovarianceEstimatorFunction::usage = "CovarianceEstimatorFunction is an option for generalized linear model fitting functions that specifies the estimator for the parameter covariance matrix."
CovarianceFunction::usage = "\!\(\*RowBox[{\"CovarianceFunction\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) estimates the covariance function at lags \!\(\*StyleBox[\"hspec\", \"TI\"]\) from \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"CovarianceFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) represents the covariance function at lags \!\(\*StyleBox[\"hspec\", \"TI\"]\) for the random process \!\(\*StyleBox[\"proc\", \"TI\"]\). \n\!\(\*RowBox[{\"CovarianceFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents the covariance function at times \!\(\*StyleBox[\"s\", \"TI\"]\) and \!\(\*StyleBox[\"t\", \"TI\"]\) for the random process \!\(\*StyleBox[\"proc\", \"TI\"]\). "
Covariance::usage = "\!\(\*RowBox[{\"Covariance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the covariance between the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"Covariance\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the covariance matrix for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"Covariance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the covariance matrix for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"Covariance\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the covariance matrix for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"Covariance\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) covariance for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). "
CoxianDistribution::usage = "\!\(\*RowBox[{\"CoxianDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], RowBox[{StyleBox[\"m\", \"TI\"], StyleBox[\"-\", \"TI\"], StyleBox[\"1\", \"TR\"]}]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represent an \!\(\*StyleBox[\"m\", \"TI\"]\)-phase Coxian distribution with phase probabilities \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\) and rates \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\)."
CoxIngersollRossProcess::usage = "\!\(\*RowBox[{\"CoxIngersollRossProcess\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents a Cox\[Dash]Ingersoll\[Dash]Ross process with long\[Hyphen]term mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), volatility \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\), speed of adjustment \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\), and initial condition \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
CoxModelFit::usage = "\!\(\*RowBox[{\"CoxModelFit\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) constructs a model of the baseline hazard \!\(\*RowBox[{SubscriptBox[StyleBox[\"h\", \"TI\"], \"0\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\) for events times \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"CoxModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[\"\[Xi]\", \"11\"], \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Xi]\", \"TR\"], RowBox[{StyleBox[\"1\", \"TR\"], StyleBox[\"p\", \"TI\"]}]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"\[Xi]\", \"TR\"], RowBox[{\"n\", \"\[ThinSpace]\", StyleBox[\"1\", \"TR\"]}]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Xi]\", \"TR\"], StyleBox[\"np\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) constructs a Cox model of the form \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"h\", \"TI\"], \"0\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \" \", RowBox[{\"exp\", \"(\", RowBox[{RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], \" \", SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"+\", \"\[Ellipsis]\", \"+\", RowBox[{SubscriptBox[\"\[Beta]\", StyleBox[\"m\", \"TI\"]], \" \", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"m\", \"TI\"]]}]}], \")\"}]}]\), where the \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) depend on the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]]\)."
CoxModel::usage = "\!\(\*RowBox[{\"CoxModel\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents the symbolic proportional hazards model obtained from CoxModelFit."
CramerVonMisesTest::usage = "\!\(\*RowBox[{\"CramerVonMisesTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed using the Cram\[EAcute]r\[Dash]von Mises test.\n\!\(\*RowBox[{\"CramerVonMisesTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is distributed according to \!\(\*StyleBox[\"dist\", \"TI\"]\) using the Cram\[EAcute]r\[Dash]von Mises test.\n\!\(\*RowBox[{\"CramerVonMisesTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
CreateArchive::usage = "\!\(\*RowBox[{\"CreateArchive\", \"[\", StyleBox[\"source\", \"TI\"], \"]\"}]\) creates a compressed archive in the current directory from a file or directory specified by \!\(\*StyleBox[\"source\", \"TI\"]\).\n\!\(\*RowBox[{\"CreateArchive\", \"[\", RowBox[{StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"path\", \"TI\"]}], \"]\"}]\) creates a compressed archive in the directory or file specified by \!\(\*StyleBox[\"path\", \"TI\"]\)."
CreateCellID::usage = "CreateCellID is an option for Notebook that specifies whether to assign a CellID to cells created in the notebook."
CreateDatabin::usage = "\!\(\*RowBox[{\"CreateDatabin\", \"[\", \"]\"}]\) creates a databin in the Wolfram Data Drop and returns the corresponding Databin object.\n\!\(\*RowBox[{\"CreateDatabin\", \"[\", StyleBox[\"options\", \"TI\"], \"]\"}]\) creates a databin with the specified options."
CreateDialog::usage = "\!\(\*RowBox[{\"CreateDialog\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) creates a dialog notebook containing \!\(\*StyleBox[\"expr\", \"TI\"]\) and opens it in the front end.\n\!\(\*RowBox[{\"CreateDialog\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) replaces the notebook represented by the notebook object \!\(\*StyleBox[\"obj\", \"TI\"]\) with the one obtained from \!\(\*StyleBox[\"expr\", \"TI\"]\)."
CreateDirectory::usage = "\!\(\*RowBox[{\"CreateDirectory\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dir\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) creates a directory with name \!\(\*StyleBox[\"dir\", \"TI\"]\). \n\!\(\*RowBox[{\"CreateDirectory\", \"[\", \"]\"}]\) creates a directory in the default area for temporary directories on your computer system."
CreateDocument::usage = "\!\(\*RowBox[{\"CreateDocument\", \"[\", \"]\"}]\) creates an empty document notebook and opens it in the front end.\n\!\(\*RowBox[{\"CreateDocument\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) creates and opens a document notebook containing the expression \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"CreateDocument\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates and opens a document notebook consisting of a sequence of cells containing the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"CreateDocument\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) replaces the notebook represented by the notebook object \!\(\*StyleBox[\"obj\", \"TI\"]\) with the one obtained from \!\(\*StyleBox[\"expr\", \"TI\"]\)."
CreateIntermediateDirectories::usage = "CreateIntermediateDirectories is an option for CreateDirectory and related functions that specifies whether to create intermediate directories in a directory path specified."
CreateManagedLibraryExpression::usage = "\!\(\*RowBox[{\"CreateManagedLibraryExpression\", \"[\", RowBox[{StyleBox[\"mname\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) creates a managed library expression by applying \!\(\*StyleBox[\"f\", \"TI\"]\) to a positive integer ID associated with a registered manager with name \!\(\*StyleBox[\"mname\", \"TI\"]\)."
CreateNotebook::usage = "\!\(\*RowBox[{\"CreateNotebook\", \"[\", \"]\"}]\) creates a generic empty notebook and opens it in the front end.\n\!\(\*RowBox[{\"CreateNotebook\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) creates an empty notebook of the specified type and opens it in the front end.\n\!\(\*RowBox[{\"CreateNotebook\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) replaces the notebook represented by the notebook object \!\(\*StyleBox[\"obj\", \"TI\"]\) by a version converted to be of the specified type."
CreatePalette::usage = "\!\(\*RowBox[{\"CreatePalette\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) creates a palette notebook containing \!\(\*StyleBox[\"expr\", \"TI\"]\), and opens it in the front end.\n\!\(\*RowBox[{\"CreatePalette\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates and opens a palette notebook consisting of a sequence of cells containing the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"CreatePalette\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) replaces the notebook represented by the notebook object \!\(\*StyleBox[\"obj\", \"TI\"]\) with the one obtained from \!\(\*StyleBox[\"expr\", \"TI\"]\)."
CreatePermissionsGroup::usage = "\!\(\*RowBox[{\"CreatePermissionsGroup\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) creates a permissions group with the specified name.\n\!\(\*RowBox[{\"CreatePermissionsGroup\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) creates a permissions group consisting of the specified initial users."
CreateScheduledTask::usage = "\!\(\*RowBox[{\"CreateScheduledTask\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) creates a local scheduled task that will repeatedly evaluate \!\(\*StyleBox[\"expr\", \"TI\"]\) once per second.\n\!\(\*RowBox[{\"CreateScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"time\", \"TI\"]}], \"]\"}]\) creates a task that will repeatedly evaluate \!\(\*StyleBox[\"expr\", \"TI\"]\) every \!\(\*StyleBox[\"time\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"CreateScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"time\", \"TI\"], \"}\"}]}], \"]\"}]\) creates a task that will evaluate \!\(\*StyleBox[\"expr\", \"TI\"]\) once after \!\(\*StyleBox[\"time\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"CreateScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"time\", \"TI\"], \",\", StyleBox[\"count\", \"TI\"]}], \"}\"}]}], \"]\"}]\) creates a task that will try evaluating \!\(\*StyleBox[\"expr\", \"TI\"]\) once every \!\(\*StyleBox[\"time\", \"TI\"]\) seconds up to \!\(\*StyleBox[\"count\", \"TI\"]\) times total.\n\!\(\*RowBox[{\"CreateScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"], \",\", StyleBox[\"start\", \"TI\"]}], \"]\"}]\) creates a task that will evaluate \!\(\*StyleBox[\"expr\", \"TI\"]\) according to \!\(\*StyleBox[\"timespec\", \"TI\"]\) starting at \!\(\*StyleBox[\"start\", \"TI\"]\) time."
CreateSearchIndex::usage = "\!\(\*RowBox[{\"CreateSearchIndex\", \"[\", StyleBox[\"dir\", \"TI\"], \"]\"}]\) creates a search index from all files in the directory \!\(\*StyleBox[\"dir\", \"TI\"]\) and its subdirectories.\n\!\(\*RowBox[{\"CreateSearchIndex\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"source\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"source\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a search index from all sources \!\(\*SubscriptBox[StyleBox[\"source\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"CreateSearchIndex\", \"[\", RowBox[{StyleBox[\"sources\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the search index the specified name."
CreateTemporary::usage = "\!\(\*RowBox[{\"CreateTemporary\", \"[\", \"]\"}]\) creates a temporary file with a unique name in the default temporary directory and returns the name of the file."
CreateUUID::usage = "\!\(\*RowBox[{\"CreateUUID\", \"[\", \"]\"}]\) creates a random, universally unique UUID string.\n\!\(\*RowBox[{\"CreateUUID\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"base\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) appends a UUID string to the specified base string."
CreateWindow::usage = "\!\(\*RowBox[{\"CreateWindow\", \"[\", \"]\"}]\) creates an empty window in the front end.\n\!\(\*RowBox[{\"CreateWindow\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) creates a window displaying the notebook expression \!\(\*StyleBox[\"expr\", \"TI\"]\), and opens it in the front end.\n\!\(\*RowBox[{\"CreateWindow\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) replaces the notebook represented by the notebook object \!\(\*StyleBox[\"obj\", \"TI\"]\) with the one obtained from \!\(\*StyleBox[\"expr\", \"TI\"]\)."
CriticalityFailureImportance::usage = "\!\(\*RowBox[{\"CriticalityFailureImportance\", \"[\", RowBox[{StyleBox[\"rdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the criticality failure importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"CriticalityFailureImportance\", \"[\", RowBox[{StyleBox[\"fdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the criticality failure importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\)."
CriticalitySuccessImportance::usage = "\!\(\*RowBox[{\"CriticalitySuccessImportance\", \"[\", RowBox[{StyleBox[\"rdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the criticality success importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"CriticalitySuccessImportance\", \"[\", RowBox[{StyleBox[\"fdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the criticality success importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\)."
CriticalSection::usage = "\!\(\*RowBox[{\"CriticalSection\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) locks the variables \!\(\*SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with respect to parallel computation, evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), then releases the \!\(\*SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
CrossingDetect::usage = "\!\(\*RowBox[{\"CrossingDetect\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a binary image in which white pixels correspond to the zero crossings in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"CrossingDetect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"delta\", \"TI\"]}], \"]\"}]\) treats values in \!\(\*StyleBox[\"image\", \"TI\"]\) that are smaller in absolute value than \!\(\*StyleBox[\"delta\", \"TI\"]\) as zero.\n\!\(\*RowBox[{\"CrossingDetect\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a binary sparse array in which 1 corresponds to zero crossings in \!\(\*StyleBox[\"array\", \"TI\"]\). "
CrossMatrix::usage = "\!\(\*RowBox[{\"CrossMatrix\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives a matrix whose elements are 1 in a centered cross-shaped region that extends \!\(\*StyleBox[\"r\", \"TI\"]\) positions along each index direction, and are 0 otherwise.\n\!\(\*RowBox[{\"CrossMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) gives a \!\(\*StyleBox[\"w\", \"TI\"]\)\[Cross]\!\(\*StyleBox[\"w\", \"TI\"]\) matrix containing a cross-shaped region of 1s.\n\!\(\*RowBox[{\"CrossMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields an array whose elements are 1 in a centered cross-shaped region that extends \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) positions in the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) index direction."
Cross::usage = "\!\(\*RowBox[{\"Cross\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the vector cross product of \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\). "
Csch::usage = "\!\(\*RowBox[{\"Csch\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the hyperbolic cosecant of \!\(\*StyleBox[\"z\", \"TI\"]\). "
Csc::usage = "\!\(\*RowBox[{\"Csc\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the cosecant of \!\(\*StyleBox[\"z\", \"TI\"]\). "
CubeRoot::usage = "\!\(\*RowBox[{\"CubeRoot\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the real-valued cube root of \!\(\*StyleBox[\"x\", \"TI\"]\)."
Cubics::usage = "Cubics is an option for functions that involve solving algebraic equations, that specifies whether explicit forms for solutions to cubic equations should be given."
Cuboid::usage = "\!\(\*RowBox[{\"Cuboid\", \"[\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"]\"}]\) represents a unit hypercube with its lower corner at \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"min\", \"TI\"]]\).\n\!\(\*RowBox[{\"Cuboid\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"]\"}]\) represents an axis-aligned filled cuboid with lower corner \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and upper corner \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"max\", \"TI\"]]\)."
CUDALink`CUDAArgMaxList::usage = "\!\(\*RowBox[{\"CUDAArgMaxList\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the index of the maximum element in \!\(\*StyleBox[\"list\", \"TI\"]\)."
CUDALink`CUDAArgMinList::usage = "\!\(\*RowBox[{\"CUDAArgMinList\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the index of the minimum element in \!\(\*StyleBox[\"list\", \"TI\"]\)."
CUDALink`CUDABoxFilter::usage = "\!\(\*RowBox[{CUDABoxFilter, \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the box filter of \!\(\*StyleBox[\"img\", \"TI\"]\) with radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{CUDABoxFilter, \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the box filter of \!\(\*StyleBox[\"list\", \"TI\"]\) with radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{CUDABoxFilter, \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the box filter of \!\(\*StyleBox[\"mem\", \"TI\"]\) with radius \!\(\*StyleBox[\"r\", \"TI\"]\)."
CUDALink`CUDACCompilers::usage = "\!\(\*RowBox[{\"CUDACCompilers\", \"[\", \"]\"}]\) gives a list of C compilers detected on system and supported by NVCCCompiler."
CUDALink`CUDAClamp::usage = "\!\(\*RowBox[{\"CUDAClamp\", \"[\", StyleBox[\"lst\", \"TI\"], \"]\"}]\) clamps the values of \!\(\*StyleBox[\"lst\", \"TI\"]\) between automatically determined values.\n\!\(\*RowBox[{\"CUDAClamp\", \"[\", RowBox[{StyleBox[\"lst\", \"TI\"], \",\", StyleBox[\"low\", \"TI\"], \",\", StyleBox[\"high\", \"TI\"]}], \"]\"}]\) clamps the values of \!\(\*StyleBox[\"lst\", \"TI\"]\) between \!\(\*StyleBox[\"low\", \"TI\"]\) and \!\(\*StyleBox[\"high\", \"TI\"]\)."
CUDALink`CUDAClosing::usage = "\!\(\*RowBox[{\"CUDAClosing\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the closing of \!\(\*StyleBox[\"img\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"CUDAClosing\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the closing of \!\(\*StyleBox[\"list\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"CUDAClosing\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the closing of \!\(\*StyleBox[\"mem\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square."
CUDALink`CUDAColorNegate::usage = "\!\(\*RowBox[{\"CUDAColorNegate\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) performs color negation on \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAColorNegate\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) performs color negation on \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAColorNegate\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) performs color negation on memory referenced by \!\(\*StyleBox[\"mem\", \"TI\"]\)."
CUDALink`CUDADilation::usage = "\!\(\*RowBox[{\"CUDADilation\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological dilation of \!\(\*StyleBox[\"img\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"CUDADilation\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological dilation of \!\(\*StyleBox[\"list\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"CUDADilation\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological dilation of \!\(\*StyleBox[\"mem\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square."
CUDALink`CUDADot::usage = "\!\(\*RowBox[{\"CUDADot\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives the dot product of \!\(\*SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"CUDADot\", \"[\", RowBox[{StyleBox[\"mat\", \"TI\"], \",\", StyleBox[\"vec\", \"TI\"]}], \"]\"}]\) gives the matrix-vector product of \!\(\*StyleBox[\"mat\", \"TI\"]\) and \!\(\*StyleBox[\"vec\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDADot\", \"[\", RowBox[{SubscriptBox[StyleBox[\"mat\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"mat\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the matrix-matrix product of \!\(\*SubscriptBox[StyleBox[\"mat\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"mat\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
CUDALink`CUDADriverVersion::usage = "\!\(\*RowBox[{\"CUDADriverVersion\", \"[\", \"]\"}]\) gives the version of the installed NVIDIA driver."
CUDALink`CUDAErosion::usage = "\!\(\*RowBox[{\"CUDAErosion\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological erosion of \!\(\*StyleBox[\"img\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"CUDAErosion\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological erosion of \!\(\*StyleBox[\"list\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"CUDAErosion\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological erosion of \!\(\*StyleBox[\"mem\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square."
CUDALink`CUDAFinancialDerivative::usage = "\!\(\*RowBox[{\"CUDAFinancialDerivative\", \"[\", RowBox[{StyleBox[\"instrument\", \"TI\"], \",\", StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"ambientparams\", \"TI\"]}], \"]\"}]\) gives the value of the specified financial instrument.\n\!\(\*RowBox[{\"CUDAFinancialDerivative\", \"[\", RowBox[{StyleBox[\"instrument\", \"TI\"], \",\", StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"ambientparams\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) computes the specified property \!\(\*StyleBox[\"prop\", \"TI\"]\)."
CUDALink`CUDAFluidDynamics::usage = "\!\(\*RowBox[{\"CUDAFluidDynamics\", \"[\", \"]\"}]\) demonstrates computational fluid dynamics using \!\(\*StyleBox[\"CUDALink\", FontSlant -> \"Italic\"]\)."
CUDALink`CUDAFoldList::usage = "\!\(\*RowBox[{\"CUDAFoldList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). "
CUDALink`CUDAFold::usage = "\!\(\*RowBox[{\"CUDAFold\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) gives the last element of \!\(\*RowBox[{\"CUDAFoldList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\)."
CUDALink`CUDAFourier::usage = "\!\(\*RowBox[{\"CUDAFourier\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds the discrete Fourier transform of a list of complex numbers.\n\!\(\*RowBox[{\"CUDAFourier\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) finds the discrete Fourier transform of a CUDAMemory."
CUDALink`CUDAFunctionInformation::usage = "\!\(\*RowBox[{\"CUDAFunctionInformation\", \"[\", StyleBox[\"fun\", \"TI\"], \"]\"}]\) returns information about a CUDAFunction."
CUDALink`CUDAFunctionLoad::usage = "\!\(\*RowBox[{\"CUDAFunctionLoad\", \"[\", RowBox[{StyleBox[\"src\", \"TI\"], \",\", StyleBox[\"fun\", \"TI\"], \",\", StyleBox[\"argtypes\", \"TI\"], \",\", StyleBox[\"blockdim\", \"TI\"]}], \"]\"}]\) loads CUDAFunction from \!\(\*StyleBox[\"scr\", \"TI\"]\) and makes \!\(\*StyleBox[\"fun\", \"TI\"]\) available in \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\).\n\!\(\*RowBox[{\"CUDAFunctionLoad\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"srcfile\", \"TI\"], \"}\"}], \",\", StyleBox[\"fun\", \"TI\"], \",\", StyleBox[\"argtypes\", \"TI\"], \",\", StyleBox[\"blockdim\", \"TI\"]}], \"]\"}]\) loads CUDAFunction from \!\(\*StyleBox[\"srcfile\", \"TI\"]\) and makes \!\(\*StyleBox[\"fun\", \"TI\"]\) available in \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\).\n\!\(\*RowBox[{\"CUDAFunctionLoad\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"libfile\", \"TI\"], \"}\"}], \",\", StyleBox[\"fun\", \"TI\"], \",\", StyleBox[\"argtypes\", \"TI\"], \",\", StyleBox[\"blockdim\", \"TI\"]}], \"]\"}]\) loads CUDAFunction from \!\(\*StyleBox[\"libfile\", \"TI\"]\) and makes \!\(\*StyleBox[\"fun\", \"TI\"]\) available in \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\)."
CUDALink`CUDAFunction::usage = "\!\(\*RowBox[{\"CUDAFunction\", \"[\", StyleBox[\"args\", \"TI\"], \"]\"}]\) represents a function loaded using CUDAFunctionLoad."
CUDALink`CUDAImageAdd::usage = "\!\(\*RowBox[{\"CUDAImageAdd\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) adds an amount \!\(\*StyleBox[\"x\", \"TI\"]\) to each channel value in \!\(\*StyleBox[\"img\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageAdd\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) adds an amount \!\(\*StyleBox[\"x\", \"TI\"]\) to each channel value in \!\(\*StyleBox[\"mem\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageAdd\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives an image in which each pixel is the sum of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"CUDAImageAdd\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives a CUDAMemory in which each pixel is the sum of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
CUDALink`CUDAImageConvolve::usage = "\!\(\*RowBox[{\"CUDAImageConvolve\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"kern\", \"TI\"]}], \"]\"}]\) gives the convolution of \!\(\*StyleBox[\"img\", \"TI\"]\) with \!\(\*StyleBox[\"kern\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageConvolve\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"kern\", \"TI\"]}], \"]\"}]\) gives the convolution of \!\(\*StyleBox[\"list\", \"TI\"]\) with \!\(\*StyleBox[\"kern\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageConvolve\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"kern\", \"TI\"]}], \"]\"}]\) gives the convolution of \!\(\*StyleBox[\"mem\", \"TI\"]\) with \!\(\*StyleBox[\"kern\", \"TI\"]\)."
CUDALink`CUDAImageDivide::usage = "\!\(\*RowBox[{\"CUDAImageDivide\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) divides each channel value in \!\(\*StyleBox[\"img\", \"TI\"]\) by an amount \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageDivide\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) divides each channel value in \!\(\*StyleBox[\"mem\", \"TI\"]\) by an amount \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageDivide\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives an image in which each pixel is the division of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"CUDAImageDivide\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives a CUDAMemory in which each pixel is the division of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
CUDALink`CUDAImageMultiply::usage = "\!\(\*RowBox[{\"CUDAImageMultiply\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) multiplies an amount \!\(\*StyleBox[\"x\", \"TI\"]\) to each channel value in \!\(\*StyleBox[\"img\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageMultiply\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) multiplies an amount \!\(\*StyleBox[\"x\", \"TI\"]\) to each channel value in \!\(\*StyleBox[\"mem\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageMultiply\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives an image in which each pixel is the product of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"CUDAImageMultiply\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives a CUDAMemory in which each pixel is the product of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
CUDALink`CUDAImageSubtract::usage = "\!\(\*RowBox[{\"CUDAImageSubtract\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) subtracts an amount \!\(\*StyleBox[\"x\", \"TI\"]\) from each channel value in \!\(\*StyleBox[\"img\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageSubtract\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) subtracts an amount \!\(\*StyleBox[\"x\", \"TI\"]\) from each channel value in \!\(\*StyleBox[\"mem\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAImageSubtract\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives an image in which each pixel is the difference of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"CUDAImageSubtract\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives a CUDAMemory in which each pixel is the difference of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
CUDALink`CUDAInformation::usage = "\!\(\*RowBox[{\"CUDAInformation\", \"[\", \"]\"}]\) queries information on all CUDA devices detected.\n\!\(\*RowBox[{\"CUDAInformation\", \"[\", StyleBox[\"dev\", \"TI\"], \"]\"}]\) queries information on CUDA \!\(\*StyleBox[\"dev\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDAInformation\", \"[\", RowBox[{StyleBox[\"dev\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) queries \!\(\*StyleBox[\"prop\", \"TI\"]\) on CUDA \!\(\*StyleBox[\"dev\", \"TI\"]\)."
CUDALink`CUDAInverseFourier::usage = "\!\(\*RowBox[{\"CUDAInverseFourier\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds the discrete inverse Fourier transform of a list of complex numbers.\n\!\(\*RowBox[{\"CUDAInverseFourier\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) finds the discrete inverse Fourier transform of a CUDAMemory."
CUDALink`CUDAMap::usage = "\!\(\*RowBox[{\"CUDAMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"lst\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to each element on \!\(\*StyleBox[\"lst\", \"TI\"]\). "
CUDALink`CUDAMemoryAllocate::usage = "\!\(\*RowBox[{\"CUDAMemoryAllocate\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"dim\", \"TI\"]}], \"]\"}]\) gives CUDAMemory with specified type and single dimension.\n\!\(\*RowBox[{\"CUDAMemoryAllocate\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dim\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dim\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives CUDAMemory with specified type and dimensions."
CUDALink`CUDAMemoryCopyToDevice::usage = "\!\(\*RowBox[{\"CUDAMemoryCopyToDevice\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) force copies CUDAMemory from the CPU to the GPU."
CUDALink`CUDAMemoryCopyToHost::usage = "\!\(\*RowBox[{\"CUDAMemoryCopyToHost\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) force copies CUDAMemory from the GPU to the CPU."
CUDALink`CUDAMemoryGet::usage = "\!\(\*RowBox[{\"CUDAMemoryGet\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) gets CUDAMemory into the CPU and \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\)."
CUDALink`CUDAMemoryInformation::usage = "\!\(\*RowBox[{\"CUDAMemoryInformation\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) gives information on CUDAMemory."
CUDALink`CUDAMemoryLoad::usage = "\!\(\*RowBox[{\"CUDAMemoryLoad\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) registers \!\(\*StyleBox[\"list\", \"TI\"]\) into the \!\(\*StyleBox[\"CUDALink\", FontSlant -> \"Italic\"]\) memory manager.\n\!\(\*RowBox[{\"CUDAMemoryLoad\", \"[\", StyleBox[\"img\", \"TI\"], \"]\"}]\) registers \!\(\*StyleBox[\"img\", \"TI\"]\) into the \!\(\*StyleBox[\"CUDALink\", FontSlant -> \"Italic\"]\) memory manager."
CUDALink`CUDAMemoryUnload::usage = "\!\(\*RowBox[{\"CUDAMemoryUnload\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) unloads CUDAMemory from the \!\(\*StyleBox[\"CUDALink\", FontSlant -> \"Italic\"]\) memory manager."
CUDALink`CUDAMemory::usage = "\!\(\*RowBox[{\"CUDAMemory\", \"[\", StyleBox[\"args\", \"TI\"], \"]\"}]\) is a handle to memory loaded using CUDAMemoryLoad or CUDAMemoryAllocate."
CUDALink`CUDAOpening::usage = "\!\(\*RowBox[{\"CUDAOpening\", \"[\", RowBox[{StyleBox[\"img\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological opening of \!\(\*StyleBox[\"img\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"CUDAOpening\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological opening of \!\(\*StyleBox[\"list\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"CUDAOpening\", \"[\", RowBox[{StyleBox[\"mem\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the morphological opening of \!\(\*StyleBox[\"mem\", \"TI\"]\) with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square."
CUDALink`CUDAQ::usage = "\!\(\*RowBox[{\"CUDAQ\", \"[\", \"]\"}]\) returns True if a CUDA-capable device is available and False otherwise."
CUDALink`CUDAResourcesInformation::usage = "\!\(\*RowBox[{\"CUDAResourcesInformation\", \"[\", \"]\"}]\) gives information on installed CUDAResources paclets."
CUDALink`CUDAResourcesInstall::usage = "\!\(\*RowBox[{\"CUDAResourcesInstall\", \"[\", \"]\"}]\) installs the CUDAResources paclet from the Wolfram Data Paclet server.\n\!\(\*RowBox[{\"CUDAResourcesInstall\", \"[\", StyleBox[\"pth\", \"TI\"], \"]\"}]\) installs the CUDAResources paclet from the paclet file."
CUDALink`CUDAResourcesUninstall::usage = "\!\(\*RowBox[{\"CUDAResourcesUninstall\", \"[\", \"]\"}]\) uninstalls the CUDAResources paclet."
CUDALink`CUDASort::usage = "\!\(\*RowBox[{\"CUDASort\", \"[\", StyleBox[\"vec\", \"TI\"], \"]\"}]\) sorts the input vector.\n\!\(\*RowBox[{\"CUDASort\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) sorts CUDAMemory in place.\n\!\(\*RowBox[{\"CUDASort\", \"[\", RowBox[{StyleBox[\"vec\", \"TI\"], \",\", StyleBox[\"op\", \"TI\"]}], \"]\"}]\) sorts input with respect to the ordering function \!\(\*StyleBox[\"op\", \"TI\"]\)."
CUDALink`CUDATotal::usage = "\!\(\*RowBox[{\"CUDATotal\", \"[\", StyleBox[\"vec\", \"TI\"], \"]\"}]\) gives the total of the absolute value of a vector \!\(\*StyleBox[\"vec\", \"TI\"]\)."
CUDALink`CUDATranspose::usage = "\!\(\*RowBox[{\"CUDATranspose\", \"[\", StyleBox[\"mat\", \"TI\"], \"]\"}]\) transposes input matrix \!\(\*StyleBox[\"mat\", \"TI\"]\).\n\!\(\*RowBox[{\"CUDATranspose\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) transposes input CUDAMemory \!\(\*StyleBox[\"mem\", \"TI\"]\)."
CUDALink`CUDAVolumetricDataRead::usage = "\!\(\*RowBox[{\"CUDAVolumetricDataRead\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"height\", \"TI\"], \",\", StyleBox[\"depth\", \"TI\"]}], \"]\"}]\) reads volumetric data stored in \!\(\*StyleBox[\"file\", \"TI\"]\) with specified \!\(\*StyleBox[\"height\", \"TI\"]\) and \!\(\*StyleBox[\"depth\", \"TI\"]\)."
CUDALink`CUDAVolumetricRender::usage = "\!\(\*RowBox[{\"CUDAVolumetricRender\", \"[\", StyleBox[\"vol\", \"TI\"], \"]\"}]\) performs volumetric rendering using the input data."
CUDALink`NVCCCompiler`NVCCCompiler::usage = "\!\(\*RowBox[{\"CreateLibrary\", \"[\", RowBox[{StyleBox[\"src\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", RowBox[{StyleBox[\"\\\"Compiler\\\"\",ShowStringCharacters->True], \"->\", \"NVCCCompiler\"}]}], \"]\"}]\) compiles a string of CUDA code in \!\(\*StyleBox[\"src\", \"TI\"]\) into a library and returns the full path to the library.\n\!\(\*RowBox[{\"CreateLibrary\", RowBox[{\"[\", \"{\"}], RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\", \",\", \"name\", \",\", RowBox[{StyleBox[\"\\\"Compiler\\\"\",ShowStringCharacters->True], \"->\", \"NVCCCompiler\"}]}], \"]\"}]\) compiles a number of CUDA and C source files into a library and returns the full path to the library.\n\!\(\*RowBox[{\" \", RowBox[{\"CreateExecutable\", \"[\", RowBox[{StyleBox[\"src\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", RowBox[{StyleBox[\"\\\"Compiler\\\"\",ShowStringCharacters->True], \"->\", \"NVCCCompiler\"}]}], \"]\"}]}]\) compiles a string of CUDA code in \!\(\*StyleBox[\"src\", \"TI\"]\) into an executable and returns the full path to the executable.\n\!\(\*RowBox[{\"CreateExecutable\", RowBox[{\"[\", \"{\"}], RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\", \",\", \"name\", \",\", RowBox[{StyleBox[\"\\\"Compiler\\\"\",ShowStringCharacters->True], \"->\", \"NVCCCompiler\"}]}], \"]\"}]\) compiles a number of CUDA, mprep, and C source files into an executable and returns the full path to the executable.\n\!\(\*RowBox[{\"CreateObjectFile\", \"[\", RowBox[{StyleBox[\"src\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", RowBox[{StyleBox[\"\\\"Compiler\\\"\",ShowStringCharacters->True], \"->\", \"NVCCCompiler\"}]}], \"]\"}]\) compiles a string of CUDA code in \!\(\*StyleBox[\"src\", \"TI\"]\) into an object file and returns the full path to the object file.\n\!\(\*RowBox[{\"CreateObjectFile\", RowBox[{\"[\", \"{\"}], RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\", \",\", \"name\", \",\", RowBox[{StyleBox[\"\\\"Compiler\\\"\",ShowStringCharacters->True], \"->\", \"NVCCCompiler\"}]}], \"]\"}]\) compiles a number of CUDA and C source files into object files and returns the full path to the object files."
CUDALink`SymbolicCUDABlockDimension::usage = "\!\(\*RowBox[{\"SymbolicCUDABlockDimension\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of a CUDA kernel block dimension call."
CUDALink`SymbolicCUDABlockIndex::usage = "\!\(\*RowBox[{\"SymbolicCUDABlockIndex\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of a CUDA kernel block index call."
CUDALink`SymbolicCUDACalculateKernelIndex::usage = "\!\(\*RowBox[{\"SymbolicCUDACalculateKernelIndex\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of a CUDA kernel index calculation."
CUDALink`SymbolicCUDADeclareIndexBlock::usage = "\!\(\*RowBox[{\"SymbolicCUDADeclareIndexBlock\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of a CUDA kernel index declaration."
CUDALink`SymbolicCUDAFunction::usage = "\!\(\*RowBox[{\"SymbolicCUDAFunction\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a CUDA function declaration.\n\!\(\*RowBox[{\"SymbolicCUDAFunction\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a CUDA function definition."
CUDALink`SymbolicCUDAKernelIndex::usage = "\!\(\*RowBox[{\"SymbolicCUDAKernelIndex\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of a CUDA kernel index call."
CUDALink`SymbolicCUDAThreadIndex::usage = "\!\(\*RowBox[{\"SymbolicCUDAThreadIndex\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of a CUDA kernel thread index call."
CumulantGeneratingFunction::usage = "\!\(\*RowBox[{\"CumulantGeneratingFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the cumulant-generating function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variable \!\(\*StyleBox[\"t\", \"TI\"]\). \n\!\(\*RowBox[{\"CumulantGeneratingFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the cumulant-generating function for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variables \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] . "
Cumulant::usage = "\!\(\*RowBox[{\"Cumulant\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) cumulant of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"Cumulant\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) cumulant of the elements in the \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Cumulant\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) represents the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) formal cumulant. "
CupCap::usage = "\!\(\*RowBox[{\"CupCap\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[CupCap]\", StyleBox[\"y\", \"TI\"], \"\[CupCap]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Cup::usage = "\!\(\*RowBox[{\"Cup\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Cup]\", StyleBox[\"y\", \"TI\"], \"\[Cup]\", \"\[Ellipsis]\"}]\)."
Curl::usage = "\!\(\*RowBox[{\"Curl\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the curl \!\(\*RowBox[{RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}]}], \"-\", RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"]}]}]}]\).\n\!\(\*RowBox[{\"Curl\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the curl \!\(\*RowBox[{\"(\", RowBox[{RowBox[{RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"3\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"]}]}], \"-\", RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"3\"]}]}]}], \",\", RowBox[{RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"3\"]}]}], \"-\", RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"3\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}]}]}], \",\", RowBox[{RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}]}], \"-\", RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"]}]}]}]}], \")\"}]\).\n\!\(\*RowBox[{\"Curl\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"TI\"]}], \"]\"}]\) gives the curl of the \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\[Ellipsis]\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) array \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*StyleBox[\"-dimensional\", Deletable -> True]\) vector \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"Curl\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) gives the curl in the coordinates \!\(\*StyleBox[\"chart\", \"TI\"]\)."
CurrencyConvert::usage = "\!\(\*RowBox[{\"CurrencyConvert\", \"[\", RowBox[{StyleBox[\"quantity\", \"TI\"], \",\", StyleBox[\"target\", \"TI\"]}], \"]\"}]\) attempts to convert the specified currency \!\(\*StyleBox[\"quantity\", \"TI\"]\) to the specified \!\(\*StyleBox[\"target\", \"TI\"]\) currency."
CurrentImage::usage = "\!\(\*RowBox[{\"CurrentImage\", \"[\", \"]\"}]\) returns the current image captured from a connected camera.\n\!\(\*RowBox[{\"CurrentImage\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns \!\(\*StyleBox[\"n\", \"TI\"]\) sequential image frames as a list."
CurrentValue::usage = "\!\(\*RowBox[{\"CurrentValue\", \"[\", StyleBox[\"item\", \"TI\"], \"]\"}]\) gives the current value of \!\(\*StyleBox[\"item\", \"TI\"]\) at a location in the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\", \"ReplacedText\" -> {StyleBox[\"Mathematica\", FontSlant -> \"Italic\"], \" system\"}]\) and interface. \n\!\(\*RowBox[{\"CurrentValue\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"item\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the current value for the feature of \!\(\*StyleBox[\"item\", \"TI\"]\) specified by \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"CurrentValue\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"item\", \"TI\"]}], \"]\"}]\) gives the current value of \!\(\*StyleBox[\"item\", \"TI\"]\) associated with the object \!\(\*StyleBox[\"obj\", \"TI\"]\). "
CurvatureFlowFilter::usage = "\!\(\*RowBox[{\"CurvatureFlowFilter\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) applies a mean curvature flow filter to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"CurvatureFlowFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) specifies the amount of curvature flow time \!\(\*StyleBox[\"t\", \"TI\"]\) to be applied.\n\!\(\*RowBox[{\"CurvatureFlowFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) applies the curvature flow with a modified conductance term parametrized by \!\(\*StyleBox[\"k\", \"TI\"]\)."
CurveClosed::usage = "CurveClosed is an option for JoinedCurve that specifies whether individual curve components should be closed curves."
C::usage = "\!\(\*RowBox[{\"C\", \"[\", StyleBox[\"i\", \"TI\"], \"]\"}]\) is the default form for the \!\(\*StyleBox[RowBox[{StyleBox[\"i\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) parameter or constant generated in representing the results of various symbolic computations. "
Cyan::usage = "Cyan represents the color cyan in graphics or style specifications. "
CycleGraph::usage = "\!\(\*RowBox[{\"CycleGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the cycle graph with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices \!\(\*SubscriptBox[StyleBox[\"C\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
CycleIndexPolynomial::usage = "\!\(\*RowBox[{\"CycleIndexPolynomial\", \"[\", RowBox[{StyleBox[\"perm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) constructs the cycle index monomial of the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\) in the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"CycleIndexPolynomial\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) constructs the cycle index polynomial of \!\(\*StyleBox[\"group\", \"TI\"]\) in the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Cycles::usage = "\!\(\*RowBox[{\"Cycles\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cyc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cyc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}], \"]\"}]\) represents a permutation with disjoint cycles \!\(\*SubscriptBox[StyleBox[\"cyc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
CyclicGroup::usage = "\!\(\*RowBox[{\"CyclicGroup\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the cyclic group of degree \!\(\*StyleBox[\"n\", \"TI\"]\)."
Cyclotomic::usage = "\!\(\*RowBox[{\"Cyclotomic\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) cyclotomic polynomial in \!\(\*StyleBox[\"x\", \"TI\"]\). "
Cylinder::usage = "\!\(\*RowBox[{\"Cylinder\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a cylinder of radius \!\(\*StyleBox[\"r\", \"TI\"]\) around the line from \!\(\*RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \")\"}]\) to \!\(\*RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \")\"}]\). \n\!\(\*RowBox[{\"Cylinder\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}], \"]\"}]\) represents a cylinder of radius 1. "
CylindricalDecomposition::usage = "\!\(\*RowBox[{\"CylindricalDecomposition\", \"[\", RowBox[{StyleBox[\"ineqs\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds a decomposition of the region represented by the inequalities \!\(\*StyleBox[\"ineqs\", \"TI\"]\) into cylindrical parts whose directions correspond to the successive \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
DagumDistribution::usage = "\!\(\*RowBox[{\"DagumDistribution\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) represents a Dagum distribution with shape parameters \!\(\*StyleBox[\"p\", \"TI\"]\) and \!\(\*StyleBox[\"a\", \"TI\"]\) and scale parameter \!\(\*StyleBox[\"b\", \"TI\"]\)."
DamData::usage = "\!\(\*RowBox[{\"DamData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the dam \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"DamData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified dam entities.\n\!\(\*RowBox[{\"DamData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
DamerauLevenshteinDistance::usage = "\!\(\*RowBox[{\"DamerauLevenshteinDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Damerau\[Dash]Levenshtein distance between strings or vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
DampingFactor::usage = "DampingFactor is an option for FindRoot, which can be used to control convergence behavior. \!\(\*RowBox[{\"DampingFactor\", \" \", \"->\", \" \", StyleBox[\"n\", \"TI\"]}]\) uses a damping factor of \!\(\*StyleBox[\"n\", \"TI\"]\) in Newton's method."
Darker::usage = "\!\(\*RowBox[{\"Darker\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) represents a darker version of the specified color. \n\!\(\*RowBox[{\"Darker\", \"[\", RowBox[{StyleBox[\"color\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) represents a version of the specified color darkened by a fraction \!\(\*StyleBox[\"f\", \"TI\"]\). \n\!\(\*RowBox[{\"Darker\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a darker version of an image."
Dashed::usage = "Dashed is a graphics directive specifying that lines that follow should be drawn dashed."
Dashing::usage = "\!\(\*RowBox[{\"Dashing\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a two-dimensional graphics directive specifying that lines that follow are to be drawn dashed, with successive segments of lengths \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] (repeated cyclically). The \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are given as a fraction of the total width of the graph. \n\!\(\*RowBox[{\"Dashing\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) is equivalent to \!\(\*RowBox[{\"Dashing\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}], \"]\"}]\). "
DatabinAdd::usage = "\!\(\*RowBox[{\"DatabinAdd\", \"[\", RowBox[{StyleBox[\"bin\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) adds the specified data to a databin.\n\!\(\*StyleBox[RowBox[{\"DatabinAdd\", \"[\", StyleBox[\"bin\", \"TI\"], \"]\"}], CellDingbat -> Cell[\"bobs   \", \"TentativeID\"]]\) represents an operator form of DatabinAdd that can be applies to an expression."
DatabinRemove::usage = "\!\(\*RowBox[{\"DatabinRemove\", \"[\", RowBox[{StyleBox[\"bin\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) removes the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\)entry from a databin.\n\!\(\*RowBox[{\"DatabinRemove\", \"[\", RowBox[{StyleBox[\"bin\", \"TI\"], \",\", StyleBox[\"uuid\", \"TI\"]}], \"]\"}]\) removes the entry with the specified UUID from a databin.\n\!\(\*RowBox[{\"DatabinRemove\", \"[\", RowBox[{StyleBox[\"bin\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"}\"}]}], \"]\"}]\) removes the span of entries with indices from \!\(\*StyleBox[\"i\", \"TI\"]\) through \!\(\*StyleBox[\"j\", \"TI\"]\)."
Databins::usage = "\!\(\*RowBox[{\"Databins\", \"[\", \"]\"}]\) gives a list of databins associated with the currently connected user."
DatabinUpload::usage = "\!\(\*RowBox[{\"DatabinUpload\", \"[\", RowBox[{StyleBox[\"bin\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entry\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entry\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) bulk uploads all the entries \!\(\*SubscriptBox[StyleBox[\"entry\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to a databin.\n\!\(\*RowBox[{\"DatabinUpload\", \"[\", RowBox[{StyleBox[\"bin\", \"TI\"], \",\", RowBox[{\"EventSeries\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]}], \"]\"}]\) bulk uploads all entries in an event series to a databin."
Databin::usage = "\!\(\*RowBox[{\"Databin\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents a databin in the Wolfram Data Drop.\n\!\(\*RowBox[{\"Databin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents the first \!\(\*StyleBox[\"n\", \"TI\"]\) entries in a databin.\n\!\(\*RowBox[{\"Databin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) represents the most recent \!\(\*StyleBox[\"n\", \"TI\"]\) entries in a databin.\n\!\(\*RowBox[{\"Databin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents entries \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) in a databin, with negative numbers counting from the end.\n\!\(\*RowBox[{\"Databin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents entries \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) with step \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{\"Databin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"time\", \"TI\"]}], \"]\"}]\) represents entries going back for the quantity of time specified by \!\(\*StyleBox[\"time\", \"TI\"]\).\n\!\(\*RowBox[{\"Databin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"date\", \"TI\"]}], \"]\"}]\) represents the entries in a databin from the specified date to now.\n\!\(\*RowBox[{\"Databin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents the entries in a databin from \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"Databin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"id\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"range\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents only elements with keys \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) within each entry in a databin."
DataDistribution::usage = "\!\(\*RowBox[{\"DataDistribution\", \"[\", RowBox[{StyleBox[\"ddist\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a probability distribution of type \!\(\*StyleBox[\"ddist\", \"TI\"]\), estimated from a set of data."
DataRange::usage = "DataRange is an option for functions such as ListPlot and ListDensityPlot that specifies what range of actual coordinates the data should be assumed to occupy. "
DataReversed::usage = "DataReversed is an option for ArrayPlot and related functions that specifies whether data should be plotted in reverse order."
Dataset::usage = "\!\(\*RowBox[{\"Dataset\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) represents a structured dataset based on a hierarchy of lists and associations."
DateDifference::usage = "\!\(\*RowBox[{\"DateDifference\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the number of days from \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"DateDifference\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"unit\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the difference between \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in the specified unit.\n\!\(\*RowBox[{\"DateDifference\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"unit\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"unit\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the difference as a list with elements corresponding to the successive \"\!\(\*SubscriptBox[\nStyleBox[\"unit\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\"."
DatedUnit::usage = "\!\(\*RowBox[{\"DatedUnit\", \"[\", RowBox[{StyleBox[\"unit\", \"TI\"], \",\", StyleBox[\"date\", \"TI\"]}], \"]\"}]\) represent the specified \!\(\*StyleBox[\"unit\", \"TI\"]\) at a specific \!\(\*StyleBox[\"date\", \"TI\"]\)."
DateFormat::usage = "DateFormat is an option that determines the date formatting that is used for DateObject display and for interpretation in Interpreter."
DateFunction::usage = "DateFunction is an option for DateListPlot that specifies how dates given as input should be converted to date lists."
DateHistogram::usage = "\!\(\*RowBox[{\"DateHistogram\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a histogram of the dates \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"DateHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) plots a histogram with bin width specification \!\(\*StyleBox[\"bspec\", \"TI\"]\).\n\!\(\*RowBox[{\"DateHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) plots a histogram with bin heights computed according to the specification \!\(\*StyleBox[\"hspec\", \"TI\"]\).\n\!\(\*RowBox[{\"DateHistogram\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots histograms for multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
DateListLogPlot::usage = "\!\(\*RowBox[{\"DateListLogPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a log plot with values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at a sequence of dates.\n\!\(\*RowBox[{\"DateListLogPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) makes a log plot with dates at equal intervals specified by \!\(\*StyleBox[\"datespec\", \"TI\"]\).\n\!\(\*RowBox[{\"DateListLogPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of values."
DateListPlot::usage = "\!\(\*RowBox[{\"DateListPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots points with values \!\(\*StyleBox[SubscriptBox[StyleBox[\"v\", \"TI\"], \"i\"], \"TI\"]\) at a sequence of dates.\n\!\(\*RowBox[{\"DateListPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) plots points with dates at equal intervals specified by \!\(\*StyleBox[\"datespec\", \"TI\"]\).\n\!\(\*RowBox[{\"DateListPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of values."
DateListStepPlot::usage = "\!\(\*RowBox[{\"DateListStepPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the values \!\(\*StyleBox[SubscriptBox[StyleBox[\"v\", \"TI\"], \"i\"], \"TI\"]\) in steps at a sequence of dates.\n\!\(\*RowBox[{\"DateListStepPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) plots the values \!\(\*StyleBox[SubscriptBox[StyleBox[\"v\", \"TI\"], \"i\"], \"TI\"]\) in steps with dates at equal intervals specified by \!\(\*StyleBox[\"datespec\", \"TI\"]\).\n\!\(\*RowBox[{\"DateListStepPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of values.\n\!\(\*RowBox[{\"DateListStepPlot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"step\", \"TI\"]}], \"]\"}]\) plots using steps specified by \!\(\*StyleBox[\"step\", \"TI\"]\)."
DateList::usage = "\!\(\*RowBox[{\"DateList\", \"[\", \"]\"}]\) gives the current local date and time in the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"DateList\", \"[\", StyleBox[\"time\", \"TI\"], \"]\"}]\) gives a date list corresponding to an AbsoluteTime specification.\n\!\(\*RowBox[{\"DateList\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) gives a date list corresponding to a DateObject specification.\n\!\(\*RowBox[{\"DateList\", \"[\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) converts a date list to standard normalized form. \n\!\(\*RowBox[{\"DateList\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) converts a date string to a date list. \n\!\(\*RowBox[{\"DateList\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"e\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"e\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \"]\"}]\) gives the date list obtained by extracting elements \"\!\(\*SubscriptBox[\nStyleBox[\"e\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\" from \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\"."
DateObjectQ::usage = "\!\(\*RowBox[{\"DateObjectQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a DateObject with valid arguments, and False otherwise."
DateObject::usage = "\!\(\*RowBox[{\"DateObject\", \"[\", \"]\"}]\) represents the current local date.\n\!\(\*RowBox[{\"DateObject\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"time\", \"TI\"]}], \"]\"}]\) represents the specified \!\(\*StyleBox[\"date\", \"TI\"]\) list and TimeObject \!\(\*StyleBox[\"time\", \"TI\"]\).\n\!\(\*RowBox[{\"DateObject\", \"[\", StyleBox[\"time\", \"TI\"], \"]\"}]\) gives a date object corresponding to an AbsoluteTime specification.\n\!\(\*RowBox[{\"DateObject\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a date object of standard normalized form.\n\!\(\*RowBox[{\"DateObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) converts a date string to a date object."
DatePattern::usage = "\!\(\*RowBox[{\"DatePattern\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"e\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"e\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents the characters of a date with elements of type \"\!\(\*SubscriptBox[\nStyleBox[\"e\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\" in StringExpression.\n\!\(\*RowBox[{\"DatePattern\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"e\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"e\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"sep\", \"TI\"]}], \"]\"}]\) allows separators that match the string expression \!\(\*StyleBox[\"sep\", \"TI\"]\)."
DatePlus::usage = "\!\(\*RowBox[{\"DatePlus\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the date \!\(\*StyleBox[\"n\", \"TI\"]\) days after \!\(\*StyleBox[\"date\", \"TI\"]\).\n\!\(\*RowBox[{\"DatePlus\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"unit\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}]}], \"]\"}]\) gives the date \!\(\*StyleBox[\"n\", \"TI\"]\) units after \!\(\*StyleBox[\"date\", \"TI\"]\).\n\!\(\*RowBox[{\"DatePlus\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"unit\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"unit\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a date offset by \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) units of each specified size. \n\!\(\*RowBox[{\"DatePlus\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the date \!\(\*StyleBox[\"n\", \"TI\"]\) days after the current date.\n\!\(\*RowBox[{\"DatePlus\", \"[\", StyleBox[\"offset\", \"TI\"], \"]\"}]\) gives the date with the specified offset from the current date."
DateRange::usage = "\!\(\*RowBox[{\"DateRange\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives all dates in the range from \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"1\", \"TR\"]], \"TI\"]\) to \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"2\", \"TR\"]], \"TI\"]\).\n\!\(\*RowBox[{\"DateRange\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"increment\", \"TI\"]}], \"]\"}]\) gives the date lists in the range from \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"1\", \"TR\"]], \"TI\"]\) to \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"2\", \"TR\"]], \"TI\"]\) that are \!\(\*StyleBox[\"increment\", \"TI\"]\) apart."
DateReduction::usage = "DateReduction is an option for DateHistogram that specifies the length for cyclic periods of time."
DateString::usage = "\!\(\*RowBox[{\"DateString\", \"[\", \"]\"}]\) gives a string representing the complete current local date and time. \n\!\(\*RowBox[{\"DateString\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"elem\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the specified element or format for date and time.\n\!\(\*RowBox[{\"DateString\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"elem\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"elem\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) concatenates the specified elements in the order given.\n\!\(\*RowBox[{\"DateString\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) gives a string corresponding to a DateList specification.\n\!\(\*RowBox[{\"DateString\", \"[\", StyleBox[\"time\", \"TI\"], \"]\"}]\) gives a string corresponding to an AbsoluteTime specification.\n\!\(\*RowBox[{\"DateString\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) gives a string corresponding to a DateObject specification.\n\!\(\*RowBox[{\"DateString\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"elems\", \"TI\"]}], \"]\"}]\) gives elements \!\(\*StyleBox[\"elems\", \"TI\"]\) of the date or time specification \!\(\*StyleBox[\"spec\", \"TI\"]\)."
DateTicksFormat::usage = "DateTicksFormat is an option for DateListPlot which specifies how date tick labels should be formatted."
Date::usage = "\!\(\*RowBox[{\"Date\", \"[\", \"]\"}]\) gives the current local date and time in the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"year\", \"TI\"], \",\", StyleBox[\"month\", \"TI\"], \",\", StyleBox[\"day\", \"TI\"], \",\", StyleBox[\"hour\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}]\). "
DateValue::usage = "\!\(\*RowBox[{\"DateValue\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"elem\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the specified element of the current date and time.\n\!\(\*RowBox[{\"DateValue\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of the specified elements of the current date and time.\n\!\(\*RowBox[{\"DateValue\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"]}], \"]\"}]\) gives the specified element of the specified date.\n\!\(\*RowBox[{\"DateValue\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the result in the specified form."
DaubechiesWavelet::usage = "\!\(\*RowBox[{\"DaubechiesWavelet\", \"[\", \"]\"}]\) represents a Daubechies wavelet of order 2. \n\!\(\*RowBox[{\"DaubechiesWavelet\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a Daubechies wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\)."
DavisDistribution::usage = "DavisDistribution\!\(\*RowBox[{\"[\", RowBox[{StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a Davis distribution with scale parameter \!\(\*StyleBox[\"b\", \"TI\"]\), shape parameter \!\(\*StyleBox[\"n\", \"TI\"]\), and location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
DawsonF::usage = "\!\(\*RowBox[{\"DawsonF\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Dawson integral \!\(\*RowBox[{StyleBox[\"F\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
DayCountConvention::usage = "DayCountConvention is an option that specifies the day count convention used by DateDifference."
DayCount::usage = "\!\(\*RowBox[{\"DayCount\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the number of days from \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"1\", \"TR\"]], \"TI\"]\) to \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"2\", \"TR\"]], \"TI\"]\).\n\!\(\*RowBox[{\"DayCount\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"daytype\", \"TI\"]}], \"]\"}]\) gives the number of days of the specified \!\(\*StyleBox[\"daytype\", \"TI\"]\) from \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"1\", \"TR\"]], \"TI\"]\) to \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"2\", \"TR\"]], \"TI\"]\)."
DayHemisphere::usage = "\!\(\*RowBox[{\"DayHemisphere\", \"[\", \"]\"}]\) is a two-dimensional GeoGraphics primitive that represents the half of the Earth that is currently in daylight. \n\!\(\*RowBox[{\"DayHemisphere\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) represents the daylight half of the Earth for the specified date."
DaylightQ::usage = "\!\(\*RowBox[{\"DaylightQ\", \"[\", \"]\"}]\) gives True if it is currently daylight from the user's location.\n\!\(\*RowBox[{\"DaylightQ\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives True if it is daylight from the user's location on the specified \!\(\*StyleBox[\"datespec\", \"TI\"]\).\n\!\(\*RowBox[{\"DaylightQ\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives True if it is currently daylight from the specified \!\(\*StyleBox[\"locationspec\", \"TI\"]\).\n\!\(\*RowBox[{\"DaylightQ\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives True if it is daylight from the specified \!\(\*StyleBox[\"locationspec\", \"TI\"]\) on the specified \!\(\*StyleBox[\"datespec\", \"TI\"]\).\n\!\(\*RowBox[{\"DaylightQ\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives True if it is daylight from the specified locations and dates.\n\!\(\*RowBox[{\"DaylightQ\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"inclusionspec\", \"TI\"]}], \"]\"}]\) gives True if it is daylight from the specified \!\(\*StyleBox[\"locationspec\", \"TI\"]\) on the specified \!\(\*StyleBox[\"datespec\", \"TI\"]\) taking \!\(\*StyleBox[\"inclusionspec\", \"TI\"]\) into account."
DayMatchQ::usage = "\!\(\*RowBox[{\"DayMatchQ\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"daytype\", \"TI\"]}], \"]\"}]\) returns True if the date matches the \!\(\*StyleBox[\"daytype\", \"TI\"]\) specification and returns False otherwise."
DayName::usage = "\!\(\*RowBox[{\"DayName\", \"[\", \"]\"}]\) gives the current day of the week.\n\!\(\*RowBox[{\"DayName\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) gives the day of the week for the given date."
DayNightTerminator::usage = "\!\(\*RowBox[{\"DayNightTerminator\", \"[\", \"]\"}]\) is a one-dimensional GeoGraphics primitive that represents the separation line between the halves of the Earth currently in daytime and nighttime.\n\!\(\*RowBox[{\"DayNightTerminator\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) represents the separation line between day and night for the specified date."
DayPlus::usage = "\!\(\*RowBox[{\"DayPlus\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the date \!\(\*StyleBox[\"n\", \"TI\"]\) days away from \!\(\*StyleBox[\"date\", \"TI\"]\).\n\!\(\*RowBox[{\"DayPlus\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"daytype\", \"TI\"]}], \"]\"}]\) gives the date that is \!\(\*StyleBox[\"n\", \"TI\"]\) days of \!\(\*StyleBox[\"daytype\", \"TI\"]\) away from \!\(\*StyleBox[\"date\", \"TI\"]\)."
DayRange::usage = "\!\(\*RowBox[{\"DayRange\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the dates in the range from \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"1\", \"TR\"]], \"TI\"]\) to \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"2\", \"TR\"]], \"TI\"]\).\n\!\(\*RowBox[{\"DayRange\", \"[\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"daytype\", \"TI\"]}], \"]\"}]\) gives the dates in the range from \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"1\", \"TR\"]], \"TI\"]\) to \!\(\*StyleBox[SubscriptBox[\"date\", StyleBox[\"2\", \"TR\"]], \"TI\"]\) that are of the specified \!\(\*StyleBox[\"daytype\", \"TI\"]\)."
DayRound::usage = "\!\(\*RowBox[{\"DayRound\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"daytype\", \"TI\"]}], \"]\"}]\) rounds \!\(\*StyleBox[\"date\", \"TI\"]\) to the nearest day of \!\(\*StyleBox[\"daytype\", \"TI\"]\),\!\(\*StyleBox[\" \", \"TI\"]\)using the next-day rounding convention.\n\!\(\*RowBox[{\"DayRound\", \"[\", RowBox[{StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"daytype\", \"TI\"], \",\", StyleBox[\"rounding\", \"TI\"]}], \"]\"}]\) rounds \!\(\*StyleBox[\"date\", \"TI\"]\) to the nearest day of \!\(\*StyleBox[\"daytype\", \"TI\"]\), using \!\(\*StyleBox[\"rounding\", \"TI\"]\)."
DeBruijnGraph::usage = "\!\(\*RowBox[{\"DeBruijnGraph\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)-dimensional De Bruijn graph with \!\(\*StyleBox[\"m\", \"TI\"]\) symbols.\n\!\(\*RowBox[{\"DeBruijnGraph\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) gives the De Bruijn graph with connectivity given by \!\(\*StyleBox[\"type\", \"TI\"]\)."
Decapitalize::usage = "\!\(\*RowBox[{\"Decapitalize\", \"[\", \"string\", \"]\"}]\) yields a string in which the first character has been made lower case."
Decimal::usage = "Decimal is a setting for the ColumnAlignments option of GridBox which states that numbers should align along the decimal place."
DeclarePackage::usage = "\!\(\*RowBox[{\"DeclarePackage\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) declares that \!\(\*RowBox[{\"Needs\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \"]\"}]\) should automatically be executed if a symbol with any of the specified names is ever used. "
Decompose::usage = "\!\(\*RowBox[{\"Decompose\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) decomposes a polynomial, if possible, into a composition of simpler polynomials. "
Decrement::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"--\"}]\) decreases the value of \!\(\*StyleBox[\"x\", \"TI\"]\) by 1, returning the old value of \!\(\*StyleBox[\"x\", \"TI\"]\). "
Decrypt::usage = "\!\(\*RowBox[{\"Decrypt\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"password\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"enc\", \"TI\"]}], \"]\"}]\) attempts to decrypt the encrypted object \!\(\*StyleBox[\"enc\", \"TI\"]\) using the specified password.\n\!\(\*RowBox[{\"Decrypt\", \"[\", RowBox[{StyleBox[\"keyspec\", \"TI\"], \",\", StyleBox[\"enc\", \"TI\"]}], \"]\"}]\) attempts to decrypt using the cryptographic key specification \!\(\*StyleBox[\"keyspec\", \"TI\"]\).\n\!\(\*RowBox[{\"Decrypt\", \"[\", RowBox[{StyleBox[\"key\", \"TI\"], \",\", StyleBox[\"bytes\", \"TI\"]}], \"]\"}]\) attempts to decrypt the ByteArray object bytes, to give another ByteArray object."
DedekindEta::usage = "\!\(\*RowBox[{\"DedekindEta\", \"[\", StyleBox[\"\[Tau]\", \"TR\"], \"]\"}]\) gives the Dedekind eta modular elliptic function \!\(\*RowBox[{\"\[Eta]\", \"(\", \"\[Tau]\", \")\"}]\)."
DeepSpaceProbeData::usage = "\!\(\*RowBox[{\"DeepSpaceProbeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the deep space probe \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"DeepSpaceProbeData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified deep space probe entities.\n\!\(\*RowBox[{\"DeepSpaceProbeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
DefaultAxesStyle::usage = "DefaultAxesStyle is a low-level option for graphics functions that specifies the default style to use in displaying axes and axes-like constructs."
DefaultBaseStyle::usage = "DefaultBaseStyle is a low-level option for formatting and related constructs that specifies a default base style to use before BaseStyle."
DefaultBoxStyle::usage = "DefaultBoxStyle is a low-level option for three-dimensional graphics functions that specifies the default style to use in rendering the bounding box."
DefaultButton::usage = "\!\(\*RowBox[{\"DefaultButton\", \"[\", \"]\"}]\) represents an \!\(\*StyleBox[\"OK\", \"DialogElementName\"]\) button that closes a dialog, and is the default when \!\(\*StyleBox[\"Enter\", \"KeyEvent\"]\) is pressed in the dialog.\n\!\(\*RowBox[{\"DefaultButton\", \"[\", StyleBox[\"action\", \"TI\"], \"]\"}]\) represents a button that is labeled \!\(\*StyleBox[\"OK\", \"DialogElementName\"]\), and whose action is to evaluate \!\(\*StyleBox[\"action\", \"TI\"]\).\n\!\(\*RowBox[{\"DefaultButton\", \"[\", RowBox[{StyleBox[\"label\", \"TI\"], \",\", StyleBox[\"action\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"label\", \"TI\"]\) as the label for the button."
DefaultColor::usage = "DefaultColor is an option for graphics functions that specifies the default color to use for lines, points, etc. "
DefaultDuplicateCellStyle::usage = "DefaultDuplicateCellStyle is a notebook option that specifies the default style to use for cells created by automatic duplication of other cells in the notebook. "
DefaultDuration::usage = "DefaultDuration is an option to Animate and related functions that specifies the default total duration of the animation in seconds."
DefaultElement::usage = "DefaultElement is an option for Grid and related constructs which specifies what to insert when a new element is interactively created."
DefaultFaceGridsStyle::usage = "DefaultFaceGridsStyle is a low-level option for 3D graphics functions that specifies the default style to use in rendering face grids."
DefaultFieldHintStyle::usage = "DefaultFieldHintStyle is a low-level option for InputField that specifies the default style to use for displaying the field hint."
DefaultFontProperties::usage = "DefaultFontProperties is a global option that specifies various properties of a font family, such as its character encoding and whether it is monospaced."
DefaultFormatType::usage = "DefaultFormatType is an option for cells that specifies the format used for displaying expressions in a newly created cell."
DefaultFrameStyle::usage = "DefaultFrameStyle is a low-level option for graphics and related constructs that specifies the default style to use in displaying their frames."
DefaultFrameTicksStyle::usage = "DefaultFrameTicksStyle is a low-level option for 2D graphics functions that specifies the default style to use in rendering frame ticks."
DefaultGridLinesStyle::usage = "DefaultGridLinesStyle is a low-level option for 2D graphics functions that specifies the default style to use in rendering grid lines."
DefaultInlineFormatType::usage = "DefaultInlineFormatType is an option for cells that specifies the format used for displaying expressions in a newly created inline cell."
DefaultLabelStyle::usage = "DefaultLabelStyle is a low-level option for formatting and related constructs that specifies the default style to use in displaying their label-like elements."
DefaultMenuStyle::usage = "DefaultMenuStyle is a low-level option for menu-generating constructs that specifies the default style to use for displaying menu items."
DefaultNaturalLanguage::usage = "DefaultNaturalLanguage is an option for character selections that specifies the language used when checking the spelling of a word in a human natural language selection."
DefaultNewCellStyle::usage = "DefaultNewCellStyle is a notebook option which specifies the default style to use for new cells created in the notebook. "
DefaultNewInlineCellStyle::usage = "DefaultNewInlineCellStyle is an option for cells that specifies the default style to use for new inline cells created in the notebook."
DefaultNotebook::usage = "DefaultNotebook is a global option that specifies which notebook is used as a template for all new notebooks."
DefaultOptions::usage = "DefaultOptions is a style option that allows default options to be specified for particular formatting and related constructs. "
DefaultStyleDefinitions::usage = "DefaultStyleDefinitions is a global option that specifies the default stylesheet for all new notebooks."
DefaultTicksStyle::usage = "DefaultTicksStyle is a low-level option for graphics functions that specifies the default style to use in rendering ticks."
DefaultTooltipStyle::usage = "DefaultTooltipStyle is a low-level option for tooltips that specifies the default style to use in displaying their elements."
Default::usage = "\!\(\*RowBox[{\"Default\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives the default value for arguments of the function \!\(\*StyleBox[\"f\", \"TI\"]\) obtained with a _. pattern object. \n\!\(\*RowBox[{\"Default\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives the default value to use when _. appears as the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) argument of \!\(\*StyleBox[\"f\", \"TI\"]\). \n\!\(\*RowBox[{\"Default\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the default value for the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) argument out of a total of \!\(\*StyleBox[\"n\", \"TI\"]\) arguments. \n\!\(\*RowBox[{RowBox[{\"Default\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \"=\", StyleBox[\"val\", \"TI\"]}]\) defines default values for arguments of \!\(\*StyleBox[\"f\", \"TI\"]\)."
DefaultValues::usage = "\!\(\*RowBox[{\"DefaultValues\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives a list of transformation rules corresponding to all defaults (values for \!\(\*RowBox[{\"Default\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\), etc.) defined for the symbol \!\(\*StyleBox[\"f\", \"TI\"]\)."
Defer::usage = "\!\(\*RowBox[{\"Defer\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) yields an object that displays as the unevaluated form of \!\(\*StyleBox[\"expr\", \"TI\"]\), but that is evaluated if it is explicitly given as \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) input. "
DefineInputStreamMethod::usage = "\!\(\*RowBox[{\"DefineInputStreamMethod\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"fname\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"function\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"fname\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"function\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \" \", \"}\"}]}], \"]\"}]\) defines a custom input stream method with the specified name, allowing \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\"]\) to call the stream functions \!\(\*SubscriptBox[StyleBox[\"fname\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for opening and reading from an input stream."
DefineOutputStreamMethod::usage = "\!\(\*RowBox[{\"DefineOutputStreamMethod\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"fname\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"function\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"fname\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"function\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \" \", \"}\"}]}], \"]\"}]\) defines a custom output stream method with the specified name, allowing \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\"]\) to call the stream functions for opening and writing to an output stream."
Definition::usage = "\!\(\*RowBox[{\"Definition\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) prints as the definitions given for a symbol. "
DegreeCentrality::usage = "\!\(\*RowBox[{\"DegreeCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of vertex degrees for the vertices in the underlying simple graph of \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"DegreeCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"In\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of vertex in-degrees.\n\!\(\*RowBox[{\"DegreeCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"Out\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of vertex out-degrees.\n\!\(\*RowBox[{\"DegreeCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
DegreeGraphDistribution::usage = "\!\(\*RowBox[{\"DegreeGraphDistribution\", \"[\", StyleBox[\"dlist\", \"TI\"], \"]\"}]\) represents a degree graph distribution with vertex degree \!\(\*StyleBox[\"dlist\", \"TI\"]\)."
DegreeLexicographic::usage = "DegreeLexicographic represents the degree lexicographic ordering of monomials."
DegreeReverseLexicographic::usage = "DegreeReverseLexicographic represents the degree reverse lexicographic ordering of monomials."
Degree::usage = "Degree gives the number of radians in one degree. It has a numerical value of \!\(\*FractionBox[\"\[Pi]\", \"180\"]\). "
DEigensystem::usage = "\!\(\*RowBox[{\"DEigensystem\", \"[\", RowBox[{RowBox[{StyleBox[\"\[ScriptCapitalL]\", \"TI\"], \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \"]\"}], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) smallest magnitude eigenvalues and eigenfunctions for the linear differential operator \!\(\*StyleBox[\"\[ScriptCapitalL]\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"DEigensystem\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the eigenvalues and eigenfunctions for solutions \!\(\*StyleBox[\"u\", \"TI\"]\) of the time-dependent differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\)."
DEigenvalues::usage = "\!\(\*RowBox[{\"DEigenvalues\", \"[\", RowBox[{StyleBox[\"\[ScriptCapitalL]\", \"TI\"], \"[\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) smallest magnitude eigenvalues for the linear differential operator \!\(\*StyleBox[\"\[ScriptCapitalL]\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"DEigenvalues\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the eigenvalues for solutions \!\(\*StyleBox[\"u\", \"TI\"]\) of the time-dependent differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\)."
Deinitialization::usage = "Deinitialization is an option for Dynamic, DynamicModule, Manipulate, and related constructs that specifies an expression to be evaluated when the construct can no longer be displayed or used. "
DelaunayMesh::usage = "\!\(\*RowBox[{\"DelaunayMesh\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a MeshRegion representing the Delaunay mesh from the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
Delayed::usage = "\!\(\*RowBox[{\"Delayed\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents an expression whose evaluation is delayed until its value is externally requested.\n\!\(\*RowBox[{\"Delayed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"fmt\", \"TI\"]}], \"]\"}]\) specifies that the result from evaluating \!\(\*StyleBox[\"expr\", \"TI\"]\) should be given in format \!\(\*StyleBox[\"fmt\", \"TI\"]\).\n\!\(\*RowBox[{\"Delayed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"fmt\", \"TI\"], \",\", StyleBox[\"rform\", \"TI\"]}], \"}\"}]}], \"]\"}]\) specifies that the result should be given as a response of the form \!\(\*StyleBox[\"rform\", \"TI\"]\)."
Deletable::usage = "Deletable is an option for Cell that specifies whether the cell can be deleted interactively using the front end. "
DeleteBorderComponents::usage = "\!\(\*RowBox[{\"DeleteBorderComponents\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) replaces connected components adjacent to the border in a binary image \!\(\*StyleBox[\"image\", \"TI\"]\) with background pixels.\n\!\(\*RowBox[{\"DeleteBorderComponents\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) replaces components adjacent to the border in a label matrix \!\(\*StyleBox[\"m\", \"TI\"]\) with 0."
DeleteCases::usage = "\!\(\*RowBox[{\"DeleteCases\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) removes all elements of \!\(\*StyleBox[\"expr\", \"TI\"]\) that match \!\(\*StyleBox[\"pattern\", \"TI\"]\). \n\!\(\*RowBox[{\"DeleteCases\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) removes all parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) on levels specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\) that match \!\(\*StyleBox[\"pattern\", \"TI\"]\). \n\!\(\*RowBox[{\"DeleteCases\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) removes the first \!\(\*StyleBox[\"n\", \"TI\"]\) parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) that match \!\(\*StyleBox[\"pattern\", \"TI\"]\). \n\!\(\*RowBox[{\"DeleteCases\", \"[\", StyleBox[\"pattern\", \"TI\"], \"]\"}]\) represents an operator form of DeleteCases that can be applied to an expression."
DeleteContents::usage = "DeleteContents is an option for DeleteDirectory that specifies whether the contents of directories should automatically be deleted."
DeleteDirectory::usage = "\!\(\*RowBox[{\"DeleteDirectory\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dir\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) deletes the specified directory. "
DeleteDuplicatesBy::usage = "\!\(\*RowBox[{\"DeleteDuplicatesBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) deletes those \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that yield duplicates in the list \!\(\*RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"DeleteDuplicatesBy\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of DeleteDuplicatesBy that can be applied to an expression."
DeleteDuplicates::usage = "\!\(\*RowBox[{\"DeleteDuplicates\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) deletes all duplicates from \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"DeleteDuplicates\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"test\", \"TI\"]\) to pairs of elements to determine whether they should be considered duplicates. "
DeleteFile::usage = "\!\(\*RowBox[{\"DeleteFile\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) deletes a file. \n\!\(\*RowBox[{\"DeleteFile\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) deletes a list of files. "
DeleteMissing::usage = "\!\(\*RowBox[{\"DeleteMissing\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) drops elements with head Missing from a list.\n\!\(\*RowBox[{\"DeleteMissing\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) drops elements whose values have head Missing from the association \!\(\*StyleBox[\"assoc\", \"TI\"]\).\n\!\(\*RowBox[{\"DeleteMissing\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) applies DeleteMissing to any lists or associations that occur within the first \!\(\*StyleBox[\"n\", \"TI\"]\) levels of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"DeleteMissing\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) considers an element at level \!\(\*StyleBox[\"n\", \"TI\"]\) to be missing if Missing occurs within the first \!\(\*StyleBox[\"d\", \"TI\"]\) levels of the element."
DeleteSearchIndex::usage = "\!\(\*RowBox[{\"DeleteSearchIndex\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) deletes the search index represented by a SearchIndexObject.\n\!\(\*RowBox[{\"DeleteSearchIndex\", \"[\", StyleBox[\"\\\"name\\\"\",ShowStringCharacters->True], \"]\"}]\) deletes a named search index."
DeleteSmallComponents::usage = "\!\(\*RowBox[{\"DeleteSmallComponents\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) replaces small connected components in a binary image \!\(\*StyleBox[\"image\", \"TI\"]\) with background pixels.\n\!\(\*RowBox[{\"DeleteSmallComponents\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) replaces positive integers in a label matrix \!\(\*StyleBox[\"m\", \"TI\"]\) with 0 if their tally is small.\n\!\(\*RowBox[{\"DeleteSmallComponents\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) replaces components consisting of \!\(\*StyleBox[\"n\", \"TI\"]\) or fewer elements."
DeleteStopwords::usage = "\!\(\*RowBox[{\"DeleteStopwords\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) delete stopwords from a list of words.\n\!\(\*RowBox[{\"DeleteStopwords\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) delete stopwords from a string.\n\!\(\*RowBox[{\"DeleteStopwords\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) delete stopwords from a list of strings."
Delete::usage = "\!\(\*RowBox[{\"Delete\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) deletes the element at position \!\(\*StyleBox[\"n\", \"TI\"]\) in \!\(\*StyleBox[\"expr\", \"TI\"]\). If \!\(\*StyleBox[\"n\", \"TI\"]\) is negative, the position is counted from the end. \n\!\(\*RowBox[{\"Delete\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) deletes the part at position \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"Delete\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) deletes parts at several positions. \n\!\(\*RowBox[{\"Delete\", \"[\", StyleBox[\"pos\", \"TI\"], \"]\"}]\) represents an operator form of Delete that can be applied to an expression."
DeletionWarning::usage = "DeletionWarning is an option for InterpretationBox or TagBox objects that specifies whether a warning is issued if the box is deleted."
DelimitedSequence::usage = "\!\(\*RowBox[{\"DelimitedSequence\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) represents a delimited sequence of elements of the specified form in Interpreter and related functions.\n\!\(\*RowBox[{\"DelimitedSequence\", \"[\", RowBox[{StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"sep\", \"TI\"]}], \"]\"}]\) assumes a separator that matches \!\(\*StyleBox[\"sep\", \"TI\"]\).\n\!\(\*RowBox[{\"DelimitedSequence\", \"[\", RowBox[{StyleBox[\"form\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"left\", \"TI\"], \",\", StyleBox[\"sep\", \"TI\"], \",\", StyleBox[\"right\", \"TI\"]}], \"}\"}]}], \"]\"}]\) assumes left and right delimiters matching \!\(\*StyleBox[\"left\", \"TI\"]\) and \!\(\*StyleBox[\"right\", \"TI\"]\), respectively."
DelimiterFlashTime::usage = "DelimiterFlashTime is an option for cells and notebooks that specifies how long in seconds a delimiter should flash when its matching delimiter is entered. "
DelimiterMatching::usage = "DelimiterMatching is an option for selections that specifies whether an opening delimiter will match only its respective closing delimiter or any closing delimiter."
Delimiters::usage = "Delimiters is an option to various functions that specifies what delimiters to use or look for."
Delimiter::usage = "Delimiter represents a delimiter to be displayed in objects such as PopupMenu, Manipulate, and FormObject. "
DeliveryFunction::usage = "DeliveryFunction is an option that specifies how material such as documents generated by DocumentGenerator should be delivered."
Del::usage = "\!\(\*RowBox[{\"Del\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) displays as \!\(\*RowBox[{\"\[Del]\", StyleBox[\"x\", \"TI\"]}]\)."
Denominator::usage = "\!\(\*RowBox[{\"Denominator\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the denominator of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
DensityGraphics::usage = "\!\(\*RowBox[{\"DensityGraphics\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) is a representation of a density plot. "
DensityHistogram::usage = "\!\(\*RowBox[{\"DensityHistogram\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a density histogram of the values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"DensityHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) plots a density histogram with bins specified by \!\(\*StyleBox[\"bspec\", \"TI\"]\).\n\!\(\*RowBox[{\"DensityHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) plots a density histogram with bin densities computed according to the specification \!\(\*StyleBox[\"hspec\", \"TI\"]\)."
DensityPlot3D::usage = "\!\(\*RowBox[{\"DensityPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) makes a density plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"DensityPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes the variables to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
DensityPlot::usage = "\!\(\*RowBox[{\"DensityPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) makes a density plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{\"DensityPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes the variables \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\). "
DependentVariables::usage = "DependentVariables is an option for NDSolve and other functions that specifies the list of all objects that should be considered as dependent variables in equations that have been supplied."
Deployed::usage = "Deployed is an option for displayed objects, cells, and notebooks that specifies whether their contents should be considered deployed, so that elements such as Slider, InputField, Locator, and Button are active, but general editing and selection is disabled. "
Deploy::usage = "\!\(\*RowBox[{\"Deploy\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) yields a deployed version of \!\(\*StyleBox[\"expr\", \"TI\"]\) in which elements such as Slider, InputField, Locator and Button are active, but general editing and selection is disabled. "
DepthFirstScan::usage = "\!\(\*RowBox[{\"DepthFirstScan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) performs a depth-first scan of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) starting at the vertex \!\(\*StyleBox[\"s\", \"TI\"]\) and evaluates \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) whenever \"\!\(\*SubscriptBox[\nStyleBox[\"event\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\" occurs.\n\!\(\*RowBox[{\"DepthFirstScan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) performs a depth-first scan of the whole graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"DepthFirstScan\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Depth::usage = "\!\(\*RowBox[{\"Depth\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the maximum number of indices needed to specify any part of \!\(\*StyleBox[\"expr\", \"TI\"]\), plus 1. "
DerivativeFilter::usage = "\!\(\*RowBox[{\"DerivativeFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) computes the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative of \!\(\*StyleBox[\"image\", \"TI\"]\) in the vertical and horizontal directions.\n\!\(\*RowBox[{\"DerivativeFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) computes the derivative at a Gaussian scale of standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"DerivativeFilter\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) computes the \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative of \!\(\*StyleBox[\"array\", \"TI\"]\).\n\!\(\*RowBox[{\"DerivativeFilter\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"der\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"der\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) computes several derivatives \!\(\*SubscriptBox[StyleBox[\"der\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"der\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
Derivative::usage = "\!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"'\"}]\) represents the derivative of a function \!\(\*StyleBox[\"f\", \"TI\"]\) of one argument. \n\!\(\*RowBox[{RowBox[{\"Derivative\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) is the general form, representing a function obtained from \!\(\*StyleBox[\"f\", \"TI\"]\) by differentiating \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) times with respect to the first argument, \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) times with respect to the second argument, and so on. "
DescriptorStateSpace::usage = "DescriptorStateSpace is an option to StateSpaceModel and StateSpaceTransform that specifies whether to use descriptor or standard representation."
DesignMatrix::usage = "\!\(\*RowBox[{\"DesignMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs the design matrix for the linear model \!\(\*RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \"+\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \" \", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"+\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \" \", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Det::usage = "\!\(\*RowBox[{\"Det\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the determinant of the square matrix \!\(\*StyleBox[\"m\", \"TI\"]\). "
Developer`BesselSimplify::usage = "\!\(\*RowBox[{\"BesselSimplify\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) transforms Bessel functions in \!\(\*StyleBox[\"expr\", \"TI\"]\), trying to either decrease the number of Bessel functions, or convert Bessel functions into more elementary functions. "
Developer`CellInformation::usage = "\!\(\*RowBox[{\"CellInformation\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) gives information about selected cells in the notebook represented by the notebook object \!\(\*StyleBox[\"obj\", \"TI\"]\). "
Developer`FromPackedArray::usage = "\!\(\*RowBox[{\"FromPackedArray\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) unpacks \!\(\*StyleBox[\"expr\", \"TI\"]\) so that its internal representation is not a packed array. "
Developer`GammaSimplify::usage = "\!\(\*RowBox[{\"GammaSimplify\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) transforms gamma functions in \!\(\*StyleBox[\"expr\", \"TI\"]\), trying to either decrease the number of gamma functions, or convert combinations of them into more elementary functions. "
Developer`MachineIntegerQ::usage = "\!\(\*RowBox[{\"MachineIntegerQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) corresponds to a machine\[Hyphen]sized integer, and False otherwise. "
Developer`NotebookConvert::usage = "\!\(\*RowBox[{\"NotebookConvert\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) converts a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) notebook from a previous version of \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) to one for the current version."
Developer`PackedArrayForm::usage = "\!\(\*RowBox[{\"PackedArrayForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints with packed arrays in \!\(\*StyleBox[\"expr\", \"TI\"]\) shown in summary form, without all their elements explicitly given. "
Developer`PackedArrayQ::usage = "\!\(\*RowBox[{\"PackedArrayQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a packed array in its internal representation, and returns False otherwise. \n\!\(\*RowBox[{\"PackedArrayQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a packed array of objects of the specified type. \n\!\(\*RowBox[{\"PackedArrayQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"rank\", \"TI\"]}], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a packed array of the specified rank. "
Developer`PartitionMap::usage = "\!\(\*RowBox[{\"PartitionMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to \!\(\*StyleBox[\"list\", \"TI\"]\) after partitioning into nonoverlapping sublists of length \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"PartitionMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to sublists obtained by partitioning with offset \!\(\*StyleBox[\"d\", \"TI\"]\). \n\!\(\*RowBox[{\"PartitionMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) after partitioning a nested list into blocks of size \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis]. \n\!\(\*RowBox[{\"PartitionMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) after partitioning using offset \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at level \!\(\*StyleBox[\"i\", \"TI\"]\). \n\!\(\*RowBox[{\"PartitionMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) specifies where sublists should begin and end. \n\!\(\*RowBox[{\"PartitionMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"padding\", \"TI\"]}], \"]\"}]\) specifies what padding should be used. "
Developer`PolyGammaSimplify::usage = "\!\(\*RowBox[{\"PolyGammaSimplify\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) transforms polygamma functions in \!\(\*StyleBox[\"expr\", \"TI\"]\), trying to either decrease the number of polygamma functions, or convert combinations of them into more elementary functions. "
Developer`PolyLogSimplify::usage = "\!\(\*RowBox[{\"PolyLogSimplify\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) transforms polylogarithm functions in \!\(\*StyleBox[\"expr\", \"TI\"]\), trying to either decrease the number of polylogarithm functions, or convert combinations of them into more elementary functions. "
Developer`ReplaceAllUnheld::usage = "\!\(\*RowBox[{\"ReplaceAllUnheld\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"rules\", \"TI\"]}], \"]\"}]\) applies a rule or list of rules in an attempt to transform each subpart of \!\(\*StyleBox[\"expr\", \"TI\"]\) that would be automatically evaluated. "
Developer`ToPackedArray::usage = "\!\(\*RowBox[{\"ToPackedArray\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) uses packed arrays if possible in the internal representation of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Developer`TrigToRadicals::usage = "\!\(\*RowBox[{\"TrigToRadicals\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts trigonometric functions to radicals whenever possible in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Developer`ZeroQ::usage = "\!\(\*RowBox[{\"ZeroQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if built\[Hyphen]in transformations allow it to be determined that \!\(\*StyleBox[\"expr\", \"TI\"]\) is numerically equal to zero, and returns False otherwise. "
Developer`ZetaSimplify::usage = "\!\(\*RowBox[{\"ZetaSimplify\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) transforms zeta functions in \!\(\*StyleBox[\"expr\", \"TI\"]\), trying to either decrease the number of zeta functions, or convert combinations of them into more elementary functions. "
Developer`$InactivateExclusions::usage = "$InactivateExclusions is a variable whose value is used to determine which heads Inactivate should ignore."
Developer`$MaxMachineInteger::usage = "$MaxMachineInteger gives the maximum integer that is represented internally as a single atomic data element on your computer system. "
DeviceClose::usage = "\!\(\*RowBox[{\"DeviceClose\", \"[\", StyleBox[\"device\", \"TI\"], \"]\"}]\) closes the connection to a device and frees related resources."
DeviceConfigure::usage = "\!\(\*RowBox[{\"DeviceConfigure\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"config\", \"TI\"]}], \"]\"}]\) configures the specified device according to \!\(\*StyleBox[\"config\", \"TI\"]\)."
DeviceExecuteAsynchronous::usage = "\!\(\*RowBox[{\"DeviceExecuteAsynchronous\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"command\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"fun\", \"TI\"]}], \"]\"}]\) initiates asynchronous execution of the specified command on a device, calling the handler function \!\(\*StyleBox[\"fun\", \"TI\"]\) when an event occurs.\n\!\(\*RowBox[{\"DeviceExecuteAsynchronous\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"command\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"fun\", \"TI\"]}], \"]\"}]\) executes the command with the parameters \!\(\*StyleBox[\"params\", \"TI\"]\)."
DeviceExecute::usage = "\!\(\*RowBox[{\"DeviceExecute\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"command\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) executes the specified command on a device.\n\!\(\*RowBox[{\"DeviceExecute\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"command\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"params\", \"TI\"]}], \"]\"}]\) executes the command with the parameters \!\(\*StyleBox[\"params\", \"TI\"]\)."
DeviceObject::usage = "\!\(\*RowBox[{\"DeviceObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents a device that can be accessed in a Wolfram Language session."
DeviceOpen::usage = "\!\(\*RowBox[{\"DeviceOpen\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"devclass\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) opens a connection to the first available device in the class specified by \"\!\(\*\nStyleBox[\"devclass\", \"TI\"]\)\".\n\!\(\*RowBox[{\"DeviceOpen\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"devclass\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"]\"}]\) opens a connection to the particular device defined by \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"DeviceOpen\", \"[\", StyleBox[\"device\", \"TI\"], \"]\"}]\) opens a connection to an existing device specified by a DeviceObject."
DeviceReadBuffer::usage = "\!\(\*RowBox[{\"DeviceReadBuffer\", \"[\", StyleBox[\"device\", \"TI\"], \"]\"}]\) reads the complete contents of the buffer on a device.\n\!\(\*RowBox[{\"DeviceReadBuffer\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) reads \!\(\*StyleBox[\"n\", \"TI\"]\) elements from the buffer.\n\!\(\*RowBox[{\"DeviceReadBuffer\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) reads elements from the buffer until the device-specific criterion \!\(\*StyleBox[\"crit\", \"TI\"]\) is met.\n\!\(\*RowBox[{\"DeviceReadBuffer\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"], \",\", StyleBox[\"param\", \"TI\"]}], \"]\"}]\) reads elements associated with the parameter \!\(\*StyleBox[\"param\", \"TI\"]\). \n\!\(\*RowBox[{\"DeviceReadBuffer\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reads elements associated with the \!\(\*SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
DeviceReadLatest::usage = "\!\(\*RowBox[{\"DeviceReadLatest\", \"[\", StyleBox[\"device\", \"TI\"], \"]\"}]\) returns the most recently collected default item from a device.\n\!\(\*RowBox[{\"DeviceReadLatest\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns a list of the \!\(\*StyleBox[\"n\", \"TI\"]\) most recently collected items.\n\!\(\*RowBox[{\"DeviceReadLatest\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"param\", \"TI\"]}], \"]\"}]\) returns the \!\(\*StyleBox[\"n\", \"TI\"]\) most recently collected values of \!\(\*StyleBox[\"param\", \"TI\"]\).\n\!\(\*RowBox[{\"DeviceReadLatest\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns a list of the most recently collected values of the \!\(\*SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
DeviceReadList::usage = "\!\(\*RowBox[{\"DeviceReadList\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) reads from the specified device \!\(\*StyleBox[\"n\", \"TI\"]\) times, returning a list of the results.\n\!\(\*RowBox[{\"DeviceReadList\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"param\", \"TI\"]}], \"]\"}]\) reads the parameter \!\(\*StyleBox[\"param\", \"TI\"]\).\n\!\(\*RowBox[{\"DeviceReadList\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reads the list of parameters \!\(\*SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
DeviceReadTimeSeries::usage = "\!\(\*RowBox[{\"DeviceReadTimeSeries\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"dt\", \"TI\"]}], \"}\"}]}], \"]\"}]\) repeatedly reads default items from the specified device at interval \!\(\*StyleBox[\"dt\", \"TI\"]\) for a total time \!\(\*StyleBox[\"t\", \"TI\"]\), returning a time series of the resulting values.\n\!\(\*RowBox[{\"DeviceReadTimeSeries\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"dt\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"param\", \"TI\"]}], \"]\"}]\) repeatedly reads the parameter \!\(\*StyleBox[\"param\", \"TI\"]\) and returns a time series of its values.\n\!\(\*RowBox[{\"DeviceReadTimeSeries\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"dt\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) repeatedly reads the \!\(\*SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and returns a time series of their values."
DeviceRead::usage = "\!\(\*RowBox[{\"DeviceRead\", \"[\", StyleBox[\"devobj\", \"TI\"], \"]\"}]\) reads a single default item from the open device corresponding to the specified DeviceObject.\n\!\(\*RowBox[{\"DeviceRead\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"devclass\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) reads from the default device in the class \"\!\(\*\nStyleBox[\"devclass\", \"TI\"]\)\".\n\!\(\*RowBox[{\"DeviceRead\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"param\", \"TI\"]}], \"]\"}]\) reads the parameter \!\(\*StyleBox[\"param\", \"TI\"]\) from the specified device.\n\!\(\*RowBox[{\"DeviceRead\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reads the list of parameters \!\(\*SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) from the specified device."
DeviceStreams::usage = "\!\(\*RowBox[{\"DeviceStreams\", \"[\", StyleBox[\"device\", \"TI\"], \"]\"}]\) gives a list of all open streams associated with a device.\n\!\(\*RowBox[{\"DeviceStreams\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of streams whose names match the string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"DeviceStreams\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of streams whose names match any of the \!\(\*SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Devices::usage = "\!\(\*RowBox[{\"Devices\", \"[\", \"]\"}]\) gives a list of registered devices on a particular system.\n\!\(\*RowBox[{\"Devices\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) gives a list of devices in classes whose names match the string pattern \!\(\*StyleBox[\"form\", \"TI\"]\).\n\!\(\*RowBox[{\"Devices\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of devices in classes whose names match any of the \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
DeviceWriteBuffer::usage = "\!\(\*RowBox[{\"DeviceWriteBuffer\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"vals\", \"TI\"]}], \"]\"}]\) fills the buffer on a device with the values \!\(\*StyleBox[\"vals\", \"TI\"]\).\n\!\(\*RowBox[{\"DeviceWriteBuffer\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{StyleBox[\"param\", \"TI\"], \"\[Rule]\", StyleBox[\"vals\", \"TI\"]}]}], \"]\"}]\) fills the buffer associated with the parameter \!\(\*StyleBox[\"param\", \"TI\"]\) with the values \!\(\*StyleBox[\"vals\", \"TI\"]\).\n\!\(\*RowBox[{RowBox[{\"DeviceWriteBuffer\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", StyleBox[SubscriptBox[\"vals\", StyleBox[\"1\", \"TR\"]], \"TI\"]}], \",\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", StyleBox[SubscriptBox[\"vals\", StyleBox[\"2\", \"TR\"]], \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) fills the buffers associated with the \!\(\*SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with the corresponding values \!\(\*StyleBox[RowBox[{SubscriptBox[StyleBox[RowBox[{\"v\", StyleBox[\"als\", \"TI\"]}]], StyleBox[\"i\", \"TI\"]], \" \"}], \"TI\"]\)."
DeviceWrite::usage = "\!\(\*RowBox[{\"DeviceWrite\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) writes the value \!\(\*StyleBox[\"val\", \"TI\"]\) to the specified device.\n\!\(\*RowBox[{\"DeviceWrite\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) writes the sequence of values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to the specified device.\n\!\(\*RowBox[{\"DeviceWrite\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{StyleBox[\"param\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}]}], \"]\"}]\) writes \!\(\*StyleBox[\"val\", \"TI\"]\) as the value of the parameter \!\(\*StyleBox[\"param\", \"TI\"]\).\n\!\(\*RowBox[{\"DeviceWrite\", \"[\", RowBox[{StyleBox[\"device\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) writes values of several parameters."
DGaussianWavelet::usage = "\!\(\*RowBox[{\"DGaussianWavelet\", \"[\", \"]\"}]\) represents a derivative of Gaussian wavelet of derivative order 2.\n\!\(\*RowBox[{\"DGaussianWavelet\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a derivative of Gaussian wavelet of derivative order \!\(\*StyleBox[\"n\", \"TI\"]\)."
DiacriticalPositioning::usage = "DiacriticalPositioning is an option for UnderscriptBox and related boxes that specifies how close diacritical characters are drawn to the base character."
DiagonalizableMatrixQ::usage = "\!\(\*RowBox[{\"DiagonalizableMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is diagonalizable, and False otherwise. "
DiagonalMatrix::usage = "\!\(\*RowBox[{\"DiagonalMatrix\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a matrix with the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) on the leading diagonal, and 0 elsewhere. \n\!\(\*RowBox[{\"DiagonalMatrix\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a matrix with the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) on the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) diagonal.\n\!\(\*RowBox[{\"DiagonalMatrix\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) pads with 0s to create an \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) matrix."
Diagonal::usage = "\!\(\*RowBox[{\"Diagonal\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the list of elements on the leading diagonal of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"Diagonal\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the elements on the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) diagonal of \!\(\*StyleBox[\"m\", \"TI\"]\)."
DialogInput::usage = "\!\(\*RowBox[{\"DialogInput\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) interactively puts up \!\(\*StyleBox[\"expr\", \"TI\"]\) as a dialog notebook, waits until a \!\(\*RowBox[{\"DialogReturn\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) is evaluated from within it, and then returns the result \!\(\*StyleBox[\"e\", \"TI\"]\). \n\!\(\*RowBox[{\"DialogInput\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", RowBox[{StyleBox[\"y\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) sets up local variables \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in \!\(\*StyleBox[\"expr\", \"TI\"]\)."
DialogNotebook::usage = "\!\(\*RowBox[{\"DialogNotebook\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a dialog notebook that can be manipulated by the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) front end. "
DialogProlog::usage = "DialogProlog is an option for Dialog that can give an expression to evaluate before the dialog starts. "
DialogReturn::usage = "\!\(\*RowBox[{\"DialogReturn\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) closes a dialog window, returning the expression \!\(\*StyleBox[\"expr\", \"TI\"]\) from the dialog.\n\!\(\*RowBox[{\"DialogReturn\", \"[\", \"]\"}]\) closes a dialog window, returning Null."
DialogSymbols::usage = "DialogSymbols is an option for Dialog that gives a list of symbols whose values should be localized in the dialog. "
Dialog::usage = "\!\(\*RowBox[{\"Dialog\", \"[\", \"]\"}]\) initiates a dialog. \n\!\(\*RowBox[{\"Dialog\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) initiates a dialog with \!\(\*StyleBox[\"expr\", \"TI\"]\) as the current value of %. "
DiamondMatrix::usage = "\!\(\*RowBox[{\"DiamondMatrix\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives a matrix whose elements are 1 in a diamond-shaped region that extends \!\(\*StyleBox[\"r\", \"TI\"]\) index positions to each side, and are 0 otherwise.\n\!\(\*RowBox[{\"DiamondMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) gives a \!\(\*StyleBox[\"w\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"w\", \"TI\"]\) matrix containing a diamond-shaped region of 1s.\n\!\(\*RowBox[{\"DiamondMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields an array whose elements are 1 in a diamond-shaped region that extends \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) index positions in the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) direction."
Diamond::usage = "\!\(\*RowBox[{\"Diamond\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Diamond]\", StyleBox[\"y\", \"TI\"], \"\[Diamond]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DiceDissimilarity::usage = "\!\(\*RowBox[{\"DiceDissimilarity\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) gives the Dice dissimilarity between Boolean vectors \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\)."
DictionaryLookup::usage = "\!\(\*RowBox[{\"DictionaryLookup\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) finds all words in an English dictionary that match the string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"DictionaryLookup\", \"[\", RowBox[{StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives only the first \!\(\*StyleBox[\"n\", \"TI\"]\) words found.\n\!\(\*RowBox[{\"DictionaryLookup\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"lang\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"}\"}], \"]\"}]\) finds words in the language specified by \!\(\*StyleBox[\"lang\", \"TI\"]\)."
DifferenceDelta::usage = "\!\(\*RowBox[{\"DifferenceDelta\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives the discrete difference \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[DifferenceDelta]\", StyleBox[\"i\", \"TI\"]], StyleBox[\"f\", \"TI\"]}], \"=\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", RowBox[{StyleBox[\"i\", \"TI\"], \"+\", \"1\"}], \")\"}], \"-\", RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"i\", \"TI\"], \")\"}]}]}]\).\n\!\(\*RowBox[{\"DifferenceDelta\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multiple difference \!\(\*RowBox[{SubsuperscriptBox[\"\[DifferenceDelta]\", StyleBox[\"i\", \"TI\"], StyleBox[\"n\", \"TI\"]], StyleBox[\"f\", \"TI\"]}]\).\n\!\(\*RowBox[{\"DifferenceDelta\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multiple difference with step \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"DifferenceDelta\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) computes the partial difference with respect to \!\(\*StyleBox[\"i\", \"TI\"]\), \!\(\*StyleBox[\"j\", \"TI\"]\), \[Ellipsis]."
DifferenceRootReduce::usage = "\!\(\*RowBox[{\"DifferenceRootReduce\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) attempts to reduce \!\(\*StyleBox[\"expr\", \"TI\"]\) to a single DifferenceRoot object as a function of \!\(\*StyleBox[\"n\", \"TI\"]\)."
DifferenceRoot::usage = "\!\(\*RowBox[{RowBox[{\"DifferenceRoot\", \"[\", StyleBox[\"lde\", \"TI\"], \"]\"}], \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]\) gives the holonomic sequence \!\(\*RowBox[{StyleBox[\"h\", \"TI\"], \"(\", StyleBox[\"k\", \"TI\"], \")\"}]\), specified by the linear difference equation \!\(\*RowBox[{StyleBox[\"lde\", \"TI\"], \"[\", RowBox[{StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\).\n\!\(\*RowBox[{\"DifferenceRoot\", \"[\", StyleBox[\"lde\", \"TI\"], \"]\"}]\) represents a pure holonomic sequence \!\(\*StyleBox[\"h\", \"TI\"]\)."
Differences::usage = "\!\(\*RowBox[{\"Differences\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the successive differences of elements in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Differences\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) differences of \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Differences\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the differences of elements step \!\(\*StyleBox[\"s\", \"TI\"]\) apart.\n\!\(\*RowBox[{\"Differences\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the successive \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) differences at level \!\(\*StyleBox[\"k\", \"TI\"]\) in a nested list. "
DifferentialD::usage = "\!\(\*RowBox[{\"DifferentialD\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) displays as \!\(\*RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}]\)."
DifferentialRootReduce::usage = "\!\(\*RowBox[{\"DifferentialRootReduce\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) attempts to reduce \!\(\*StyleBox[\"expr\", \"TI\"]\) to a single DifferentialRoot object as a function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"DifferentialRootReduce\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) takes the initial conditions to be specified at \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\)."
DifferentialRoot::usage = "\!\(\*RowBox[{RowBox[{\"DifferentialRoot\", \"[\", StyleBox[\"lde\", \"TI\"], \"]\"}], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the holonomic function \!\(\*RowBox[{StyleBox[\"h\", \"TI\"], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\), specified by the linear differential equation \!\(\*RowBox[{StyleBox[\"lde\", \"TI\"], \"[\", RowBox[{StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\).\n\!\(\*RowBox[{\"DifferentialRoot\", \"[\", StyleBox[\"lde\", \"TI\"], \"]\"}]\) represents a pure holonomic function \!\(\*StyleBox[\"h\", \"TI\"]\). "
DifferentiatorFilter::usage = "\!\(\*RowBox[{\"DifferentiatorFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"]\"}]\) applies a differentiator filter with a cutoff frequency \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]\) to an array of data.\n\!\(\*RowBox[{\"DifferentiatorFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses a filter kernel of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"DifferentiatorFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to the filter kernel.\n\!\(\*RowBox[{\"DifferentiatorFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a differentiator filter to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"DifferentiatorFilter\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a differentiator filter to sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
DigitBlock::usage = "DigitBlock is an option for NumberForm and related functions that specifies the maximum length of blocks of digits between breaks. "
DigitCharacter::usage = "DigitCharacter represents a digit character 0\[Dash]9 in StringExpression. "
DigitCount::usage = "\!\(\*RowBox[{\"DigitCount\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the number of \!\(\*StyleBox[\"d\", \"TI\"]\) digits in the base-\!\(\*StyleBox[\"b\", \"TI\"]\) representation of \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"DigitCount\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives a list of the numbers of 1, 2, \[Ellipsis], \!\(\*RowBox[{StyleBox[\"b\", \"TI\"], \"-\", \"1\"}]\), 0 digits in the base-\!\(\*StyleBox[\"b\", \"TI\"]\) representation of \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"DigitCount\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a list of the numbers of 1, 2, \[Ellipsis], 9, 0 digits in the base-10 representation of \!\(\*StyleBox[\"n\", \"TI\"]\). "
DigitQ::usage = "\!\(\*RowBox[{\"DigitQ\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) yields True if all the characters in the string are digits in the range 0 through 9, and yields False otherwise. "
DihedralGroup::usage = "\!\(\*RowBox[{\"DihedralGroup\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the dihedral group of order \!\(\*StyleBox[RowBox[{\"2\", \"n\"}], \"TI\"]\)."
Dilation::usage = "\!\(\*RowBox[{\"Dilation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the morphological dilation of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to the structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"Dilation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the dilation with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"Dilation\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies dilation to an array of data."
DimensionalCombinations::usage = "\!\(\*RowBox[{\"DimensionalCombinations\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pq\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pq\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) returns the possible combinations of the list of physical quantities \!\(\*SubscriptBox[StyleBox[\"pq\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that are dimensionless.\n\!\(\*RowBox[{\"DimensionalCombinations\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pq\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pq\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dim\", \"TI\"]}], \"]\"}]\) returns the possible combinations of the list of physical quantities \!\(\*SubscriptBox[StyleBox[\"pq\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that match the dimensions of physical quantity \!\(\*StyleBox[\"dim\", \"TI\"]\)."
DimensionalMeshComponents::usage = "\!\(\*RowBox[{\"DimensionalMeshComponents\", \"[\", StyleBox[\"mr\", \"TI\"], \"]\"}]\) gives a list \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) of regions such that \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"d\", \"TI\"]]\) has dimension \!\(\*StyleBox[\"d\", \"TI\"]\) for a mesh region \!\(\*StyleBox[\"mr\", \"TI\"]\)."
DimensionReducerFunction::usage = "\!\(\*RowBox[{\"DimensionReducerFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents a function generated by DimensionReduction that projects data onto a lower-dimensional approximating manifold. "
DimensionReduce::usage = "\!\(\*RowBox[{\"DimensionReduce\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) projects the vectors \!\(\*SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) onto an approximating manifold in lower-dimensional space. \n\!\(\*RowBox[{\"DimensionReduce\", \"[\", RowBox[{StyleBox[\"vecs\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) projects onto an approximating manifold in \!\(\*StyleBox[\"n\", \"TI\"]\)-dimensional space. \n\!\(\*RowBox[{\"DimensionReduce\", \"[\", RowBox[{StyleBox[\"vecs\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) applies the projection deduced from \!\(\*StyleBox[\"vecs\", \"TI\"]\) to the list of vectors \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"DimensionReduce\", \"[\", RowBox[{StyleBox[\"vecs\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives the specified property of the reduction associated with \!\(\*StyleBox[\"data\", \"TI\"]\)."
DimensionReduction::usage = "\!\(\*RowBox[{\"DimensionReduction\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a \!\(\*RowBox[{\"DimensionReducerFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that projects to the lower-dimensional approximating manifold defined by the vectors \!\(\*SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"DimensionReduction\", \"[\", RowBox[{StyleBox[\"vecs\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates a \!\(\*RowBox[{\"DimensionReducerFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) for an \!\(\*StyleBox[\"n\", \"TI\"]\)-dimensional approximating manifold. \n\!\(\*RowBox[{\"DimensionReduction\", \"[\", RowBox[{StyleBox[\"vecs\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"props\", \"TI\"]}], \"]\"}]\) generates the specified properties of the dimensionality reduction. "
Dimensions::usage = "\!\(\*RowBox[{\"Dimensions\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives a list of the dimensions of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Dimensions\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of the dimensions of \!\(\*StyleBox[\"expr\", \"TI\"]\) down to level \!\(\*StyleBox[\"n\", \"TI\"]\). "
DiracComb::usage = "\!\(\*RowBox[{\"DiracComb\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the Dirac comb function giving a delta function at every integer point. \n\!\(\*RowBox[{\"DiracComb\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the multidimensional Dirac comb function."
DiracDelta::usage = "\!\(\*RowBox[{\"DiracDelta\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the Dirac delta function \!\(\*RowBox[{\"\[Delta]\", \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"DiracDelta\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the multidimensional Dirac delta function \!\(\*RowBox[{\"\[Delta]\", \"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"], \",\", \"\[Ellipsis]\"}], \")\"}]\). "
DirectedEdges::usage = "DirectedEdges is an option for Graph, GraphPlot, and related functions that specifies whether edges should be taken to be directed."
DirectedEdge::usage = "\!\(\*RowBox[{\"DirectedEdge\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"\[DirectedEdge]\", StyleBox[\"v\", \"TI\"]}]\) represents a directed edge from \!\(\*StyleBox[\"u\", \"TI\"]\) to \!\(\*StyleBox[\"v\", \"TI\"]\)."
DirectedGraphQ::usage = "\!\(\*RowBox[{\"DirectedGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a directed graph and False otherwise."
DirectedGraph::usage = "\!\(\*RowBox[{\"DirectedGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a directed graph from the undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"DirectedGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"conv\", \"TI\"]}], \"]\"}]\) gives a directed graph using the conversion \!\(\*StyleBox[\"conv\", \"TI\"]\).\n\!\(\*RowBox[{\"DirectedGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
DirectedInfinity::usage = "\!\(\*RowBox[{\"DirectedInfinity\", \"[\", \"]\"}]\) represents an infinite numerical quantity whose direction in the complex plane is unknown. \n\!\(\*RowBox[{\"DirectedInfinity\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) represents an infinite numerical quantity that is a positive real multiple of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
Direction::usage = "Direction is an option for Limit that specifies the direction in which the limit is taken."
Directive::usage = "\!\(\*RowBox[{\"Directive\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a single graphics directive composed of the directives \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
DirectoryName::usage = "\!\(\*RowBox[{\"DirectoryName\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) extracts the directory name from the specification for a file. "
DirectoryQ::usage = "\!\(\*RowBox[{\"DirectoryQ\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives True if the directory with the specified name exists, and gives False otherwise."
DirectoryStack::usage = "\!\(\*RowBox[{\"DirectoryStack\", \"[\", \"]\"}]\) gives the directory stack that represents the sequence of current directories used. "
Directory::usage = "\!\(\*RowBox[{\"Directory\", \"[\", \"]\"}]\) gives the current working directory. "
DirichletBeta::usage = "\!\(\*RowBox[{\"DirichletBeta\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives the Dirichlet beta function \!\(\*RowBox[{\"\[Beta]\", \"(\", StyleBox[\"s\", \"TI\"], \")\"}]\)."
DirichletCharacter::usage = "\!\(\*RowBox[{\"DirichletCharacter\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the Dirichlet character \!\(\*RowBox[{SubscriptBox[\"\[Chi]\", RowBox[{\"{\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \"}\"}]], \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\) with modulus \!\(\*StyleBox[\"k\", \"TI\"]\) and index \!\(\*StyleBox[\"j\", \"TI\"]\)."
DirichletCondition::usage = "\!\(\*RowBox[{\"DirichletCondition\", \"[\", RowBox[{StyleBox[\"beqn\", \"TI\"], \",\", StyleBox[\"pred\", \"TI\"]}], \"]\"}]\) represents a Dirichlet boundary condition given by equation \!\(\*StyleBox[\"beqn\", \"TI\"]\), satisfied on the part of the boundary of the region given to NDSolve where \!\(\*StyleBox[\"pred\", \"TI\"]\) is True."
DirichletConvolve::usage = "\!\(\*RowBox[{\"DirichletConvolve\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Dirichlet convolution of the expressions \!\(\*StyleBox[\"f\", \"TI\"]\) and \!\(\*StyleBox[\"g\", \"TI\"]\). "
DirichletDistribution::usage = "\!\(\*RowBox[{\"DirichletDistribution\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], RowBox[{StyleBox[\"k\", \"TI\"], StyleBox[\"+\", \"TR\"], StyleBox[\"1\", \"TR\"]}]], \"TR\"]}], \"}\"}], \"]\"}]\) represents a Dirichlet distribution of dimension \!\(\*StyleBox[\"k\", \"TI\"]\) with shape parameters \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\)."
DirichletEta::usage = "\!\(\*RowBox[{\"DirichletEta\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives the Dirichlet eta function \!\(\*RowBox[{\"\[Eta]\", \"(\", StyleBox[\"s\", \"TI\"], \")\"}]\)."
DirichletLambda::usage = "\!\(\*RowBox[{\"DirichletLambda\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives the Dirichlet lambda function \!\(\*RowBox[{\"\[Lambda]\", \"(\", StyleBox[\"s\", \"TI\"], \")\"}]\)."
DirichletL::usage = "\!\(\*RowBox[{\"DirichletL\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the Dirichlet L-function \!\(\*RowBox[{StyleBox[\"L\", \"TI\"], \"(\", RowBox[{\"\[Chi]\", \",\", StyleBox[\"s\", \"TI\"]}], \")\"}]\) for the Dirichlet character \!\(\*RowBox[{\"\[Chi]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\) with modulus \!\(\*StyleBox[\"k\", \"TI\"]\) and index \!\(\*StyleBox[\"j\", \"TI\"]\)."
DirichletTransform::usage = "\!\(\*RowBox[{\"DirichletTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the Dirichlet transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) with respect to \!\(\*StyleBox[\"n\", \"TI\"]\)."
DirichletWindow::usage = "\!\(\*RowBox[{\"DirichletWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Dirichlet window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
DiscreteChirpZTransform::usage = "\!\(\*RowBox[{\"DiscreteChirpZTransform\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the chirp Z transform of \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteChirpZTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns a length \!\(\*StyleBox[\"n\", \"TI\"]\) chirp Z transform.\n\!\(\*RowBox[{\"DiscreteChirpZTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) uses a spiral path on the complex \!\(\*StyleBox[\"z\", \"TI\"]\) plane defined by \!\(\*StyleBox[\"w\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteChirpZTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"a\", \"TI\"]\) as the complex starting point.\n\!\(\*RowBox[{\"DiscreteChirpZTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional chirp Z transform. "
DiscreteConvolve::usage = "\!\(\*RowBox[{\"DiscreteConvolve\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the convolution with respect to \!\(\*StyleBox[\"n\", \"TI\"]\) of the expressions \!\(\*StyleBox[\"f\", \"TI\"]\) and \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"DiscreteConvolve\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional convolution."
DiscreteDelta::usage = "\!\(\*RowBox[{\"DiscreteDelta\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the discrete delta function \!\(\*RowBox[{StyleBox[\"\[Delta]\", \"TR\"], RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \")\"}]}]\), equal to 1 if all the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are zero, and 0 otherwise. "
DiscreteHadamardTransform::usage = "\!\(\*RowBox[{\"DiscreteHadamardTransform\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the discrete Hadamard transform of \!\(\*StyleBox[\"list\", \"TI\"]\)."
DiscreteIndicator::usage = "\!\(\*RowBox[{\"DiscreteIndicator\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields the discrete indicator function, equal to 1 if \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}]\) and, otherwise, to 0 if \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\) for some \!\(\*StyleBox[\"i\", \"TI\"]\)."
DiscreteLQEstimatorGains::usage = "\!\(\*RowBox[{\"DiscreteLQEstimatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Tau]\", \"TR\"]}], \"]\"}]\) gives the optimal discrete-time estimator gain matrix with sampling period \!\(\*StyleBox[\"\[Tau]\", \"TR\"]\) for the continuous-time StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\), with process and measurement noise covariance matrices \!\(\*StyleBox[\"w\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteLQEstimatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Tau]\", \"TR\"]}], \"]\"}]\) specifies \!\(\*StyleBox[\"sensors\", \"TI\"]\) as the noisy measurements of \!\(\*StyleBox[\"ssm\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteLQEstimatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"dinputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Tau]\", \"TR\"]}], \"]\"}]\) specifies \!\(\*StyleBox[\"dinputs\", \"TI\"]\) as the deterministic inputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
DiscreteLQRegulatorGains::usage = "\!\(\*RowBox[{\"DiscreteLQRegulatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Tau]\", \"TI\"]}], \"]\"}]\) gives the optimal discrete-time state feedback gain matrix with sampling period \!\(\*StyleBox[\"\[Tau]\", \"TR\"]\) for the continuous-time StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\) and the quadratic cost function, with state and control weighting matrices \!\(\*StyleBox[\"q\", \"TI\"]\) and \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteLQRegulatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Tau]\", \"TI\"]}], \"]\"}]\) includes the state-control cross-coupling matrix \!\(\*StyleBox[\"p\", \"TI\"]\) in the cost function.\n\!\(\*RowBox[{\"DiscreteLQRegulatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"finputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", StyleBox[\"\[Tau]\", \"TI\"]}], \"]\"}]\) specifies the feedback inputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
DiscreteLyapunovSolve::usage = "\!\(\*RowBox[{\"DiscreteLyapunovSolve\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) finds the numeric solution \!\(\*StyleBox[\"x\", \"TI\"]\) of the discrete matrix equation \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", RowBox[{StyleBox[\"a\", \"TI\"], \"\[ConjugateTranspose]\"}]}], \"-\", StyleBox[\"x\", \"TI\"]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\).\n\!\(\*RowBox[{\"DiscreteLyapunovSolve\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) solves \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"]}], \"-\", StyleBox[\"x\", \"TI\"]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\).\n\!\(\*RowBox[{\"DiscreteLyapunovSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) solves \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", RowBox[{StyleBox[\"a\", \"TI\"], \"\[ConjugateTranspose]\"}]}], \"-\", RowBox[{StyleBox[\"d\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", RowBox[{StyleBox[\"d\", \"TI\"], \"\[ConjugateTranspose]\"}]}]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\).\n\!\(\*RowBox[{\"DiscreteLyapunovSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) solves \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"]}], \"-\", RowBox[{StyleBox[\"d\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"e\", \"TI\"]}]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\)."
DiscreteMarkovProcess::usage = "\!\(\*RowBox[{\"DiscreteMarkovProcess\", \"[\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) represents a discrete-time, finite-state Markov process with transition matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and initial state \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"DiscreteMarkovProcess\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) represents a Markov process with initial state probability vector \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"DiscreteMarkovProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) represents a Markov process with transition matrix from the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
DiscretePlot3D::usage = "\!\(\*RowBox[{\"DiscretePlot3D\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the values of \!\(\*StyleBox[\"expr\", \"TI\"]\) when \!\(\*StyleBox[\"i\", \"TI\"]\) runs from \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) and \!\(\*StyleBox[\"j\", \"TI\"]\) runs from \!\(\*SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"DiscretePlot3D\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dj\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"di\", \"TI\"]\) and \!\(\*StyleBox[\"dj\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscretePlot3D\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses successive \!\(\*StyleBox[\"i\", \"TI\"]\) values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] and \!\(\*StyleBox[\"j\", \"TI\"]\) values \!\(\*SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*RowBox[{StyleBox[\" \", \"TI\"], SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]\), \[Ellipsis]. \n\!\(\*RowBox[{\"DiscretePlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots the values of all the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
DiscretePlot::usage = "\!\(\*RowBox[{\"DiscretePlot\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the values of \!\(\*StyleBox[\"expr\", \"TI\"]\) when \!\(\*StyleBox[\"n\", \"TI\"]\) runs from 1 to \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"DiscretePlot\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the values of \!\(\*StyleBox[\"expr\", \"TI\"]\) when \!\(\*StyleBox[\"n\", \"TI\"]\) runs from \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"DiscretePlot\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dn\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dn\", \"TI\"]\). \n\!\(\*RowBox[{\"DiscretePlot\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses the successive values \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"DiscretePlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots the values of all the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
DiscreteRatio::usage = "\!\(\*RowBox[{\"DiscreteRatio\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives the discrete ratio \!\(\*FractionBox[RowBox[{StyleBox[\"f\", \"TI\"], \"(\", RowBox[{StyleBox[\"i\", \"TI\"], \"+\", \"1\"}], \")\"}], RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"i\", \"TI\"], \")\"}]]\).\n\!\(\*RowBox[{\"DiscreteRatio\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multiple discrete ratio.\n\!\(\*RowBox[{\"DiscreteRatio\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multiple discrete ratio with step \!\(\*StyleBox[\"h\", \"TI\"]\). \n\!\(\*RowBox[{\"DiscreteRatio\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) computes the partial difference ratio with respect to \!\(\*StyleBox[\"i\", \"TI\"]\), \!\(\*StyleBox[\"j\", \"TI\"]\), \[Ellipsis] ."
DiscreteRiccatiSolve::usage = "\!\(\*RowBox[{\"DiscreteRiccatiSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the matrix \!\(\*StyleBox[\"x\", \"TI\"]\) that is the stabilizing solution of the discrete algebraic Riccati equation \!\(\*RowBox[{RowBox[{RowBox[{SuperscriptBox[\"a\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"a\", \"TI\"]}], \"-\", StyleBox[\"x\", \"TI\"], \"-\", RowBox[{SuperscriptBox[\"a\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"], \".\", SuperscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"r\", \"TI\"], \"+\", RowBox[{TemplateBox[{\"b\"}, \"ConjugateTranspose\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"]}]}], \")\"}], RowBox[{\"-\", \"1\"}]], \".\", SuperscriptBox[\"b\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"a\", \"TI\"]}], \"+\", StyleBox[\"q\", \"TI\"]}], \"\[LongEqual]\", \"0\"}]\).\n\!\(\*RowBox[{\"DiscreteRiccatiSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"}\"}]}], \"]\"}]\) solves \!\(\*RowBox[{RowBox[{RowBox[{SuperscriptBox[\"a\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"a\", \"TI\"]}], \"-\", StyleBox[\"x\", \"TI\"], \"-\", RowBox[{RowBox[{\"(\", RowBox[{RowBox[{SuperscriptBox[\"a\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"]}], \"+\", StyleBox[\"p\", \"TI\"]}], \")\"}], \".\", SuperscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"r\", \"TI\"], \"+\", RowBox[{TemplateBox[{\"b\"}, \"ConjugateTranspose\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"]}]}], \")\"}], RowBox[{\"-\", \"1\"}]], \".\", RowBox[{\"(\", RowBox[{RowBox[{SuperscriptBox[\"b\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"a\", \"TI\"]}], \"+\", SuperscriptBox[\"p\", \"\[ConjugateTranspose]\"]}], \")\"}]}], \"+\", StyleBox[\"q\", \"TI\"]}], \"\[LongEqual]\", \"0\"}]\)."
DiscreteShift::usage = "\!\(\*RowBox[{\"DiscreteShift\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives the discrete shift \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[DiscreteShift]\", StyleBox[\"i\", \"TI\"]], RowBox[{\"(\", RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"i\", \"TI\"], \")\"}], \")\"}]}], \"\[LongEqual]\", RowBox[{StyleBox[\"f\", \"TI\"], \"(\", RowBox[{StyleBox[\"i\", \"TI\"], \"+\", \"1\"}], \")\"}]}]\). \n\!\(\*RowBox[{\"DiscreteShift\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multiple shift \!\(\*RowBox[{SubsuperscriptBox[\"\[DiscreteShift]\", StyleBox[\"i\", \"TI\"], StyleBox[\"n\", \"TI\"]], \" \", StyleBox[\"f\", \"TI\"]}]\).\n\!\(\*RowBox[{\"DiscreteShift\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multiple shift of step \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteShift\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) computes partial shifts with respect to \!\(\*StyleBox[\"i\", \"TI\"]\), \!\(\*StyleBox[\"j\", \"TI\"]\), \[Ellipsis]."
DiscreteTimeModelQ::usage = "\!\(\*RowBox[{\"DiscreteTimeModelQ\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"lsys\", \"TI\"]\) is a discrete-time systems model, and False otherwise."
DiscreteUniformDistribution::usage = "\!\(\*RowBox[{\"DiscreteUniformDistribution\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents a discrete uniform distribution over the integers from \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"DiscreteUniformDistribution\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a multivariate discrete uniform distribution over integers within the box \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
DiscreteVariables::usage = "DiscreteVariables is an option for NDSolve and other functions that specifies variables that only change at discrete times in a temporal integration."
DiscreteWaveletData::usage = "\!\(\*RowBox[{\"DiscreteWaveletData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"wind\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"coef\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"wtrans\", \"TI\"]}], \"]\"}]\) yields a discrete wavelet data object with wavelet coefficients \!\(\*SubscriptBox[StyleBox[\"coef\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to wavelet index \!\(\*SubscriptBox[StyleBox[\"wind\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\), and wavelet transform \!\(\*StyleBox[\"wtrans\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteWaveletData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"wind\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"coef\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"wtrans\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields a discrete wavelet data object assuming data dimensions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
DiscreteWaveletPacketTransform::usage = "\!\(\*RowBox[{\"DiscreteWaveletPacketTransform\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) gives the discrete wavelet packet transform (DWPT) of an array of \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteWaveletPacketTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"]}], \"]\"}]\) gives the discrete wavelet packet transform using the wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteWaveletPacketTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the discrete wavelet packet transform using \!\(\*StyleBox[\"r\", \"TI\"]\) levels of refinement.\n\!\(\*RowBox[{\"DiscreteWaveletPacketTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the discrete wavelet packet transform of an image.\n\!\(\*RowBox[{\"DiscreteWaveletPacketTransform\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the discrete wavelet packet transform of sampled sound."
DiscreteWaveletTransform::usage = "\!\(\*RowBox[{\"DiscreteWaveletTransform\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) gives the discrete wavelet transform (DWT) of an array of \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteWaveletTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"]}], \"]\"}]\) gives the discrete wavelet transform using the wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\).\n\!\(\*RowBox[{\"DiscreteWaveletTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the discrete wavelet transform using \!\(\*StyleBox[\"r\", \"TI\"]\) levels of refinement.\n\!\(\*RowBox[{\"DiscreteWaveletTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the discrete wavelet transform of an image.\n\!\(\*RowBox[{\"DiscreteWaveletTransform\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the discrete wavelet transform of sampled sound."
DiscretizeGraphics::usage = "\!\(\*RowBox[{\"DiscretizeGraphics\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) discretizes a 2D or 3D graphic \!\(\*StyleBox[\"g\", \"TI\"]\) into a MeshRegion.\n\!\(\*RowBox[{\"DiscretizeGraphics\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) discretizes only the elements in \!\(\*StyleBox[\"g\", \"TI\"]\) that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\)."
DiscretizeRegion::usage = "\!\(\*RowBox[{\"DiscretizeRegion\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) discretizes a region \!\(\*StyleBox[\"reg\", \"TI\"]\) into a MeshRegion.\n\!\(\*RowBox[{\"DiscretizeRegion\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) restricts to the bounds \!\(\*RowBox[{RowBox[{\"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]}], \"]\"}], \"\[Times]\", \"\[CenterEllipsis]\"}]\)."
Discriminant::usage = "\!\(\*RowBox[{\"Discriminant\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) computes the discriminant of the polynomial \!\(\*StyleBox[\"poly\", \"TI\"]\) with respect to the variable \!\(\*StyleBox[\"var\", \"TI\"]\).\n\!\(\*RowBox[{\"Discriminant\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) computes the discriminant modulo \!\(\*StyleBox[\"p\", \"TI\"]\)."
DisjointQ::usage = "\!\(\*RowBox[{\"DisjointQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) do not share any common elements, and False otherwise."
Disjunction::usage = "\!\(\*RowBox[{\"Disjunction\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the disjunction of \!\(\*StyleBox[\"expr\", \"TI\"]\) over all choices of the Boolean variables \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
DiskMatrix::usage = "\!\(\*RowBox[{\"DiskMatrix\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives a matrix whose elements are 1 in a disk-shaped region of radius \!\(\*StyleBox[\"r\", \"TI\"]\), and are otherwise 0.\n\!\(\*RowBox[{\"DiskMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) gives a \!\(\*StyleBox[\"w\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"w\", \"TI\"]\) matrix containing a disk of 1s with radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"DiskMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields an array whose elements are 1 in an ellipsoidal region with semiaxis \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) index direction."
DiskSegment::usage = "\!\(\*RowBox[{\"DiskSegment\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents the disk segment from angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\) in a disk centered at \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) of radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"DiskSegment\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents the ellipse segment from angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\) in an axis-aligned ellipse with semiaxes lengths \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"x\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"y\", \"TI\"]]\)."
Disk::usage = "\!\(\*RowBox[{\"Disk\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a disk of radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"Disk\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"]\"}]\) gives a disk of radius 1. \n\!\(\*RowBox[{\"Disk\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives an axis-aligned elliptical disk with semiaxes lengths \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"x\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"y\", \"TI\"]]\).\n\!\(\*RowBox[{\"Disk\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives a sector of a disk from angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
Dispatch::usage = "\!\(\*RowBox[{\"Dispatch\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lhs\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"rhs\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lhs\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"rhs\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates an optimized dispatch table representation of a list of rules. The object produced by Dispatch can be used to give the rules in \!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"/.\", StyleBox[\"rules\", \"TI\"]}]\). "
DispersionEstimatorFunction::usage = "DispersionEstimatorFunction is an option for generalized linear model fitting functions that specifies the estimator for the dispersion parameter."
DisplayAllSteps::usage = "DisplayAllSteps is an option to Animate and related functions that specifies whether all frames should be displayed in an animation, even if to do so would slow the animation down."
DisplayEndPacket::usage = "\!\(\*RowBox[{\"DisplayEndPacket\", \"[\", \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that indicates the end of a series of expressions relating to a postscript graphic."
DisplayForm::usage = "\!\(\*RowBox[{\"DisplayForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints with low-level boxes inside \!\(\*StyleBox[\"expr\", \"TI\"]\) shown in explicit two-dimensional or other form. "
DisplayFunction::usage = "DisplayFunction is an option for graphics and sound functions that specifies a function to apply to graphics and sound objects before returning them."
DisplayPacket::usage = "\!\(\*RowBox[{\"DisplayPacket\", \"[\", \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that indicates the beginning of a series of expressions related to a PostScript graphic."
DisplayString::usage = "\!\(\*RowBox[{\"DisplayString\", \"[\", StyleBox[\"graphics\", \"TI\"], \"]\"}]\) generates a string giving graphics or sound in PostScript format. \n\!\(\*RowBox[{\"DisplayString\", \"[\", RowBox[{StyleBox[\"graphics\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) generates a string giving graphics or sound in the specified format. \n\!\(\*RowBox[{\"DisplayString\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) generates a string giving boxes, cells, or notebook expressions in the specified format. "
Display::usage = "\!\(\*RowBox[{\"Display\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", StyleBox[\"graphics\", \"TI\"]}], \"]\"}]\) writes graphics or sound to the specified output channel in PostScript format. \n\!\(\*RowBox[{\"Display\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", StyleBox[\"graphics\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes graphics or sound in the specified format. \n\!\(\*RowBox[{\"Display\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes boxes, cells, or notebook expressions in the specified format. "
DistanceFunction::usage = "DistanceFunction is an option for functions such as Nearest that specifies the distance value to assume between any two specified points."
DistanceMatrix::usage = "\!\(\*RowBox[{\"DistanceMatrix\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the matrix of distances between each pair of elements \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"j\", \"TI\"]]\). \n\!\(\*RowBox[{\"DistanceMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the matrix of distances between each pair of elements \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"j\", \"TI\"]]\)."
DistanceTransform::usage = "\!\(\*RowBox[{\"DistanceTransform\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the distance transform of \!\(\*StyleBox[\"image\", \"TI\"]\), in which the value of each pixel is replaced by its distance to the nearest background pixel.\n\!\(\*RowBox[{\"DistanceTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) treats values above \!\(\*StyleBox[\"t\", \"TI\"]\) as foreground."
DistributedContexts::usage = "DistributedContexts is an option for various parallel computing functions that specifies which definitions for symbols appearing in an expression should be distributed to all parallel kernels."
DistributeDefinitions::usage = "\!\(\*RowBox[{\"DistributeDefinitions\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) distributes all definitions for the symbols \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to all parallel kernels.\n\!\(\*RowBox[{\"DistributeDefinitions\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context`\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) distributes definitions for all symbols in the specified context."
Distributed::usage = "\!\(\*RowBox[{\"Distributed\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]\) asserts that the random variable \!\(\*StyleBox[\"x\", \"TI\"]\) is distributed according to the probability distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"Distributed\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]\) asserts that the random vector \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) is distributed according to the multivariate probability distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
Distribute::usage = "\!\(\*RowBox[{\"Distribute\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \"]\"}]\) distributes \!\(\*StyleBox[\"f\", \"TI\"]\) over Plus appearing in any of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Distribute\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) distributes over \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"Distribute\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) performs the distribution only if the head of \!\(\*StyleBox[\"expr\", \"TI\"]\) is \!\(\*StyleBox[\"f\", \"TI\"]\). "
DistributionChart::usage = "\!\(\*RowBox[{\"DistributionChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a distribution chart with a distribution symbol for each \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"DistributionChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a distribution chart with symbol features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"DistributionChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a distribution chart from multiple groups of datasets \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
DistributionFitTest::usage = "\!\(\*RowBox[{\"DistributionFitTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed. \n\!\(\*RowBox[{\"DistributionFitTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is distributed according to \!\(\*StyleBox[\"dist\", \"TI\"]\). \n\!\(\*RowBox[{\"DistributionFitTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
DistributionParameterAssumptions::usage = "\!\(\*RowBox[{\"DistributionParameterAssumptions\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives a logical expression for assumptions on parameters in the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
DistributionParameterQ::usage = "\!\(\*RowBox[{\"DistributionParameterQ\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"dist\", \"TI\"]\) is a valid distribution, and yields False otherwise."
Dithering::usage = "Dithering is an option for ColorQuantize that specifies whether or not to apply dithering while quantizing the pixel values."
DivideBy::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"/=\", StyleBox[\"c\", \"TI\"]}]\) divides \!\(\*StyleBox[\"x\", \"TI\"]\) by \!\(\*StyleBox[\"c\", \"TI\"]\) and returns the new value of \!\(\*StyleBox[\"x\", \"TI\"]\). "
Dividers::usage = "Dividers is an option for Grid and related constructs that specifies where and how to draw divider lines."
Divide::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"/\", StyleBox[\"y\", \"TI\"]}]\) or \!\(\*RowBox[{\"Divide\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is equivalent to \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \" \", RowBox[{StyleBox[\"y\", \"TI\"], \"^\", RowBox[{\"-\", \"1\"}]}]}]\). "
Divisible::usage = "\!\(\*RowBox[{\"Divisible\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) yields True if \!\(\*StyleBox[\"n\", \"TI\"]\) is divisible by \!\(\*StyleBox[\"m\", \"TI\"]\), and yields False if it is not. "
DivisorSigma::usage = "\!\(\*RowBox[{\"DivisorSigma\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the divisor function \!\(\*RowBox[{SubscriptBox[\"\[Sigma]\", StyleBox[\"k\", \"TI\"]], \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\). "
DivisorSum::usage = "\!\(\*RowBox[{\"DivisorSum\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) represents the sum of \!\(\*RowBox[{StyleBox[\"form\", \"TI\"], \"[\", StyleBox[\"i\", \"TI\"], \"]\"}]\) for all \!\(\*StyleBox[\"i\", \"TI\"]\) that divide \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"DivisorSum\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"cond\", \"TI\"]}], \"]\"}]\) includes only those divisors for which \!\(\*RowBox[{StyleBox[\"cond\", \"TI\"], \"[\", StyleBox[\"i\", \"TI\"], \"]\"}]\) gives True."
Divisors::usage = "\!\(\*RowBox[{\"Divisors\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a list of the integers that divide \!\(\*StyleBox[\"n\", \"TI\"]\). "
Div::usage = "\!\(\*RowBox[{\"Div\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the divergence \!\(\*RowBox[{RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"+\", RowBox[{RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]}]}]\).\n\!\(\*RowBox[{\"Div\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) gives the divergence in the coordinates \!\(\*StyleBox[\"chart\", \"TI\"]\)."
DMSList::usage = "\!\(\*RowBox[{\"DMSList\", \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}]\) converts an angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) given in decimal degrees to a DMS list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"degree\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"DMSList\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dms\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) converts a DMS string to a DMS list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"degree\", \"TI\"], \",\", StyleBox[\"minute\", \"TI\"], \",\", StyleBox[\"second\", \"TI\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"DMSList\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"latlong\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) converts a latitude-longitude string to a pair of DMS lists."
DMSString::usage = "\!\(\*RowBox[{\"DMSString\", \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}]\) converts an angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) given in decimal degrees to a degrees-minutes-seconds string.\n\!\(\*RowBox[{\"DMSString\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"}\"}], \"]\"}]\) converts latitude and longitude given in decimal degrees to a DMS latitude-longitude string.\n\!\(\*RowBox[{\"DMSString\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) converts a DMS list to a DMS string."
DockedCells::usage = "DockedCells is an option for notebooks that gives a list of cells that are to be displayed \"docked\" at the top of the notebook."
DocumentGeneratorInformation::usage = "\!\(\*RowBox[{\"DocumentGeneratorInformation\", \"[\", StyleBox[\"cloudobj\", \"TI\"], \"]\"}]\) returns the properties of the DocumentGenerator \!\(\*StyleBox[\"cloudobj\", \"TI\"]\).\n\!\(\*RowBox[{\"DocumentGeneratorInformation\", \"[\", RowBox[{StyleBox[\"cloudobj\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) returns the value of the property \!\(\*StyleBox[\"property\", \"TI\"]\)."
DocumentGenerators::usage = "\!\(\*RowBox[{\"DocumentGenerators\", \"[\", \"]\"}]\) returns a list of CloudObject expressions that represent currently deployed document generators."
DocumentGenerator::usage = "\!\(\*RowBox[{\"DocumentGenerator\", \"[\", RowBox[{StyleBox[\"template\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"]}], \"]\"}]\) represents a document generator with template \!\(\*StyleBox[\"template\", \"TI\"]\) to be evaluated on the schedule defined by \!\(\*StyleBox[\"timespec\", \"TI\"]\).\n\!\(\*RowBox[{\"DocumentGenerator\", \"[\", RowBox[{StyleBox[\"template\", \"TI\"], \",\", StyleBox[\"driver\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"]}], \"]\"}]\) takes parameters for filling the template from \!\(\*StyleBox[\"driver\", \"TI\"]\)."
DocumentNotebook::usage = "\!\(\*RowBox[{\"DocumentNotebook\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a complete document notebook in the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) front end. "
DominantColors::usage = "\!\(\*RowBox[{\"DominantColors\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) returns dominant colors in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"DominantColors\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns at most \!\(\*StyleBox[\"n\", \"TI\"]\) dominant colors in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"DominantColors\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) returns the specified property \!\(\*StyleBox[\"prop\", \"TI\"]\) for the regions that belong to the same dominant color."
DOSTextFormat::usage = "DOSTextFormat is an option for OpenRead, OpenWrite, and OpenAppend that specifies whether files should be opened in text mode. With \!\(\*RowBox[{\"DOSTextFormat\", \" \", \"->\", \" \", \"True\"}]\), \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) uses the normal text format for the type of computer on which \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) is running. Text mode typically entails translation of a text file's line-ending characters into the newline character \"\\n\". With \!\(\*RowBox[{\"DOSTextFormat\", \" \", \"->\", \" \", \"False\"}]\), files are opened in \"binary mode\", in which no such translation is performed. On some systems, there is no difference between text mode and binary mode."
DotDashed::usage = "DotDashed is a graphics directive specifying that lines that follow should be drawn dot-dashed."
DotEqual::usage = "\!\(\*RowBox[{\"DotEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DotEqual]\", StyleBox[\"y\", \"TI\"], \"\[DotEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Dotted::usage = "Dotted is a graphics directive specifying that lines that follow should be drawn dotted."
Dot::usage = "\!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"], \".\", StyleBox[\"c\", \"TI\"]}]\) or \!\(\*RowBox[{\"Dot\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) gives products of vectors, matrices, and tensors. "
DoubleBracketingBar::usage = "\!\(\*RowBox[{\"DoubleBracketingBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{\"\[LeftDoubleBracketingBar]\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", \"\[Ellipsis]\"}], \"\[RightDoubleBracketingBar]\"}]\)."
DoubleDownArrow::usage = "\!\(\*RowBox[{\"DoubleDownArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleDownArrow]\", StyleBox[\"y\[Ellipsis]\", \"TI\"]}]\)."
DoubleLeftArrow::usage = "\!\(\*RowBox[{\"DoubleLeftArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleLeftArrow]\", StyleBox[\"y\", \"TI\"], \"\[DoubleLeftArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoubleLeftRightArrow::usage = "\!\(\*RowBox[{\"DoubleLeftRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleLeftRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[DoubleLeftRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoubleLeftTee::usage = "\!\(\*RowBox[{\"DoubleLeftTee\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleLeftTee]\", StyleBox[\"y\", \"TI\"]}]\)."
DoubleLongLeftArrow::usage = "\!\(\*RowBox[{\"DoubleLongLeftArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleLongLeftArrow]\", StyleBox[\"y\", \"TI\"], \"\[DoubleLongLeftArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoubleLongLeftRightArrow::usage = "\!\(\*RowBox[{\"DoubleLongLeftRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleLongLeftRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[DoubleLongLeftRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoubleLongRightArrow::usage = "\!\(\*RowBox[{\"DoubleLongRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleLongRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[DoubleLongRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoubleRightArrow::usage = "\!\(\*RowBox[{\"DoubleRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[DoubleRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoubleRightTee::usage = "\!\(\*RowBox[{\"DoubleRightTee\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleRightTee]\", StyleBox[\"y\", \"TI\"]}]\)."
DoubleUpArrow::usage = "\!\(\*RowBox[{\"DoubleUpArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleUpArrow]\", StyleBox[\"y\", \"TI\"], \"\[DoubleUpArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoubleUpDownArrow::usage = "\!\(\*RowBox[{\"DoubleUpDownArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleUpDownArrow]\", StyleBox[\"y\", \"TI\"], \"\[DoubleUpDownArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoubleVerticalBar::usage = "\!\(\*RowBox[{\"DoubleVerticalBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DoubleVerticalBar]\", StyleBox[\"y\", \"TI\"], \"\[DoubleVerticalBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DoublyInfinite::usage = "DoublyInfinite is an option for LerchPhi. With \!\(\*RowBox[{\"DoublyInfinite\", \" \", \"->\", \" \", \"True\"}]\), the summation is taken from -Infinity to Infinity. With \!\(\*RowBox[{\"DoublyInfinite\", \" \", \"->\", \" \", \"False\"}]\), the summation is taken from zero to Infinity."
Do::usage = "\!\(\*RowBox[{\"Do\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) \!\(\*StyleBox[\"n\", \"TI\"]\) times. \n\!\(\*RowBox[{\"Do\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) with the variable \!\(\*StyleBox[\"i\", \"TI\"]\) successively taking on the values 1 through \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) (in steps of 1). \n\!\(\*RowBox[{\"Do\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) starts with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"Do\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"di\", \"TI\"]\). \n\!\(\*RowBox[{\"Do\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses the successive values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"Do\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) looping over different values of \!\(\*StyleBox[\"j\", \"TI\"]\) etc. for each \!\(\*StyleBox[\"i\", \"TI\"]\). "
DownArrowBar::usage = "\!\(\*RowBox[{\"DownArrowBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownArrowBar]\", StyleBox[\"y\", \"TI\"], \"\[DownArrowBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownArrowUpArrow::usage = "\!\(\*RowBox[{\"DownArrowUpArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownArrowUpArrow]\", StyleBox[\"y\", \"TI\"], \"\[DownArrowUpArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownArrow::usage = "\!\(\*RowBox[{\"DownArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownArrow]\", StyleBox[\"y\", \"TI\"], \"\[DownArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownLeftRightVector::usage = "\!\(\*RowBox[{\"DownLeftRightVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownLeftRightVector]\", StyleBox[\"y\", \"TI\"], \"\[DownLeftRightVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownLeftTeeVector::usage = "\!\(\*RowBox[{\"DownLeftTeeVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownLeftTeeVector]\", StyleBox[\"y\", \"TI\"], \"\[DownLeftTeeVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownLeftVectorBar::usage = "\!\(\*RowBox[{\"DownLeftVectorBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownLeftVectorBar]\", StyleBox[\"y\", \"TI\"], \"\[DownLeftVectorBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownLeftVector::usage = "\!\(\*RowBox[{\"DownLeftVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownLeftVector]\", StyleBox[\"y\", \"TI\"], \"\[DownLeftVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownRightTeeVector::usage = "\!\(\*RowBox[{\"DownRightTeeVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownRightTeeVector]\", StyleBox[\"y\", \"TI\"], \"\[DownRightTeeVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownRightVectorBar::usage = "\!\(\*RowBox[{\"DownRightVectorBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownRightVectorBar]\", StyleBox[\"y\", \"TI\"], \"\[DownRightVectorBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownRightVector::usage = "\!\(\*RowBox[{\"DownRightVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownRightVector]\", StyleBox[\"y\", \"TI\"], \"\[DownRightVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Downsample::usage = "\!\(\*RowBox[{\"Downsample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns a downsampled version of the array by sampling every \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) element.\n\!\(\*RowBox[{\"Downsample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"offset\", \"TI\"]}], \"]\"}]\) starts sampling from the element at position \!\(\*StyleBox[\"offset\", \"TI\"]\)."
DownTeeArrow::usage = "\!\(\*RowBox[{\"DownTeeArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownTeeArrow]\", StyleBox[\"y\", \"TI\"], \"\[DownTeeArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
DownTee::usage = "\!\(\*RowBox[{\"DownTee\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[DownTee]\", StyleBox[\"y\", \"TI\"]}]\)."
DownValues::usage = "\!\(\*RowBox[{\"DownValues\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives a list of transformation rules corresponding to all downvalues defined for the symbol \!\(\*StyleBox[\"f\", \"TI\"]\). "
DragAndDrop::usage = "DragAndDrop is a global front end option that specifies whether to allow drag\[Hyphen]and\[Hyphen]drop editing. "
Drop::usage = "\!\(\*RowBox[{\"Drop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"list\", \"TI\"]\) with its first \!\(\*StyleBox[\"n\", \"TI\"]\) elements dropped. \n\!\(\*RowBox[{\"Drop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) gives \!\(\*StyleBox[\"list\", \"TI\"]\) with its last \!\(\*StyleBox[\"n\", \"TI\"]\) elements dropped. \n\!\(\*RowBox[{\"Drop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) gives \!\(\*StyleBox[\"list\", \"TI\"]\) with its \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) element dropped. \n\!\(\*RowBox[{\"Drop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*StyleBox[\"list\", \"TI\"]\) with elements \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) dropped. \n\!\(\*RowBox[{\"Drop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*StyleBox[\"list\", \"TI\"]\) with elements \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) in steps of \!\(\*StyleBox[\"s\", \"TI\"]\) dropped. \n\!\(\*RowBox[{\"Drop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", SubscriptBox[StyleBox[\"seq\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"seq\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a nested list in which elements specified by \!\(\*SubscriptBox[StyleBox[\"seq\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) have been dropped at level \!\(\*StyleBox[\"i\", \"TI\"]\) in \!\(\*StyleBox[\"list\", \"TI\"]\). "
DSolve::usage = "\!\(\*RowBox[{\"DSolve\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) solves a differential equation for the function \!\(\*StyleBox[\"u\", \"TI\"]\), with independent variable\[NonBreakingSpace]\!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"DSolve\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) solves a differential equation for \!\(\*StyleBox[\"x\", \"TI\"]\) between \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"DSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) solves a list of differential equations. \n\!\(\*RowBox[{\"DSolve\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) solves a partial differential equation. \n\!\(\*RowBox[{\"DSolve\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}]}], \"]\"}]\) solves the partial differential equation \!\(\*StyleBox[\"eqn\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\)."
DSolveValue::usage = "\!\(\*RowBox[{\"DSolveValue\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the value of \!\(\*StyleBox[\"expr\", \"TI\"]\) determined by a symbolic solution to the ordinary differential equation \!\(\*StyleBox[\"eqn\", \"TI\"]\) with independent variable \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"DSolveValue\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) uses a symbolic solution for \!\(\*StyleBox[\"x\", \"TI\"]\) between \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"DSolveValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) uses a solution for the partial differential equation \!\(\*StyleBox[\"eqn\", \"TI\"]\). \n\!\(\*RowBox[{\"DSolveValue\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses a symbolic solution for a list of differential equations.\n\!\(\*RowBox[{\"DSolveValue\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}]}], \"]\"}]\) uses a solution of the partial differential equation \!\(\*StyleBox[\"eqn\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\)."
Dt::usage = "\!\(\*RowBox[{\"Dt\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the total derivative \!\(\*RowBox[{StyleBox[\"d\", \"TI\"], StyleBox[\"f\", \"TI\"], \"/\", StyleBox[\"d\", \"TI\"], StyleBox[\"x\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Dt\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives the total differential \!\(\*StyleBox[RowBox[{\"d\", \"f\"}], \"TI\"]\). \n\!\(\*RowBox[{\"Dt\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multiple derivative \!\(\*RowBox[{SuperscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"n\", \"TI\"]], StyleBox[\"f\", \"TI\"], \"/\", StyleBox[\"d\", \"TI\"], SuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"Dt\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives \!\(\*RowBox[{StyleBox[\"d\", \"TI\"], \"/\", RowBox[{StyleBox[\"d\", \"TI\"], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \" \", RowBox[{StyleBox[\"d\", \"TI\"], \"/\", StyleBox[\"d\", \"TI\"]}], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \" \", \"\[Ellipsis]\", \" \", StyleBox[\"f\", \"TI\"]}]}]\). "
DualSystemsModel::usage = "\!\(\*RowBox[{\"DualSystemsModel\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) gives the dual of the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\). "
DumpGet::usage = "\!\(\*RowBox[{\"DumpGet\", \"[\", \" \", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) reads in a file saved with DumpSave."
DumpSave::usage = "\!\(\*RowBox[{\"DumpSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).mx\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"symbol\", \"TI\"]}], \"]\"}]\) writes definitions associated with a symbol to a file in internal \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) format. \n\!\(\*RowBox[{\"DumpSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).mx\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes out definitions associated with all symbols in the specified context. \n\!\(\*RowBox[{\"DumpSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).mx\\\"\",ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) writes out definitions for several symbols or contexts. \n\!\(\*RowBox[{\"DumpSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"package\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"objects\", \"TI\"]}], \"]\"}]\) chooses the name of the output file based on the computer system used. "
DuplicateFreeQ::usage = "\!\(\*RowBox[{\"DuplicateFreeQ\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"list\", \"TI\"]\) has no duplicates, and False otherwise.\n\!\(\*RowBox[{\"DuplicateFreeQ\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"test\", \"TI\"]\) to pairs of elements to determine whether they should be considered duplicates."
D::usage = "\!\(\*RowBox[{\"D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the partial derivative \!\(\*RowBox[{\"\[PartialD]\", StyleBox[\"f\", \"TI\"], \"/\", \"\[PartialD]\", StyleBox[\"x\", \"TI\"]}]\). \n\!\(\*RowBox[{\"D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multiple derivative \!\(\*RowBox[{SuperscriptBox[\"\[PartialD]\", StyleBox[\"n\", \"TI\"]], StyleBox[\"f\", \"TI\"], \"/\", \"\[PartialD]\", SuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) differentiates \!\(\*StyleBox[\"f\", \"TI\"]\) successively with respect to \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\).\n\!\(\*RowBox[{\"D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) for a scalar \!\(\*StyleBox[\"f\", \"TI\"]\) gives the vector derivative \!\(\*RowBox[{\"(\", RowBox[{RowBox[{\"\[PartialD]\", RowBox[{StyleBox[\"f\", \"TI\"], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}]}]}], \",\", RowBox[{\"\[PartialD]\", RowBox[{StyleBox[\"f\", \"TI\"], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"]}]}]}], \",\", \"\[Ellipsis]\"}], \")\"}]\). \n\!\(\*RowBox[{\"D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"array\", \"TI\"], \"}\"}]}], \"]\"}]\) gives a tensor derivative."
DynamicBoxOptions::usage = "\!\(\*RowBox[{DynamicBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for DynamicBox objects."
DynamicEvaluationTimeout::usage = "DynamicEvaluationTimeout is an option for displayed objects, cells, and notebooks that specifies the timeout in seconds for any Dynamic computations they contain."
DynamicModuleBoxOptions::usage = "\!\(\*RowBox[{DynamicModuleBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for DynamicModuleBox objects."
DynamicModule::usage = "\!\(\*RowBox[{\"DynamicModule\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) represents an object which maintains the same local instance of the symbols \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis] in the course of all evaluations of Dynamic objects in \!\(\*StyleBox[\"expr\", \"TI\"]\). Symbols specified in a DynamicModule will by default have their values maintained even across \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) sessions. \n\!\(\*RowBox[{\"DynamicModule\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", RowBox[{StyleBox[\"y\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) specifies initial values for \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis]. "
DynamicModuleValues::usage = "DynamicModuleValues is an option for DynamicModule that stores downvalues of local symbols."
DynamicSetting::usage = "\!\(\*RowBox[{\"DynamicSetting\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) represents an object which displays as \!\(\*StyleBox[\"e\", \"TI\"]\), but is interpreted as the dynamically updated current value of \!\(\*RowBox[{\"Setting\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) if supplied as \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) input.\n\!\(\*RowBox[{\"DynamicSetting\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) displays as \!\(\*StyleBox[\"e\", \"TI\"]\), but is interpreted as \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) if supplied as input."
Dynamic::usage = "\!\(\*RowBox[{\"Dynamic\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents an object that displays as the dynamically updated current value of \!\(\*StyleBox[\"expr\", \"TI\"]\). If the displayed form of \!\(\*RowBox[{\"Dynamic\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) is interactively changed or edited, an assignment \!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"=\", StyleBox[\"val\", \"TI\"]}]\) is done to give \!\(\*StyleBox[\"expr\", \"TI\"]\) the new value \!\(\*StyleBox[\"val\", \"TI\"]\) that corresponds to the displayed form. \n\!\(\*RowBox[{\"Dynamic\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"None\"}], \"]\"}]\) does not allow interactive changing or editing. \n\!\(\*RowBox[{\"Dynamic\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) continually evaluates \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) during interactive changing or editing of \!\(\*StyleBox[\"val\", \"TI\"]\). \n\!\(\*RowBox[{\"Dynamic\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"end\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) also evaluates \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"end\", \"TI\"]], \"[\", RowBox[{StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) when interactive changing or editing is complete. \n\!\(\*RowBox[{\"Dynamic\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"start\", \"TI\"]], \",\", StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"end\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) also evaluates \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"start\", \"TI\"]], \"[\", RowBox[{StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) when interactive changing or editing begins. "
DynamicWrapperBoxOptions::usage = "\!\(\*RowBox[{DynamicWrapperBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for DynamicWrapperBox objects."
DynamicWrapper::usage = "\!\(\*RowBox[{\"DynamicWrapper\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) represents an object that displays as \!\(\*StyleBox[\"e\", \"TI\"]\), but dynamically updates the expression \!\(\*StyleBox[\"expr\", \"TI\"]\) whenever that object is visible on screen."
EarthImpactData::usage = "\!\(\*RowBox[{\"EarthImpactData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the earth impact crater \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"EarthImpactData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified earth impact crater names.\n\!\(\*RowBox[{\"EarthImpactData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
EarthquakeData::usage = "\!\(\*RowBox[{\"EarthquakeData\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) gives all earthquake properties for the location corresponding to \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"EarthquakeData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"mag\", \"TI\"]}], \"]\"}]\) restricts earthquakes returned to the magnitude range \!\(\*StyleBox[\"mag\", \"TI\"]\). \n\!\(\*RowBox[{\"EarthquakeData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"mag\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives earthquake data within the magnitude range \!\(\*StyleBox[\"mag\", \"TI\"]\) during the time interval \!\(\*StyleBox[\"start\", \"TI\"]\) to \!\(\*StyleBox[\"end\", \"TI\"]\).\n\!\(\*RowBox[{\"EarthquakeData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"mag\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a time series for the specific earthquake \!\(\*StyleBox[\"property\", \"TI\"]\) for earthquakes within the magnitude range \!\(\*StyleBox[\"mag\", \"TI\"]\) during the time interval \!\(\*StyleBox[\"start\", \"TI\"]\) to \!\(\*StyleBox[\"end\", \"TI\"]\).\n\!\(\*RowBox[{\"EarthquakeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) returns data for a specific earthquake. "
EccentricityCentrality::usage = "\!\(\*RowBox[{\"EccentricityCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of eccentricity centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EccentricityCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Echo::usage = "\!\(\*RowBox[{\"Echo\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints \!\(\*StyleBox[\"expr\", \"TI\"]\) and returns \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"Echo\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"label\", \"TI\"]}], \"]\"}]\) prints \!\(\*StyleBox[\"expr\", \"TI\"]\) prepending \!\(\*StyleBox[\"label\", \"TI\"]\) and returns \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"Echo\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"label\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) prints \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prepending \!\(\*StyleBox[\"label\", \"TI\"]\) and returns \!\(\*StyleBox[\"expr\", \"TI\"]\)."
EclipseType::usage = "EclipseType is an option for SolarEclipse and LunarEclipse that specifies the type of eclipse being queried for."
EdgeAdd::usage = "\!\(\*RowBox[{\"EdgeAdd\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) makes a graph by adding the edge \!\(\*StyleBox[\"e\", \"TI\"]\) to the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeAdd\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) adds a collection of edges to \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeAdd\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeBetweennessCentrality::usage = "\!\(\*RowBox[{\"EdgeBetweennessCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of betweenness centralities for the edges in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeBetweennessCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeCapacity::usage = "EdgeCapacity is an option and property for Graph and related functions that specifies an edge capacity."
EdgeConnectivity::usage = "\!\(\*RowBox[{\"EdgeConnectivity\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the edge connectivity of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeConnectivity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"s\", \"TI\"]\)-\!\(\*StyleBox[\"t\", \"TI\"]\) edge connectivity of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeConnectivity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeContract::usage = "\!\(\*RowBox[{\"EdgeContract\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) contracts the edge \!\(\*StyleBox[\"e\", \"TI\"]\) of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeContract\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) contracts a collection of edges \!\(\*RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\).\n\!\(\*RowBox[{\"EdgeContract\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeCost::usage = "EdgeCost is an option and property for Graph and related functions that specifies an edge cost."
EdgeCount::usage = "\!\(\*RowBox[{\"EdgeCount\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a count of the number of edges in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeCount\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a count of the number of edges that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeCount\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeCoverQ::usage = "\!\(\*RowBox[{\"EdgeCoverQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"elist\", \"TI\"]}], \"]\"}]\) yields True if the edge list \!\(\*StyleBox[\"elist\", \"TI\"]\) is an edge cover of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) and False otherwise."
EdgeCycleMatrix::usage = "\!\(\*RowBox[{\"EdgeCycleMatrix\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the edge cycle matrix of a graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeCycleMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeDelete::usage = "\!\(\*RowBox[{\"EdgeDelete\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) makes a graph by deleting the edge \!\(\*StyleBox[\"e\", \"TI\"]\) from the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeDelete\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) deletes a collection of edges from \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeDelete\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) deletes all edges that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeDelete\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeDetect::usage = "\!\(\*RowBox[{\"EdgeDetect\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds edges in \!\(\*StyleBox[\"image\", \"TI\"]\) and returns the result as a binary image.\n\!\(\*RowBox[{\"EdgeDetect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) finds edges at the scale of the specified pixel range \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeDetect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) uses a threshold \!\(\*StyleBox[\"t\", \"TI\"]\) for selecting image edges."
EdgeForm::usage = "\!\(\*RowBox[{\"EdgeForm\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that edges of polygons and other filled graphics objects are to be drawn using the graphics directive or list of directives \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeIndex::usage = "\!\(\*RowBox[{\"EdgeIndex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) gives the integer index for the edge \!\(\*StyleBox[\"e\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeIndex\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeLabeling::usage = "EdgeLabeling is an option for GraphPlot and related functions that specifies whether labeling specified for edges should be displayed by default."
EdgeLabelStyle::usage = "EdgeLabelStyle is an option and property for Graph and related functions that specifies the style to use for edge labels."
EdgeLabels::usage = "EdgeLabels is an option and property for Graph and related functions that specifies what labels and label positions should be used for edges. "
EdgeList::usage = "\!\(\*RowBox[{\"EdgeList\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of edges for the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeList\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of edges that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeQ::usage = "\!\(\*RowBox[{\"EdgeQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"]\"}]\) yields True if \!\(\*StyleBox[\"e\", \"TI\"]\) is an edge in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) and False otherwise."
EdgeRenderingFunction::usage = "EdgeRenderingFunction is an option for GraphPlot and related functions that gives a function to generate the graphics primitives to use in rendering each edge."
EdgeRules::usage = "\!\(\*RowBox[{\"EdgeRules\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of edge rules for the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EdgeRules\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
EdgeShapeFunction::usage = "EdgeShapeFunction is an option and property for Graph and related functions that specifies a function to use to generate primitives for rendering each edge. "
EdgeStyle::usage = "EdgeStyle is an option and property for Graph and related functions that specifies what style to use for edges. "
EdgeWeight::usage = "EdgeWeight is an option and property for Graph and related functions that specifies an edge weight."
Editable::usage = "Editable is an option for displayed objects, cells, and notebooks that specifies whether their contents can be edited interactively using the front end. "
EditCellTagsSettings::usage = "\!\(\*RowBox[{\"EditCellTagsSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}]}]\) is a global option that specifies settings for the \!\(\*StyleBox[\"Edit Cell Tags\", \"DialogElementName\"]\) dialog box."
EditDefinition::usage = "\!\(\*RowBox[{\"EditDefinition\", \"[\", RowBox[{StyleBox[\"syms\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) lets you edit the rules attached to the symbols \!\(\*RowBox[{StyleBox[\"syms\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
EditDistance::usage = "\!\(\*RowBox[{\"EditDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the edit or Levenshtein distance between strings or vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
EditIn::usage = "\!\(\*RowBox[{\"EditIn\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) lets you edit input lines \!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\). \!\(\*RowBox[{\"EditIn\", \"[\", \"]\"}]\) edits the previous input line."
Edit::usage = "\!\(\*RowBox[{\"Edit\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) lets you edit the expressions \!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
EffectiveInterest::usage = "\!\(\*RowBox[{\"EffectiveInterest\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the effective interest rate corresponding to interest specification \!\(\*StyleBox[\"r\", \"TI\"]\), compounded at time intervals \!\(\*StyleBox[\"q\", \"TI\"]\)."
Eigensystem::usage = "\!\(\*RowBox[{\"Eigensystem\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"values\", \"TI\"], \",\", StyleBox[\"vectors\", \"TI\"]}], \"}\"}]\) of the eigenvalues and eigenvectors of the square matrix \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigensystem\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the generalized eigenvalues and eigenvectors of \!\(\*StyleBox[\"m\", \"TI\"]\) with respect to\[NonBreakingSpace]\!\(\*StyleBox[\"a\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigensystem\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the eigenvalues and eigenvectors for the first \!\(\*StyleBox[\"k\", \"TI\"]\) eigenvalues of \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigensystem\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"k\", \"TI\"]\) generalized eigenvalues and eigenvectors."
Eigenvalues::usage = "\!\(\*RowBox[{\"Eigenvalues\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a list of the eigenvalues of the square matrix \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigenvalues\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the generalized eigenvalues of \!\(\*StyleBox[\"m\", \"TI\"]\) with respect to \!\(\*StyleBox[\"a\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigenvalues\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"k\", \"TI\"]\) eigenvalues of \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigenvalues\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"k\", \"TI\"]\) generalized eigenvalues."
EigenvectorCentrality::usage = "\!\(\*RowBox[{\"EigenvectorCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of eigenvector centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EigenvectorCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"In\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of in-centralities for a directed graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EigenvectorCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"Out\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of out-centralities for a directed graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"EigenvectorCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Eigenvectors::usage = "\!\(\*RowBox[{\"Eigenvectors\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a list of the eigenvectors of the square matrix \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigenvectors\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the generalized eigenvectors of \!\(\*StyleBox[\"m\", \"TI\"]\) with respect to \!\(\*StyleBox[\"a\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigenvectors\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"k\", \"TI\"]\) eigenvectors of \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"Eigenvectors\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"k\", \"TI\"]\) generalized eigenvectors."
ElementData::usage = "\!\(\*RowBox[{\"ElementData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the chemical element \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"ElementData\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property for the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) chemical element."
Element::usage = "\!\(\*RowBox[{\"Element\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], StyleBox[\"\[Element]\", \"TR\"], StyleBox[\"dom\", \"TI\"]}]\) asserts that \!\(\*StyleBox[\"x\", \"TI\"]\) is an element of the domain \!\(\*StyleBox[\"dom\", \"TI\"]\). \n\!\(\*RowBox[{\"Element\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"reg\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]\) asserts that \!\(\*StyleBox[\"x\", \"TI\"]\) is an element of the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"Element\", \"[\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"|\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"|\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) asserts that all the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are elements of \!\(\*StyleBox[\"dom\", \"TI\"]\). \n\!\(\*RowBox[{\"Element\", \"[\", RowBox[{StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) asserts that any expression matching the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\) is an element of \!\(\*StyleBox[\"dom\", \"TI\"]\). "
ElidedForms::usage = "ElidedForms is an option to TextString and related functions that specifies which expressions should be elided."
Eliminate::usage = "\!\(\*RowBox[{\"Eliminate\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) eliminates variables between a set of simultaneous equations. "
EliminationOrder::usage = "EliminationOrder represents the elimination ordering of monomials."
Ellipsoid::usage = "\!\(\*RowBox[{\"Ellipsoid\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents an axis-aligned ellipsoid centered at the point \!\(\*StyleBox[\"p\", \"TI\"]\) and with semiaxes lengths \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Ellipsoid\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents an ellipsoid centered at \!\(\*StyleBox[\"p\", \"TI\"]\) and weight matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\)."
EllipticE::usage = "\!\(\*RowBox[{\"EllipticE\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the complete elliptic integral \!\(\*RowBox[{StyleBox[\"E\", \"TI\"], \"(\", StyleBox[\"m\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"EllipticE\", \"[\", RowBox[{StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the elliptic integral of the second kind \!\(\*RowBox[{StyleBox[\"E\", \"TI\"], \"(\", RowBox[{RowBox[{\"\[Phi]\", \"\[VerticalSeparator]\"}], StyleBox[\"m\", \"TI\"]}], \")\"}]\). "
EllipticExpPrime::usage = "\!\(\*RowBox[{\"EllipticExpPrime\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the derivative of \!\(\*RowBox[{\"EllipticExp\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]\) with respect to \!\(\*StyleBox[\"u\", \"TI\"]\)."
EllipticExp::usage = "\!\(\*RowBox[{\"EllipticExp\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]\) is the inverse for EllipticLog. It produces a list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) such that \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"==\", RowBox[{\"EllipticLog\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]}]\). "
EllipticFilterModel::usage = "\!\(\*RowBox[{\"EllipticFilterModel\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) designs a lowpass elliptic filter of order \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"EllipticFilterModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"}\"}], \"]\"}]\) uses the cutoff frequency \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]\).\n\!\(\*RowBox[{\"EllipticFilterModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \"]\"}]\) designs an elliptic filter of the specified type \"\!\(\*\nStyleBox[\"type\", \"TI\"]\)\", using the \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"EllipticFilterModel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) expresses the model in terms of the variable \!\(\*StyleBox[\"var\", \"TI\"]\)."
EllipticF::usage = "\!\(\*RowBox[{\"EllipticF\", \"[\", RowBox[{StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the elliptic integral of the first kind \!\(\*RowBox[{StyleBox[\"F\", \"TI\"], \"(\", RowBox[{\"\[Phi]\", \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]\). "
EllipticK::usage = "\!\(\*RowBox[{\"EllipticK\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the complete elliptic integral of the first kind \!\(\*RowBox[{StyleBox[\"K\", \"TI\"], \"(\", StyleBox[\"m\", \"TI\"], \")\"}]\). "
EllipticLog::usage = "\!\(\*RowBox[{\"EllipticLog\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the generalized logarithm associated with the elliptic curve \!\(\*RowBox[{SuperscriptBox[StyleBox[\"y\", \"TI\"], \"2\"], \"=\", RowBox[{SuperscriptBox[StyleBox[\"x\", \"TI\"], \"3\"], \"+\", RowBox[{StyleBox[\"a\", \"TI\"], \" \", SuperscriptBox[StyleBox[\"x\", \"TI\"], \"2\"]}], \"+\", RowBox[{StyleBox[\"b\", \"TI\"], \" \", StyleBox[\"x\", \"TI\"]}]}]}]\). "
EllipticNomeQ::usage = "\!\(\*RowBox[{\"EllipticNomeQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the nome \!\(\*StyleBox[\"q\", \"TI\"]\) corresponding to the parameter \!\(\*StyleBox[\"m\", \"TI\"]\) in an elliptic function. "
EllipticPi::usage = "\!\(\*RowBox[{\"EllipticPi\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the complete elliptic integral of the third kind \!\(\*RowBox[{StyleBox[\"\[CapitalPi]\", \"TR\"], RowBox[{\"(\", RowBox[{StyleBox[\"n\", \"TI\"], \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]}]\). \n\!\(\*RowBox[{\"EllipticPi\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the incomplete elliptic integral \!\(\*RowBox[{StyleBox[\"\[CapitalPi]\", \"TR\"], RowBox[{\"(\", RowBox[{StyleBox[\"n\", \"TI\"], \";\", RowBox[{StyleBox[\"\[Phi]\", \"TR\"], \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}]}], \")\"}]}]\). "
EllipticReducedHalfPeriods::usage = "\!\(\*RowBox[{\"EllipticReducedHalfPeriods\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", \" \", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"]\"}]\) gives a reduced pair of half periods \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", \" \", RowBox[{StyleBox[\"w\", \"TI\"], \"'\"}]}], \"}\"}]\) corresponding to the same lattice as that of \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", \" \", StyleBox[\"v\", \"TI\"]}], \"}\"}]\)."
EllipticThetaPrime::usage = "\!\(\*RowBox[{\"EllipticThetaPrime\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the derivative with respect to \!\(\*StyleBox[\"u\", \"TI\"]\) of the theta function \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[CurlyTheta]\", StyleBox[\"a\", \"TI\"]], \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \")\"}], RowBox[{\"(\", RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \"=\", \"1\"}], \",\", \"\[Ellipsis]\", \",\", \"4\"}], \")\"}]}]\)."
EllipticTheta::usage = "\!\(\*RowBox[{\"EllipticTheta\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the theta function \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[CurlyTheta]\", StyleBox[\"a\", \"TI\"]], \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \")\"}], RowBox[{\"(\", RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \"=\", \"1\"}], \",\", \"\[Ellipsis]\", \",\", \"4\"}], \")\"}]}]\)."
EmbedCode::usage = "\!\(\*RowBox[{\"EmbedCode\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) generates the code necessary to embed the object \!\(\*StyleBox[\"obj\", \"TI\"]\) on a web page.\n\!\(\*RowBox[{\"EmbedCode\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dest\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) generates code for an external environment or language of type \"\!\(\*\nStyleBox[\"dest\", \"TI\"]\)\".\n\!\(\*RowBox[{\"EmbedCode\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dest\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"dir\", \"TI\"]}], \"]\"}]\) saves the generated code as files in the directory \!\(\*StyleBox[\"dir\", \"TI\"]\).\n\!\(\*RowBox[{\"EmbedCode\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dest\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"loc\", \"TI\"]}], \"]\"}]\) saves the generated code as a file archive in the file location \!\(\*StyleBox[\"loc\", \"TI\"]\)."
EmbeddedHTML::usage = "\!\(\*RowBox[{\"EmbeddedHTML\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) is an object that formats as a web frame containing the HTML content \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"EmbeddedHTML\", \"[\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}]\) formats as a web rendering of the specified cloud object."
EmbeddedService::usage = "\!\(\*RowBox[{\"EmbeddedService\", \"[\", StyleBox[\"service\", \"TI\"], \"]\"}]\) is an object that formats as a web frame containing content from the specified external service."
EmitSound::usage = "\!\(\*RowBox[{\"EmitSound\", \"[\", StyleBox[\"snd\", \"TI\"], \"]\"}]\) emits the sound \!\(\*StyleBox[\"snd\", \"TI\"]\) when evaluated. \n\!\(\*RowBox[{\"EmitSound\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"snd\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"snd\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) emits each of the sounds \!\(\*SubscriptBox[StyleBox[\"snd\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in sequence. "
EmpiricalDistribution::usage = "\!\(\*RowBox[{\"EmpiricalDistribution\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an empirical distribution based on the data values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"EmpiricalDistribution\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a multivariate empirical distribution based on the data values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"EmpiricalDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents an empirical distribution where data values \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) occur with weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
EmptyGraphQ::usage = "\!\(\*RowBox[{\"EmptyGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"g\", \"TI\"]\) is an empty graph and False otherwise."
EmptyRegion::usage = "\!\(\*RowBox[{\"EmptyRegion\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the empty subset of \!\(\*SuperscriptBox[\"\[DoubleStruckCapitalR]\", StyleBox[\"n\", \"TI\"]]\). "
Enabled::usage = "Enabled is an option for objects such as Slider that specifies whether the objects should be enabled for interactive manipulation. "
Encode::usage = "\!\(\*RowBox[{\"Encode\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"source\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dest\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes an encoded version of the file \!\(\*StyleBox[\"source\", \"TI\"]\) to the file \!\(\*StyleBox[\"dest\", \"TI\"]\). \n\!\(\*RowBox[{\"<<\", StyleBox[\"dest\", \"TI\"]}]\) decodes the file before reading its contents. \n\!\(\*RowBox[{\"Encode\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"source\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dest\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"key\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) produces an encoded file that must be read in using \!\(\*RowBox[{\"Get\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dest\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"key\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\). "
EncryptedObject::usage = "\!\(\*RowBox[{\"EncryptedObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents encrypted data generated by Encrypt."
Encrypt::usage = "\!\(\*RowBox[{\"Encrypt\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"password\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) encrypts \!\(\*StyleBox[\"expr\", \"TI\"]\) using the specified password, to give an encrypted object.\n\!\(\*RowBox[{\"Encrypt\", \"[\", RowBox[{StyleBox[\"keyspec\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) encrypts \!\(\*StyleBox[\"expr\", \"TI\"]\) using the cryptographic key specification \!\(\*StyleBox[\"keyspec\", \"TI\"]\)."
EndAdd::usage = "\!\(\*RowBox[{\"EndAdd\", \"[\", \" \", \"]\"}]\) returns the present context, and reverts to the previous one, prepending the present context to $ContextPath."
EndDialogPacket::usage = "\!\(\*RowBox[{\"EndDialogPacket\", \"[\", StyleBox[\"integer\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet indicating the end of the Dialog subsession referenced by \!\(\*StyleBox[\"integer\", \"TI\"]\)."
EndOfBuffer::usage = "EndOfBuffer is a symbol that represents the end of currently available data in the buffer for a process or stream. "
EndOfFile::usage = "EndOfFile is a symbol returned by Read when it reaches the end of a file. "
EndOfLine::usage = "EndOfLine represents the end of a line in a string for purposes of matching in StringExpression."
EndOfString::usage = "EndOfString represents the end of a string for purposes of matching in StringExpression."
EndPackage::usage = "\!\(\*RowBox[{\"EndPackage\", \"[\", \"]\"}]\) restores $Context and $ContextPath to their values before the preceding BeginPackage, and prepends the current context to the list $ContextPath. "
End::usage = "\!\(\*RowBox[{\"End\", \"[\", \"]\"}]\) returns the present context, and reverts to the previous one. "
EngineeringForm::usage = "\!\(\*RowBox[{\"EngineeringForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints with all real numbers in \!\(\*StyleBox[\"expr\", \"TI\"]\) given in engineering notation. \n\!\(\*RowBox[{\"EngineeringForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) prints with numbers given to \!\(\*StyleBox[\"n\", \"TI\"]\)\[Hyphen]digit precision. "
EnterExpressionPacket::usage = "\!\(\*RowBox[{\"EnterExpressionPacket\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that requests the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
EnterTextPacket::usage = "\!\(\*RowBox[{\"EnterTextPacket\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that requests the parsing and evaluation of \!\(\*StyleBox[\"string\", \"TI\"]\) as an expression."
EntityClassList::usage = "\!\(\*RowBox[{\"EntityClassList\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of entity classes for the specified type of entity."
EntityClass::usage = "\!\(\*RowBox[{\"EntityClass\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) represents a class of entities of the specified type identified by \!\(\*StyleBox[\"name\", \"TI\"]\)."
EntityCopies::usage = "\!\(\*RowBox[{\"EntityCopies\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents \!\(\*StyleBox[\"n\", \"TI\"]\) copies of \!\(\*StyleBox[\"entity\", \"TI\"]\)."
EntityGroup::usage = "\!\(\*RowBox[{\"EntityGroup\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \"\[Ellipsis]\"}], \"}\"}], \"]\"}]\) represents a group of entities."
EntityInstance::usage = "\!\(\*RowBox[{\"EntityInstance\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", RowBox[{StyleBox[\"qual\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}]}], \"]\"}]\) represents an entity whose qualifier \!\(\*StyleBox[\"qual\", \"TI\"]\) has value \!\(\*StyleBox[\"val\", \"TI\"]\).\n\!\(\*RowBox[{\"EntityInstance\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", \"\[Ellipsis]\"}], \"}\"}]}], \"]\"}]\) represents an entity whose qualifiers \!\(\*SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) have values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"EntityInstance\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"quantity\", \"TI\"]}], \"]\"}]\) represents an entity qualified by \!\(\*StyleBox[\"quantity\", \"TI\"]\)."
EntityList::usage = "\!\(\*RowBox[{\"EntityList\", \"[\", StyleBox[\"class\", \"TI\"], \"]\"}]\) gives a list of entities in the specified entity class. \n\!\(\*RowBox[{\"EntityList\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of entities of the specified type."
EntityProperties::usage = "\!\(\*RowBox[{\"EntityProperties\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) lists properties associated with entity type \!\(\*StyleBox[\"type\", \"TI\"]\)."
EntityPropertyClass::usage = "\!\(\*RowBox[{\"EntityPropertyClass\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"pcname\", \"TI\"]}], \"]\"}]\) represents a class of properties identified by the name \!\(\*StyleBox[\"pcname\", \"TI\"]\)."
EntityProperty::usage = "\!\(\*RowBox[{\"EntityProperty\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"pname\", \"TI\"]}], \"]\"}]\) represents a property identified by \!\(\*StyleBox[\"pname\", \"TI\"]\) for use in EntityValue.\n\!\(\*RowBox[{\"EntityProperty\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"pname\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a property modified by the qualifier rules \!\(\*RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\)."
EntityTypeName::usage = "\!\(\*RowBox[{\"EntityTypeName\", \"[\", StyleBox[\"entity\", \"TI\"], \"]\"}]\) gives the name of the entity type of \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"EntityTypeName\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the name of the entity type for \!\(\*SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
Entity::usage = "\!\(\*RowBox[{\"Entity\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) represents an entity of specified type identified by \!\(\*StyleBox[\"name\", \"TI\"]\).\n\!\(\*RowBox[{\"Entity\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"property\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"property\", \"TI\"], \"2\"], \"\[Rule]\", SubscriptBox[StyleBox[\"value\", \"TI\"], \"2\"]}], \",\", \"\[Ellipsis]\"}], \"}\"}]}], \"]\"}]\) represents an implicitly defined entity object whose members have values \!\(\*SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for properties \!\(\*SubscriptBox[StyleBox[\"property\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
EntityValue::usage = "\!\(\*RowBox[{\"EntityValue\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the given entity.\n\!\(\*RowBox[{\"EntityValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"property\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"property\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the values of multiple properties for multiple entities.\n\!\(\*RowBox[{\"EntityValue\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified annotation associated with the property."
EntropyFilter::usage = "\!\(\*RowBox[{\"EntropyFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every value by the information entropy of the values in its range \!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"EntropyFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies entropy filtering to an array of data."
Entropy::usage = "\!\(\*RowBox[{\"Entropy\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the base \[ExponentialE] information entropy of the values in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Entropy\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) gives the base \!\(\*StyleBox[\"k\", \"TI\"]\) information entropy."
Environment::usage = "\!\(\*RowBox[{\"Environment\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"var\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the value of an operating system environment variable. "
EpilogFunction::usage = "EpilogFunction is an option for DocumentGenerator allowing arbitrary code to be executed after a document is generated."
Epilog::usage = "Epilog is an option for graphics functions that gives a list of graphics primitives to be rendered after the main part of the graphics is rendered. "
EqualColumns::usage = "EqualColumns is an option to GridBox which specifies whether the size of the columns are all set to the size of the largest column. The default value of EqualColumns is False."
EqualRows::usage = "EqualRows is an option to GridBox which specifies whether the size of the rows are all set to the size of the largest row. The default value of EqualRows is False."
EqualTilde::usage = "\!\(\*RowBox[{\"EqualTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[EqualTilde]\", StyleBox[\"y\", \"TI\"], \"\[EqualTilde]\", \"\[Ellipsis]\"}]\)."
EqualTo::usage = "\!\(\*RowBox[{\"EqualTo\", \"[\", StyleBox[\"y\", \"TI\"], \"]\"}]\) is an operator form that yields \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"==\", StyleBox[\"y\", \"TI\"]}]\) when applied to an expression \!\(\*StyleBox[\"x\", \"TI\"]\). "
Equal::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"==\", StyleBox[\"rhs\", \"TI\"]}]\) returns True if \!\(\*StyleBox[\"lhs\", \"TI\"]\) and \!\(\*StyleBox[\"rhs\", \"TI\"]\) are identical. "
EquatedTo::usage = "EquatedTo is an option for Roots, which specifies an expression to use in place of the variable in the solution."
EquationTrekker`DifferentialEquationTrek::usage = "DifferentialEquationTrek is a setting for the option TrekGenerator that specifies that treks are generated from the phase space of the numerical solution of a differential equation."
EquationTrekker`EquationTrekkerNonModal::usage = "EquationTrekkerNonModal is the nonmodal dialog version of EquationTrekker."
EquationTrekker`EquationTrekkerState::usage = "\!\(\*RowBox[{\"EquationTrekkerState\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"dvars\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"treks\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) is the data object returned by the function EquationTrekker that contains the information needed to restore the graphical interface to the state it was in when the EquationTrekker window was closed."
EquationTrekker`EquationTrekker::usage = "\!\(\*RowBox[{\"EquationTrekker\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) opens a graphical interface for specifying initial conditions and plotting the resulting numerical solution to the first- or second-order ordinary differential equation \!\(\*StyleBox[\"eqn\", \"TI\"]\) for the function \!\(\*StyleBox[\"x\", \"TI\"]\) with the independent variable \!\(\*StyleBox[\"t\", \"TI\"]\) in the range \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"EquationTrekker\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) opens a graphical interface for specifying initial conditions and plotting the resulting numerical solution to the system of two first-order ordinary differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) for the functions \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\).\n\!\(\*RowBox[{\"EquationTrekker\", \"[\", StyleBox[\"state\", \"TI\"], \"]\"}]\) reopens a graphical interface with the treks saved in the EquationTrekkerState object \!\(\*StyleBox[\"state\", \"TI\"]\)."
EquationTrekker`InitializeGenerator::usage = "\!\(\*RowBox[{\"InitializeGenerator\", \"[\", RowBox[{StyleBox[\"gen\", \"TI\"], \",\", StyleBox[\"problem\", \"TI\"], \",\", StyleBox[\"dvars\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) returns the trek generator \!\(\*RowBox[{StyleBox[\"gen\", \"TI\"], \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) when called by EquationTrekker. The specific form of \!\(\*StyleBox[\"data\", \"TI\"]\) depends on the trek generator \!\(\*StyleBox[\"gen\", \"TI\"]\).\n\!\(\*RowBox[{\"IntializeGenerator\", \"[\", RowBox[{StyleBox[\"gen\", \"TI\"], \",\", StyleBox[\"problem\", \"TI\"], \",\", StyleBox[\"dvars\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) returns a trek generator that does not use an independent variable."
EquationTrekker`PoincareSection::usage = "PoincareSection is a setting for the option TrekGenerator that specifies that the Poincar\[EAcute] section for differential equations is used to generate treks."
EquationTrekker`TrekData::usage = "\!\(\*RowBox[{\"TrekData\", \"[\", RowBox[{StyleBox[\"tag\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) is a data object that contains the information necessary to recreate the trek associated with the tag \!\(\*StyleBox[\"tag\", \"TI\"]\) in a graphical interface created by EquationTrekker."
EquationTrekker`TrekGenerator::usage = "TrekGenerator is an option to EquationTrekker that specifies the method used to generate treks."
EquationTrekker`TrekParameters::usage = "TrekParameters is an option to EquationTrekker that specifies the dynamic parameters and their ranges."
Equilibrium::usage = "\!\(\*RowBox[{\"Equilibrium\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Equilibrium]\", StyleBox[\"y\", \"TI\"], \"\[Equilibrium]\", \"\[Ellipsis]\"}]\)."
EquirippleFilterKernel::usage = "\!\(\*RowBox[{\"EquirippleFilterKernel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"L\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"R\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"L\", StyleBox[\"2\", FontSlant -> \"Plain\"]}]], \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"R\", StyleBox[\"2\", FontSlant -> \"Plain\"]}]], \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) creates a finite impulse response (FIR) filter kernel of length \!\(\*StyleBox[\"n\", \"TI\"]\) with an equiripple amplitude response, given the specified left and right band edge frequencies \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"Li\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"Ri\", \"TI\"]]}], \"}\"}]\) and amplitudes \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"EquirippleFilterKernel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"L\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"R\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"L\", StyleBox[\"2\", FontSlant -> \"Plain\"]}]], \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"R\", StyleBox[\"2\", FontSlant -> \"Plain\"]}]], \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses relative weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for each frequency band.\n\!\(\*RowBox[{RowBox[{\"EquirippleFilterKernel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"L\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[StyleBox[RowBox[{\"R\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}]}]}], \"]\"}]\) creates a filter of the specified \"\!\(\*\nStyleBox[\"type\", \"TI\"]\)\"."
Equivalent::usage = "\!\(\*RowBox[{\"Equivalent\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the logical equivalence \!\(\*RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[DoubleLeftRightArrow]\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[DoubleLeftRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\), giving True when all of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are the same."
Erfc::usage = "\!\(\*RowBox[{\"Erfc\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the complementary error function \!\(\*RowBox[{\"erfc\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
Erfi::usage = "\!\(\*RowBox[{\"Erfi\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the imaginary error function \!\(\*RowBox[{RowBox[{\"erf\", \"(\", RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"z\", \"TI\"]}], \")\"}], \"/\", StyleBox[\"i\", \"TI\"]}]\). "
Erf::usage = "\!\(\*RowBox[{\"Erf\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the error function \!\(\*RowBox[{\"erf\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"Erf\", \"[\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}]\) gives the generalized error function \!\(\*RowBox[{RowBox[{\"erf\", \"(\", SubscriptBox[StyleBox[\"z\", \"TI\"], \"1\"], \")\"}], \"-\", RowBox[{\"erf\", \"(\", SubscriptBox[StyleBox[\"z\", \"TI\"], \"0\"], \")\"}]}]\). "
ErlangB::usage = "\!\(\*RowBox[{\"ErlangB\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) computes the Erlang B loss probability for an M/M/c/c queue."
ErlangC::usage = "\!\(\*RowBox[{\"ErlangC\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) computes the Erlang C probability for nonzero waiting time in an M/M/c queue."
ErlangDistribution::usage = "\!\(\*RowBox[{\"ErlangDistribution\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"]\"}]\) represents the Erlang distribution with shape parameter \!\(\*StyleBox[\"k\", \"TI\"]\) and rate \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\)."
Erosion::usage = "\!\(\*RowBox[{\"Erosion\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the morphological erosion of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to the structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"Erosion\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the erosion with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"Erosion\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies erosion to an array of data."
ErrorBarPlots`ErrorBarFunction::usage = "ErrorBarFunction is an option for ErrorListPlot that specifies a function to apply to determine the shape of error bars. "
ErrorBarPlots`ErrorBar::usage = "\!\(\*RowBox[{RowBox[{\"ErrorBar\", \"[\", \"{\"}], StyleBox[\"negerror\", \"TI\"], \",\", StyleBox[\"poserror\", \"TI\"], RowBox[{\"}\", \"]\"}]}]\) represents error in the positive and negative directions.\n\!\(\*RowBox[{\"ErrorBar\", \"[\", StyleBox[\"yerr\", \"TI\"], \"]\"}]\) represents error \!\(\*StyleBox[\"yerr\", \"TI\"]\) in both the positive and negative directions.\n\!\(\*RowBox[{\"ErrorBar\", \"[\", RowBox[{StyleBox[\"xerr\", \"TI\"], \",\", StyleBox[\"yerr\", \"TI\"]}], \"]\"}]\) represents errors specified for both the \!\(\*StyleBox[\"x\", \"TI\"]\) and the \!\(\*StyleBox[\"y\", \"TI\"]\) coordinates."
ErrorBarPlots`ErrorListPlot::usage = "\!\(\*RowBox[{\"ErrorListPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dy\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dy\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \"]\"}]\) plots points corresponding to a list of values \!\(\*RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\), with corresponding error bars. The errors have magnitudes \!\(\*RowBox[{SubscriptBox[StyleBox[\"dy\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dy\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\).\n\!\(\*RowBox[{\"ErrorListPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"ErrorBar\", \"[\", SubscriptBox[StyleBox[\"err\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"]\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"ErrorBar\", \"[\", SubscriptBox[StyleBox[\"err\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots points with specified \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) coordinates and error magnitudes."
ErrorBox::usage = "\!\(\*RowBox[{ErrorBox, \"[\", StyleBox[\"boxes\", \"TI\"], \"]\"}]\) is a low-level box construct that represents boxes that cannot be interpreted in input or output. "
EscapeRadius::usage = "\!\(\*RowBox[{\"EscapeRadius\", \" \"}]\) is an option to MandelbrotSetPlot that specifies the criterion to use to decide that a point is not in the Mandelbrot set."
EstimatedBackground::usage = "\!\(\*RowBox[{\"EstimatedBackground\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) estimates the background of \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"EstimatedBackground\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) tries to preserve peaks up to scale \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
EstimatedDistribution::usage = "\!\(\*RowBox[{\"EstimatedDistribution\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) estimates the parametric distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) from \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"EstimatedDistribution\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{StyleBox[\"p\", \"TI\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) estimates the parameters \!\(\*StyleBox[\"p\", \"TI\"]\), \!\(\*StyleBox[\"q\", \"TI\"]\), \[Ellipsis] with starting values \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"EstimatedDistribution\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"idist\", \"TI\"]}], \"]\"}]\) estimates distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) with starting values taken from the instantiated distribution \!\(\*StyleBox[\"idist\", \"TI\"]\)."
EstimatedProcess::usage = "\!\(\*RowBox[{\"EstimatedProcess\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"proc\", \"TI\"]}], \"]\"}]\) estimates the parametric process \!\(\*StyleBox[\"proc\", \"TI\"]\) from \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"EstimatedProcess\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) estimates the parameters \!\(\*StyleBox[\"p\", \"TI\"]\), \!\(\*StyleBox[\"q\", \"TI\"]\), \[Ellipsis] with starting values \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"EstimatedProcess\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"iproc\", \"TI\"]}], \"]\"}]\) estimates process \!\(\*StyleBox[\"proc\", \"TI\"]\) with starting values taken from the instantiated process \!\(\*StyleBox[\"iproc\", \"TI\"]\)."
EstimatorGains::usage = "\!\(\*RowBox[{\"EstimatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the estimator gain matrix for the StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\), such that the poles of the estimator are \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"EstimatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) specifies the measured outputs \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to use."
EstimatorRegulator::usage = "\!\(\*RowBox[{\"EstimatorRegulator\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"\[Kappa]\", FontFamily -> \"Times\"]}], \"}\"}]}], \"]\"}]\) constructs the feedback regulator for the StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\) with estimator and feedback gain matrices \!\(\*StyleBox[\"l\", \"TI\"]\) and \!\(\*StyleBox[\"\[Kappa]\", FontFamily -> \"Times\"]\), respectively.\n\!\(\*RowBox[{\"EstimatorRegulator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"\[Kappa]\", FontFamily -> \"Times\"]}], \"}\"}]}], \"]\"}]\) uses only \!\(\*StyleBox[\"sensors\", \"TI\"]\) as the measured outputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\).\n\!\(\*RowBox[{\"EstimatorRegulator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"finputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"\[Kappa]\", FontFamily -> \"Times\"]}], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"finputs\", \"TI\"]\) as the feedback inputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\).\n\!\(\*RowBox[{\"EstimatorRegulator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"finputs\", \"TI\"], \",\", StyleBox[\"einputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"\[Kappa]\", FontFamily -> \"Times\"]}], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"einputs\", \"TI\"]\) as the exogenous deterministic inputs."
EuclideanDistance::usage = "\!\(\*RowBox[{\"EuclideanDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Euclidean distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
EulerAngles::usage = "\!\(\*RowBox[{\"EulerAngles\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives Euler angles \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}]\) corresponding to the rotation matrix \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"EulerAngles\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives Euler angles \!\(\*RowBox[{\"{\", RowBox[{\"\[Alpha]\", \",\", \"\[Beta]\", \",\", \"\[Gamma]\"}], \"}\"}]\) with rotation order \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}]\). "
EulerE::usage = "\!\(\*RowBox[{\"EulerE\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Euler number \!\(\*SubscriptBox[StyleBox[\"E\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"EulerE\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Euler polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"E\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
EulerGamma::usage = "EulerGamma is Euler\[CloseCurlyQuote]s constant \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\), with numerical value \!\(\*RowBox[{\"\[TildeEqual]\", \"0.577216\"}]\). "
EulerianGraphQ::usage = "\!\(\*RowBox[{\"EulerianGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is Eulerian, and False otherwise."
EulerMatrix::usage = "\!\(\*RowBox[{\"EulerMatrix\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the Euler 3D rotation matrix formed by rotating \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) around the current \!\(\*StyleBox[\"z\", \"TI\"]\) axis, then \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) around the current \!\(\*StyleBox[\"y\", \"TI\"]\) axis, and then \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\) around the current \!\(\*StyleBox[\"z\", \"TI\"]\) axis. \n\!\(\*RowBox[{\"EulerMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the Euler 3D rotation matrix corresponding, first rotating \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) around the current \!\(\*StyleBox[\"a\", \"TI\"]\) axis, then \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) around the current \!\(\*StyleBox[\"b\", \"TI\"]\) axis, and finally \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\) around the current \!\(\*StyleBox[\"c\", \"TI\"]\) axis."
EulerPhi::usage = "\!\(\*RowBox[{\"EulerPhi\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Euler totient function \!\(\*RowBox[{\"\[Phi]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\). "
E::usage = "E is the exponential constant \[ExponentialE] (base of natural logarithms), with numerical value \!\(\*RowBox[{\"\[TildeEqual]\", \"2.71828\"}]\)."
Evaluatable::usage = "Evaluatable is an option for Cell that specifies whether a cell should be used as input to be evaluated by the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) kernel. "
EvaluatePacket::usage = "\!\(\*RowBox[{\"EvaluatePacket\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet requesting evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
EvaluateScheduledTask::usage = "\!\(\*RowBox[{\"EvaluateScheduledTask\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) triggers immediate local execution of the specified task object."
Evaluate::usage = "\!\(\*RowBox[{\"Evaluate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) causes \!\(\*StyleBox[\"expr\", \"TI\"]\) to be evaluated even if it appears as the argument of a function whose attributes specify that it should be held unevaluated. "
EvaluationBox::usage = "\!\(\*RowBox[{EvaluationBox, \"[\", \"]\"}]\) returns a BoxObject corresponding to the box structure in which this function is being evaluated."
EvaluationCell::usage = "\!\(\*RowBox[{\"EvaluationCell\", \"[\", \"]\"}]\) returns a CellObject corresponding to the cell in which this function is being evaluated."
EvaluationCompletionAction::usage = "EvaluationCompletionAction is an option for notebooks that specifies the action taken when an evaluation is completed."
EvaluationData::usage = "\!\(\*RowBox[{\"EvaluationData\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives an association containing the result of evaluating \!\(\*StyleBox[\"expr\", \"TI\"]\) and metadata about the process of doing so."
EvaluationElements::usage = "EvaluationElements is an option for NotebookEvaluate that determines which cells to evaluate."
EvaluationMonitor::usage = "EvaluationMonitor is an option for various numerical computation and plotting functions that gives an expression to evaluate whenever functions derived from the input are evaluated numerically. "
EvaluationNotebook::usage = "\!\(\*RowBox[{\"EvaluationNotebook\", \"[\", \"]\"}]\) gives the notebook in which this function is being evaluated. "
EvaluationObject::usage = "\!\(\*RowBox[{\"EvaluationObject\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents an expression submitted for evaluation on any available parallel kernel."
EvaluatorNames::usage = "EvaluatorNames is a global option that specifies the kernels that are currently configured to perform evaluations."
Evaluator::usage = "Evaluator is an option for objects such as Button, Dynamic, and Cell that gives the name of the kernel to use to evaluate their contents. "
EvenQ::usage = "\!\(\*RowBox[{\"EvenQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is an even integer, and False otherwise. "
EventData::usage = "\!\(\*RowBox[{\"EventData\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents event data with explicitly specified censoring \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"EventData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"ci\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ci\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents event data \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with censoring indicators \!\(\*SubscriptBox[StyleBox[\"ci\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"EventData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents event data \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with censoring counts \!\(\*SubscriptBox[StyleBox[\"cc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"EventData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"cspec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"tr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"tr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents event data with censoring and truncation \!\(\*SubscriptBox[StyleBox[\"tr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
EventHandler::usage = "\!\(\*RowBox[{\"EventHandler\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"1\", \"TR\"]], \":>\", SubscriptBox[StyleBox[\"action\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"2\", \"TR\"]], \":>\", SubscriptBox[StyleBox[\"action\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) displays as \!\(\*StyleBox[\"expr\", \"TI\"]\), evaluating \!\(\*SubscriptBox[StyleBox[\"action\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) whenever \"\!\(\*SubscriptBox[\nStyleBox[\"event\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\" occurs in connection with \!\(\*StyleBox[\"expr\", \"TI\"]\). "
EventLabels::usage = "EventLabels is an option to CandlestickChart, KagiChart, and similar functions that specifies events to labels."
EventSeries::usage = "\!\(\*RowBox[{\"EventSeries\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}], \"}\"}], \"]\"}]\) represents a series of events given as time-value pairs \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"EventSeries\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"tspec\", \"TI\"]}], \"]\"}]\) represents a series of events with values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at times specified by \!\(\*StyleBox[\"tspec\", \"TI\"]\)."
ExactBlackmanWindow::usage = "\!\(\*RowBox[{\"ExactBlackmanWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a exact Blackman window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
ExactNumberQ::usage = "\!\(\*RowBox[{\"ExactNumberQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is an exact real or complex number, and returns False otherwise."
ExactRootIsolation::usage = "ExactRootIsolation is an option for Root, which specifies whether exact isolating intervals rather then numeric approximations should be used to identify algebraic numbers."
ExampleData::usage = "\!\(\*RowBox[{\"ExampleData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of names of examples of the specified type.\n\!\(\*RowBox[{\"ExampleData\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}], \"]\"}]\) gives the default form of the named example of the specified type.\n\!\(\*RowBox[{\"ExampleData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"elem\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified element or property of an example."
Except::usage = "\!\(\*RowBox[{\"Except\", \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) is a pattern object which represents any expression except one that matches \!\(\*StyleBox[\"c\", \"TI\"]\). \n\!\(\*RowBox[{\"Except\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents any expression that matches \!\(\*StyleBox[\"p\", \"TI\"]\) but not \!\(\*StyleBox[\"c\", \"TI\"]\). "
ExcludedForms::usage = "ExcludedForms is an option that gives a list of patterns for expressions that should excluded from an operation performed by a particular function. "
ExcludedLines::usage = "ExcludedLines is an option for SemanticImport and related functions that specifies which lines should be ignored for further processing."
ExcludedPhysicalQuantities::usage = "ExcludedPhysicalQuantities is an option for FormulaLookup that specifies physical quantities that should be not used by the formulas returned."
ExcludePods::usage = "ExcludePods is an option to WolframAlpha that specifies pod IDs to exclude from the results."
ExclusionsStyle::usage = "ExclusionsStyle is an option to plotting functions that specifies how to render subregions excluded according to Exclusions. "
Exclusions::usage = "Exclusions is an option that specifies where to exclude in regions used by functions like Plot, Plot3D, and NIntegrate."
Exists::usage = "\!\(\*RowBox[{\"Exists\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) represents the statement that there exists a value of \!\(\*StyleBox[\"x\", \"TI\"]\) for which \!\(\*StyleBox[\"expr\", \"TI\"]\) is True. \n\!\(\*RowBox[{\"Exists\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"cond\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) states that there exists an \!\(\*StyleBox[\"x\", \"TI\"]\) satisfying the condition \!\(\*StyleBox[\"cond\", \"TI\"]\) for which \!\(\*StyleBox[\"expr\", \"TI\"]\) is True. \n\!\(\*RowBox[{\"Exists\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) states that there exist values for all the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for which \!\(\*StyleBox[\"expr\", \"TI\"]\) is True. "
Exit::usage = "\!\(\*RowBox[{\"Exit\", \"[\", \"]\"}]\) terminates a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) kernel session. "
ExoplanetData::usage = "\!\(\*RowBox[{\"ExoplanetData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the exoplanet \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"ExoplanetData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified exoplanet entities.\n\!\(\*RowBox[{\"ExoplanetData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
ExpandAll::usage = "\!\(\*RowBox[{\"ExpandAll\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands out all products and integer powers in any part of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"ExpandAll\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) avoids expanding parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) that do not contain terms matching the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\). "
ExpandDenominator::usage = "\!\(\*RowBox[{\"ExpandDenominator\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands out products and powers that appear as denominators in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
ExpandFileName::usage = "\!\(\*RowBox[{\"ExpandFileName\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) textually expands \!\(\*StyleBox[\"name\", \"TI\"]\) to have the form of an absolute file name for your operating system."
ExpandNumerator::usage = "\!\(\*RowBox[{\"ExpandNumerator\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands out products and powers that appear in the numerator of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Expand::usage = "\!\(\*RowBox[{\"Expand\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands out products and positive integer powers in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Expand\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) leaves unexpanded any parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) that are free of the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\)."
Expectation::usage = "\!\(\*RowBox[{\"Expectation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) gives the expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) under the assumption that \!\(\*StyleBox[\"x\", \"TI\"]\) follows the probability distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). \n\!\(\*RowBox[{\"Expectation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"data\", \"TI\"]}]}], \"]\"}]\) gives the expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) under the assumption that \!\(\*StyleBox[\"x\", \"TI\"]\) follows the probability distribution given by \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"Expectation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) gives the expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) under the assumption that \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) follows the multivariate distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). \n\!\(\*RowBox[{\"Expectation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}]}], \"]\"}]\) gives the expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) under the assumption that \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] are independent and follow the distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. \n\!\(\*RowBox[{\"Expectation\", \"[\", RowBox[{RowBox[{StyleBox[\"expr\", \"TI\"], \"\[Conditioned]\", StyleBox[\"pred\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the conditional expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) given \!\(\*StyleBox[\"pred\", \"TI\"]\)."
ExpectedValue::usage = "\!\(\*RowBox[{\"ExpectedValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) gives the expected value of the pure function \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to the values in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"ExpectedValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the expected value of the function \!\(\*StyleBox[\"f\", \"TI\"]\) of \!\(\*StyleBox[\"x\", \"TI\"]\) with respect to the values of \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"ExpectedValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) gives the expected value of the pure function \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"ExpectedValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the expected value of the function \!\(\*StyleBox[\"f\", \"TI\"]\) of \!\(\*StyleBox[\"x\", \"TI\"]\) with respect to the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
Experimental`CompileEvaluate::usage = "\!\(\*RowBox[{\"CompileEvaluate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) compiles \!\(\*StyleBox[\"expr\", \"TI\"]\) and then evaluates the resulting compiled code. "
Experimental`ExistsRealQ::usage = "\!\(\*RowBox[{\"ExistsRealQ\", \"[\", RowBox[{StyleBox[\"ineqs\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) tests whether there exist real values of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for which the inequalities and equations \!\(\*StyleBox[\"ineqs\", \"TI\"]\) are satisfied. "
Experimental`ForAllRealQ::usage = "\!\(\*RowBox[{\"ForAllRealQ\", \"[\", RowBox[{StyleBox[\"ineqs\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) tests whether for all real values of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) the inequalities and equations \!\(\*StyleBox[\"ineqs\", \"TI\"]\) are satisfied. "
Experimental`ImpliesQ::usage = "\!\(\*RowBox[{\"ImpliesQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the expression \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) implies \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
Experimental`ImpliesRealQ::usage = "\!\(\*RowBox[{\"ImpliesRealQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"ineqs\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ineqs\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the inequalities and equations \!\(\*SubscriptBox[StyleBox[\"ineqs\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) imply the \!\(\*SubscriptBox[StyleBox[\"ineqs\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) for all real values of all variables. "
Experimental`ValueFunction::usage = "\!\(\*RowBox[{\"ValueFunction\", \"[\", StyleBox[\"symb\", \"TI\"], \"]\"}]\) represents a function to be applied whenever the symbol \!\(\*StyleBox[\"symb\", \"TI\"]\) gets a new value."
ExpGammaDistribution::usage = "\!\(\*RowBox[{\"ExpGammaDistribution\", \"[\", RowBox[{StyleBox[\"\[Kappa]\", \"TR\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents an exp-gamma distribution with shape parameter \!\(\*StyleBox[\"\[Kappa]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\), and location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
ExpIntegralEi::usage = "\!\(\*RowBox[{\"ExpIntegralEi\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the exponential integral function \!\(\*RowBox[{\"Ei\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
ExpIntegralE::usage = "\!\(\*RowBox[{\"ExpIntegralE\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the exponential integral function \!\(\*RowBox[{SubscriptBox[StyleBox[\"E\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
ExponentFunction::usage = "ExponentFunction is an option for NumberForm and related functions that determines the exponent to use in printing approximate real numbers. "
ExponentialDistribution::usage = "\!\(\*RowBox[{\"ExponentialDistribution\", \"[\", StyleBox[\"\[Lambda]\", \"TR\"], \"]\"}]\) represents an exponential distribution with scale inversely proportional to parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\)."
ExponentialFamily::usage = "ExponentialFamily is an option for GeneralizedLinearModelFit that specifies the exponential family for the model."
ExponentialGeneratingFunction::usage = "\!\(\*RowBox[{\"ExponentialGeneratingFunction\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the exponential generating function in \!\(\*StyleBox[\"x\", \"TI\"]\) for the sequence whose \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) term is given by the expression \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"ExponentialGeneratingFunction\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \"\[Ellipsis]\"}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \"\[Ellipsis]\"}], \"}\"}]}], \"]\"}]\) gives the multidimensional exponential generating function in \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] whose \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] term is given by \!\(\*StyleBox[\"expr\", \"TI\"]\)."
ExponentialMovingAverage::usage = "\!\(\*RowBox[{\"ExponentialMovingAverage\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) gives the exponential moving average of \!\(\*StyleBox[\"list\", \"TI\"]\) with smoothing constant \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
ExponentialPowerDistribution::usage = "\!\(\*RowBox[{\"ExponentialPowerDistribution\", \"[\", RowBox[{StyleBox[\"\[Kappa]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents an exponential power distribution with shape parameter \!\(\*StyleBox[\"\[Kappa]\", \"TR\"]\), location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"ExponentialPowerDistribution\", \"[\", StyleBox[\"\[Kappa]\", \"TR\"], \"]\"}]\) represents an exponential power distribution with location parameter 0 and scale parameter 1."
ExponentPosition::usage = "ExponentPosition is an option for RadicalBox that specifies the placement of the index outside a radical sign."
ExponentStep::usage = "ExponentStep is an option for NumberForm and related functions that determines in what steps exponents are taken to increase when scientific notation is used."
Exponent::usage = "\!\(\*RowBox[{\"Exponent\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the maximum power with which \!\(\*StyleBox[\"form\", \"TI\"]\) appears in the expanded form of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Exponent\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"h\", \"TI\"]\) to the set of exponents with which \!\(\*StyleBox[\"form\", \"TI\"]\) appears in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
ExportAutoReplacements::usage = "ExportAutoReplacements is an option for cells that specifies which replacement rules \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\"]\) automatically applies when exporting text."
ExportForm::usage = "\!\(\*RowBox[{\"ExportForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"fmt\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) specifies that \!\(\*StyleBox[\"expr\", \"TI\"]\) should be exported in the specified format in functions like CloudDeploy and in external results from APIFunction and FormFunction.\n\!\(\*RowBox[{\"ExportForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"fmt\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}]}], \"]\"}]\) specifies that when \!\(\*StyleBox[\"expr\", \"TI\"]\) is exported, it should be tagged as having the specified MIME type."
ExportString::usage = "\!\(\*RowBox[{\"ExportString\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) generates a string corresponding to \!\(\*StyleBox[\"expr\", \"TI\"]\) exported in the specified format. \n\!\(\*RowBox[{\"ExportString\", \"[\", RowBox[{StyleBox[\"rules\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"Rules\\\"\",ShowStringCharacters->True]}], \"}\"}]}], \"]\"}]\) gives explicit rules for different elements of the data to be exported. \n\!\(\*RowBox[{\"ExportString\", \"[\", RowBox[{StyleBox[\"exprs\", \"TI\"], \",\", StyleBox[\"elems\", \"TI\"]}], \"]\"}]\) generates a string by treating \!\(\*StyleBox[\"exprs\", \"TI\"]\) as elements specified by \!\(\*StyleBox[\"elems\", \"TI\"]\)."
Export::usage = "\!\(\*RowBox[{\"Export\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).\\!\\(\\*StyleBox[\\\"ext\\\",\\\"TI\\\"]\\)\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) exports data to a file, converting it to the format corresponding to the file extension \!\(\*StyleBox[\"ext\", \"TI\"]\). \n\!\(\*RowBox[{\"Export\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) exports data in the specified format.\n\!\(\*RowBox[{\"Export\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"exprs\", \"TI\"], \",\", StyleBox[\"elems\", \"TI\"]}], \"]\"}]\) exports data by treating \!\(\*StyleBox[\"exprs\", \"TI\"]\) as elements specified by \!\(\*StyleBox[\"elems\", \"TI\"]\)."
ExpressionCell::usage = "\!\(\*RowBox[{\"ExpressionCell\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives an expression cell that can appear in a \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) notebook.\n\!\(\*RowBox[{\"ExpressionCell\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives an expression cell with the specified style."
Expression::usage = "Expression is a symbol that represents an ordinary \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) expression in Read and related functions. "
ExpToTrig::usage = "\!\(\*RowBox[{\"ExpToTrig\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts exponentials in \!\(\*StyleBox[\"expr\", \"TI\"]\) to trigonometric functions. "
Exp::usage = "\!\(\*RowBox[{\"Exp\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the exponential of \!\(\*StyleBox[\"z\", \"TI\"]\). "
ExtendedGCD::usage = "\!\(\*RowBox[{\"ExtendedGCD\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the extended greatest common divisor of the integers \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
Extension::usage = "Extension is an option for various polynomial and algebraic functions that specifies generators for the algebraic number field to be used. "
ExtentElementFunction::usage = "ExtentElementFunction is an option to DiscretePlot and DiscretePlot3D that gives a function to use to generate the primitives for rendering each extent element. "
ExtentMarkers::usage = "ExtentMarkers is an option to DiscretePlot and DiscretePlot3D that specifies markers to draw at extent boundaries. "
ExtentSize::usage = "ExtentSize is an option to DiscretePlot and DiscretePlot3D that specifies how far to extend out from each plot point. "
ExternalBundle::usage = "\!\(\*RowBox[{\"ExternalBundle\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", StyleBox[SubscriptBox[StyleBox[\"obj\", \"TI\"], \"1\"], \"TI\"]}], \",\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a bundle of resources to be externally deployed as named URLs, functions, etc. \n\!\(\*RowBox[{\"ExternalBundle\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"11\", \"TR\"]], \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a nested bundle of resources."
ExternalDataCharacterEncoding::usage = "ExternalDataCharacterEncoding is a global option that specifies the character encoding used in reading and writing plain text data outside of \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\)."
ExternalOptions::usage = "ExternalOptions is an option for EmbedCode and related functions that gives options specific to the external environment or language used."
ExternalTypeSignature::usage = "ExternalTypeSignature is an option for EmbedCode that gives rules specifying the mapping to external types in an embedded code."
ExtractArchive::usage = "\!\(\*RowBox[{\"ExtractArchive\", \"[\", StyleBox[\"file\", \"TI\"], \"]\"}]\) expands an archive \!\(\*StyleBox[\"file\", \"TI\"]\), saving its content into the current directory.\n\!\(\*RowBox[{\"ExtractArchive\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"dir\", \"TI\"]}], \"]\"}]\) saves the content of an archive \!\(\*StyleBox[\"file\", \"TI\"]\) into directory \!\(\*StyleBox[\"dir\", \"TI\"]\).\n\!\(\*RowBox[{\"ExtractArchive\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"dir\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) extracts only files whose names match \!\(\*StyleBox[\"pattern\", \"TI\"]\)."
Extract::usage = "\!\(\*RowBox[{\"Extract\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) extracts the part of \!\(\*StyleBox[\"expr\", \"TI\"]\) at the position specified by \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Extract\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) extracts a list of parts of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Extract\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) extracts parts of \!\(\*StyleBox[\"expr\", \"TI\"]\), wrapping each of them with head \!\(\*StyleBox[\"h\", \"TI\"]\) before evaluation. \n\!\(\*RowBox[{\"Extract\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) represents an operator form of Extract that can be applied to an expression."
ExtremeValueDistribution::usage = "\!\(\*RowBox[{\"ExtremeValueDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents an extreme value distribution with location parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"ExtremeValueDistribution\", \"[\", \"]\"}]\) represents an extreme value distribution with location parameter 0 and scale parameter 1."
FaceForm::usage = "\!\(\*RowBox[{\"FaceForm\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that faces of polygons and other filled graphics objects are to be drawn using the graphics directive or list of directives \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"FaceForm\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"gback\", \"TI\"]}], \"]\"}]\) specifies that the front faces of three-dimensional polygons should be drawn with directives \!\(\*StyleBox[\"g\", \"TI\"]\), and the backs with directives \!\(\*StyleBox[\"gback\", \"TI\"]\). "
FaceGridsStyle::usage = "FaceGridsStyle is an option for 3D graphics functions that specifies how face grids should be rendered."
FaceGrids::usage = "FaceGrids is an option for three-dimensional graphics functions that specifies grid lines to draw on the faces of the bounding box. "
Factorial2::usage = "\!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \"!!\"}]\) gives the double factorial of \!\(\*StyleBox[\"n\", \"TI\"]\). "
FactorialMomentGeneratingFunction::usage = "\!\(\*RowBox[{\"FactorialMomentGeneratingFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the factorial moment-generating function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variable \!\(\*StyleBox[\"t\", \"TI\"]\). \n\!\(\*RowBox[{\"FactorialMomentGeneratingFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the factorial moment-generating function for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variables \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. "
FactorialMoment::usage = "\!\(\*RowBox[{\"FactorialMoment\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) moment of the elements in the \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"FactorialMoment\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) moment of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"FactorialMoment\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) represents the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) factorial moment. "
FactorialPower::usage = "\!\(\*RowBox[{\"FactorialPower\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the factorial power \!\(\*SuperscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{\"(\", StyleBox[\"n\", \"TI\"], \")\"}]]\). \n\!\(\*RowBox[{\"FactorialPower\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) gives the step-\!\(\*StyleBox[\"h\", \"TI\"]\) factorial power \!\(\*SuperscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{\"(\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", \" \", StyleBox[\"h\", \"TI\"]}], \")\"}]]\)."
Factorial::usage = "\!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \"!\"}]\) gives the factorial of \!\(\*StyleBox[\"n\", \"TI\"]\). "
FactorInteger::usage = "\!\(\*RowBox[{\"FactorInteger\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a list of the prime factors of the integer \!\(\*StyleBox[\"n\", \"TI\"]\), together with their exponents. \n\!\(\*RowBox[{\"FactorInteger\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) does partial factorization, pulling out at most \!\(\*StyleBox[\"k\", \"TI\"]\) distinct factors."
FactorList::usage = "\!\(\*RowBox[{\"FactorList\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) gives a list of the factors of a polynomial, together with their exponents. "
FactorSquareFreeList::usage = "\!\(\*RowBox[{\"FactorSquareFreeList\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) gives a list of square\[Hyphen]free factors of a polynomial, together with their exponents. "
FactorSquareFree::usage = "\!\(\*RowBox[{\"FactorSquareFree\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) pulls out any multiple factors in a polynomial. "
FactorTermsList::usage = "\!\(\*RowBox[{\"FactorTermsList\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) gives a list in which the first element is the overall numerical factor in \!\(\*StyleBox[\"poly\", \"TI\"]\), and the second element is the polynomial with the overall factor removed.\n\!\(\*RowBox[{\"FactorTermsList\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of factors of \!\(\*StyleBox[\"poly\", \"TI\"]\). The first element in the list is the overall numerical factor. The second element is a factor that does not depend on any of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). Subsequent elements are factors which depend on progressively more of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
FactorTerms::usage = "\!\(\*RowBox[{\"FactorTerms\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) pulls out any overall numerical factor in \!\(\*StyleBox[\"poly\", \"TI\"]\). \n\!\(\*RowBox[{\"FactorTerms\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) pulls out any overall factor in \!\(\*StyleBox[\"poly\", \"TI\"]\) that does not depend on \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"FactorTerms\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) pulls out any overall factor in \!\(\*StyleBox[\"poly\", \"TI\"]\) that does not depend on any of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
Factor::usage = "\!\(\*RowBox[{\"Factor\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) factors a polynomial over the integers. \n\!\(\*RowBox[{\"Factor\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) factors a polynomial modulo a prime \!\(\*StyleBox[\"p\", \"TI\"]\). \n\!\(\*RowBox[{\"Factor\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"Extension\", \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]}], \"]\"}]\) factors a polynomial allowing coefficients that are rational combinations of the algebraic numbers \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
FailureAction::usage = "FailureAction is an option to Query and related functions that determines what should happen when a failure or message is generated."
FailureDistribution::usage = "\!\(\*RowBox[{\"FailureDistribution\", \"[\", RowBox[{StyleBox[\"bexpr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the failure distribution for a system with events \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) having reliability distribution \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) where the top event occurs when the Boolean expression \!\(\*StyleBox[\"bexpr\", \"TI\"]\) is True and event \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) has occurred when \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is True."
FailureQ::usage = "\!\(\*RowBox[{\"FailureQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) has head Failure or is equal to $Failed or $Aborted."
Failure::usage = "\!\(\*RowBox[{\"Failure\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"tag\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"assoc\", \"TI\"]}], \"]\"}]\) represents a failure of a type indicated by \!\(\*StyleBox[\"tag\", \"TI\"]\), with details given by the association \!\(\*StyleBox[\"assoc\", \"TI\"]\)."
False::usage = "False is the symbol for the Boolean value false. "
FareySequence::usage = "\!\(\*RowBox[{\"FareySequence\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) generates the Farey sequence of order \!\(\*StyleBox[\"n\", \"TI\"]\)."
FARIMAProcess::usage = "\!\(\*RowBox[{\"FARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents an autoregressive fractionally integrated moving-average process \!\(\*RowBox[{StyleBox[\"y\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\) such that its \!\(\*StyleBox[\"d\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) difference is an \!\(\*RowBox[{RowBox[{\"ARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]], \",\", StyleBox[\"v\", \"TI\"]}]}]}]}], \"]\"}]\).\n\!\(\*RowBox[{\"FARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a vector autoregressive fractionally integrated moving-average process \!\(\*RowBox[{\"(\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \" \", \",\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}]}], \")\"}]\) such that its \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"d\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) difference is a vector ARMAProcess.\n\!\(\*RowBox[{\"FARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a vector autoregressive fractionally integrated moving-average process \!\(\*RowBox[{\"(\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \" \", \",\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}]}], \")\"}]\) such that its \!\(\*RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) difference is a vector ARMAProcess."
FeatureNames::usage = "FeatureNames is an option for machine learning functions such as Classify or Predict that specifies names of features."
FeatureTypes::usage = "FeatureTypes is an option for machine learning functions such as Classify or Predict that specifies how features should be interpreted."
FeedbackLinearize::usage = "\!\(\*RowBox[{\"FeedbackLinearize\", \"[\", StyleBox[\"asys\", \"TI\"], \"]\"}]\) input-output linearizes the AffineStateSpaceModel \!\(\*StyleBox[\"asys\", \"TI\"]\) by state transformation and feedback.\n\!\(\*RowBox[{\"FeedbackLinearize\", \"[\", RowBox[{StyleBox[\"asys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) specifies the new states \!\(\*StyleBox[\"z\", \"TI\"]\) and the new control inputs \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"FeedbackLinearize\", \"[\", RowBox[{StyleBox[\"asys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) computes the property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\"."
FeedbackSectorStyle::usage = "FeedbackSectorStyle is an option to NyquistPlot that specifies the style in which graphics of FeedbackSector should be drawn."
FeedbackSector::usage = "FeedbackSector is an option to NyquistPlot that specifies the sector limits of the nonlinearity in the feedback. "
FeedbackType::usage = "FeedbackType is an option for some control system functions that specifies the feedback type."
FetalGrowthData::usage = "\!\(\*RowBox[{\"FetalGrowthData\", \"[\", StyleBox[\"age\", \"TI\"], \"]\"}]\) returns the values for all properties of fetal development for the specified age of the fetus.\n\!\(\*RowBox[{\"FetalGrowthData\", \"[\", RowBox[{StyleBox[\"age\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) returns the value for a property of fetal development for the specified age.\n\!\(\*RowBox[{\"FetalGrowthData\", \"[\", RowBox[{StyleBox[\"age\", \"TI\"], \",\", StyleBox[\"index\", \"TI\"]}], \"]\"}]\) returns the values for all properties of fetal development at the specified age and percentile.\n\!\(\*RowBox[{\"FetalGrowthData\", \"[\", RowBox[{StyleBox[\"age\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"index\", \"TI\"]}], \"]\"}]\) returns the value for a property at the specified age and percentile."
Fibonacci::usage = "\!\(\*RowBox[{\"Fibonacci\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Fibonacci number \!\(\*SubscriptBox[StyleBox[\"F\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"Fibonacci\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Fibonacci polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"F\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
Fibonorial::usage = "\!\(\*RowBox[{\"Fibonorial\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the fibonorial \!\(\*SubscriptBox[RowBox[{StyleBox[\"n\", \"TI\"], \"!\"}], StyleBox[\"F\", \"TI\"]]\)."
FieldHintStyle::usage = "FieldHintStyle is an option for InputField that specifies the style to use for displaying the field hint."
FieldHint::usage = "FieldHint is an option for InputField that specifies contents to display when the input field is empty."
FieldMasked::usage = "FieldMasked is an option to InputField that determines whether to mask user input."
FieldSize::usage = "FieldSize is an option for InputField, PopupMenu, and related functions that specifies the size of the field allowed for input or contents. "
FileBaseName::usage = "\!\(\*RowBox[{\"FileBaseName\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the base name for a file without its extension."
FileByteCount::usage = "\!\(\*RowBox[{\"FileByteCount\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the number of bytes in a file. "
FileDate::usage = "\!\(\*RowBox[{\"FileDate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the date and time at which a file was last modified. \n\!\(\*RowBox[{\"FileDate\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives information on the specified type of date associated with a file."
FileExistsQ::usage = "\!\(\*RowBox[{\"FileExistsQ\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives True if the file with the specified name exists, and gives False otherwise."
FileExtension::usage = "\!\(\*RowBox[{\"FileExtension\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the file extension for a file name."
FileFormat::usage = "\!\(\*RowBox[{\"FileFormat\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) attempts to determine what Import format could be used to import the file corresponding to \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\". "
FileHash::usage = "\!\(\*RowBox[{\"FileHash\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives an integer hash code for the contents of the specified file.\n\!\(\*RowBox[{\"FileHash\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives an integer hash of the specified type."
FileNameDepth::usage = "\!\(\*RowBox[{\"FileNameDepth\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the number of path elements in the file name \"\!\(\*\nStyleBox[\"file\", \"TI\"]\)\"."
FileNameDialogSettings::usage = "\!\(\*RowBox[{\"FileNameDialogSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{StyleBox[\"opt\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}], \"}\"}]}]\) is a global option that specifies settings for the \!\(\*StyleBox[\"Insert File Path\", \"DialogElementName\"]\) dialog box."
FileNameDrop::usage = "\!\(\*RowBox[{\"FileNameDrop\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) drops the first \!\(\*StyleBox[\"n\", \"TI\"]\) path elements in the file name \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FileNameDrop\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) drops the last \!\(\*StyleBox[\"n\", \"TI\"]\) path elements in the file name \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FileNameDrop\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) drops elements \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) in the file name \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FileNameDrop\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) drops the last path element in the file name \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\"."
FileNameJoin::usage = "\!\(\*RowBox[{\"FileNameJoin\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) joins the \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) together into a file name suitable for your current operating system. "
FileNameSetter::usage = "\!\(\*RowBox[{\"FileNameSetter\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) represents a file name setter which displays as a \!\(\*StyleBox[\"Browse\", \"MenuName\"]\) button and when clicked brings up a system file opening dialog, starting from the location corresponding to \!\(\*StyleBox[\"name\", \"TI\"]\). \n\!\(\*RowBox[{\"FileNameSetter\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}], \"]\"}]\) uses the dynamically updated current value of \!\(\*StyleBox[\"name\", \"TI\"]\), with the value of \!\(\*StyleBox[\"name\", \"TI\"]\) being reset if a different file is chosen.\n\!\(\*RowBox[{\"FileNameSetter\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"\\\"Save\\\"\",ShowStringCharacters->True]}], \"]\"}]\) brings up a file saving dialog.\n\!\(\*RowBox[{\"FileNameSetter\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"spec\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) looks for files of types \!\(\*SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with names matching the file patterns \!\(\*SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"ij\", \"TI\"]]\). "
FileNameSplit::usage = "\!\(\*RowBox[{\"FileNameSplit\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) splits a file name into a list of parts."
FileNames::usage = "\!\(\*RowBox[{\"FileNames\", \"[\", \"]\"}]\) lists all files in the current working directory. \n\!\(\*RowBox[{\"FileNames\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) lists all files in the current working directory whose names match the string pattern \!\(\*StyleBox[\"form\", \"TI\"]\). \n\!\(\*RowBox[{\"FileNames\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) lists all files whose names match any of the \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"FileNames\", \"[\", RowBox[{StyleBox[\"forms\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) lists files with names matching \!\(\*StyleBox[\"forms\", \"TI\"]\) in any of the directories \!\(\*SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"FileNames\", \"[\", RowBox[{StyleBox[\"forms\", \"TI\"], \",\", StyleBox[\"dirs\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) includes files that are in subdirectories up to \!\(\*StyleBox[\"n\", \"TI\"]\) levels down. "
FileNameTake::usage = "\!\(\*RowBox[{\"FileNameTake\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the last path element in the file name \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FileNameTake\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"n\", \"TI\"]\) path elements in the file name \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FileNameTake\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) gives the last \!\(\*StyleBox[\"n\", \"TI\"]\) path elements in the file name \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FileNameTake\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives elements \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) in the file name \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\"."
FilePrint::usage = "\!\(\*RowBox[{\"FilePrint\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) prints out the raw textual contents of \!\(\*StyleBox[\"file\", \"TI\"]\)."
FileTemplateApply::usage = "\!\(\*RowBox[{\"FileTemplateApply\", \"[\", StyleBox[\"template\", \"TI\"], \"]\"}]\) applies a template, evaluating all template elements it contains, and then writes the result to a temporary file, whose name is returned.\n\!\(\*RowBox[{\"FileTemplateApply\", \"[\", RowBox[{StyleBox[\"template\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) applies a template, using \!\(\*StyleBox[\"args\", \"TI\"]\) to fill its slots, and then writes the result to a temporary file.\n\!\(\*RowBox[{\"FileTemplateApply\", \"[\", RowBox[{StyleBox[\"template\", \"TI\"], \",\", StyleBox[\"output\", \"TI\"]}], \"]\"}]\) applies a template, writing the results to the file represented by \!\(\*StyleBox[\"output\", \"TI\"]\).\n\!\(\*RowBox[{\"FileTemplateApply\", \"[\", RowBox[{StyleBox[\"template\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"], \",\", StyleBox[\"output\", \"TI\"]}], \"]\"}]\) applies a template, using \!\(\*StyleBox[\"args\", \"TI\"]\) to fill its slots, and then writes the result to the file represented by \!\(\*StyleBox[\"output\", \"TI\"]\)."
FileTemplate::usage = "\!\(\*RowBox[{\"FileTemplate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) yields a TemplateObject that represents a file template to be applied using functions like TemplateApply."
FileType::usage = "\!\(\*RowBox[{\"FileType\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the type of a file, typically File, Directory, or None. "
FilledCurveBoxOptions::usage = "\!\(\*RowBox[{FilledCurveBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for FilledCurveBox objects."
FilledCurve::usage = "\!\(\*RowBox[{\"FilledCurve\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"segment\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"segment\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a filled curve consisting of \!\(\*SubscriptBox[StyleBox[\"segment\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) followed by \!\(\*SubscriptBox[StyleBox[\"segment\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) etc. \n\!\(\*RowBox[{\"FilledCurve\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a list of separate filled component curves \!\(\*SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc. "
FillingStyle::usage = "FillingStyle is an option for ListPlot, Plot, Plot3D, and related functions that specifies the default style of filling to be used. "
FillingTransform::usage = "\!\(\*RowBox[{\"FillingTransform\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a version of \!\(\*StyleBox[\"image\", \"TI\"]\) with all extended minima filled.\n\!\(\*RowBox[{\"FillingTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"]}], \"]\"}]\) fills extended minima in regions where at least one corresponding element of marker is nonzero.\n\!\(\*RowBox[{\"FillingTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) fills only extended minima of depth \!\(\*StyleBox[\"h\", \"TI\"]\) or less."
Filling::usage = "Filling is an option for ListPlot, Plot, Plot3D, and related functions that specifies what filling to add under points, curves, and surfaces. "
FilterRules::usage = "\!\(\*RowBox[{\"FilterRules\", \"[\", RowBox[{StyleBox[\"rules\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) filters the list \!\(\*StyleBox[\"rules\", \"TI\"]\) by picking out only those rules whose left-hand sides match \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"FilterRules\", \"[\", RowBox[{StyleBox[\"rules\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) picks out rules whose left-hand sides match any of the \!\(\*SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
FinancialBond::usage = "\!\(\*RowBox[{\"FinancialBond\", \"[\", RowBox[{StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"ambientparams\", \"TI\"]}], \"]\"}]\) gives the value of a financial bond instrument.\n\!\(\*RowBox[{\"FinancialBond\", \"[\", RowBox[{StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"ambientparams\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], StyleBox[\"]\", \"TI\"]}]\) computes the specified property \!\(\*StyleBox[\"prop\", \"TI\"]\)."
FinancialData::usage = "\!\(\*RowBox[{\"FinancialData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the last known price or value for the financial entity specified by \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FinancialData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"start\", \"TI\"]}], \"]\"}]\) gives a list of dates and daily closing values for \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" from \!\(\*StyleBox[\"start\", \"TI\"]\) until the current date.\n\!\(\*RowBox[{\"FinancialData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives a list of dates and daily closing values for dates from \!\(\*StyleBox[\"start\", \"TI\"]\) to \!\(\*StyleBox[\"end\", \"TI\"]\).\n\!\(\*RowBox[{\"FinancialData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"], \",\", StyleBox[\"period\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives a list of dates and prices for the specified periods lying between \!\(\*StyleBox[\"start\", \"TI\"]\) and \!\(\*StyleBox[\"end\", \"TI\"]\).\n\!\(\*RowBox[{\"FinancialData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the financial entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\". \n\!\(\*RowBox[{\"FinancialData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of dates and values of a property for a sequence of dates or periods. "
FinancialDerivative::usage = "\!\(\*RowBox[{\"FinancialDerivative\", \"[\", RowBox[{StyleBox[\"instrument\", \"TI\"], \",\", StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"ambientparams\", \"TI\"]}], \"]\"}]\) gives the value of the specified financial instrument.\n\!\(\*RowBox[{\"FinancialDerivative\", \"[\", RowBox[{StyleBox[\"instrument\", \"TI\"], \",\", StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"ambientparams\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) computes the specified property \!\(\*StyleBox[\"prop\", \"TI\"]\)."
FinancialIndicator::usage = "\!\(\*RowBox[{\"FinancialIndicator\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"ind\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", SubscriptBox[StyleBox[\"par\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"par\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a financial indicator \"\!\(\*\nStyleBox[\"ind\", \"TI\"]\)\" with parameters \!\(\*SubscriptBox[StyleBox[\"par\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"par\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc. "
FindArgMax::usage = "\!\(\*RowBox[{\"FindArgMax\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the position \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) of a local maximum of \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"FindArgMax\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the position \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) of a local maximum of \!\(\*StyleBox[\"f\", \"TI\"]\), found by a search starting from the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\). \n\!\(\*RowBox[{\"FindArgMax\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the position \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) of a local maximum of a function of several variables. \n\!\(\*RowBox[{\"FindArgMax\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the position of a local maximum subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\).\n\!\(\*RowBox[{\"FindArgMax\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts from a point within the region defined by the constraints."
FindArgMin::usage = "\!\(\*RowBox[{\"FindArgMin\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the position \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) of a local minimum of \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"FindArgMin\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the position \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) of a local minimum of \!\(\*StyleBox[\"f\", \"TI\"]\), found by a search starting from the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\). \n\!\(\*RowBox[{\"FindArgMin\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the position \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) of a local minimum of a function of several variables. \n\!\(\*RowBox[{\"FindArgMin\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the position of a local minimum subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\).\n\!\(\*RowBox[{\"FindArgMin\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts from a point within the region defined by the constraints."
FindClique::usage = "\!\(\*RowBox[{\"FindClique\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a largest clique in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds a clique containing at most \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[RowBox[{\"{\", \"n\", \"}\"}], \"TI\"]}], \"]\"}]\) finds a clique containing exactly \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) finds a clique containing between \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) vertices.\n\!\(\*RowBox[{\"FindClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"nspec\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"s\", \"TI\"]\) cliques.\n\!\(\*RowBox[{\"FindClique\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds cliques that include the vertex \!\(\*StyleBox[\"v\", \"TI\"]\) only.\n\!\(\*RowBox[{\"FindClique\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindClusters::usage = "\!\(\*RowBox[{\"FindClusters\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) partitions the \!\(\*StyleBox[SubscriptBox[StyleBox[\"e\", \"TI\"], \"i\"], \"TI\"]\) into clusters of similar elements. \n\!\(\*RowBox[{\"FindClusters\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) returns the \!\(\*StyleBox[SubscriptBox[\"v\", \"i\"], \"TI\"]\) corresponding to the \!\(\*StyleBox[SubscriptBox[StyleBox[\"e\", \"TI\"], \"i\"], \"TI\"]\) in each cluster. \n\!\(\*RowBox[{\"FindClusters\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the same result. \n\!\(\*RowBox[{\"FindClusters\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) partitions the \!\(\*StyleBox[SubscriptBox[StyleBox[\"e\", \"TI\"], \"i\"], \"TI\"]\) into exactly \!\(\*StyleBox[\"n\", \"TI\"]\) clusters. "
FindCurvePath::usage = "\!\(\*RowBox[{\"FindCurvePath\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives an ordering of the \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) that corresponds to one or more smooth curves."
FindCycle::usage = "\!\(\*RowBox[{\"FindCycle\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a cycle in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindCycle\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds a cycle of length at most \!\(\*StyleBox[\"k\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindCycle\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"k\", \"TI\"], \"}\"}]}], \"]\"}]\) finds a cycle of length exactly \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"FindCycle\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) finds a cycle of length between \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindCycle\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"kspec\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"s\", \"TI\"]\) cycles.\n\!\(\*RowBox[{\"FindCycle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds cycles that include the vertex \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"FindCycle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindDevices::usage = "\!\(\*RowBox[{\"FindDevices\", \"[\", \"]\"}]\) searches for available devices on your computer system.\n\!\(\*RowBox[{\"FindDevices\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) gives a list of devices in classes whose names match the string pattern \!\(\*StyleBox[\"form\", \"TI\"]\).\n\!\(\*RowBox[{\"FindDevices\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of devices in classes whose names match any of the \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindDevices\", \"[\", RowBox[{StyleBox[\"forms\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns at most \!\(\*StyleBox[\"n\", \"TI\"]\) devices."
FindDistributionParameters::usage = "\!\(\*RowBox[{\"FindDistributionParameters\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) finds the parameter estimates for the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) from \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"FindDistributionParameters\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{StyleBox[\"p\", \"TI\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds the parameters \!\(\*StyleBox[\"p\", \"TI\"]\), \!\(\*StyleBox[\"q\", \"TI\"]\), \[Ellipsis] with starting values \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \[Ellipsis]."
FindDistribution::usage = "\!\(\*RowBox[{\"FindDistribution\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) finds a simple functional form to fit the distribution of \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"FindDistribution\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds up to \!\(\*StyleBox[\"n\", \"TI\"]\) best distributions.\n\!\(\*RowBox[{\"FindDistribution\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) returns up to \!\(\*StyleBox[\"n\", \"TI\"]\) best distributions associated with property \!\(\*StyleBox[\"prop\", \"TI\"]\).\n\!\(\*RowBox[{\"FindDistribution\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"prop\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"prop\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns up to \!\(\*StyleBox[\"n\", \"TI\"]\) best distributions associated with properties \!\(\*SubscriptBox[StyleBox[\"prop\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"prop\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc."
FindDivisions::usage = "\!\(\*RowBox[{\"FindDivisions\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds a list of about \!\(\*StyleBox[\"n\", \"TI\"]\) \"nice\" numbers that divide the interval around \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) into equally spaced parts. \n\!\(\*RowBox[{\"FindDivisions\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) makes the parts always have lengths that are integer multiples of \!\(\*StyleBox[\"dx\", \"TI\"]\). \n\!\(\*RowBox[{\"FindDivisions\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds successive subdivisions into about \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] parts. \n\!\(\*RowBox[{\"FindDivisions\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dx\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dx\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses spacings that are forced to be multiples of \!\(\*SubscriptBox[StyleBox[\"dx\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dx\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. \n\!\(\*RowBox[{\"FindDivisions\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dx\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dx\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \"]\"}]\) gives all numbers in the interval that are multiples of the \!\(\*SubscriptBox[StyleBox[\"dx\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
FindEdgeCover::usage = "\!\(\*RowBox[{\"FindEdgeCover\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds an edge cover of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with a minimum number of edges.\n\!\(\*RowBox[{\"FindEdgeCover\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindEdgeCut::usage = "\!\(\*RowBox[{\"FindEdgeCut\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a smallest edge cut of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindEdgeCut\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds a smallest \!\(\*StyleBox[\"s\", \"TI\"]\)-\!\(\*StyleBox[\"t\", \"TI\"]\) edge cut of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindEdgeCut\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindEdgeIndependentPaths::usage = "\!\(\*RowBox[{\"FindEdgeIndependentPaths\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"k\", \"TI\"]\) edge-independent paths from vertex \!\(\*StyleBox[\"s\", \"TI\"]\) to vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindEdgeIndependentPaths\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindEulerianCycle::usage = "\!\(\*RowBox[{\"FindEulerianCycle\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds an Eulerian cycle in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindEulerianCycle\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"k\", \"TI\"]\) Eulerian cycles.\n\!\(\*RowBox[{\"FindEulerianCycle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindFaces::usage = "\!\(\*RowBox[{\"FindFaces\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) attempts to find human faces in \!\(\*StyleBox[\"image\", \"TI\"]\) and returns a list of bounding boxes.\n\!\(\*RowBox[{\"FindFaces\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) finds faces whose approximate pixel widths range from \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\)."
FindFile::usage = "\!\(\*RowBox[{\"FindFile\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) finds the file with the specified name that would be loaded by \!\(\*RowBox[{\"Get\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) and related functions."
FindFit::usage = "\!\(\*RowBox[{\"FindFit\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pars\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) finds numerical values of the parameters \!\(\*StyleBox[\"pars\", \"TI\"]\) that make \!\(\*StyleBox[\"expr\", \"TI\"]\) give a best fit to \!\(\*StyleBox[\"data\", \"TI\"]\) as a function of \!\(\*StyleBox[\"vars\", \"TI\"]\). \n\!\(\*RowBox[{\"FindFit\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"pars\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) finds a best fit subject to the parameter constraints \!\(\*StyleBox[\"cons\", \"TI\"]\)."
FindFormula::usage = "\!\(\*RowBox[{\"FindFormula\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) finds a pure function that approximates \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"FindFormula\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) finds a symbolic function of the variable \!\(\*StyleBox[\"x\", \"TI\"]\) that approximates \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"FindFormula\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds up to \!\(\*StyleBox[\"n\", \"TI\"]\) functions that approximate \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"FindFormula\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) returns up to \!\(\*StyleBox[\"n\", \"TI\"]\) best functions associated with property \!\(\*StyleBox[\"prop\", \"TI\"]\).\n\!\(\*RowBox[{\"FindFormula\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"prop\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"prop\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \"\[Ellipsis]\"}], \"}\"}]}], \"]\"}]\) returns up to \!\(\*StyleBox[\"n\", \"TI\"]\) best functions associated with properties \!\(\*SubscriptBox[StyleBox[\"prop\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"prop\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc."
FindFundamentalCycles::usage = "\!\(\*RowBox[{\"FindFundamentalCycles\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds fundamental cycles of the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindGeneratingFunction::usage = "\!\(\*RowBox[{\"FindGeneratingFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) attempts to find a simple generating function in \!\(\*StyleBox[\"x\", \"TI\"]\) whose \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) series coefficient is \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindGeneratingFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) attempts to find a simple generating function whose \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) series coefficient is \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
FindGeoLocation::usage = "\!\(\*RowBox[{\"FindGeoLocation\", \"[\", \"]\"}]\) attempts to find the current geo location of your computer.\n\!\(\*RowBox[{\"FindGeoLocation\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"ip\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives an estimate of the geo location associated with the IP address given.\n\!\(\*RowBox[{\"FindGeoLocation\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"address\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) attempts to find the geo location associated with the street address given.\n\!\(\*RowBox[{\"FindGeoLocation\", \"[\", StyleBox[\"entity\", \"TI\"], \"]\"}]\) gives the geo location associated with the specified entity."
FindGeometricTransform::usage = "\!\(\*RowBox[{\"FindGeometricTransform\", \"[\", RowBox[{SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) finds a geometric transformation that aligns positions specified by \!\(\*SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with \!\(\*SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), returning the alignment error together with the transformation function.\n\!\(\*RowBox[{\"FindGeometricTransform\", \"[\", RowBox[{StyleBox[\"ref\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds geometric transformations that align each of the \!\(\*SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with \!\(\*StyleBox[\"ref\", \"TI\"]\). \n\!\(\*RowBox[{\"FindGeometricTransform\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) finds geometric transformations that align each of the \!\(\*SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with \!\(\*SubscriptBox[StyleBox[\"pts\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)."
FindGraphCommunities::usage = "\!\(\*RowBox[{\"FindGraphCommunities\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds communities in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindGraphCommunities\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindGraphIsomorphism::usage = "\!\(\*RowBox[{\"FindGraphIsomorphism\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) finds an isomorphism that maps the graph \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) by renaming vertices.\n\!\(\*RowBox[{\"FindGraphIsomorphism\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"n\", \"TI\"]\) isomorphisms. \n\!\(\*RowBox[{\"FindGraphIsomorphism\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindGraphPartition::usage = "\!\(\*RowBox[{\"FindGraphPartition\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a partition of vertices of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindGraphPartition\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a partition of vertices into \!\(\*StyleBox[\"k\", \"TI\"]\) approximately equal-size parts.\n\!\(\*RowBox[{\"FindGraphPartition\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives a partition of vertices into parts with sizes \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \[Ellipsis], \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindGraphPartition\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives a partition of vertices into parts with approximate size proportions \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\), \[Ellipsis], \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindGraphPartition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindHamiltonianCycle::usage = "\!\(\*RowBox[{\"FindHamiltonianCycle\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a Hamiltonian cycle in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindHamiltonianCycle\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"k\", \"TI\"]\) Hamiltonian cycles.\n\!\(\*RowBox[{\"FindHamiltonianCycle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindHamiltonianPath::usage = "\!\(\*RowBox[{\"FindHamiltonianPath\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a Hamiltonian path in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with the smallest total length.\n\!\(\*RowBox[{\"FindHamiltonianPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds a Hamiltonian path with the smallest total length from \!\(\*StyleBox[\"s\", \"TI\"]\) to \!\(\*StyleBox[\"t\", \"TI\"]\)."
FindHiddenMarkovStates::usage = "\!\(\*RowBox[{\"FindHiddenMarkovStates\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"hmm\", \"TI\"]}], \"]\"}]\) finds the most likely hidden states of the HiddenMarkovProcess \!\(\*StyleBox[\"hmm\", \"TI\"]\) corresponding to the emissions \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"FindHiddenMarkovStates\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"hmm\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) uses the given criterion \!\(\*StyleBox[\"crit\", \"TI\"]\) to find the hidden states."
FindIndependentEdgeSet::usage = "\!\(\*RowBox[{\"FindIndependentEdgeSet\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds an independent edge set of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with a maximum number of edges.\n\!\(\*RowBox[{\"FindIndependentEdgeSet\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindIndependentVertexSet::usage = "\!\(\*RowBox[{\"FindIndependentVertexSet\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds an independent vertex set of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with a maximum number of vertices.\n\!\(\*RowBox[{\"FindIndependentVertexSet\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds an independent vertex set with at most \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindIndependentVertexSet\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) finds an independent vertex set with exactly \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindIndependentVertexSet\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) finds an independent vertex set containing between \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) vertices.\n\!\(\*RowBox[{\"FindIndependentVertexSet\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"nspec\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"s\", \"TI\"]\) independent vertex sets.\n\!\(\*RowBox[{\"FindIndependentVertexSet\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds independent sets that include the vertex \!\(\*StyleBox[\"v\", \"TI\"]\) only.\n\!\(\*RowBox[{\"FindIndependentVertexSet\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindInstance::usage = "\!\(\*RowBox[{\"FindInstance\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) finds an instance of \!\(\*StyleBox[\"vars\", \"TI\"]\) that makes the statement \!\(\*StyleBox[\"expr\", \"TI\"]\) be True. \n\!\(\*RowBox[{\"FindInstance\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) finds an instance over the domain \!\(\*StyleBox[\"dom\", \"TI\"]\). Common choices of \!\(\*StyleBox[\"dom\", \"TI\"]\) are Complexes, Reals, Integers, and Booleans. \n\!\(\*RowBox[{\"FindInstance\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds \!\(\*StyleBox[\"n\", \"TI\"]\) instances. "
FindIntegerNullVector::usage = "\!\(\*RowBox[{\"FindIntegerNullVector\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) finds a list of integers \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) such that \!\(\*RowBox[{RowBox[{RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], \"1\"], \" \", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}], \"+\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], \"2\"], \" \", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"]}], \"+\", \"\[CenterEllipsis]\", \"+\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]], \" \", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]}], \"\[LongEqual]\", \"0\"}]\). \n\!\(\*RowBox[{\"FindIntegerNullVector\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) finds a list of integers \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with \!\(\*RowBox[{RowBox[{\"\[LeftDoubleBracketingBar]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], \"1\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"\[RightDoubleBracketingBar]\"}], \"\[LessEqual]\", StyleBox[\"d\", \"TI\"]}]\) such that \!\(\*RowBox[{RowBox[{RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], \"1\"], \" \", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}], \"+\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], \"2\"], \" \", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"]}], \"+\", \"\[CenterEllipsis]\", \"+\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]], \" \", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]}], \"\[LongEqual]\", \"0\"}]\). "
FindKClan::usage = "\!\(\*RowBox[{\"FindKClan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds a largest \!\(\*StyleBox[\"k\", \"TI\"]\)-clan in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindKClan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-clan containing at most \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindKClan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-clan containing exactly \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindKClan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-clan containing between \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) vertices.\n\!\(\*RowBox[{\"FindKClan\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"nspec\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"s\", \"TI\"]\) \!\(\*StyleBox[\"k\", \"TI\"]\)-clans.\n\!\(\*RowBox[{\"FindKClan\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds \!\(\*StyleBox[\"k\", \"TI\"]\)-clans that include the vertex \!\(\*StyleBox[\"v\", \"TI\"]\) only.\n\!\(\*RowBox[{\"FindKClan\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindKClique::usage = "\!\(\*RowBox[{\"FindKClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds a largest \!\(\*StyleBox[\"k\", \"TI\"]\)-clique in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindKClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-clique containing at most \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindKClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-clique containing exactly \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindKClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-clique containing between \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) vertices.\n\!\(\*RowBox[{\"FindKClique\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"nspec\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"s\", \"TI\"]\) \!\(\*StyleBox[\"k\", \"TI\"]\)-cliques.\n\!\(\*RowBox[{\"FindKClique\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds \!\(\*StyleBox[\"k\", \"TI\"]\)-cliques that include the vertex \!\(\*StyleBox[\"v\", \"TI\"]\) only.\n\!\(\*RowBox[{\"FindKClique\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindKClub::usage = "\!\(\*RowBox[{\"FindKClub\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds a largest \!\(\*StyleBox[\"k\", \"TI\"]\)-club in the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindKPlex::usage = "\!\(\*RowBox[{\"FindKPlex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds a largest \!\(\*StyleBox[\"k\", \"TI\"]\)-plex in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindKPlex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-plex containing at most \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindKPlex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-plex containing exactly \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"FindKPlex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) finds a \!\(\*StyleBox[\"k\", \"TI\"]\)-plex containing between \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) vertices.\n\!\(\*RowBox[{\"FindKPlex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"nspec\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"s\", \"TI\"]\) \!\(\*StyleBox[\"k\", \"TI\"]\)-plexes.\n\!\(\*RowBox[{\"FindKPlex\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds \!\(\*StyleBox[\"k\", \"TI\"]\)-plexes that include the vertex \!\(\*StyleBox[\"v\", \"TI\"]\) only.\n\!\(\*RowBox[{\"FindKPlex\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindLibrary::usage = "\!\(\*RowBox[{\"FindLibrary\", \"[\", StyleBox[\"lib\", \"TI\"], \"]\"}]\) finds a dynamic library that can be loaded by LibraryFunctionLoad."
FindLinearRecurrence::usage = "\!\(\*RowBox[{\"FindLinearRecurrence\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds if possible the minimal linear recurrence that generates \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"FindLinearRecurrence\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) finds if possible the linear recurrence of maximum order \!\(\*StyleBox[\"d\", \"TI\"]\) that generates \!\(\*StyleBox[\"list\", \"TI\"]\)."
FindList::usage = "\!\(\*RowBox[{\"FindList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a list of lines in the file that contain the specified string. \n\!\(\*RowBox[{\"FindList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of all lines that contain any of the specified strings. \n\!\(\*RowBox[{\"FindList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a list of lines containing the specified strings in any of the \!\(\*SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"FindList\", \"[\", RowBox[{StyleBox[\"files\", \"TI\"], \",\", StyleBox[\"text\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) includes only the first \!\(\*StyleBox[\"n\", \"TI\"]\) lines found. "
FindMaximumFlow::usage = "\!\(\*RowBox[{\"FindMaximumFlow\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds the maximum flow between source vertex \!\(\*StyleBox[\"s\", \"TI\"]\) and target vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in a graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMaximumFlow\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds the maximum flow between vertex indices \!\(\*StyleBox[\"s\", \"TI\"]\) and \!\(\*StyleBox[\"t\", \"TI\"]\) in a graph with edge capacity matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMaximumFlow\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds the maximum flow between multi-sources \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \[Ellipsis] and multi-targets \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"FindMaximumFlow\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"target\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FindMaximumFlow\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindMaximum::usage = "\!\(\*RowBox[{\"FindMaximum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) searches for a local maximum in \!\(\*StyleBox[\"f\", \"TI\"]\), starting from an automatically selected point.\n\!\(\*RowBox[{\"FindMaximum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) searches for a local maximum in \!\(\*StyleBox[\"f\", \"TI\"]\), starting from the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\). \n\!\(\*RowBox[{\"FindMaximum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) searches for a local maximum in a function of several variables. \n\!\(\*RowBox[{\"FindMaximum\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) searches for a local maximum subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMaximum\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts from a point within the region defined by the constraints."
FindMaxValue::usage = "\!\(\*RowBox[{\"FindMaxValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the value at a local maximum of \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMaxValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the value at a local maximum of \!\(\*StyleBox[\"f\", \"TI\"]\), found by a search starting from the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\). \n\!\(\*RowBox[{\"FindMaxValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the value at a local maximum of a function of several variables. \n\!\(\*RowBox[{\"FindMaxValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the value at a local maximum subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMaxValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts from a point within the region defined by the constraints."
FindMinimumCostFlow::usage = "\!\(\*RowBox[{\"FindMinimumCostFlow\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"sd\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sd\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds the minimum cost flow in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with \!\(\*SubscriptBox[StyleBox[\"sd\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"sd\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] vertex supplies or demands.\n\!\(\*RowBox[{\"FindMinimumCostFlow\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds the minimum cost maximum flow between source vertex \!\(\*StyleBox[\"s\", \"TI\"]\) and target vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in a graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMinimumCostFlow\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) finds the minimum cost flow between source \!\(\*StyleBox[\"s\", \"TI\"]\) and target \!\(\*StyleBox[\"t\", \"TI\"]\), with the required flow \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMinimumCostFlow\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds the minimum cost flow in a graph with cost matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMinimumCostFlow\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FindMinimumCostFlow\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindMinimumCut::usage = "\!\(\*RowBox[{\"FindMinimumCut\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the minimum cut of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMinimumCut\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindMinimum::usage = "\!\(\*RowBox[{\"FindMinimum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) searches for a local minimum in \!\(\*StyleBox[\"f\", \"TI\"]\), starting from an automatically selected point.\n\!\(\*RowBox[{\"FindMinimum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) searches for a local minimum in \!\(\*StyleBox[\"f\", \"TI\"]\), starting from the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\). \n\!\(\*RowBox[{\"FindMinimum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) searches for a local minimum in a function of several variables. \n\!\(\*RowBox[{\"FindMinimum\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) searches for a local minimum subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMinimum\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts from a point within the region defined by the constraints."
FindMinValue::usage = "\!\(\*RowBox[{\"FindMinValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the value at a local minimum of \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMinValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the value at a local minimum of \!\(\*StyleBox[\"f\", \"TI\"]\), found by a search starting from the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\). \n\!\(\*RowBox[{\"FindMinValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the value at a local minimum of a function of several variables. \n\!\(\*RowBox[{\"FindMinValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the value at a local minimum subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\).\n\!\(\*RowBox[{\"FindMinValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) starts from a point within the region defined by the constraints."
FindPath::usage = "\!\(\*RowBox[{\"FindPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds a path between vertex \!\(\*StyleBox[\"s\", \"TI\"]\) and vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds a path of length at most \!\(\*StyleBox[\"k\", \"TI\"]\) between vertex \!\(\*StyleBox[\"s\", \"TI\"]\) and vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"k\", \"TI\"], \"}\"}]}], \"]\"}]\) finds a path of length exactly \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"FindPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) finds a path of length between \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"kspec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"n\", \"TI\"]\) paths.\n\!\(\*RowBox[{\"FindPath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindPeaks::usage = "\!\(\*RowBox[{\"FindPeaks\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) gives positions and values of the detected peaks in \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"FindPeaks\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) finds peaks that survive Gaussian blurring up to scale \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"FindPeaks\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) finds peaks with minimum sharpness \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{\"FindPeaks\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds only peaks with values greater than \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"FindPeaks\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"s\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"t\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) uses different scales for thresholding sharpness and value."
FindPermutation::usage = "\!\(\*RowBox[{\"FindPermutation\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives a permutation that produces \!\(\*StyleBox[\"expr\", \"TI\"]\) by permuting \!\(\*RowBox[{\"Sort\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\).\n\!\(\*RowBox[{\"FindPermutation\", \"[\", RowBox[{StyleBox[SubscriptBox[StyleBox[RowBox[{\"e\", StyleBox[\"xpr\", \"TI\"]}]], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[\"expr\", StyleBox[\"2\", \"TR\"]], \"TI\"]}], \"]\"}]\) gives a permutation that converts \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) for two expressions that differ only in the order of their arguments."
FindPostmanTour::usage = "\!\(\*RowBox[{\"FindPostmanTour\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a Chinese postman tour in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) of minimal length.\n\!\(\*RowBox[{\"FindPostmanTour\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"k\", \"TI\"]\) Chinese postman tours. \n\!\(\*RowBox[{\"FindPostmanTour\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
FindProcessParameters::usage = "\!\(\*RowBox[{\"FindProcessParameters\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"proc\", \"TI\"]}], \"]\"}]\) finds the parameter estimates for the process \!\(\*StyleBox[\"proc\", \"TI\"]\) from \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"FindProcessParameters\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds the parameters \!\(\*StyleBox[\"p\", \"TI\"]\), \!\(\*StyleBox[\"q\", \"TI\"]\), \[Ellipsis] with starting values \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \[Ellipsis] ."
FindRoot::usage = "\!\(\*RowBox[{\"FindRoot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) searches for a numerical root of \!\(\*StyleBox[\"f\", \"TI\"]\), starting from the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\).\n\!\(\*RowBox[{\"FindRoot\", \"[\", RowBox[{RowBox[{StyleBox[\"lhs\", \"TI\"], \"==\", StyleBox[\"rhs\", \"TI\"]}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) searches for a numerical solution to the equation \!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"==\", StyleBox[\"rhs\", \"TI\"]}]\). \n\!\(\*RowBox[{\"FindRoot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) searches for a simultaneous numerical root of all the \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindRoot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) searches for a numerical solution to the simultaneous equations \!\(\*SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
FindSequenceFunction::usage = "\!\(\*RowBox[{\"FindSequenceFunction\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) attempts to find a simple function that yields the sequence \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]]\) when given successive integer arguments.\n\!\(\*RowBox[{\"FindSequenceFunction\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) attempts to find a simple function that yields \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) when given argument \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{RowBox[{RowBox[{\"FindSequenceFunction\", \"[\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]}], \"|>\"}], \"]\"}]\) gives a function that yields \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) when given argument \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindSequenceFunction\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a function that yields \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) when given argument \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindSequenceFunction\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the function applied to \!\(\*StyleBox[\"n\", \"TI\"]\)."
FindSettings::usage = "\!\(\*RowBox[{\"FindSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is a global option that specifies settings for the \!\(\*StyleBox[\"Find\", \"MenuName\"]\) dialog box."
FindShortestPath::usage = "\!\(\*RowBox[{\"FindShortestPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds the shortest path from source vertex \!\(\*StyleBox[\"s\", \"TI\"]\) to target vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindShortestPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", \"All\"}], \"]\"}]\) generates a \!\(\*RowBox[{\"ShortestPathFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied repeatedly to different \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"FindShortestPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"All\", \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) generates a \!\(\*RowBox[{\"ShortestPathFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied repeatedly to different \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{\"FindShortestPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", \"All\", \",\", \"All\"}], \"]\"}]\) generates a \!\(\*RowBox[{\"ShortestPathFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied to different \!\(\*StyleBox[\"s\", \"TI\"]\) and \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"FindShortestPath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
FindShortestTour::usage = "\!\(\*RowBox[{\"FindShortestTour\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) attempts to find an ordering of the \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that minimizes the total distance on a tour that visits all the \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) once.\n\!\(\*RowBox[{\"FindShortestTour\", \"[\", StyleBox[\"graph\", \"TI\"], \"]\"}]\) attempts to find an ordering of the vertices in \!\(\*StyleBox[\"graph\", \"TI\"]\) that minimizes the total length when visiting each vertex once.\n\!\(\*RowBox[{\"FindShortestTour\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds an ordering of the \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that minimizes the total distance on a path from \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"FindShortestTour\", \"[\", RowBox[{StyleBox[\"graph\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds an ordering of the vertices that minimizes the total length on a path from \!\(\*StyleBox[\"s\", \"TI\"]\) to \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"FindShortestTour\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
FindSpanningTree::usage = "\!\(\*RowBox[{\"FindSpanningTree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a spanning tree of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindSpanningTree\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds a spanning tree of the connected component of \!\(\*StyleBox[\"g\", \"TI\"]\) that includes the vertex \!\(\*StyleBox[\"v\", \"TI\"]\). \n\!\(\*RowBox[{\"FindSpanningTree\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
FindThreshold::usage = "\!\(\*RowBox[{\"FindThreshold\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds a global threshold value that partitions the intensity values in \!\(\*StyleBox[\"image\", \"TI\"]\) into two intervals."
Find::usage = "\!\(\*RowBox[{\"Find\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) finds the first line in an input stream that contains the specified string. \n\!\(\*RowBox[{\"Find\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds the first line that contains any of the specified strings. "
FindVertexCover::usage = "\!\(\*RowBox[{\"FindVertexCover\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a vertex cover of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with a minimum number of vertices.\n\!\(\*RowBox[{\"FindVertexCover\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
FindVertexCut::usage = "\!\(\*RowBox[{\"FindVertexCut\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) finds a smallest vertex cut of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindVertexCut\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) finds a smallest \!\(\*StyleBox[\"s\", \"TI\"]\)-\!\(\*StyleBox[\"t\", \"TI\"]\) vertex cut of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindVertexCut\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
FindVertexIndependentPaths::usage = "\!\(\*RowBox[{\"FindVertexIndependentPaths\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) finds at most \!\(\*StyleBox[\"k\", \"TI\"]\) vertex-independent paths from vertex \!\(\*StyleBox[\"s\", \"TI\"]\) to vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FindVertexIndependentPaths\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
FinishDynamic::usage = "\!\(\*RowBox[{\"FinishDynamic\", \"[\", \"]\"}]\) finishes updating and displaying all currently visible Dynamic objects. "
FiniteAbelianGroupCount::usage = "\!\(\*RowBox[{\"FiniteAbelianGroupCount\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number of finite Abelian groups of order \!\(\*StyleBox[\"n\", \"TI\"]\)."
FiniteFields`Characteristic::usage = "\!\(\*RowBox[{\"Characteristic\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives the characteristic of the field \!\(\*StyleBox[\"f\", \"TI\"]\)."
FiniteFields`ElementToPolynomial::usage = "\!\(\*RowBox[{\"ElementToPolynomial\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives a polynomial in the symbol \!\(\*StyleBox[\"s\", \"TI\"]\) corresponding to the field element \!\(\*StyleBox[\"e\", \"TI\"]\).\n\!\(\*RowBox[{\"ElementToPolynomial\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the irreducible polynomial in \!\(\*StyleBox[\"s\", \"TI\"]\) of the field \!\(\*StyleBox[\"f\", \"TI\"]\)."
FiniteFields`ExtensionDegree::usage = "\!\(\*RowBox[{\"ExtensionDegree\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives the degree of the extension of the field \!\(\*StyleBox[\"f\", \"TI\"]\) over its base field."
FiniteFields`FieldExp::usage = "\!\(\*RowBox[{\"FieldExp\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the value of the discrete exponential of \!\(\*StyleBox[\"n\", \"TI\"]\) associated with the field \!\(\*StyleBox[\"f\", \"TI\"]\)."
FiniteFields`FieldInd::usage = "\!\(\*RowBox[{\"FieldInd\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) gives the value of the discrete logarithm of \!\(\*StyleBox[\"e\", \"TI\"]\)."
FiniteFields`FieldIrreducible::usage = "\!\(\*RowBox[{\"FieldIrreducible\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the irreducible polynomial in the symbol \!\(\*StyleBox[\"s\", \"TI\"]\) associated with the field \!\(\*StyleBox[\"f\", \"TI\"]\)."
FiniteFields`FromElementCode::usage = "\!\(\*RowBox[{\"FromElementCode\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"code\", \"TI\"]}], \"]\"}]\) gives the field element of \!\(\*StyleBox[\"f\", \"TI\"]\) associated with \!\(\*StyleBox[\"code\", \"TI\"]\), a non-negative integer less than the field size of \!\(\*StyleBox[\"f\", \"TI\"]\)."
FiniteFields`FunctionOfCode::usage = "\!\(\*RowBox[{\"FunctionOfCode\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) is a setting for the option FormatType that specifies the format \!\(\*RowBox[{StyleBox[\"g\", \"TI\"], \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) for an element, where \!\(\*StyleBox[\"c\", \"TI\"]\) is the integer code for the element."
FiniteFields`FunctionOfCoefficients::usage = "\!\(\*RowBox[{\"FunctionOfCoefficients\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) is a setting for the option FormatType that specifies the format \!\(\*RowBox[{StyleBox[\"g\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) for an element, where \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \[Ellipsis] are the coefficients in the polynomial representation of the element."
FiniteFields`GF::usage = "\!\(\*RowBox[{\"GF\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the Galois field that is a degree \!\(\*StyleBox[\"d\", \"TI\"]\) extension of the prime field of \!\(\*StyleBox[\"p\", \"TI\"]\) elements.\n\!\(\*RowBox[{\"GF\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives the Galois field with \!\(\*StyleBox[\"q\", \"TI\"]\) elements, for \!\(\*StyleBox[\"q\", \"TI\"]\) a prime power.\n\!\(\*RowBox[{\"GF\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"ilist\", \"TI\"]}], StyleBox[\"]\", \"TI\"]}]\) represents the Galois field with prime characteristic \!\(\*StyleBox[\"p\", \"TI\"]\) and an irreducible polynomial whose coefficient list is given by \!\(\*StyleBox[\"ilist\", \"TI\"]\).\n\!\(\*RowBox[{RowBox[{\"GF\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"ilist\", \"TI\"]}], \"]\"}], \"[\", StyleBox[\"elist\", \"TI\"], \"]\"}]\) represents an element of the Galois field \!\(\*RowBox[{\"GF\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"ilist\", \"TI\"]}], \"]\"}]\) whose polynomial representation has coefficient list \!\(\*StyleBox[\"elist\", \"TI\"]\)."
FiniteFields`IrreduciblePolynomial::usage = "\!\(\*RowBox[{\"IrreduciblePolynomial\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives an irreducible polynomial in the symbol \!\(\*StyleBox[\"s\", \"TI\"]\) of degree \!\(\*StyleBox[\"d\", \"TI\"]\) over the integers modulo the prime \!\(\*StyleBox[\"p\", \"TI\"]\)."
FiniteFields`PerfectPowerQ::usage = "\!\(\*RowBox[{\"PerfectPowerQ\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives True if \!\(\*StyleBox[\"e\", \"TI\"]\) is a perfect \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) power in its field, and False otherwise."
FiniteFields`PolynomialToElement::usage = "\!\(\*RowBox[{\"PolynomialToElement\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"poly\", \"TI\"]}], \"]\"}]\) gives an element in the field \!\(\*StyleBox[\"f\", \"TI\"]\) corresponding to the univariate polynomial \!\(\*StyleBox[\"poly\", \"TI\"]\) with integer coefficients."
FiniteFields`PowerListQ::usage = "\!\(\*RowBox[{\"PowerListQ\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives True if the list representing the powers of a primitive element of the field is used to do field arithmetic, and False otherwise."
FiniteFields`PowerListToField::usage = "\!\(\*RowBox[{\"PowerListToField\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the field associated with the list of element data parts \!\(\*StyleBox[\"list\", \"TI\"]\), where the elements are generated by successive powers of a primitive element."
FiniteFields`PowerList::usage = "\!\(\*RowBox[{\"PowerList\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives a list of the data parts of the nonzero elements of the field \!\(\*StyleBox[\"f\", \"TI\"]\)."
FiniteFields`ReduceElement::usage = "\!\(\*RowBox[{\"ReduceElement\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) gives a field element in reduced form."
FiniteFields`SetFieldFormat::usage = "\!\(\*RowBox[{\"SetFieldFormat\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) sets the output form of elements in the field \!\(\*StyleBox[\"f\", \"TI\"]\)."
FiniteFields`Successor::usage = "\!\(\*RowBox[{\"Successor\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) gives the next element in a canonical ordering of the field elements."
FiniteFields`ToElementCode::usage = "\!\(\*RowBox[{\"ToElementCode\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) gives a non-negative integer code, less than the field size, associated with the element \!\(\*StyleBox[\"e\", \"TI\"]\)."
FiniteGroupCount::usage = "\!\(\*RowBox[{\"FiniteGroupCount\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number of finite groups of order \!\(\*StyleBox[\"n\", \"TI\"]\)."
FiniteGroupData::usage = "\!\(\*RowBox[{\"FiniteGroupData\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the finite group specified by \!\(\*StyleBox[\"name\", \"TI\"]\).\n\!\(\*RowBox[{\"FiniteGroupData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"class\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of finite groups in the specified class."
FirstCase::usage = "\!\(\*RowBox[{\"FirstCase\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to match \!\(\*StyleBox[\"pattern\", \"TI\"]\), or \!\(\*RowBox[{\"Missing\", \"[\", StyleBox[\"\\\"NotFound\\\"\",ShowStringCharacters->True], \"]\"}]\) if none matching \!\(\*StyleBox[\"pattern\", \"TI\"]\) is found. \n\!\(\*RowBox[{\"FirstCase\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{StyleBox[\"pattern\", \"TI\"], \"\[Rule]\", StyleBox[\"rhs\", \"TI\"]}]}], \"]\"}]\) gives the value of \!\(\*StyleBox[\"rhs\", \"TI\"]\) corresponding to the first \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to match \!\(\*StyleBox[\"pattern\", \"TI\"]\).\n\!\(\*RowBox[{\"FirstCase\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"default\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"default\", \"TI\"]\) if no element matching \!\(\*StyleBox[\"pattern\", \"TI\"]\) is found. \n\!\(\*RowBox[{\"FirstCase\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"default\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) finds only objects that appear on levels specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"FirstCase\", \"[\", StyleBox[\"pattern\", \"TI\"], \"]\"}]\) represents an operator form of FirstCase that can be applied to an expression."
FirstPassageTimeDistribution::usage = "\!\(\*RowBox[{\"FirstPassageTimeDistribution\", \"[\", RowBox[{StyleBox[\"mproc\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) represents the distribution of times for the Markov process \!\(\*StyleBox[\"mproc\", \"TI\"]\) to pass from the initial state to final states \!\(\*StyleBox[\"f\", \"TI\"]\) for the first time. "
FirstPosition::usage = "\!\(\*RowBox[{\"FirstPosition\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) gives the position of the first element in \!\(\*StyleBox[\"expr\", \"TI\"]\) that matches \!\(\*StyleBox[\"pattern\", \"TI\"]\), or \!\(\*RowBox[{\"Missing\", \"[\", StyleBox[\"\\\"NotFound\\\"\",ShowStringCharacters->True], \"]\"}]\) if no such element is found.\n\!\(\*RowBox[{\"FirstPosition\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"default\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"default\", \"TI\"]\) if no element matching \!\(\*StyleBox[\"pattern\", \"TI\"]\) is found.\n\!\(\*RowBox[{\"FirstPosition\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"default\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) finds only objects that appear on levels specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"FirstPosition\", \"[\", StyleBox[\"pattern\", \"TI\"], \"]\"}]\) represents an operator form of FirstPosition that can be applied to an expression."
First::usage = "\!\(\*RowBox[{\"First\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the first element in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"First\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"def\", \"TI\"]}], \"]\"}]\) gives the first element if it exists, or \!\(\*StyleBox[\"def\", \"TI\"]\) otherwise."
FischerGroupFi22::usage = "\!\(\*RowBox[{\"FischerGroupFi22\", \"[\", \"]\"}]\) represents the sporadic simple Fischer group \!\(\*SubscriptBox[\"Fi\", \"22\"]\)."
FischerGroupFi23::usage = "\!\(\*RowBox[{\"FischerGroupFi23\", \"[\", \"]\"}]\) represents the sporadic simple Fischer group \!\(\*SubscriptBox[\"Fi\", \"23\"]\)."
FischerGroupFi24Prime::usage = "\!\(\*RowBox[{\"FischerGroupFi24Prime\", \"[\", \"]\"}]\) represents the sporadic simple Fischer group \!\(\*RowBox[{SubscriptBox[\"Fi\", \"24\"], \"'\"}]\)."
FisherHypergeometricDistribution::usage = "\!\(\*RowBox[{\"FisherHypergeometricDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"succ\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"tot\", \"TI\"]], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) represents a Fisher noncentral hypergeometric distribution."
FisherRatioTest::usage = "\!\(\*RowBox[{\"FisherRatioTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the variance of \!\(\*StyleBox[\"data\", \"TI\"]\) is 1. \n\!\(\*RowBox[{\"FisherRatioTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the variances of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"FisherRatioTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests a dispersion measure against \!\(\*SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"FisherRatioTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
FisherZDistribution::usage = "\!\(\*RowBox[{\"FisherZDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) represents a Fisher \!\(\*StyleBox[\"z\", \"TI\"]\) distribution with \!\(\*StyleBox[\"n\", \"TI\"]\) numerator and \!\(\*StyleBox[\"m\", \"TI\"]\) denominator degrees of freedom."
FittedModel::usage = "\!\(\*RowBox[{\"FittedModel\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents the symbolic fitted model obtained from functions like LinearModelFit."
Fit::usage = "\!\(\*RowBox[{\"Fit\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"funs\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) finds a least\[Hyphen]squares fit to a list of data as a linear combination of the functions \!\(\*StyleBox[\"funs\", \"TI\"]\) of variables \!\(\*StyleBox[\"vars\", \"TI\"]\). "
FixedOrder::usage = "\!\(\*RowBox[{\"FixedOrder\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is a grammar rules pattern object that represents a sequence of elements matching \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\), in the fixed order given."
FixedPointList::usage = "\!\(\*RowBox[{\"FixedPointList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) generates a list giving the results of applying \!\(\*StyleBox[\"f\", \"TI\"]\) repeatedly, starting with \!\(\*StyleBox[\"expr\", \"TI\"]\), until the results no longer change. "
FixedPoint::usage = "\!\(\*RowBox[{\"FixedPoint\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) starts with \!\(\*StyleBox[\"expr\", \"TI\"]\), then applies \!\(\*StyleBox[\"f\", \"TI\"]\) repeatedly until the result no longer changes. "
FlattenAt::usage = "\!\(\*RowBox[{\"FlattenAt\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) flattens out a sublist that appears as the \!\(\*SuperscriptBox[StyleBox[RowBox[{StyleBox[\"n\", \"TI\"], \"\[Null]\"}]], \"th\"]\) element of \!\(\*StyleBox[\"list\", \"TI\"]\). If \!\(\*StyleBox[\"n\", \"TI\"]\) is negative, the position is counted from the end. \n\!\(\*RowBox[{\"FlattenAt\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) flattens out the part of \!\(\*StyleBox[\"expr\", \"TI\"]\) at position \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"FlattenAt\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) flattens out parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) at several positions. "
Flatten::usage = "\!\(\*RowBox[{\"Flatten\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) flattens out nested lists. \n\!\(\*RowBox[{\"Flatten\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) flattens to level \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"Flatten\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) flattens subexpressions with head \!\(\*StyleBox[\"h\", \"TI\"]\). \n\!\(\*RowBox[{\"Flatten\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) flattens \!\(\*StyleBox[\"list\", \"TI\"]\) by combining all levels \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"ij\", \"TI\"]]\) to make each level \!\(\*StyleBox[\"i\", \"TI\"]\) in the result. "
FlatTopWindow::usage = "\!\(\*RowBox[{\"FlatTopWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a exact flat top window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
Flat::usage = "Flat is an attribute that can be assigned to a symbol \!\(\*StyleBox[\"f\", \"TI\"]\) to indicate that all expressions involving nested functions \!\(\*StyleBox[\"f\", \"TI\"]\) should be flattened out. This property is accounted for in pattern matching. "
FlipView::usage = "\!\(\*RowBox[{\"FlipView\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents an object which flips between displaying \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) each time it is clicked.\n\!\(\*RowBox[{\"FlipView\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) cyclically flips through successive \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FlipView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) makes \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) be the object currently displayed."
Floor::usage = "\!\(\*RowBox[{\"Floor\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the greatest integer less than or equal to \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Floor\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives the greatest multiple of \!\(\*StyleBox[\"a\", \"TI\"]\) less than or equal to \!\(\*StyleBox[\"x\", \"TI\"]\). "
FlowPolynomial::usage = "\!\(\*RowBox[{\"FlowPolynomial\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the flow polynomial of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"FlowPolynomial\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
FoldList::usage = "\!\(\*RowBox[{\"FoldList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"FoldList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
FoldPairList::usage = "\!\(\*RowBox[{\"FoldPairList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the list of successive \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) obtained by applying \!\(\*StyleBox[\"f\", \"TI\"]\) to pairs of the form \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[RowBox[{\"i\", \"-\", StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\), where at each step \!\(\*StyleBox[\"f\", \"TI\"]\) returns \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"FoldPairList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) gives the list of successive values of \!\(\*RowBox[{StyleBox[\"g\", \"TI\"], \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}], \"]\"}]\).\n\!\(\*RowBox[{\"FoldPairList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) is equivalent to \!\(\*RowBox[{\"FoldPairList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\)."
FoldPair::usage = "\!\(\*RowBox[{\"FoldPair\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) gives the last element of \!\(\*RowBox[{\"FoldPairList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\).\n\!\(\*RowBox[{\"FoldPair\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) gives the last element of \!\(\*RowBox[{\"FoldPairList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\).\n\!\(\*RowBox[{\"FoldPair\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) is equivalent to \!\(\*RowBox[{\"FoldPair\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\)."
Fold::usage = "\!\(\*RowBox[{\"Fold\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) gives the last element of \!\(\*RowBox[{\"FoldList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\).\n\!\(\*RowBox[{\"Fold\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) is equivalent to \!\(\*RowBox[{\"Fold\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"First\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \",\", RowBox[{\"Rest\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]}], \"]\"}]\)."
FontColor::usage = "FontColor is an option for Style, Cell, and related constructs that specifies the default color in which to render text. "
FontFamily::usage = "FontFamily is an option for Style and Cell that specifies the font family in which text should be rendered. "
FontPostScriptName::usage = "FontPostScriptName is an option to StyleBox which changes the current font. A sample specification is \!\(\*RowBox[{\"FontPostScriptName\", \" \", \"->\", \" \", RowBox[{\"Times\", \"-\", \"Roman\"}]}]\). The default value is Automatic."
FontProperties::usage = "\!\(\*RowBox[{\"FontProperties\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}]}]\) specifies font properties."
FontSize::usage = "FontSize is an option for Style and Cell that specifies the default size in printer's points of the font in which to render text. "
FontSlant::usage = "FontSlant is an option for Style, Cell, and related constructs that specifies how slanted characters in text should be. "
FontSubstitutions::usage = "FontSubstitutions is an option for Cell that gives a list of substitutions to try for font family names. "
FontTracking::usage = "FontTracking is an option for Style and Cell that specifies how condensed or expanded you want the font in which text is rendered to be. "
FontVariations::usage = "FontVariations is an option for Style, Cell, and related constructs that specifies what font variations should be used."
FontWeight::usage = "FontWeight is an option for Style, Cell, and related constructs that specifies how heavy the characters in a font should be. "
ForAll::usage = "\!\(\*RowBox[{\"ForAll\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) represents the statement that \!\(\*StyleBox[\"expr\", \"TI\"]\) is True for all values of \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"ForAll\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"cond\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) states that \!\(\*StyleBox[\"expr\", \"TI\"]\) is True for all \!\(\*StyleBox[\"x\", \"TI\"]\) satisfying the condition \!\(\*StyleBox[\"cond\", \"TI\"]\). \n\!\(\*RowBox[{\"ForAll\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) states that \!\(\*StyleBox[\"expr\", \"TI\"]\) is True for all values of all the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TR\", FontSlant -> \"Italic\"]]\). "
FormatTypeAutoConvert::usage = "FormatTypeAutoConvert is an option for cells that specifies whether the contents of a cell are automatically converted into a different format when the style of that cell is changed."
FormatType::usage = "FormatType is an option for output streams, graphics, and functions such as Text that specifies the default format type to use when outputting expressions. "
Format::usage = "\!\(\*RowBox[{\"Format\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as the formatted form of \!\(\*StyleBox[\"expr\", \"TI\"]\). Assigning values to \!\(\*RowBox[{\"Format\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) defines print forms for expressions. \n\!\(\*RowBox[{\"Format\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives a format for the specified form of output. "
FormatValues::usage = "\!\(\*RowBox[{\"FormatValues\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives a list of transformation rules corresponding to all printing formats (values for \!\(\*RowBox[{\"Format\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\), etc.) defined for the symbol \!\(\*StyleBox[\"f\", \"TI\"]\)."
FormBoxOptions::usage = "\!\(\*RowBox[{FormBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}]}]\) is an option for cells that specifies settings for FormBox objects within the cell."
FormBox::usage = "\!\(\*RowBox[{FormBox, \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) is a low-level box construct which displays as \!\(\*StyleBox[\"boxes\", \"TI\"]\) but specifies that rules associated with \!\(\*StyleBox[\"form\", \"TI\"]\) should be used to interpret \!\(\*StyleBox[\"boxes\", \"TI\"]\) on input. "
FormFunction::usage = "\!\(\*RowBox[{\"FormFunction\", \"[\", RowBox[{StyleBox[\"formspec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) represents an active form that, when submitted, applies \!\(\*StyleBox[\"func\", \"TI\"]\) to the values obtained from the form specified by \!\(\*StyleBox[\"formspec\", \"TI\"]\).\n\!\(\*RowBox[{\"FormFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) represents an active form with fields named \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) interpreted as types \!\(\*SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FormFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"label\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*SubscriptBox[StyleBox[\"label\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as the label for the field named \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FormFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"namespec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"default\", \"TI\"], StyleBox[\"1\", \"TR\"]]}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*SubscriptBox[StyleBox[\"default\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as the default for the field specified by \!\(\*SubscriptBox[StyleBox[\"namespec\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FormFunction\", \"[\", RowBox[{StyleBox[\"formspec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"], \",\", StyleBox[\"fmt\", \"TI\"]}], \"]\"}]\) specifies that in the cloud, the result from applying \!\(\*StyleBox[\"func\", \"TI\"]\) should be returned in format \!\(\*StyleBox[\"fmt\", \"TI\"]\).\n\!\(\*RowBox[{\"FormFunction\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"formspec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"formspec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"func\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a multipage form, in which the successive \!\(\*SubscriptBox[StyleBox[\"formspec\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) can be functions that are applied to the values obtained so far."
FormLayoutFunction::usage = "FormLayoutFunction is an option for FormObject and FormFunction that can be used to specify how to lay out a form."
FormObject::usage = "\!\(\*RowBox[{\"FormObject\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a form with fields having names \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that take data of type \!\(\*SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FormObject\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"label\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) uses \!\(\*SubscriptBox[StyleBox[\"label\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as the label for the field named \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FormObject\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) uses full specification \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for a field, and \!\(\*SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) as part of the layout of the form."
FormPage::usage = "\!\(\*RowBox[{\"FormPage\", \"[\", RowBox[{StyleBox[\"formspec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) represents an active page that takes input from a form and generates results on the same page by applying \!\(\*StyleBox[\"func\", \"TI\"]\) to the values obtained from the form whose structure is defined by \!\(\*StyleBox[\"formspec\", \"TI\"]\). \n\!\(\*RowBox[{\"FormPage\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) represents an active form page with fields named \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) interpreted as types \!\(\*SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FormPage\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"label\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*SubscriptBox[StyleBox[\"label\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as the label for the field named \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FormPage\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"namespec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"default\", \"TI\"], StyleBox[\"1\", \"TR\"]]}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*SubscriptBox[StyleBox[\"default\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as the default for the field specified by \!\(\*SubscriptBox[StyleBox[\"namespec\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FormPage\", \"[\", RowBox[{StyleBox[\"formspec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) lays out the page according to the layout specification \!\(\*StyleBox[\"form\", \"TI\"]\).\n\!\(\*RowBox[{\"FormPage\", \"[\", RowBox[{StyleBox[\"formspec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"], \",\", RowBox[{StyleBox[\"initform\", \"TI\"], \"\[Rule]\", StyleBox[\"resform\", \"TI\"]}]}], \"]\"}]\) uses \!\(\*StyleBox[\"initform\", \"TI\"]\) as the initial layout specification and \!\(\*StyleBox[\"resform\", \"TI\"]\) as the layout specification for result pages."
FormTheme::usage = "FormTheme is an option for FormObject and related functions that specifies an overall theme for a form and its elements."
FormulaData::usage = "\!\(\*RowBox[{\"FormulaData\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) gives the equations for the formula \!\(\*StyleBox[\"name\", \"TI\"]\).\n\!\(\*RowBox[{\"FormulaData\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) inserts the specified values \!\(\*SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for the variables \!\(\*SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) into the equations for the formula.\n\!\(\*RowBox[{\"FormulaData\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the formula \!\(\*StyleBox[\"name\", \"TI\"]\)."
FormulaLookup::usage = "\!\(\*RowBox[{\"FormulaLookup\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"query\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the full names of formulas whose names are consistent with \"\!\(\*\nStyleBox[\"query\", \"TI\"]\)\".\n\!\(\*RowBox[{\"FormulaLookup\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"query\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns at most \!\(\*StyleBox[\"n\", \"TI\"]\) results."
FortranForm::usage = "\!\(\*RowBox[{\"FortranForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as a Fortran language version of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
For::usage = "\!\(\*RowBox[{\"For\", \"[\", RowBox[{StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"incr\", \"TI\"], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) executes \!\(\*StyleBox[\"start\", \"TI\"]\), then repeatedly evaluates \!\(\*StyleBox[\"body\", \"TI\"]\) and \!\(\*StyleBox[\"incr\", \"TI\"]\) until \!\(\*StyleBox[\"test\", \"TI\"]\) fails to give True. "
ForwardBackward::usage = "ForwardBackward is a symbol that represents alternate forward and backward motion or animation."
Forward::usage = "Forward is a symbol that represents the forward direction for purposes of motion and animation."
FourierCoefficient::usage = "\!\(\*RowBox[{\"FourierCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) coefficient in the Fourier series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"FourierCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a multidimensional Fourier coefficient."
FourierCosCoefficient::usage = "\!\(\*RowBox[{\"FourierCosCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) coefficient in the Fourier cosine series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"FourierCosCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a multidimensional Fourier cosine coefficient."
FourierCosSeries::usage = "\!\(\*RowBox[{\"FourierCosSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\)-order Fourier cosine series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\) in \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"FourierCosSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Fourier cosine series of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
FourierCosTransform::usage = "\!\(\*RowBox[{\"FourierCosTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives the symbolic Fourier cosine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"FourierCosTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Fourier cosine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
FourierDCTFilter::usage = "\!\(\*RowBox[{\"FourierDCTFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) reduces noise in \!\(\*StyleBox[\"image\", \"TI\"]\) by locally thresholding the discrete cosine transforms of overlapping subimages, using the hard threshold \!\(\*StyleBox[\"t\", \"TI\"]\)."
FourierDCTMatrix::usage = "\!\(\*RowBox[{\"FourierDCTMatrix\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns an \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) discrete cosine transform matrix of type 2.\n\!\(\*RowBox[{\"FourierDCTMatrix\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) returns an \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) discrete cosine transform matrix of type \!\(\*StyleBox[\"m\", \"TI\"]\)."
FourierDCT::usage = "\!\(\*RowBox[{\"FourierDCT\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds the Fourier discrete cosine transform of a list of real numbers.\n\!\(\*RowBox[{\"FourierDCT\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) finds the Fourier discrete cosine transform of type \!\(\*StyleBox[\"m\", \"TI\"]\)."
FourierDSTMatrix::usage = "\!\(\*RowBox[{\"FourierDSTMatrix\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns an \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) discrete sine transform matrix of type 2.\n\!\(\*RowBox[{\"FourierDSTMatrix\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) returns an \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) discrete sine transform matrix of type \!\(\*StyleBox[\"m\", \"TI\"]\)."
FourierDST::usage = "\!\(\*RowBox[{\"FourierDST\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds the Fourier discrete sine transform of a list of real numbers.\n\!\(\*RowBox[{\"FourierDST\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) finds the Fourier discrete sine transform of type \!\(\*StyleBox[\"m\", \"TI\"]\)."
FourierMatrix::usage = "\!\(\*RowBox[{\"FourierMatrix\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns an \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) Fourier matrix."
FourierParameters::usage = "FourierParameters is an option to Fourier and related functions that specifies the conventions to use in computing Fourier transforms."
FourierSequenceTransform::usage = "\!\(\*RowBox[{\"FourierSequenceTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives the Fourier sequence transform of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"FourierSequenceTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Fourier sequence transform. "
FourierSeries`DTFourierTransform::usage = "\!\(\*RowBox[{\"DTFourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives the discrete time Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) as a function of \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"n\", \"TI\"]\)."
FourierSeries`InverseDTFourierTransform::usage = "\!\(\*RowBox[{\"InverseDTFourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the inverse discrete time Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a periodic function of \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\) with period 1."
FourierSeries`InverseFourierCoefficient::usage = "\!\(\*RowBox[{\"InverseFourierCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the function of \!\(\*StyleBox[\"t\", \"TI\"]\) whose Fourier exponential series representation has coefficients given by \!\(\*StyleBox[\"expr\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"n\", \"TI\"]\)."
FourierSeries`NDTFourierTransform::usage = "\!\(\*RowBox[{\"NDTFourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives a numerical approximation to the discrete time Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) evaluated at the numerical value \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"n\", \"TI\"]\)."
FourierSeries`NFourierCoefficient::usage = "\!\(\*RowBox[{\"NFourierCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) coefficient in the Fourier exponential series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a periodic function of \!\(\*StyleBox[\"t\", \"TI\"]\) with period \!\(\*RowBox[{\"2\", \"\[Pi]\"}]\)."
FourierSeries`NFourierCosCoefficient::usage = "\!\(\*RowBox[{\"NFourierCosCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) coefficient in the Fourier cosine series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a periodic function of \!\(\*StyleBox[\"t\", \"TI\"]\) with period \!\(\*RowBox[{\"2\", \"\[Pi]\"}]\)."
FourierSeries`NFourierCosTransform::usage = "\!\(\*RowBox[{\"NFourierCosTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives a numerical approximation to the Fourier cosine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) evaluated at the numerical value \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"n\", \"TI\"]\)."
FourierSeries`NFourierSeries::usage = "\!\(\*RowBox[{\"NFourierSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the order \!\(\*StyleBox[\"n\", \"TI\"]\) Fourier exponential series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a periodic function of \!\(\*StyleBox[\"t\", \"TI\"]\) with period \!\(\*RowBox[{\"2\", \"\[Pi]\"}]\)."
FourierSeries`NFourierSinCoefficient::usage = "\!\(\*RowBox[{\"NFourierSinCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) coefficient in the Fourier sine series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a periodic function of \!\(\*StyleBox[\"t\", \"TI\"]\) with period \!\(\*RowBox[{\"2\", \"\[Pi]\"}]\)."
FourierSeries`NFourierSinTransform::usage = "\!\(\*RowBox[{\"NFourierSinTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives a numerical approximation to the Fourier sine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) evaluated at the numerical value \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"n\", \"TI\"]\)."
FourierSeries`NFourierTransform::usage = "\!\(\*RowBox[{RowBox[{RowBox[{RowBox[{\"NFourierTransform\", \"[\"}], StyleBox[\"expr\", \"TI\"]}], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives a numerical approximation to the Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) evaluated at the numerical value \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"t\", \"TI\"]\)."
FourierSeries`NFourierTrigSeries::usage = "\!\(\*RowBox[{\"NFourierTrigSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the order \!\(\*StyleBox[\"n\", \"TI\"]\) Fourier trigonometric series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a periodic function of \!\(\*StyleBox[\"t\", \"TI\"]\) with period \!\(\*RowBox[{\"2\", \"\[Pi]\"}]\)."
FourierSeries`NInverseDTFourierTransform::usage = "\!\(\*RowBox[{\"NInverseDTFourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the inverse discrete time Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) evaluated at the integer \!\(\*StyleBox[\"n\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a periodic function of \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\) with period 1."
FourierSeries`NInverseFourierCoefficient::usage = "\!\(\*RowBox[{\"NInverseFourierCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the function, evaluated at \!\(\*StyleBox[\"t\", \"TI\"]\), whose Fourier exponential series representation has coefficients given by \!\(\*StyleBox[\"expr\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"n\", \"TI\"]\)."
FourierSeries`NInverseFourierCosTransform::usage = "\!\(\*RowBox[{\"NInverseFourierCosTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the inverse Fourier cosine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) evaluated at the numerical value \!\(\*StyleBox[\"t\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
FourierSeries`NInverseFourierSinTransform::usage = "\!\(\*RowBox[{\"NInverseFourierSinTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the inverse Fourier sine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) evaluated at the numerical value \!\(\*StyleBox[\"t\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
FourierSeries`NInverseFourierTransform::usage = "\!\(\*RowBox[{\"NInverseFourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives a numerical approximation to the inverse Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\) evaluated at the numerical value \!\(\*StyleBox[\"t\", \"TI\"]\), where \!\(\*StyleBox[\"expr\", \"TI\"]\) is a function of \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
FourierSeries::usage = "\!\(\*RowBox[{\"FourierSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\)-order Fourier series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\) in \!\(\*StyleBox[\"t\", \"TI\"]\). \n\!\(\*RowBox[{\"FourierSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Fourier series."
FourierSinCoefficient::usage = "\!\(\*RowBox[{\"FourierSinCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) coefficient in the Fourier sine series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"FourierSinCoefficient\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a multidimensional Fourier sine coefficient\!\(\*StyleBox[\".\", FontSlant -> \"Italic\"]\)"
FourierSinSeries::usage = "\!\(\*RowBox[{\"FourierSinSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\)-order Fourier sine series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\) in \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"FourierSinSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Fourier sine series of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
FourierSinTransform::usage = "\!\(\*RowBox[{\"FourierSinTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives the symbolic Fourier sine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"FourierSinTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Fourier sine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
FourierTransform::usage = "\!\(\*RowBox[{\"FourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", \"\[Omega]\"}], \"]\"}]\) gives the symbolic Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"FourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[\"\[Omega]\", StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[\"\[Omega]\", StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
FourierTrigSeries::usage = "\!\(\*RowBox[{\"FourierTrigSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\)-order Fourier trigonometric series expansion of \!\(\*StyleBox[\"expr\", \"TI\"]\) in \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"FourierTrigSeries\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Fourier trigonometric series of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
Fourier::usage = "\!\(\*RowBox[{\"Fourier\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds the discrete Fourier transform of a list of complex numbers.\n\!\(\*RowBox[{\"Fourier\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns the specified positions of the discrete Fourier transform. "
FractionalBrownianMotionProcess::usage = "\!\(\*RowBox[{\"FractionalBrownianMotionProcess\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) represents fractional Brownian motion process with drift \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), volatility \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\), and Hurst index \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"FractionalBrownianMotionProcess\", \"[\", StyleBox[\"h\", \"TI\"], \"]\"}]\) represents fractional Brownian motion process with drift 0, volatility 1, and Hurst index \!\(\*StyleBox[\"h\", \"TI\"]\)."
FractionalGaussianNoiseProcess::usage = "\!\(\*RowBox[{\"FractionalGaussianNoiseProcess\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) represents a fractional Gaussian noise process with drift \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), volatility \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\), and Hurst index \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"FractionalGaussianNoiseProcess\", \"[\", StyleBox[\"h\", \"TI\"], \"]\"}]\) represents a fractional Gaussian noise process with drift 0, volatility 1, and Hurst index \!\(\*StyleBox[\"h\", \"TI\"]\)."
FractionalPart::usage = "\!\(\*RowBox[{\"FractionalPart\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the fractional part of \!\(\*StyleBox[\"x\", \"TI\"]\). "
FractionBoxOptions::usage = "\!\(\*RowBox[{FractionBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for cells that specifies settings for FractionBox objects within the cell."
FractionBox::usage = "\!\(\*RowBox[{FractionBox, \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is a low-level formatting construct that represents \!\(\*FractionBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\) in notebook expressions. "
FractionLine::usage = "FractionLine is an option for fractions that specifies the thickness of the line separating the numerator and denominator."
FrameBoxOptions::usage = "\!\(\*RowBox[{FrameBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for cells that specifies default settings."
FrameBox::usage = "\!\(\*RowBox[{FrameBox, \"[\", StyleBox[\"box\", \"TI\"], \"]\"}]\) is a low-level box construct which represents \!\(\*StyleBox[\"box\", \"TI\"]\) with a frame drawn around it. "
Framed::usage = "\!\(\*RowBox[{\"Framed\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays a framed version of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
FrameLabel::usage = "FrameLabel is an option for Graphics, Manipulate, and related functions that specifies labels to be placed on the edges of a frame. "
FrameMargins::usage = "FrameMargins is an option for objects that can be displayed with frames which specifies the absolute margins in printer's points to leave inside the frame. "
FrameStyle::usage = "FrameStyle is an option for Graphics, Grid, and other constructs that specifies the style in which to draw frames."
FrameTicksStyle::usage = "FrameTicksStyle is an option for 2D graphics functions that specifies how frame ticks should be rendered."
FrameTicks::usage = "FrameTicks is an option for 2D graphics functions that specifies tick marks for the edges of a frame. "
Frame::usage = "Frame is an option for Graphics, Grid, and other constructs that specifies whether to include a frame. "
FRatioDistribution::usage = "\!\(\*RowBox[{\"FRatioDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) represents an F-ratio distribution with \!\(\*StyleBox[\"n\", \"TI\"]\) numerator and \!\(\*StyleBox[\"m\", \"TI\"]\) denominator degrees of freedom."
FrechetDistribution::usage = "\!\(\*RowBox[{\"FrechetDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents the Frechet distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"FrechetDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents the Frechet distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\), and location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
FreeQ::usage = "\!\(\*RowBox[{\"FreeQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) yields True if no subexpression in \!\(\*StyleBox[\"expr\", \"TI\"]\) matches \!\(\*StyleBox[\"form\", \"TI\"]\), and yields False otherwise. \n\!\(\*RowBox[{\"FreeQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) tests only those parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) on levels specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"FreeQ\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) represents an operator form of FreeQ that can be applied to an expression."
FrenetSerretSystem::usage = "\!\(\*RowBox[{\"FrenetSerretSystem\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the generalized curvatures and Frenet\[Dash]Serret basis for the parametric curve \!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\).\n\!\(\*RowBox[{\"FrenetSerretSystem\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) interprets the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as coordinates in the specified coordinate chart."
FrequencySamplingFilterKernel::usage = "\!\(\*RowBox[{\"FrequencySamplingFilterKernel\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}], \"]\"}]\) creates a finite impulse response (FIR) filter kernel using a frequency sampling method from amplitude values \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"FrequencySamplingFilterKernel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) creates an FIR filter kernel of type \!\(\*StyleBox[\"m\", \"TI\"]\)."
FresnelC::usage = "\!\(\*RowBox[{\"FresnelC\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Fresnel integral \!\(\*RowBox[{StyleBox[\"C\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
FresnelF::usage = "\!\(\*RowBox[{\"FresnelF\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Fresnel auxiliary function \!\(\*RowBox[{StyleBox[\"F\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
FresnelG::usage = "\!\(\*RowBox[{\"FresnelG\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Fresnel auxiliary function \!\(\*RowBox[{StyleBox[\"G\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
FresnelS::usage = "\!\(\*RowBox[{\"FresnelS\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Fresnel integral \!\(\*RowBox[{StyleBox[\"S\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
Friday::usage = "Friday is a day of the week."
FrobeniusNumber::usage = "\!\(\*RowBox[{\"FrobeniusNumber\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the Frobenius number of \!\(\*RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\)."
FrobeniusSolve::usage = "\!\(\*RowBox[{\"FrobeniusSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives a list of all solutions of the Frobenius equation \!\(\*RowBox[{RowBox[{RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], \"1\"], SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}], \"+\", \"\[Ellipsis]\", \"+\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]}], \"=\", StyleBox[\"b\", \"TI\"]}]\).\n\!\(\*RowBox[{\"FrobeniusSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives at most \!\(\*StyleBox[\"m\", \"TI\"]\) solutions."
FromCharacterCode::usage = "\!\(\*RowBox[{\"FromCharacterCode\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a string consisting of the character with integer code \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"FromCharacterCode\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a string consisting of the sequence of characters with codes \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"FromCharacterCode\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of strings. \n\!\(\*RowBox[{\"FromCharacterCode\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"encoding\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses the specified character encoding. "
FromCoefficientRules::usage = "\!\(\*RowBox[{\"FromCoefficientRules\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs a polynomial from a list of rules for exponent vectors and coefficients. "
FromContinuedFraction::usage = "\!\(\*RowBox[{\"FromContinuedFraction\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) reconstructs a number from the list of its continued fraction terms. "
FromDate::usage = "\!\(\*RowBox[{\"FromDate\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) converts a date of the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}]\) to an absolute number of seconds since the beginning of January 1, 1900. "
FromDigits::usage = "\!\(\*RowBox[{\"FromDigits\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) constructs an integer from the list of its decimal digits. \n\!\(\*RowBox[{\"FromDigits\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) takes the digits to be given in base \!\(\*StyleBox[\"b\", \"TI\"]\). \n\!\(\*RowBox[{\"FromDigits\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"MixedRadix\", \"[\", StyleBox[\"blist\", \"TI\"], \"]\"}]}], \"]\"}]\) uses the mixed radix with list of bases \!\(\*StyleBox[\"blist\", \"TI\"]\). \n\!\(\*RowBox[{\"FromDigits\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) constructs an integer from a string of digits.\n\!\(\*RowBox[{\"FromDigits\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"Roman\\\"\",ShowStringCharacters->True]}], \"]\"}]\) constructs an integer from Roman numerals."
FromDMS::usage = "\!\(\*RowBox[{\"FromDMS\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) converts from degrees, minutes, and seconds to decimal degrees. \n\!\(\*RowBox[{\"FromDMS\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dms\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) converts from a DMS string to decimal degrees.\n\!\(\*RowBox[{\"FromDMS\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"latlon\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) converts from a latitude-longitude string to latitude and longitude in decimal degrees."
FromEntity::usage = "\!\(\*RowBox[{\"FromEntity\", \"[\", StyleBox[\"entity\", \"TI\"], \"]\"}]\) returns a Wolfram Language object corresponding to an entity."
FromJulianDate::usage = "\!\(\*RowBox[{\"FromJulianDate\", \"[\", StyleBox[\"jd\", \"TI\"], \"]\"}]\) gives a date object corresponding to the Julian date \!\(\*StyleBox[\"jd\", \"TI\"]\).\n\!\(\*RowBox[{\"FromJulianDate\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"jd\", \"TI\"]}], \"]\"}]\) gives a date object corresponding to the specified Julian date variant."
FromPolarCoordinates::usage = "\!\(\*RowBox[{\"FromPolarCoordinates\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) Cartesian coordinates corresponding to the polar coordinates \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"FromPolarCoordinates\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], RowBox[{StyleBox[\"n\", \"TI\"], \"-\", StyleBox[\"2\", \"TR\"]}]], \",\", StyleBox[\"\[CurlyPhi]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the coordinates corresponding to the hyperspherical coordinates \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], RowBox[{StyleBox[\"n\", \"TI\"], \"-\", StyleBox[\"2\", \"TR\"]}]], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"}\"}]\) "
FromRomanNumeral::usage = "\!\(\*RowBox[{\"FromRomanNumeral\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the integer corresponding to the Roman numeral \!\(\*StyleBox[StyleBox[\"\\\"string\\\"\",ShowStringCharacters->True], \"TI\"]\). "
FromSphericalCoordinates::usage = "\!\(\*RowBox[{\"FromSphericalCoordinates\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}]\) Cartesian coordinates corresponding to the spherical coordinates \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"}\"}]\)."
FromUnixTime::usage = "\!\(\*RowBox[{\"FromUnixTime\", \"[\", StyleBox[\"time\", \"TI\"], \"]\"}]\) gives a date object corresponding to a UnixTime specification."
FrontEndDynamicExpression::usage = "FrontEndDynamicExpression is a global front end option that specifies an expression to be dynamically updated whenever the front end is running."
FrontEndEventActions::usage = "FrontEndEventActions is an option for the notebook front end that gives a list of actions to perform when specified user-interface events occur. "
FrontEndExecute::usage = "\!\(\*RowBox[{\"FrontEndExecute\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) sends \!\(\*StyleBox[\"expr\", \"TI\"]\) to be executed by the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) front end. "
FrontEndStackSize::usage = "FrontEndStackSize is a global option that specifies the size of the stack used to store data in the front end (Macintosh only)."
FrontEndTokenExecute::usage = "\!\(\*RowBox[{\"FrontEndTokenExecute\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"cmd\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) executes the specified front end command token, typically corresponding to a front end menu item. "
FrontEndToken::usage = "\!\(\*RowBox[{\"FrontEndToken\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"cmd\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) is an object that represents a front end command token, typically corresponding to a front end menu item, to be executed by FrontEndExecute. \n\!\(\*RowBox[{\"FrontEndToken\", \"[\", RowBox[{StyleBox[\"nb\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"cmd\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents a command that targets the specified notebook. \n\!\(\*RowBox[{\"FrontEndToken\", \"[\", RowBox[{StyleBox[\"nb\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"cmd\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"param\", \"TI\"]}], \"]\"}]\) represents a command with a parameter."
Front::usage = "Front is a symbol that represents the front of a graphic for purposes of placement and alignment."
FullAxes::usage = "\!\(\*RowBox[{\"FullAxes\", \"[\", StyleBox[\"graphics\", \"TI\"], \"]\"}]\) returns the axes options of a graphics object."
FullDefinition::usage = "\!\(\*RowBox[{\"FullDefinition\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) prints as the definitions given for \!\(\*StyleBox[\"symbol\", \"TI\"]\), and all symbols on which these depend. "
FullForm::usage = "\!\(\*RowBox[{\"FullForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as the full form of \!\(\*StyleBox[\"expr\", \"TI\"]\), with no special syntax. "
FullGraphics::usage = "\!\(\*RowBox[{\"FullGraphics\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) takes a graphics object, and generates a new one in which objects specified by graphics options are given as explicit lists of graphics primitives. "
FullInformationOutputRegulator::usage = "\!\(\*RowBox[{\"FullInformationOutputRegulator\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"rspec\", \"TI\"]}], \"]\"}]\) gives the full state information output regulator for \!\(\*StyleBox[\"sys\", \"TI\"]\) using specification \!\(\*StyleBox[\"rspec\", \"TI\"]\). \n\!\(\*RowBox[{\"FullInformationOutputRegulator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) specifies the regulated outputs \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and the controlled inputs \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"j\", \"TI\"]]\)."
FullRegion::usage = "\!\(\*RowBox[{\"FullRegion\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the full region \!\(\*SuperscriptBox[\"\[DoubleStruckCapitalR]\", StyleBox[\"n\", \"TI\"]]\)."
FullSimplify::usage = "\!\(\*RowBox[{\"FullSimplify\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) tries a wide range of transformations on \!\(\*StyleBox[\"expr\", \"TI\"]\) involving elementary and special functions and returns the simplest form it finds. \n\!\(\*RowBox[{\"FullSimplify\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"assum\", \"TI\"]}], \"]\"}]\) does simplification using assumptions. "
Full::usage = "Full is a setting used for certain options, typically indicating that a full range of values should be included. "
FunctionApproximations`Bias::usage = "Bias is an option to RationalInterpolation, GeneralRationalInterpolation, MiniMaxApproximation, and GeneralMiniMaxApproximation that specifies the bias to apply when automatically picking interpolation points."
FunctionApproximations`Brake::usage = "Brake is an option to MiniMaxApproximation and GeneralMiniMaxApproximation that specifies how changes from one iteration to the next are to be restricted."
FunctionApproximations`Derivatives::usage = "Derivatives is an option to MiniMaxApproximation and GeneralMiniMaxApproximation that specifies an expression that evaluates to a list containing the function and its first two derivatives."
FunctionApproximations`EconomizedRationalApproximation::usage = "\!\(\*RowBox[{\"EconomizedRationalApproximation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the economized rational approximation to \!\(\*StyleBox[\"expr\", \"TI\"]\) that is good over the interval \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), with numerator order \!\(\*StyleBox[\"m\", \"TI\"]\) and denominator order \!\(\*StyleBox[\"n\", \"TI\"]\)."
FunctionApproximations`GeneralMiniMaxApproximation::usage = "\!\(\*RowBox[{\"GeneralMiniMaxApproximation\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) finds the rational polynomial function of \!\(\*StyleBox[\"x\", \"TI\"]\), with numerator order \!\(\*StyleBox[\"m\", \"TI\"]\) and denominator order \!\(\*StyleBox[\"n\", \"TI\"]\), that gives a mini-max approximation to the curve with \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) coordinates \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]\) generated as a function of \!\(\*StyleBox[\"t\", \"TI\"]\) on the interval \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"0\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\).\n\!\(\*RowBox[{\"GeneralMiniMaxApproximation\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"approx\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) finds the mini-max approximation, starting the iterative algorithm with \!\(\*StyleBox[\"approx\", \"TI\"]\)."
FunctionApproximations`GeneralRationalInterpolation::usage = "\!\(\*RowBox[{RowBox[{\"GeneralRationalInterpolation\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], RowBox[{StyleBox[\"m\", \"TI\"], \"+\", StyleBox[\"n\", \"TI\"], \"+\", StyleBox[\"1\", \"TR\"]}]]}], \"}\"}]}], \"]\"}], \"]\"}]\) gives the rational polynomial function of \!\(\*StyleBox[\"x\", \"TI\"]\), with numerator order \!\(\*StyleBox[\"m\", \"TI\"]\) and denominator order \!\(\*StyleBox[\"n\", \"TI\"]\), that interpolates the curve with \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) coordinates \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]\) generated as a function of \!\(\*StyleBox[\"t\", \"TI\"]\), at the interpolation points \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. \n\!\(\*RowBox[{\"GeneralRationalInterpolation\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the rational interpolant with the interpolation points chosen automatically from the interval \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"0\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)."
FunctionApproximations`InterpolateRoot::usage = "\!\(\*RowBox[{\"InterpolateRoot\", \"[\", RowBox[{RowBox[{StyleBox[\"lhs\", \"TI\"], \"==\", StyleBox[\"rhs\", \"TI\"]}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) searches for a numerical solution to the equation \!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"==\", StyleBox[\"rhs\", \"TI\"]}]\) using \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) as the first two values of \!\(\*StyleBox[\"x\", \"TI\"]\)."
FunctionApproximations`ListIntegrate::usage = "\!\(\*RowBox[{\"ListIntegrate\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) is an obsolete function that uses an InterpolatingFunction object of order \!\(\*StyleBox[\"k\", \"TI\"]\) to give an approximation to the integral of a function with values \!\(\*RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\) at points equally spaced a distance \!\(\*StyleBox[\"h\", \"TI\"]\) apart.\n\!\(\*RowBox[{\"ListIntegrate\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) approximates the integral of a function with values \!\(\*RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\) at the points \!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\)."
FunctionApproximations`MiniMaxApproximation::usage = "\!\(\*RowBox[{\"MiniMaxApproximation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) finds the rational polynomial function of \!\(\*StyleBox[\"x\", \"TI\"]\), with numerator order \!\(\*StyleBox[\"m\", \"TI\"]\) and denominator order \!\(\*StyleBox[\"n\", \"TI\"]\), that gives a mini-max approximation to \!\(\*StyleBox[\"expr\", \"TI\"]\) on the interval \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\).\n\!\(\*RowBox[{\"MiniMaxApproximation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"approx\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) finds the mini-max approximation to \!\(\*StyleBox[\"expr\", \"TI\"]\), starting the iterative algorithm with \!\(\*StyleBox[\"approx\", \"TI\"]\)."
FunctionApproximations`NIntegrateInterpolatingFunction::usage = "\!\(\*RowBox[{\"NIntegrateInterpolatingFunction\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives a numerical approximation to an integral with InterpolatingFunction objects in the integrand.\n\!\(\*RowBox[{\"NIntegrateInterpolatingFunction\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a numerical approximation to a multidimensional integral."
FunctionApproximations`OrderStarInterpolation::usage = "OrderStarInterpolation is an option to OrderStarPlot that specifies whether interpolation points of an approximant to a function should be displayed. "
FunctionApproximations`OrderStarKind::usage = "OrderStarKind is an option to OrderStarPlot that specifies the type of order star to be displayed. "
FunctionApproximations`OrderStarLegend::usage = "OrderStarLegend is an option to OrderStarPlot that specifies whether to display the legend of symbols used to represent zeros, poles, and interpolation points. "
FunctionApproximations`OrderStarPlot::usage = "\!\(\*RowBox[{\"OrderStarPlot\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) draws the order star depicting the region where \!\(\*RowBox[{StyleBox[\"|\", \"TI\"], RowBox[{StyleBox[\"r\", \"TI\"], \"/\", StyleBox[\"f\", \"TI\"]}], StyleBox[\"|\", \"TI\"], RowBox[{\"<\", StyleBox[\"1\", FontFamily -> \"Times\"]}]}]\) for the functions \!\(\*StyleBox[\"r\", \"TI\"]\) and \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"OrderStarPlot\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) draws the order star where \!\(\*StyleBox[\"r\", \"TI\"]\) and \!\(\*StyleBox[\"f\", \"TI\"]\) are functions of \!\(\*StyleBox[\"z\", \"TI\"]\)."
FunctionApproximations`OrderStarPoles::usage = "OrderStarPoles is an option to OrderStarPlot that specifies whether poles of an approximant and the function to be approximated should be displayed. "
FunctionApproximations`OrderStarSymbolSize::usage = "OrderStarSymbolSize is an option to OrderStarPlot that specifies the size of the symbols used to represent poles, zeros, and interpolation points."
FunctionApproximations`OrderStarSymbolThickness::usage = "OrderStarSymbolThickness is an option to OrderStarPlot that specifies the thickness of the outline of the symbols used to represent interpolation points, poles, and zeros."
FunctionApproximations`OrderStarZeros::usage = "OrderStarZeros is an option to OrderStarPlot that specifies whether zeros of an approximant and the function to be approximated should be displayed."
FunctionApproximations`PlotFlag::usage = "PlotFlag is an option to MiniMaxApproximation and GeneralMiniMaxApproximation that specifies whether plots of the relative error of successive iterates in the approximation algorithm are to be drawn."
FunctionApproximations`PrintFlag::usage = "PrintFlag is an option to MiniMaxApproximation and GeneralMiniMaxApproximation that specifies whether data from the successive iterates in the approximation algorithm are to be shown."
FunctionApproximations`RationalInterpolation::usage = "\!\(\*RowBox[{\"RationalInterpolation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \"+\", StyleBox[\"m\", \"TI\"], \"+\", StyleBox[\"1\", \"TR\"]}]]}], \"}\"}]}], \"]\"}]\) gives the rational interpolant to \!\(\*StyleBox[\"expr\", \"TI\"]\) with numerator order \!\(\*StyleBox[\"m\", \"TI\"]\) and denominator order \!\(\*StyleBox[\"n\", \"TI\"]\), where \!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) are the abscissas of the interpolation points.\n\!\(\*RowBox[{\"RationalInterpolation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the rational interpolant with the interpolation points chosen automatically on the interval \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)."
FunctionDomain::usage = "\!\(\*RowBox[{\"FunctionDomain\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) finds the largest domain of definition of the real function \!\(\*StyleBox[\"f\", \"TI\"]\) of the variable \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"FunctionDomain\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) considers \!\(\*StyleBox[\"f\", \"TI\"]\) to be a function with arguments and values in the domain \!\(\*StyleBox[\"dom\", \"TI\"]\).\n\!\(\*RowBox[{\"FunctionDomain\", \"[\", RowBox[{StyleBox[\"funs\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) finds the largest domain of definition of the mapping \!\(\*StyleBox[\"funs\", \"TI\"]\) of the variables \!\(\*StyleBox[\"vars\", \"TI\"]\). \n\!\(\*RowBox[{\"FunctionDomain\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"funs\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"vars\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) finds the domain of \!\(\*StyleBox[\"funs\", \"TI\"]\) with the values of \!\(\*StyleBox[\"vars\", \"TI\"]\) restricted by constraints \!\(\*StyleBox[\"cons\", \"TI\"]\)."
FunctionExpand::usage = "\!\(\*RowBox[{\"FunctionExpand\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) tries to expand out special and certain other functions in \!\(\*StyleBox[\"expr\", \"TI\"]\), when possible reducing compound arguments to simpler ones. \n\!\(\*RowBox[{\"FunctionExpand\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"assum\", \"TI\"]}], \"]\"}]\) expands using assumptions. "
FunctionInterpolation::usage = "\!\(\*RowBox[{\"FunctionInterpolation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) with \!\(\*StyleBox[\"x\", \"TI\"]\) running from \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) and constructs an InterpolatingFunction object which represents an approximate function corresponding to the result. \n\!\(\*RowBox[{\"FunctionInterpolation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) constructs an InterpolatingFunction object with several arguments. "
FunctionPeriod::usage = "\!\(\*RowBox[{\"FunctionPeriod\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a period \!\(\*StyleBox[\"p\", \"TI\"]\) of the function \!\(\*StyleBox[\"f\", \"TI\"]\) over the reals such that \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"+\", StyleBox[\"p\", \"TI\"]}], \")\"}], \"\[LongEqual]\", RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]}]\).\n\!\(\*RowBox[{\"FunctionPeriod\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) gives a period with \!\(\*StyleBox[\"x\", \"TI\"]\) restricted to the domain \!\(\*StyleBox[\"dom\", \"TI\"]\).\n\!\(\*RowBox[{\"FunctionPeriod\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives periods \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) for \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) such that \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \"+\", SubscriptBox[StyleBox[\"p\", \"TI\"], \"1\"]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"], \"+\", SubscriptBox[StyleBox[\"p\", \"TI\"], \"2\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \")\"}], \"\[LongEqual]\", RowBox[{StyleBox[\"f\", \"TI\"], \"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \")\"}]}]\)."
FunctionRange::usage = "\!\(\*RowBox[{\"FunctionRange\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) finds the range of the real function \!\(\*StyleBox[\"f\", \"TI\"]\) of the variable \!\(\*StyleBox[\"x\", \"TI\"]\) returning the result in terms of \!\(\*StyleBox[\"y\", \"TI\"]\).\n\!\(\*RowBox[{\"FunctionRange\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) considers \!\(\*StyleBox[\"f\", \"TI\"]\) to be a function with arguments and values in the domain \!\(\*StyleBox[\"dom\", \"TI\"]\).\n\!\(\*RowBox[{\"FunctionRange\", \"[\", RowBox[{StyleBox[\"funs\", \"TI\"], \",\", StyleBox[\"xvars\", \"TI\"], \",\", StyleBox[\"yvars\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) finds the range of the mapping \!\(\*StyleBox[\"funs\", \"TI\"]\) of the variables \!\(\*StyleBox[\"xvars\", \"TI\"]\) returning the result in terms of \!\(\*StyleBox[\"yvars\", \"TI\"]\).\n\!\(\*RowBox[{\"FunctionRange\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"funs\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"xvars\", \"TI\"], \",\", StyleBox[\"yvars\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) finds the range of the mapping \!\(\*StyleBox[\"funs\", \"TI\"]\) with the values of \!\(\*StyleBox[\"xvars\", \"TI\"]\) restricted by constraints \!\(\*StyleBox[\"cons\", \"TI\"]\)."
FunctionSpace::usage = "FunctionSpace is an option for FindSequenceFunction and related functions that specifies the space of functions to consider for representations. "
Function::usage = "\!\(\*RowBox[{\"Function\", \"[\", StyleBox[\"body\", \"TI\"], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"body\", \"TI\"], \"&\"}]\) is a pure function. The formal parameters are # (or #1), #2, etc. \n\!\(\*RowBox[{\"Function\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) is a pure function with a single formal parameter \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Function\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) is a pure function with a list of formal parameters. "
FussellVeselyImportance::usage = "\!\(\*RowBox[{\"FussellVeselyImportance\", \"[\", RowBox[{StyleBox[\"rdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the Fussell\[Dash]Vesely importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"FussellVeselyImportance\", \"[\", RowBox[{StyleBox[\"fdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the Fussell\[Dash]Vesely importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\)."
GaborFilter::usage = "\!\(\*RowBox[{\"GaborFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by convolving with a Gabor kernel of pixel radius \!\(\*StyleBox[\"r\", \"TI\"]\) and wave vector \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"GaborFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) uses a Gabor kernel with phase shift \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\).\n\!\(\*RowBox[{RowBox[{\"GaborFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \" \"}]\) uses a Gabor kernel with radius \!\(\*StyleBox[RowBox[{\"r\", \" \"}], \"TI\"]\) and standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GaborFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies Gabor filtering to an array of \!\(\*StyleBox[\"data\", \"TI\"]\). "
GaborMatrix::usage = "\!\(\*RowBox[{\"GaborMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a matrix that corresponds to the real part of a Gabor kernel of radius \!\(\*StyleBox[\"r\", \"TI\"]\) and wave vector \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"GaborMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) uses phase shift \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\).\n\!\(\*RowBox[{\"GaborMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) uses the specified standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GaborMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives an array corresponding to a Gabor kernel with radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) index direction."
GaborWavelet::usage = "\!\(\*RowBox[{\"GaborWavelet\", \"[\", \"]\"}]\) represents a Gabor wavelet of frequency 6.\n\!\(\*RowBox[{\"GaborWavelet\", \"[\", StyleBox[\"w\", \"TI\"], \"]\"}]\) represents a Gabor wavelet of frequency \!\(\*StyleBox[\"w\", \"TI\"]\)."
GainMargins::usage = "\!\(\*RowBox[{\"GainMargins\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) gives the gain margins of the linear time-invariant system \!\(\*StyleBox[\"lsys\", \"TI\"]\)."
GainPhaseMargins::usage = "\!\(\*RowBox[{\"GainPhaseMargins\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) gives the gain and phase margins of the linear time-invariant system \!\(\*StyleBox[\"lsys\", \"TI\"]\)."
GalaxyData::usage = "\!\(\*RowBox[{\"GalaxyData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the galaxy \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"GalaxyData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified galaxy entities.\n\!\(\*RowBox[{\"GalaxyData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
GammaDistribution::usage = "\!\(\*RowBox[{\"GammaDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a gamma distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"GammaDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a generalized gamma distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\), and location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
GammaRegularized::usage = "\!\(\*RowBox[{\"GammaRegularized\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the regularized incomplete gamma function \!\(\*RowBox[{StyleBox[\"Q\", \"TI\"], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\). "
Gamma::usage = "\!\(\*RowBox[{\"Gamma\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) is the Euler gamma function \!\(\*RowBox[{\"\[CapitalGamma]\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"Gamma\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the incomplete gamma function \!\(\*RowBox[{\"\[CapitalGamma]\", \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\). \n\!\(\*RowBox[{\"Gamma\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}]\) is the generalized incomplete gamma function \!\(\*RowBox[{RowBox[{\"\[CapitalGamma]\", \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], \"0\"]}], \")\"}], \"-\", RowBox[{\"\[CapitalGamma]\", \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], \"1\"]}], \")\"}]}]\). "
GapPenalty::usage = "GapPenalty is an option for SequenceAlignment and related functions that gives the additional cost associated with each gap corresponding to a run of insertions or deletions."
GARCHProcess::usage = "\!\(\*RowBox[{\"GARCHProcess\", \"[\", RowBox[{StyleBox[\"\[Kappa]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a generalized autoregressive conditionally heteroscedastic process of orders \!\(\*StyleBox[\"p\", \"TI\"]\) and \!\(\*StyleBox[\"q\", \"TI\"]\), driven by a standard white noise.\n\!\(\*RowBox[{\"GARCHProcess\", \"[\", RowBox[{StyleBox[\"\[Kappa]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) represents a GARCH process with initial data \!\(\*StyleBox[\"init\", \"TI\"]\)."
GatherBy::usage = "\!\(\*RowBox[{\"GatherBy\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gathers into sublists each set of elements in \!\(\*StyleBox[\"list\", \"TI\"]\) that gives the same value when \!\(\*StyleBox[\"f\", \"TI\"]\) is applied.\n\!\(\*RowBox[{\"GatherBy\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gathers \!\(\*StyleBox[\"list\", \"TI\"]\) into nested sublists using \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at level \!\(\*StyleBox[\"i\", \"TI\"]\). "
Gather::usage = "\!\(\*RowBox[{\"Gather\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gathers the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) into sublists of identical elements.\n\!\(\*RowBox[{\"Gather\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"test\", \"TI\"]\) to pairs of elements to determine if they should be considered identical."
GaugeFaceElementFunction::usage = "GaugeFaceElementFunction is an option for gauge functions that gives a function to use to generate the primitives for rendering the gauge face."
GaugeFaceStyle::usage = "GaugeFaceStyle is an option for gauge functions that specifies the style in which the face is to be drawn."
GaugeFrameElementFunction::usage = "GaugeFrameElementFunction is an option for gauge functions that gives a function to generate the primitives for rendering the gauge frame."
GaugeFrameSize::usage = "GaugeFrameSize is an option for gauge functions that controls the size of the frame around the gauge."
GaugeFrameStyle::usage = "GaugeFrameStyle is an option for gauge functions that specifies the style in which the frame is to be drawn."
GaugeLabels::usage = "GaugeLabels is an option for gauge functions that specifies labels to be placed on the gauge."
GaugeMarkers::usage = "GaugeMarkers is an option for gauge functions that specifies what markers to draw to mark the values."
GaugeStyle::usage = "GaugeStyle is an option for gauge functions that specifies styles in which the markers are to be drawn."
GaussianFilter::usage = "\!\(\*RowBox[{\"GaussianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by convolving with a Gaussian kernel of pixel radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"GaussianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) convolves \!\(\*StyleBox[\"image\", \"TI\"]\) with a kernel formed from the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivatives of the discrete Gaussian.\n\!\(\*RowBox[{RowBox[{\"GaussianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \" \"}]\) uses a Gaussian kernel with radius \!\(\*StyleBox[\"r\", \"TI\"]\) and standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GaussianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses radii \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) etc. in vertical and horizontal directions.\n\!\(\*RowBox[{\"GaussianFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies Gaussian filtering to an array of \!\(\*StyleBox[\"data\", \"TI\"]\). "
GaussianIntegers::usage = "GaussianIntegers is an option for FactorInteger, PrimeQ, Factor, and related functions that specifies whether factorization should be done over Gaussian integers. "
GaussianMatrix::usage = "\!\(\*RowBox[{\"GaussianMatrix\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives a matrix that corresponds to a Gaussian kernel of radius \!\(\*StyleBox[\"r\", \"TI\"]\). \n\!\(\*RowBox[{\"GaussianMatrix\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}], \"]\"}]\) gives a matrix corresponding to a Gaussian kernel with radius \!\(\*StyleBox[\"r\", \"TI\"]\) and standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GaussianMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives a matrix formed from the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative of the Gaussian with respect to rows and the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative with respect to columns.\n\!\(\*RowBox[{\"GaussianMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"12\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"22\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a matrix formed from the sums of the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[StyleBox[RowBox[{\"i\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[StyleBox[RowBox[{\"i\", StyleBox[\"2\", FontSlant -> \"Plain\"]}]], \"TI\"]]\) derivatives.\n\!\(\*RowBox[{\"GaussianMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives an array corresponding to a Gaussian kernel with radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) index direction."
GaussianOrthogonalMatrixDistribution::usage = "\!\(\*RowBox[{\"GaussianOrthogonalMatrixDistribution\", \"[\", RowBox[{StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a Gaussian orthogonal matrix distribution with matrix dimensions \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]\) and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GaussianOrthogonalMatrixDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a Gaussian orthogonal matrix distribution with unit scale parameter."
GaussianSymplecticMatrixDistribution::usage = "\!\(\*RowBox[{\"GaussianSymplecticMatrixDistribution\", \"[\", RowBox[{StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a Gaussian symplectic matrix distribution with matrix dimensions \!\(\*RowBox[{\"{\", RowBox[{StyleBox[RowBox[{\"2\", \" \", \"n\"}], \"TI\"], \",\", StyleBox[RowBox[{\"2\", \" \", \"n\"}], \"TI\"]}], \"}\"}]\) over the field of complex numbers and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GaussianSymplecticMatrixDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a Gaussian symplectic matrix distribution with unit scale parameter."
GaussianUnitaryMatrixDistribution::usage = "\!\(\*RowBox[{\"GaussianUnitaryMatrixDistribution\", \"[\", RowBox[{StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a Gaussian unitary matrix distribution with matrix dimensions \!\(\*RowBox[{\"{\", StyleBox[RowBox[{\"n\", \",\", \"n\"}], \"TI\"], \"}\"}]\) and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GaussianUnitaryMatrixDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a Gaussian unitary matrix distribution with unit scale parameter."
GaussianWindow::usage = "\!\(\*RowBox[{\"GaussianWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Gaussian window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"GaussianWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) uses standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
GCD::usage = "\!\(\*RowBox[{\"GCD\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the greatest common divisor of the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
GegenbauerC::usage = "\!\(\*RowBox[{\"GegenbauerC\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Gegenbauer polynomial \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"C\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", StyleBox[\"m\", \"TI\"], \")\"}]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"GegenbauerC\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the renormalized form \!\(\*RowBox[{UnderscriptBox[\"lim\", RowBox[{StyleBox[\"m\", \"TI\"], \"\[Rule]\", \"0\"}], LimitsPositioning -> True], RowBox[{RowBox[{SubsuperscriptBox[StyleBox[\"C\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", StyleBox[\"m\", \"TI\"], \")\"}]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}], \"/\", StyleBox[\"m\", \"TI\"]}]}]\). "
GeneralizedLinearModelFit::usage = "\!\(\*RowBox[{\"GeneralizedLinearModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) constructs a generalized linear model of the form \!\(\*RowBox[{SuperscriptBox[StyleBox[\"g\", \"TI\"], RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{SubscriptBox[\"\[Beta]\", \"0\"], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"2\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\")\", \"TR\"]}]\) that fits the \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for successive \!\(\*StyleBox[\"x\", \"TI\"]\) values 1, 2, \[Ellipsis].\n\!\(\*RowBox[{\"GeneralizedLinearModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs a generalized linear model of the form \!\(\*RowBox[{SuperscriptBox[StyleBox[\"g\", \"TI\"], RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{SubscriptBox[\"\[Beta]\", \"0\"], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"2\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\")\", \"TR\"]}]\) where the \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) depend on the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"GeneralizedLinearModelFit\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"]\"}]\) constructs a generalized linear model from the design matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and response vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
General::usage = "General is a symbol to which general system messages are attached. "
GenerateAsymmetricKeyPair::usage = "\!\(\*RowBox[{\"GenerateAsymmetricKeyPair\", \"[\", \"]\"}]\) randomly generates a PrivateKey and corresponding PublicKey object for use with public-key cryptographic functions.\n\!\(\*RowBox[{\"GenerateAsymmetricKeyPair\", \"[\", StyleBox[\"opts\", \"TI\"], \"]\"}]\) randomly generates private and public keys using the specified options."
GenerateConditions::usage = "GenerateConditions is an option for Integrate, Sum, and similar functions that specifies whether explicit conditions on parameters should be generated in the result."
GeneratedCell::usage = "GeneratedCell is an option for Cell that indicates whether the cell was generated from the kernel. "
GeneratedDocumentBinding::usage = "GeneratedDocumentBinding is an option for supplying parameters to a DocumentGenerator during manual evaluation."
GenerateDocument::usage = "\!\(\*RowBox[{\"GenerateDocument\", \"[\", StyleBox[\"nb\", \"TI\"], \"]\"}]\) generates a document by evaluating all template elements in the notebook \!\(\*StyleBox[\"nb\", \"TI\"]\).\n\!\(\*RowBox[{\"GenerateDocument\", \"[\", RowBox[{StyleBox[\"nb\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) generates a document using \!\(\*StyleBox[\"args\", \"TI\"]\) to fill template slots.\n\!\(\*RowBox[{\"GenerateDocument\", \"[\", RowBox[{StyleBox[\"nb\", \"TI\"], \",\", StyleBox[\"output\", \"TI\"]}], \"]\"}]\) writes the generated document in the output file represented by \!\(\*StyleBox[\"output\", \"TI\"]\).\n\!\(\*RowBox[{\"GenerateDocument\", \"[\", RowBox[{StyleBox[\"nb\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"], \",\", StyleBox[\"output\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"args\", \"TI\"]\) to fill template slots and puts the result in \!\(\*StyleBox[\"output\", \"TI\"]\)."
GeneratedParameters::usage = "GeneratedParameters is an option that specifies how parameters generated to represent the results of various symbolic operations should be named. "
GenerateHTTPResponse::usage = "\!\(\*RowBox[{\"GenerateHTTPResponse\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the HTTPResponse object that is generated when a cloud object containing \!\(\*StyleBox[\"expr\", \"TI\"]\) is requested on the web.\n\!\(\*RowBox[{\"GenerateHTTPResponse\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"req\", \"TI\"]}], \"]\"}]\) gives the response for the HTTP request specified by \!\(\*StyleBox[\"req\", \"TI\"]\)."
GenerateSymmetricKey::usage = "\!\(\*RowBox[{\"GenerateSymmetricKey\", \"[\", \"]\"}]\) randomly generates a SymmetricKey object suitable for use with cryptographic functions.\n\!\(\*RowBox[{\"GenerateSymmetricKey\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"password\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) generates a SymmetricKey object from the password string given.\n\!\(\*RowBox[{\"GenerateSymmetricKey\", \"[\", StyleBox[\"opts\", \"TI\"], \"]\"}]\) randomly generates a symmetric key using the specified options."
GeneratingFunction::usage = "\!\(\*RowBox[{\"GeneratingFunction\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the generating function in \!\(\*StyleBox[\"x\", \"TI\"]\) for the sequence whose \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) series coefficient is given by the expression \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"GeneratingFunction\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional generating function in \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) whose \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) coefficient is given by \!\(\*StyleBox[\"expr\", \"TI\"]\)."
GeneratorDescription::usage = "GeneratorDescription is an option for providing a textual description for a DocumentGenerator."
GeneratorHistoryLength::usage = "GeneratorHistoryLength is an option for document generators controlling the number of runs archived in the cloud."
GeneratorOutputType::usage = "GeneratorOutputType is an option controlling the file format of documents produced by a DocumentGenerator."
GenericCylindricalDecomposition::usage = "\!\(\*RowBox[{\"GenericCylindricalDecomposition\", \"[\", RowBox[{StyleBox[\"ineqs\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds the full-dimensional part of the decomposition of the region represented by the inequalities \!\(\*StyleBox[\"ineqs\", \"TI\"]\) into cylindrical parts whose directions correspond to the successive \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), together with any hypersurfaces containing the rest of the region."
Generic::usage = "Generic is a setting for the Mode option of Solve and related functions."
GenomeData::usage = "\!\(\*RowBox[{\"GenomeData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"gene\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the DNA sequence for the specified gene on the reference human genome.\n\!\(\*RowBox[{\"GenomeData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"gene\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the human gene \!\(\*StyleBox[\"gene\", \"TI\"]\).\n\!\(\*RowBox[{\"GenomeData\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"chr\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}], \"]\"}]\) gives the sequence from positions \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) on chromosome \!\(\*StyleBox[\"chr\", \"TI\"]\) in the reference human genome."
GenomeLookup::usage = "\!\(\*RowBox[{\"GenomeLookup\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"seq\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) returns the positions of exact matches for the DNA sequence \!\(\*StyleBox[\"seq\", \"TI\"]\) on the reference human genome.\n\!\(\*RowBox[{\"GenomeLookup\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"seq\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns at most \!\(\*StyleBox[\"n\", \"TI\"]\) matches."
GeoArea::usage = "\!\(\*RowBox[{\"GeoArea\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the area of the geo region \!\(\*StyleBox[\"g\", \"TI\"]\)."
GeoBackground::usage = "GeoBackground is an option that specifies the background style of a GeoGraphics object."
GeoBoundingBox::usage = "\!\(\*RowBox[{GeoBoundingBox, \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the geo positions that define the bounding rectangle enclosing the geo region \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{GeoBoundingBox, \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Delta]\", \"TR\"]}], \"]\"}]\) pads the region on all sides by an amount \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\).\n\!\(\*RowBox[{GeoBoundingBox, \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"Scaled\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]}], \"]\"}]\) pads by a fractional amount \!\(\*StyleBox[\"s\", \"TI\"]\)."
GeoBoundsRegion::usage = "\!\(\*RowBox[{\"GeoBoundsRegion\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"}\"}], \"]\"}]\) is a two-dimensional GeoGraphics primitive that represents a geo region bounded by parallels \!\(\*SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"min\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) and meridians \!\(\*SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"min\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) on the surface of the Earth.\n\!\(\*RowBox[{\"GeoBoundsRegion\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) represents the latitude-longitude bounding box of the geo region \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoBoundsRegion\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Delta]\", \"TR\"]}], \"]\"}]\) pads the ranges of latitudes and longitudes by \!\(\*RowBox[{\"\[PlusMinus]\", StyleBox[\"\[Delta]\", \"TR\"]}]\)."
GeoBounds::usage = "\!\(\*RowBox[{\"GeoBounds\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the ranges of latitudes and longitudes in the geo region \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoBounds\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Delta]\", \"TR\"]}], \"]\"}]\) pads ranges of latitudes and longitudes by \!\(\*RowBox[{\"\[PlusMinus]\", StyleBox[\"\[Delta]\", \"TR\"]}]\).\n\!\(\*RowBox[{\"GeoBounds\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"Scaled\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]}], \"]\"}]\) pads range of latitudes and longitudes by a scaled amount \!\(\*StyleBox[\"s\", \"TI\"]\)."
GeoCenter::usage = "GeoCenter is an option for GeoGraphics that specifies the coordinates of the point that should appear at the geographic center of the final map."
GeoCircle::usage = "\!\(\*RowBox[{\"GeoCircle\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) is a two-dimensional GeoGraphics primitive that represents a circle of radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at the location \!\(\*StyleBox[\"loc\", \"TI\"]\) on the surface of the Earth.\n\!\(\*RowBox[{\"GeoCircle\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents a sector of a circle from bearing \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to bearing \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
GeodesicClosing::usage = "\!\(\*RowBox[{\"GeodesicClosing\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the geodesic closing of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to the structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"GeodesicClosing\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the geodesic closing with respect to a range \!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"GeodesicClosing\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies geodesic closing to an array of data."
GeodesicDilation::usage = "\!\(\*RowBox[{\"GeodesicDilation\", \"[\", RowBox[{StyleBox[\"marker\", \"TI\"], \",\", StyleBox[\"mask\", \"TI\"]}], \"]\"}]\) gives the fixed point of the geodesic dilation of the \!\(\*StyleBox[\"marker\", \"TI\"]\) constrained by the \!\(\*StyleBox[\"mask\", \"TI\"]\)."
GeodesicErosion::usage = "\!\(\*RowBox[{\"GeodesicErosion\", \"[\", RowBox[{StyleBox[\"marker\", \"TI\"], \",\", StyleBox[\"mask\", \"TI\"]}], \"]\"}]\) gives the fixed point of the geodesic erosion of the \!\(\*StyleBox[\"marker\", \"TI\"]\) constrained by the \!\(\*StyleBox[\"mask\", \"TI\"]\)."
GeodesicOpening::usage = "\!\(\*RowBox[{\"GeodesicOpening\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the geodesic opening of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to the structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"GeodesicOpening\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the geodesic opening with respect to a range \!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"GeodesicOpening\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies geodesic opening to an array of data."
GeoDestination::usage = "\!\(\*RowBox[{\"GeoDestination\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the end position of the geodesic of length \!\(\*StyleBox[\"d\", \"TI\"]\) starting from \!\(\*StyleBox[\"loc\", \"TI\"]\) with azimuthal direction \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
GeodesyData::usage = "\!\(\*RowBox[{\"GeodesyData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for a named geodetic datum or reference ellipsoid.\n\!\(\*RowBox[{\"GeodesyData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the property for the ellipsoid with semimajor axis \!\(\*StyleBox[\"a\", \"TI\"]\) and semiminor axis \!\(\*StyleBox[\"b\", \"TI\"]\).\n\!\(\*RowBox[{\"GeodesyData\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"coords\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the value of the property at the specified coordinates."
Geodesy`GeodeticToAuthalic::usage = "\!\(\*RowBox[{\"GeodeticToAuthalic\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"latitude\", \"TI\"], \",\", StyleBox[\"longitude\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"eccentricity\", \"TI\"]}], \"]\"}]\) gives the coordinates of the corresponding point on an authalic sphere given the latitude and longitude of a point on a spheroid with specified eccentricity."
Geodesy`SemimajorAxis::usage = "SemimajorAxis is an option for SpheroidalDistance which specifies the length of the semimajor axis in the spheroidal model."
Geodesy`SphericalDistance::usage = "\!\(\*RowBox[{\"SphericalDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the distance between points \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) on Earth using a spherical model of the planet. "
Geodesy`SpheroidalDistance::usage = "\!\(\*RowBox[{\"SpheroidalDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the distance between points \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) on Earth using the spheroidal model of the planet."
Geodesy`ToAuthalicRadius::usage = "\!\(\*RowBox[{\"ToAuthalicRadius\", \"[\", RowBox[{StyleBox[\"semimajor\", \"TI\"], \",\", StyleBox[\"eccentricity\", \"TI\"]}], \"]\"}]\) gives the radius of the authalic sphere based on the spheroid with semimajor axis \!\(\*StyleBox[\"semimajor\", \"TI\"]\) and eccentricity \!\(\*StyleBox[\"eccentricity\", \"TI\"]\)."
Geodesy`ToDegrees::usage = "\!\(\*RowBox[{\"ToDegrees\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"degrees\", \"TI\"], \",\", StyleBox[\"minutes\", \"TI\"], \",\", StyleBox[\"seconds\", \"TI\"]}], \"}\"}], \"]\"}]\) converts a coordinate in degree-minute-second format to degrees.\n\!\(\*RowBox[{\"ToDegrees\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"degrees\", \"TI\"], \",\", StyleBox[\"minutes\", \"TI\"]}], \"}\"}], \"]\"}]\) converts from degrees-minutes format to degrees."
Geodesy`ToDMS::usage = "\!\(\*RowBox[{\"ToDMS\", \"[\", StyleBox[\"degrees\", \"TI\"], \"]\"}]\) converts a coordinate in degrees to degree-minute-second format."
GeoDirection::usage = "\!\(\*RowBox[{\"GeoDirection\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the azimuthal direction from one latitude-longitude position on the Earth to another.\n\!\(\*RowBox[{\"GeoDirection\", \"[\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the azimuthal direction between locations specified by position objects or geographic entities."
GeoDisk::usage = "\!\(\*RowBox[{RowBox[{\"GeoDisk\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}], \" \"}]\) is a two-dimensional GeoGraphics primitive that represents a filled disk of radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at the location \!\(\*StyleBox[\"loc\", \"TI\"]\) on the surface of the Earth.\n\!\(\*RowBox[{\"GeoDisk\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives a sector of a disk from bearing \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to bearing \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
GeoDisplacement::usage = "\!\(\*RowBox[{\"GeoDisplacement\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}], \"]\"}]\) represents a geodesic displacement of length \!\(\*StyleBox[\"dist\", \"TI\"]\) and initial bearing \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) from a geo location.\n\!\(\*RowBox[{\"GeoDisplacement\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}], \",\", StyleBox[\"pathtype\", \"TI\"]}], \"]\"}]\) represents a displacement of length \!\(\*StyleBox[\"dist\", \"TI\"]\) and initial bearing \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) along a path of type \!\(\*StyleBox[\"pathtype\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoDisplacement\", \"[\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"pathtype\", \"TI\"]}], \"]\"}]\) returns the displacement needed to reach \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) from \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) along a path of type \!\(\*StyleBox[\"pathtype\", \"TI\"]\)."
GeoDistance::usage = "\!\(\*RowBox[{\"GeoDistance\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the geodesic distance between latitude-longitude positions on the Earth.\n\!\(\*RowBox[{\"GeoDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the distance between locations specified by position objects or geographical entities."
GeoElevationData::usage = "\!\(\*RowBox[{\"GeoElevationData\", \"[\", \"]\"}]\) gives the elevation above sea level at $GeoLocation.\n\!\(\*RowBox[{\"GeoElevationData\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) gives the elevation at the geographic location \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoElevationData\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) gives an array of elevation values within the bounding box given by \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"GeoElevationData\", \"[\", RowBox[{\"GeoPosition\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \"]\"}]\) gives the list of elevations at the positions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"GeoElevationData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"etype\", \"TI\"]}], \"]\"}]\) gives the elevation of type \!\(\*StyleBox[\"etype\", \"TI\"]\) for the location \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoElevationData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"etype\", \"TI\"], \",\", StyleBox[\"format\", \"TI\"]}], \"]\"}]\) gives the elevation in the specified format."
GeoEntities::usage = "\!\(\*RowBox[{\"GeoEntities\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"enttype\", \"TI\"]}], \"]\"}]\) gives a list of the geographic entities of type \!\(\*StyleBox[\"enttype\", \"TI\"]\) contained in the extended region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
GeoGraphics::usage = "\!\(\*RowBox[{\"GeoGraphics\", \"[\", RowBox[{StyleBox[\"primitives\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) represents a two-dimensional geographical image."
GeogravityModelData::usage = "\!\(\*RowBox[{\"GeogravityModelData\", \"[\", \"]\"}]\) returns the gravitational field data for the current location.\n\!\(\*RowBox[{\"GeogravityModelData\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) returns the gravitational field data for a location.\n\!\(\*RowBox[{\"GeogravityModelData\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"component\", \"TI\"]}], \"]\"}]\) returns the component of the gravitational field."
GeoGridLinesStyle::usage = "GeoGridLinesStyle is an option for GeoGraphics that specifies how parallels and meridians should be rendered."
GeoGridLines::usage = "\!\(\*RowBox[{\"GeoGridLines\", \" \"}]\) is an option for GeoGraphics that specifies what parallels and meridians to show."
GeoGridPosition::usage = "\!\(\*RowBox[{\"GeoGridPosition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"proj\", \"TI\"]}], \"]\"}]\) represents a point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) in a planimetric cartographic grid using the projection \!\(\*StyleBox[\"proj\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoGridPosition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"proj\", \"TI\"]}], \"]\"}]\) represents a point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]\) in a cartographic grid with height \!\(\*StyleBox[\"h\", \"TI\"]\) with respect to the reference ellipsoid.\n\!\(\*RowBox[{\"GeoGridPosition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"proj\", \"TI\"], \",\", StyleBox[\"datum\", \"TI\"]}], \"]\"}]\) represents a point in a cartographic grid obtained by projection from data in the given datum."
GeoGroup::usage = "\!\(\*RowBox[{\"GeoGroup\", \"[\", StyleBox[\"geoobjects\", \"TI\"], \"]\"}]\) represents a list of geographic objects to be treated as a single object for certain operations."
GeoHemisphereBoundary::usage = "\!\(\*RowBox[{\"GeoHemisphereBoundary\", \"[\", \"]\"}]\) is a one-dimensional GeoGraphics primitive that represents the boundary line of a hemisphere of the Earth centered at the current geo location.\n\!\(\*RowBox[{\"GeoHemisphereBoundary\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) represents the boundary line of a hemisphere centered at the location \!\(\*StyleBox[\"loc\", \"TI\"]\)."
GeoHemisphere::usage = "\!\(\*RowBox[{\"GeoHemisphere\", \"[\", \"]\"}]\) is a two-dimensional GeoGraphics primitive that represents the half of the Earth centered at your current geo location.\n\!\(\*RowBox[{\"GeoHemisphere\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) represents the half of the Earth centered at the location \!\(\*StyleBox[\"loc\", \"TI\"]\)."
GeoIdentify::usage = "\!\(\*RowBox[{\"GeoIdentify\", \"[\", StyleBox[\"enttype\", \"TI\"], \"]\"}]\) identifies the geographic entities of the type \!\(\*StyleBox[\"enttype\", \"TI\"]\) in which the current geo location is contained.\n\!\(\*RowBox[{\"GeoIdentify\", \"[\", RowBox[{StyleBox[\"enttype\", \"TI\"], \",\", StyleBox[\"loc\", \"TI\"]}], \"]\"}]\) identifies the entities in which the location \!\(\*StyleBox[\"loc\", \"TI\"]\) is contained.\n\!\(\*RowBox[{\"GeoIdentify\", \"[\", \"]\"}]\) identifies the entities of any type in which the current geo location is contained."
GeoLabels::usage = "GeoLabels is an option for GeoListPlot and GeoRegionValuePlot that specifies whether and how to add labels to the locations in the first argument."
GeoListPlot::usage = "\!\(\*RowBox[{\"GeoListPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a map on which the locations \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are indicated.\n\!\(\*RowBox[{RowBox[{\"GeoListPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \" \"}]\) generates a map showing several lists of locations. "
GeoLocation::usage = "GeoLocation is an option for Interpreter and related functions that specifies the location to assume for semantic interpretation."
GeologicalPeriodData::usage = "\!\(\*RowBox[{\"GeologicalPeriodData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the geological period \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"GeologicalPeriodData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified period name entities.\n\!\(\*RowBox[{\"GeologicalPeriodData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
GeomagneticModelData::usage = "\!\(\*RowBox[{\"GeomagneticModelData\", \"[\", \"]\"}]\) returns the current magnetic field data for the current location.\n\!\(\*RowBox[{\"GeomagneticModelData\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) returns the current magnetic field data for a location.\n\!\(\*RowBox[{\"GeomagneticModelData\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) returns the magnetic field data for the specified time for the current location.\n\!\(\*RowBox[{\"GeomagneticModelData\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) returns the magnetic field data for the specified time and location.\n\!\(\*RowBox[{\"GeomagneticModelData\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"component\", \"TI\"]}], \"]\"}]\) returns the component of the magnetic field for the specified time and location."
GeoMarker::usage = "\!\(\*RowBox[{\"GeoMarker\", \"[\", \"]\"}]\) is a GeoGraphics primitive that represents a marker at the current $GeoLocation.\n\!\(\*RowBox[{\"GeoMarker\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) is a GeoGraphics primitive that represents a marker at the location \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoMarker\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a GeoGraphics primitive that represents markers at locations \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"GeoMarker\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"]}], \"]\"}]\) is a GeoGraphics primitive that represents a custom marker at the location \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoMarker\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"marker\", \"TI\"]}], \"]\"}]\) is a GeoGraphics primitive that represents custom markers at locations \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
GeometricBrownianMotionProcess::usage = "\!\(\*RowBox[{\"GeometricBrownianMotionProcess\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents a geometric Brownian motion process with drift \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), volatility \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\), and initial value \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
GeometricDistribution::usage = "\!\(\*RowBox[{\"GeometricDistribution\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) represents a geometric distribution with probability parameter \!\(\*StyleBox[\"p\", \"TI\"]\). "
GeometricMeanFilter::usage = "\!\(\*RowBox[{\"GeometricMeanFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every value by the geometric mean of the values in its range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"GeometricMeanFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies geometric mean filtering to an array of data."
GeometricMean::usage = "\!\(\*RowBox[{\"GeometricMean\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the geometric mean of the values in \!\(\*StyleBox[\"list\", \"TI\"]\)."
GeometricTransformation3DBoxOptions::usage = "\!\(\*RowBox[{GeometricTransformation3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for GeometricTransformation3DBox objects."
GeometricTransformationBoxOptions::usage = "\!\(\*RowBox[{GeometricTransformationBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for GeometricTransformationBox objects."
GeometricTransformation::usage = "\!\(\*RowBox[{\"GeometricTransformation\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"tfun\", \"TI\"]}], \"]\"}]\) represents the result of applying the transformation function \!\(\*StyleBox[\"tfun\", \"TI\"]\) to the geometric objects corresponding to the primitives \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GeometricTransformation\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) transforms geometric objects in \!\(\*StyleBox[\"g\", \"TI\"]\) by effectively replacing every point \!\(\*StyleBox[\"r\", \"TI\"]\) by \!\(\*RowBox[{StyleBox[\"m\", \"TI\"], \".\", StyleBox[\"r\", \"TI\"]}]\). \n\!\(\*RowBox[{\"GeometricTransformation\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) effectively replaces every point \!\(\*StyleBox[\"r\", \"TI\"]\) by \!\(\*RowBox[{RowBox[{StyleBox[\"m\", \"TI\"], \".\", StyleBox[\"r\", \"TI\"]}], \"+\", StyleBox[\"v\", \"TI\"]}]\).\n\!\(\*RowBox[{\"GeometricTransformation\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents multiple copies of \!\(\*StyleBox[\"g\", \"TI\"]\) transformed by a collection of transformations."
GeoModel::usage = "GeoModel is an option for GeoGraphics that specifies the reference body or model for it for the purposes of geodetic computations and map drawing."
GeoNearest::usage = "\!\(\*RowBox[{\"GeoNearest\", \"[\", RowBox[{StyleBox[\"enttype\", \"TI\"], \",\", StyleBox[\"loc\", \"TI\"]}], \"]\"}]\) returns the geographic entity of type \!\(\*StyleBox[\"enttype\", \"TI\"]\) closest to the geo location \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoNearest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"loc\", \"TI\"]}], \"]\"}]\) returns the nearest of the \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"GeoNearest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]}], \"}\"}], \",\", StyleBox[\"loc\", \"TI\"]}], \"]\"}]\) returns the \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the nearest \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"GeoNearest\", \"[\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \",\", StyleBox[\"loc\", \"TI\"]}], \"]\"}]\) returns the same result.\n\!\(\*RowBox[{\"GeoNearest\", \"[\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \"\[Ellipsis]\", \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"\[Rule]\", \"Automatic\"}], \",\", StyleBox[\"loc\", \"TI\"]}], \"]\"}]\) takes the \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to be successive integers \!\(\*StyleBox[\"i\", \"TI\"]\). \n\!\(\*RowBox[{\"GeoNearest\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns \!\(\*StyleBox[\"n\", \"TI\"]\) nearest values.\n\!\(\*RowBox[{\"GeoNearest\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"loc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]}], \"]\"}]\) returns up to \!\(\*StyleBox[\"n\", \"TI\"]\) matches within a radius \!\(\*StyleBox[\"r\", \"TI\"]\) of \!\(\*StyleBox[\"loc\", \"TI\"]\)."
GeoPath::usage = "\!\(\*RowBox[{\"GeoPath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"pathtype\", \"TI\"]}], \"]\"}]\) is a GeoGraphics primitive that represents a path of type \!\(\*StyleBox[\"pathtype\", \"TI\"]\) between locations \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"GeoPath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"pathtype\", \"TI\"]}], \"]\"}]\) represents a path formed by joining paths of type \!\(\*StyleBox[\"pathtype\", \"TI\"]\) between consecutive locations \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"GeoPath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"pathtype\", \"TI\"]}], \"]\"}]\) represents a path moving from location \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) a distance \!\(\*StyleBox[\"d\", \"TI\"]\) with initial bearing \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\).\n\!\(\*RowBox[{\"GeoPath\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"pathtype\", \"TI\"]}], \"]\"}]\) represents a disjoint collection of paths of type \!\(\*StyleBox[\"pathtype\", \"TI\"]\)."
GeoPositionENU::usage = "\!\(\*RowBox[{RowBox[{\"GeoPositionENU\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"east\", \"TI\"], \",\", StyleBox[\"north\", \"TI\"], \",\", StyleBox[\"up\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}], \" \"}]\) represents a position with local Cartesian coordinates \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"east\", \"TI\"], \",\", StyleBox[\"north\", \"TI\"], \",\", StyleBox[\"up\", \"TI\"]}], \"}\"}]\) in a reference system centered at the position \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoPositionENU\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents an array of positions.\n\!\(\*RowBox[{\"GeoPositionENU\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) returns the Cartesian position with respect to \!\(\*StyleBox[\"p\", \"TI\"]\) of the specified geographical entity."
GeoPosition::usage = "\!\(\*RowBox[{\"GeoPosition\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"lon\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a geodetic position with latitude \!\(\*StyleBox[\"lat\", \"TI\"]\) and longitude \!\(\*StyleBox[\"lon\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoPosition\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"lon\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a geodetic position with height \!\(\*StyleBox[\"h\", \"TI\"]\) relative to the reference ellipsoid.\n\!\(\*RowBox[{\"GeoPosition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"lon\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"datum\", \"TI\"]}], \"]\"}]\) represents a geodetic position referring to the specified datum.\n\!\(\*RowBox[{\"GeoPosition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lat\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lon\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"datum\", \"TI\"]}], \"]\"}]\) represents an array of geodetic positions.\n\!\(\*RowBox[{\"GeoPosition\", \"[\", StyleBox[\"entity\", \"TI\"], \"]\"}]\) returns the geodetic position of the specified geographical entity."
GeoPositionXYZ::usage = "\!\(\*RowBox[{\"GeoPositionXYZ\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a position in a Cartesian geocentric coordinate system.\n\!\(\*RowBox[{\"GeoPositionXYZ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"datum\", \"TI\"]}], \"]\"}]\) represents a point referred to the specified datum.\n\!\(\*RowBox[{\"GeoPositionXYZ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"datum\", \"TI\"]}], \"]\"}]\) represents an array of points in a Cartesian geocentric coordinate system.\n\!\(\*RowBox[{\"GeoPositionXYZ\", \"[\", StyleBox[\"entity\", \"TI\"], \"]\"}]\) returns the Cartesian geocentric position of the given geographical entity."
GeoProjectionData::usage = "\!\(\*RowBox[{\"GeoProjectionData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"projection\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the specified cartographic projection.\n\!\(\*RowBox[{\"GeoProjectionData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"projection\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the complete options for the default form of the specified projection."
GeoProjection::usage = "GeoProjection is an option for GeoGraphics that specifies the cartographic projection to use for the map."
GeoRangePadding::usage = "GeoRangePadding is an option for GeoGraphics that specifies what padding to use when extending beyond the original ranges of latitude and longitude."
GeoRange::usage = "GeoRange is an option for GeoGraphics and GeoStyling that specifies the range of latitude and longitude to include. "
GeoRegionValuePlot::usage = "\!\(\*RowBox[{\"GeoRegionValuePlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a plot in which the geographic regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are colored according to the values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"GeoRegionValuePlot\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) generates a plot in which the geographic subdivisions of \!\(\*StyleBox[\"reg\", \"TI\"]\) are colored according to the values \!\(\*RowBox[{\"EntityValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\).\n\!\(\*RowBox[{\"GeoRegionValuePlot\", \"[\", RowBox[{StyleBox[\"entityclass\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) generates a plot in which the geographic regions in \!\(\*StyleBox[\"entityclass\", \"TI\"]\) are colored according to the values \!\(\*RowBox[{\"EntityValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\)."
GeoScaleBar::usage = "\!\(\*RowBox[{\"GeoScaleBar\", \" \"}]\) is an option for GeoGraphics that determines what scale to show on the map."
GeoServer::usage = "GeoServer is an option for GeoGraphics and GeoStyling that specifies the URL address of a geo server and connection parameters to download map tiles and geo elevation data."
GeoStylingImageFunction::usage = "GeoStylingImageFunction is an option for specifying an image effect to apply to a geo style."
GeoStyling::usage = "\!\(\*RowBox[{\"GeoStyling\", \"[\", StyleBox[\"mapstyle\", \"TI\"], \"]\"}]\) displays faces of polygons and other filled geo objects using \!\(\*StyleBox[\"mapstyle\", \"TI\"]\).\n\!\(\*RowBox[{\"GeoStyling\", \"[\", RowBox[{StyleBox[\"mapstyle\", \"TI\"], \",\", StyleBox[\"directive\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"mapstyle\", \"TI\"]\)\!\(\*StyleBox[\" \", \"TI\"]\)with the given graphics \!\(\*StyleBox[\"directive\", \"TI\"]\)\!\(\*StyleBox[\" \", \"TI\"]\)applied."
GeoVariant::usage = "\!\(\*RowBox[{\"GeoVariant\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"qual\", \"TI\"]}], \"]\"}]\) represents a geographic object \!\(\*StyleBox[\"obj\", \"TI\"]\) with qualifier \!\(\*StyleBox[\"qual\", \"TI\"]\)."
GeoVisibleRegionBoundary::usage = "\!\(\*RowBox[{\"GeoVisibleRegionBoundary\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"lon\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \"]\"}]\) is a one-dimensional GeoGraphics primitive that represents the boundary of the region on the surface of the Earth visible from the point of coordinates \!\(\*RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"lon\", \"TI\"]}]\) and height \!\(\*StyleBox[\"h\", \"TI\"]\) above the reference ellipsoid.\n\!\(\*RowBox[{\"GeoVisibleRegionBoundary\", \"[\", StyleBox[\"pos\", \"TI\"], \"]\"}]\) represents the boundary of the region visible from the position \!\(\*StyleBox[\"pos\", \"TI\"]\)."
GeoVisibleRegion::usage = "\!\(\*RowBox[{\"GeoVisibleRegion\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"lon\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \"]\"}]\) is a two-dimensional GeoGraphics primitive that represents the region on the surface of the Earth visible from the point of coordinates \!\(\*RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"lon\", \"TI\"]}]\) and height \!\(\*StyleBox[\"h\", \"TI\"]\) above the reference ellipsoid.\n\!\(\*RowBox[{\"GeoVisibleRegion\", \"[\", StyleBox[\"pos\", \"TI\"], \"]\"}]\) represents the region visible from the position \!\(\*StyleBox[\"pos\", \"TI\"]\)."
GeoWithinQ::usage = "\!\(\*RowBox[{\"GeoWithinQ\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"loc\", \"TI\"]}], \"]\"}]\) returns True if the location \!\(\*StyleBox[\"loc\", \"TI\"]\) is contained within the region \!\(\*StyleBox[\"reg\", \"TI\"]\), and False otherwise."
GeoZoomLevel::usage = "GeoZoomLevel is an option for specifying the resolution at which to render a map."
GestureHandler::usage = "\!\(\*RowBox[{RowBox[{\"GestureHandler\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"gesture\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[RuleDelayed]\", SubscriptBox[StyleBox[\"fun\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"gesture\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[RuleDelayed]\", SubscriptBox[StyleBox[\"fun\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]}]}], \"]\"}]\) displays as \!\(\*StyleBox[\"expr\", \"TI\"]\), evaluating \!\(\*RowBox[{SubscriptBox[StyleBox[\"fun\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"velocity\", \"TI\"]}], \"]\"}]\) whenever \"\!\(\*SubscriptBox[\nStyleBox[\"gesture\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\" occurs within the screen space occupied by \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"GestureHandler\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"gesture\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"\[RuleDelayed]\", RowBox[{\"{\", RowBox[{StyleBox[\"fun\", \"TI\"], \",\", SubscriptBox[StyleBox[\"fun\", \"TI\"], StyleBox[\"end\", \"TI\"]]}], \"}\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"fun\", \"TI\"]\) as updates are received for \"\!\(\*\nStyleBox[\"gesture\", \"TI\"]\)\", followed by \!\(\*RowBox[{SubscriptBox[StyleBox[\"fun\", \"TI\"], StyleBox[\"end\", \"TI\"]], \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"velocity\", \"TI\"]}], \"]\"}]\) when the gesture ends.\n\!\(\*RowBox[{\"GestureHandler\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"gesture\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"\[RuleDelayed]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"fun\", \"TI\"], StyleBox[\"start\", \"TI\"]], \",\", StyleBox[\"fun\", \"TI\"], \",\", SubscriptBox[StyleBox[\"fun\", \"TI\"], StyleBox[\"end\", \"TI\"]]}], \"}\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) also evaluates \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"start\", \"TI\"]], \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"velocity\", \"TI\"]}], \"]\"}]\) when \"\!\(\*\nStyleBox[\"gesture\", \"TI\"]\)\" begins."
GetContext::usage = "\!\(\*RowBox[{\"GetContext\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context`\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) loads the file named by \!\(\*RowBox[{\"ContextToFileName\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context`\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\), which gives the conventional filename for a package that defines \"\!\(\*\nStyleBox[\"context`\", \"TI\"]\)\"."
GetEnvironment::usage = "\!\(\*RowBox[{\"GetEnvironment\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"var\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the setting corresponding to the variable \"\!\(\*\nStyleBox[\"var\", \"TI\"]\)\" in the operating system environment.\n\!\(\*RowBox[{\"GetEnvironment\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of rules, corresponding to specified environment variables.\n\!\(\*RowBox[{\"GetEnvironment\", \"[\", \"]\"}]\) gives information about all existing settings in the operating system environment."
Get::usage = "\!\(\*RowBox[{\"<<\", StyleBox[\"name\", \"TI\"]}]\) reads in a file, evaluating each expression in it and returning the last one. \n\!\(\*RowBox[{\"Get\", \"[\", StyleBox[\"stream\", \"TI\"], \"]\"}]\) reads from a stream, evaluating each expression in it and returning the last one."
Glaisher::usage = "Glaisher is Glaisher's constant with numerical value \!\(\*RowBox[{\"\[TildeEqual]\", \"1.28243\"}]\). "
GlobalClusteringCoefficient::usage = "\!\(\*RowBox[{\"GlobalClusteringCoefficient\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the global clustering coefficient of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GlobalClusteringCoefficient\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Glow::usage = "\!\(\*RowBox[{\"Glow\", \"[\", StyleBox[\"col\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that surfaces of 3D graphics objects that follow are to be taken to glow with color \!\(\*StyleBox[\"col\", \"TI\"]\). \n\!\(\*RowBox[{\"Glow\", \"[\", \"]\"}]\) specifies that there is no glow. "
GoldenAngle::usage = "GoldenAngle is the golden angle \!\(\*RowBox[{RowBox[{\"(\", RowBox[{\"3\", \"-\", SqrtBox[\"5\"]}], \")\"}], \" \", \"\[Pi]\"}]\), with numerical value \!\(\*RowBox[{\"\[TildeEqual]\", RowBox[{\"137.5\", \"\[Degree]\"}]}]\)."
GoldenRatio::usage = "GoldenRatio is the golden ratio \!\(\*RowBox[{\"\[Phi]\", \"\[LongEqual]\", RowBox[{FractionBox[\"1\", \"2\"], \" \", RowBox[{\"(\", RowBox[{SqrtBox[\"5\"], \"+\", \"1\"}], \")\"}]}]}]\), with numerical value \!\(\*RowBox[{\"\[TildeEqual]\", \"1.61803\"}]\)."
GompertzMakehamDistribution::usage = "\!\(\*RowBox[{\"GompertzMakehamDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Xi]\", \"TR\"]}], \"]\"}]\) represents a Gompertz distribution with scale parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\) and frailty parameter \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\).\n\!\(\*RowBox[{\"GompertzMakehamDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Xi]\", \"TR\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) represents a Gompertz\[Dash]Makeham distribution with parameters \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\), \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\), \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
GoodmanKruskalGammaTest::usage = "\!\(\*RowBox[{\"GoodmanKruskalGammaTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"GoodmanKruskalGammaTest\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], StyleBox[\",\", \"MR\"], StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
GoodmanKruskalGamma::usage = "\!\(\*RowBox[{\"GoodmanKruskalGamma\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the Goodman\[Dash]Kruskal \[Gamma] coefficient for the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"GoodmanKruskalGamma\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the Goodman\[Dash]Kruskal \[Gamma] coefficients for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"GoodmanKruskalGamma\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the Goodman\[Dash]Kruskal \[Gamma] coefficients for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"GoodmanKruskalGamma\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the \[Gamma] coefficient matrix for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"GoodmanKruskalGamma\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) \[Gamma] coefficient for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
Goto::usage = "\!\(\*RowBox[{\"Goto\", \"[\", StyleBox[\"tag\", \"TI\"], \"]\"}]\) scans for \!\(\*RowBox[{\"Label\", \"[\", StyleBox[\"tag\", \"TI\"], \"]\"}]\), and transfers control to that point. "
GradientFilter::usage = "\!\(\*RowBox[{\"GradientFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives an image corresponding to the magnitude of the gradient of \!\(\*StyleBox[\"image\", \"TI\"]\), computed using discrete derivatives of a Gaussian of pixel radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"GradientFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses a Gaussian with standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GradientFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses a Gaussian with radii \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) etc. in the vertical and horizontal directions.\n\!\(\*RowBox[{\"GradientFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies gradient filtering to an array of data."
GradientOrientationFilter::usage = "\!\(\*RowBox[{\"GradientOrientationFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives an image corresponding to the local orientation parallel to the gradient of \!\(\*StyleBox[\"image\", \"TI\"]\), computed using discrete derivatives of a Gaussian of pixel radius \!\(\*StyleBox[\"r\", \"TI\"]\), returning values between \!\(\*RowBox[{RowBox[{\"-\", \"\[Pi]\"}], \"/\", \"2\"}]\) and \!\(\*RowBox[{\"\[Pi]\", \"/\", \"2\"}]\).\n\!\(\*RowBox[{\"GradientOrientationFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses a Gaussian with standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"GradientOrientationFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies orientation filtering to an array of \!\(\*StyleBox[\"data\", \"TI\"]\)."
Gradient::usage = "Gradient is an option for FindMinimum and related functions that specifies the gradient vector to assume for the function being extremized."
Grad::usage = "\!\(\*RowBox[{\"Grad\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the gradient \!\(\*RowBox[{\"(\", RowBox[{RowBox[{RowBox[{\"\[PartialD]\", StyleBox[\"f\", \"TI\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"]}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"\[PartialD]\", StyleBox[\"f\", \"TI\"]}], \"/\", RowBox[{\"\[PartialD]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]}]}], \")\"}]\).\n\!\(\*RowBox[{\"Grad\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) gives the gradient in the coordinates \!\(\*StyleBox[\"chart\", \"TI\"]\)."
GrammarApply::usage = "\!\(\*RowBox[{\"GrammarApply\", \"[\", RowBox[{StyleBox[\"grammar\", \"TI\"], \",\", StyleBox[\"input\", \"TI\"]}], \"]\"}]\) attempts to parse \!\(\*StyleBox[\"input\", \"TI\"]\) according to the grammar defined by \!\(\*StyleBox[\"grammar\", \"TI\"]\)."
GrammarRules::usage = "\!\(\*RowBox[{\"GrammarRules\", \"[\", StyleBox[\"rules\", \"TI\"], \"]\"}]\) represents grammar rules to be deployed to a cloud object that implements the grammar in a form suitable for use with functions like GrammarApply and Interpreter.\n\!\(\*RowBox[{\"GrammarRules\", \"[\", RowBox[{StyleBox[\"rules\", \"TI\"], \",\", StyleBox[\"defs\", \"TI\"]}], \"]\"}]\) uses grammar definitions \!\(\*StyleBox[\"defs\", \"TI\"]\)."
GrammarToken::usage = "\!\(\*RowBox[{\"GrammarToken\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) is a grammar rules pattern object that represents any input of the specified form. "
Graph3D::usage = "\!\(\*RowBox[{\"Graph3D\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) creates a graph with vertices and edges from the graph \!\(\*StyleBox[\"g\", \"TI\"]\) and represented as a 3D plot.\n\!\(\*RowBox[{\"Graph3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a graph with edges \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) and represented as a 3D plot.\n\!\(\*RowBox[{\"Graph3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) creates a graph with vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and edges \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"j\", \"TI\"]]\). "
GraphAssortativity::usage = "\!\(\*RowBox[{\"GraphAssortativity\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the assortativity coefficient of a graph \!\(\*StyleBox[\"g\", \"TI\"]\) using vertex degrees.\n\!\(\*RowBox[{\"GraphAssortativity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the assortativity coefficient of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) using vertex property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\".\n\!\(\*RowBox[{\"GraphAssortativity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], StyleBox[\"\[InvisibleSpace]\", \"TR\"], StyleBox[\"1\", \"TR\"]}]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], StyleBox[\"\[InvisibleSpace]\", \"TR\"], StyleBox[\"2\", \"TR\"]}]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the assortativity coefficient of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) with respect to the vertex partition \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], StyleBox[\"\[InvisibleSpace]\", \"TR\"], StyleBox[\"1\", \"TR\"]}]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], StyleBox[\"\[InvisibleSpace]\", \"TR\"], StyleBox[\"2\", \"TR\"]}]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"GraphAssortativity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]}], \"]\"}]\) gives the assortativity coefficient of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) using data \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) for vertices \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"GraphAssortativity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
GraphAutomorphismGroup::usage = "\!\(\*RowBox[{\"GraphAutomorphismGroup\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the automorphism group of a graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphAutomorphismGroup\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphCenter::usage = "\!\(\*RowBox[{\"GraphCenter\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the set of vertices with minimum eccentricity in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphCenter\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphComplement::usage = "\!\(\*RowBox[{\"GraphComplement\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the graph complement of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphComplement\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphData::usage = "\!\(\*RowBox[{\"GraphData\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) gives a graph with the specified name.\n\!\(\*RowBox[{\"GraphData\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value for the specified property for a named graph.\n\!\(\*RowBox[{\"GraphData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"class\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of named graphs in the specified class.\n\!\(\*RowBox[{\"GraphData\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a list of named graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices."
GraphDensity::usage = "\!\(\*RowBox[{\"GraphDensity\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the graph density of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphDensity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphDiameter::usage = "\!\(\*RowBox[{\"GraphDiameter\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the greatest distance between any pair of vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphDiameter\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphDifference::usage = "\!\(\*RowBox[{\"GraphDifference\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the graph difference of the graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"GraphDifference\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphDisjointUnion::usage = "\!\(\*RowBox[{\"GraphDisjointUnion\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the graph disjoint union of the graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"GraphDisjointUnion\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the disjoint union of \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"GraphDisjointUnion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphDistanceMatrix::usage = "\!\(\*RowBox[{\"GraphDistanceMatrix\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the matrix of distances between vertices for the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphDistanceMatrix\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the matrix of distances between vertices of maximal distance \!\(\*StyleBox[\"d\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphDistanceMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphDistance::usage = "\!\(\*RowBox[{\"GraphDistance\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the distance from source vertex \!\(\*StyleBox[\"s\", \"TI\"]\) to target vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphDistance\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the distance from \!\(\*StyleBox[\"s\", \"TI\"]\) to all vertices of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphDistance\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphEmbedding::usage = "\!\(\*RowBox[{\"GraphEmbedding\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives coordinates of the vertices of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphEmbedding\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"emb\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives coordinates of the vertices of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) using the embedding \"\!\(\*\nStyleBox[\"emb\", \"TI\"]\)\".\n\!\(\*RowBox[{\"GraphEmbedding\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"emb\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"dim\", \"TI\"]}], \"]\"}]\) gives coordinates in dimension \!\(\*StyleBox[\"dim\", \"TI\"]\) of the vertices of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) using the embedding \"\!\(\*\nStyleBox[\"emb\", \"TI\"]\)\"."
GraphHighlightStyle::usage = "GraphHighlightStyle is an option to Graph and related objects that specifies styles to use for highlighted graph elements. "
GraphHighlight::usage = "GraphHighlight is an option to Graph and related objects that specifies graph elements to highlight. "
GraphHub::usage = "\!\(\*RowBox[{\"GraphHub\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the set of vertices with maximum vertex degree in the underlying simple graph of \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphHub\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"In\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives the set of vertices with maximum vertex in-degree.\n\!\(\*RowBox[{\"GraphHub\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"Out\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives the set of vertices with maximum vertex out-degree.\n\!\(\*RowBox[{\"GraphHub\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Graphics3DBoxOptions::usage = "\!\(\*RowBox[{Graphics3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for Graphics3DBox objects."
Graphics3D::usage = "\!\(\*RowBox[{\"Graphics3D\", \"[\", RowBox[{StyleBox[\"primitives\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) represents a three-dimensional graphical image. "
GraphicsArray::usage = "\!\(\*RowBox[{\"GraphicsArray\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a row of graphics objects.\n\!\(\*RowBox[{\"GraphicsArray\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a two-dimensional array of graphical objects."
GraphicsBoxOptions::usage = "\!\(\*RowBox[{GraphicsBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for GraphicsBox objects."
GraphicsColumn::usage = "\!\(\*RowBox[{\"GraphicsColumn\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a graphic in which the \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are laid out in a column, with \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) above \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc. \n\!\(\*RowBox[{\"GraphicsColumn\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"alignment\", \"TI\"]}], \"]\"}]\) aligns each element horizontally in the specified way. \n\!\(\*RowBox[{\"GraphicsColumn\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"alignment\", \"TI\"], \",\", StyleBox[\"spacing\", \"TI\"]}], \"]\"}]\) leaves the specified spacing between successive elements."
GraphicsComplex3DBoxOptions::usage = "\!\(\*RowBox[{GraphicsComplex3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for GraphicsComplex3DBox objects."
GraphicsComplexBoxOptions::usage = "\!\(\*RowBox[{GraphicsComplexBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for GraphicsComplexBox objects."
GraphicsComplex::usage = "\!\(\*RowBox[{\"GraphicsComplex\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) represents a graphics complex in which coordinates given as integers \!\(\*StyleBox[\"i\", \"TI\"]\) in graphics primitives in \!\(\*StyleBox[\"data\", \"TI\"]\) are taken to be \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
GraphicsGrid::usage = "\!\(\*RowBox[{\"GraphicsGrid\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a graphic in which the \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"ij\", \"TI\"]]\) are laid out in a two-dimensional grid."
GraphicsGroup3DBoxOptions::usage = "\!\(\*RowBox[{GraphicsGroup3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for GraphicsGroup3DBox objects."
GraphicsGroupBoxOptions::usage = "\!\(\*RowBox[{GraphicsGroupBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for GraphicsGroupBox objects."
GraphicsGroup::usage = "\!\(\*RowBox[{\"GraphicsGroup\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a collection of graphics objects grouped together for purposes of interactive selection in a notebook. "
GraphicsRow::usage = "\!\(\*RowBox[{\"GraphicsRow\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a graphic in which the \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are laid out in a row.\n\!\(\*RowBox[{\"GraphicsRow\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"spacing\", \"TI\"]}], \"]\"}]\) leaves the specified spacing between successive elements."
GraphicsSpacing::usage = "GraphicsSpacing is an option for GraphicsArray that specifies the spacing between elements in the array. "
Graphics::usage = "\!\(\*RowBox[{\"Graphics\", \"[\", RowBox[{StyleBox[\"primitives\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) represents a two-dimensional graphical image. "
GraphIntersection::usage = "\!\(\*RowBox[{\"GraphIntersection\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the graph intersection of the graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"GraphIntersection\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the graph intersection of \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"GraphIntersection\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphLayout::usage = "GraphLayout is an option to Graph and related functions that specifies what layout to use."
GraphLinkEfficiency::usage = "\!\(\*RowBox[{\"GraphLinkEfficiency\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the link efficiency of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphLinkEfficiency\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphPeriphery::usage = "\!\(\*RowBox[{\"GraphPeriphery\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives vertices that are maximally distant to at least one vertex in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphPeriphery\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphPlot3D::usage = "\!\(\*RowBox[{\"GraphPlot3D\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) generates a 3D plot of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphPlot3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a 3D plot of the graph in which vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"ik\", \"TI\"]]\) is connected to vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"jk\", \"TI\"]]\).\n\!\(\*RowBox[{\"GraphPlot3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]]}], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) associates labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"k\", \"TI\"]]\) with edges in the graph.\n\!\(\*RowBox[{\"GraphPlot3D\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) generates a plot of the graph represented by the adjacency matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
GraphPlot::usage = "\!\(\*RowBox[{\"GraphPlot\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) generates a plot of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a plot of the graph in which vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"ik\", \"TI\"]]\) is connected to vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"jk\", \"TI\"]]\).\n\!\(\*RowBox[{\"GraphPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]]}], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) associates labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"k\", \"TI\"]]\) with edges in the graph.\n\!\(\*RowBox[{\"GraphPlot\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) generates a plot of the graph represented by the adjacency matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
GraphPower::usage = "\!\(\*RowBox[{\"GraphPower\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the graph-\!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) power of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphPower\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphPropertyDistribution::usage = "\!\(\*RowBox[{\"GraphPropertyDistribution\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"gdist\", \"TI\"]}]}], \"]\"}]\) represents the distribution of the property \!\(\*StyleBox[\"expr\", \"TI\"]\) where the random variable \!\(\*StyleBox[\"x\", \"TI\"]\) follows the graph distribution \!\(\*StyleBox[\"gdist\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphPropertyDistribution\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"gdist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"gdist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the distribution where \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] are independent and follow the graph distributions \!\(\*SubscriptBox[StyleBox[\"gdist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"gdist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
GraphQ::usage = "\!\(\*RowBox[{\"GraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"g\", \"TI\"]\) is a valid Graph object and False otherwise."
GraphRadius::usage = "\!\(\*RowBox[{\"GraphRadius\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the minimum eccentricity of the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphRadius\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphReciprocity::usage = "\!\(\*RowBox[{\"GraphReciprocity\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the reciprocity of a graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"GraphReciprocity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphStyle::usage = "GraphStyle is an option to Graph and related objects that specifies styles to use for the different graph elements. "
GraphUnion::usage = "\!\(\*RowBox[{\"GraphUnion\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the graph union of the graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"GraphUnion\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the graph union of \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"GraphUnion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Graph::usage = "\!\(\*RowBox[{\"Graph\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) yields a graph with edges \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"j\", \"TI\"]]\).\n\!\(\*RowBox[{\"Graph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields the graph with vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and edges \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"j\", \"TI\"]]\). \n\!\(\*RowBox[{\"Graph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields a graph with vertex and edge properties defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\)."
GraphUtilities`Aggressive::usage = "Aggressive is an option to PseudoDiameter that specifies whether an extra iteration is to be carried out."
GraphUtilities`Bicomponents::usage = "\!\(\*RowBox[{\"Bicomponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the biconnected components of the undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphUtilities`CommunityModularity::usage = "\!\(\*RowBox[{\"CommunityModularity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"partition\", \"TI\"]}], \"]\"}]\) gives the community modularity of a partition.\n\!\(\*RowBox[{\"CommunityModularity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"assignment\", \"TI\"]}], \"]\"}]\) gives the community modularity of an assignment."
GraphUtilities`CommunityStructureAssignment::usage = "\!\(\*RowBox[{\"CommunityStructureAssignment\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the assignment of vertices of a graph \!\(\*StyleBox[\"g\", \"TI\"]\) into communities. "
GraphUtilities`CommunityStructurePartition::usage = "\!\(\*RowBox[{\"CommunityStructurePartition\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the partition of a graph \!\(\*StyleBox[\"g\", \"TI\"]\) into communities. "
GraphUtilities`ExpressionTreePlot::usage = "\!\(\*RowBox[{\"ExpressionTreePlot\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) plots the expression tree of \!\(\*StyleBox[\"e\", \"TI\"]\)\!\(\*StyleBox[\".\", \"TI\"]\)\n\!\(\*RowBox[{\"ExpressionTreePlot\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) plots the expression tree of \!\(\*StyleBox[\"e\", \"TI\"]\) with its root placed at position \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"ExpressionTreePlot\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"lev\", \"TI\"]}], \"]\"}]\) plots the expression tree of \!\(\*StyleBox[\"e\", \"TI\"]\) up to level \!\(\*StyleBox[\"lev\", \"TI\"]\) with its root placed at position \!\(\*StyleBox[\"pos\", \"TI\"]\)."
GraphUtilities`GraphCoordinates3D::usage = "\!\(\*RowBox[{\"GraphCoordinates3D\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) calculates a visually appealing 3D layout of the vertices of a graph \!\(\*StyleBox[\"g\", \"TI\"]\) and returns the coordinates of the vertices."
GraphUtilities`GraphCoordinates::usage = "\!\(\*RowBox[{\"GraphCoordinates\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) calculates a visually appealing 2D layout of the vertices of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) and returns the coordinates of the vertices."
GraphUtilities`GraphEdit::usage = "\!\(\*RowBox[{\"GraphEdit\", \"[\", \"]\"}]\) opens an interactive graph editor.\n\!\(\*RowBox[{\"GraphEdit\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) plots the graph \!\(\*StyleBox[\"g\", \"TI\"]\) in the interactive graph editor."
GraphUtilities`GraphPath::usage = "\!\(\*RowBox[{\"GraphPath\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"]}], \"]\"}]\) finds a shortest path between vertices \!\(\*StyleBox[\"start\", \"TI\"]\) and \!\(\*StyleBox[\"end\", \"TI\"]\) in graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphUtilities`HamiltonianCycles::usage = "\!\(\*RowBox[{\"HamiltonianCycles\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) Hamiltonian cycles.\n\!\(\*RowBox[{\"HamiltonianCycles\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of one Hamiltonian cycle."
GraphUtilities`LineScaledCoordinate::usage = "\!\(\*RowBox[{\"LineScaledCoordinate\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the coordinate of a point in the polyline \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"}\"}]\), at a scaled distance of \!\(\*StyleBox[\"r\", \"TI\"]\) from point \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]\).\n\!\(\*RowBox[{RowBox[{\"LineScaledCoordinate\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"}\"}], \"]\"}], \" \"}]\) is the same as \!\(\*RowBox[{\"LineScaledCoordinate\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", \"0.5\"}], \"]\"}]\)."
GraphUtilities`LinkRankMatrix::usage = "\!\(\*RowBox[{\"LinkRankMatrix\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the link rank of the graph \!\(\*StyleBox[\"g\", \"TI\"]\), in the form of a sparse matrix. The link rank of an edge \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"->\", StyleBox[\"v\", \"TI\"]}]\) is defined as the PageRanks of \!\(\*StyleBox[\"u\", \"TI\"]\), divided by the out-degree of \!\(\*StyleBox[\"u\", \"TI\"]\)."
GraphUtilities`LinkRanks::usage = "\!\(\*RowBox[{\"LinkRanks\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the link ranks of the directed graph \!\(\*StyleBox[\"g\", \"TI\"]\) as a rule list."
GraphUtilities`MaximalBipartiteMatching::usage = "\!\(\*RowBox[{\"MaximalBipartiteMatching\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the maximal matching of the bipartite graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphUtilities`MaximalIndependentEdgeSet::usage = "\!\(\*RowBox[{\"MaximalIndependentEdgeSet\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a maximal independent edge set of an undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphUtilities`MaximalIndependentVertexSet::usage = "\!\(\*RowBox[{\"MaximalIndependentVertexSet\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a maximal independent vertex set of an undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"MaximalIndependentVertexSet\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) gives a maximal independent vertex set of \!\(\*StyleBox[\"g\", \"TI\"]\) with vertices weighted by \!\(\*StyleBox[\"w\", \"TI\"]\)."
GraphUtilities`MinCut::usage = "\!\(\*RowBox[{\"MinCut\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) partitions the undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\) into \!\(\*StyleBox[\"k\", \"TI\"]\) parts where the number of edge cuts is approximately minimized."
GraphUtilities`MinimumBandwidthOrdering::usage = "\!\(\*RowBox[{\"MinimumBandwidthOrdering\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) attempts to find a vertex ordering that minimizes the bandwidth of the undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"MinimumBandwidthOrdering\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) attempts to find row and column permutations that minimize the bandwidth of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
GraphUtilities`NeighborhoodSubgraph::usage = "\!\(\*RowBox[{\"NeighborhoodSubgraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives a subgraph consisting of vertices that can be reached from vertex \!\(\*StyleBox[\"i\", \"TI\"]\) within \!\(\*StyleBox[\"r\", \"TI\"]\) hops.\n\!\(\*RowBox[{\"NeighborhoodSubgraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives a subgraph consisting of vertices that can be reached from vertex \!\(\*StyleBox[\"i\", \"TI\"]\)."
GraphUtilities`NeighborhoodVertices::usage = "\!\(\*RowBox[{\"NeighborhoodVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives vertices that can be reached from vertex \!\(\*StyleBox[\"i\", \"TI\"]\) within \!\(\*StyleBox[\"r\", \"TI\"]\) hops.\n\!\(\*RowBox[{\"NeighborhoodVertices\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives vertices that can be reached from vertex \!\(\*StyleBox[\"i\", \"TI\"]\)."
GraphUtilities`PageRanks::usage = "\!\(\*RowBox[{\"PageRanks\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) give the page rank of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) as a rule list."
GraphUtilities`PageRankVector::usage = "\!\(\*RowBox[{\"PageRankVector\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the page rank of the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphUtilities`PseudoDiameter::usage = "\!\(\*RowBox[{\"PseudoDiameter\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) give the pseudo-diameter of the undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\), and the two vertices that achieve this diameter."
GraphUtilities`RecursionMethod::usage = "RecursionMethod is an option to MinimumBandwidthOrdering that specifies whether to employ a multilevel process to find a minimal bandwidth ordering."
GraphUtilities`RefinementMethod::usage = "RefinementMethod is an option to MinimumBandwidthOrdering that specifies the refinement method used to further improve the bandwidth ordering."
GraphUtilities`RemoveSinks::usage = "RemoveSinks is an option of PageRanks, PageRankVector, LinkRanks, and LinkRankMatrix that specifies whether sinks are removed by linking with all vertices."
GraphUtilities`StrongComponents::usage = "\!\(\*RowBox[{\"StrongComponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of all strongly connected components in the directed graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphUtilities`TeleportProbability::usage = "TeleportProbability is an option to PageRanks, PageRankVector, LinkRanks, and LinkRankMatrix that specifies the probability that an internet user may choose to visit a vertex at random instead of choosing an outlink."
GraphUtilities`ToCombinatoricaGraph::usage = "\!\(\*RowBox[{\"ToCombinatoricaGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns the \!\(\*StyleBox[\"Combinatorica\", FontSlant -> \"Italic\"]\) representation of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"ToCombinatoricaGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns the graph \!\(\*StyleBox[\"g\", \"TI\"]\), adding additional unconnected vertices, if necessary, to create a graph with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices."
GraphUtilities`WeakComponents::usage = "\!\(\*RowBox[{\"WeakComponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of all weakly connected components in the undirected graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
GraphUtilities`Weighted::usage = "Weighted is an option to functions in the Graph Utilities Package that specifies how to treat edges with higher weight."
GrayLevel::usage = "\!\(\*RowBox[{\"GrayLevel\", \"[\", StyleBox[\"level\", \"TI\"], \"]\"}]\) is a graphics directive specifying that objects that follow are to be displayed in the gray level given. \n\!\(\*RowBox[{\"GrayLevel\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) specifies opacity \!\(\*StyleBox[\"a\", \"TI\"]\). "
Gray::usage = "Gray represents the color gray in graphics or style specifications. "
GreaterEqualLess::usage = "\!\(\*RowBox[{\"GreaterEqualLess\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterEqualLess]\", StyleBox[\"y\", \"TI\"], \"\[GreaterEqualLess]\", \"\[Ellipsis]\"}]\)."
GreaterEqualThan::usage = "\!\(\*RowBox[{\"GreaterEqualThan\", \"[\", StyleBox[\"y\", \"TI\"], \"]\"}]\) is an operator form that yields \!\(\*StyleBox[RowBox[{\"x\", \"\[GreaterEqual]\", \"y\"}], \"TI\"]\) when applied to an expression \!\(\*StyleBox[\"x\", \"TI\"]\)."
GreaterEqual::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \">=\", StyleBox[\"y\", \"TI\"]}]\) or \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterEqual]\", StyleBox[\"y\", \"TI\"]}]\) yields True if \!\(\*StyleBox[\"x\", \"TI\"]\) is determined to be greater than or equal to \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[GreaterEqual]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[GreaterEqual]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"3\", \"TR\"]]}]\) yields True if the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) form a non\[Hyphen]increasing sequence. "
GreaterFullEqual::usage = "\!\(\*RowBox[{\"GreaterFullEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterFullEqual]\", StyleBox[\"y\", \"TI\"], \"\[GreaterFullEqual]\", \"\[Ellipsis]\"}]\)."
GreaterGreater::usage = "\!\(\*RowBox[{\"GreaterGreater\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterGreater]\", StyleBox[\"y\", \"TI\"], \"\[GreaterGreater]\", \"\[Ellipsis]\"}]\)."
GreaterLess::usage = "\!\(\*RowBox[{\"GreaterLess\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterLess]\", StyleBox[\"y\", \"TI\"], \"\[GreaterLess]\", \"\[Ellipsis]\"}]\)."
GreaterSlantEqual::usage = "\!\(\*RowBox[{\"GreaterSlantEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterSlantEqual]\", StyleBox[\"y\", \"TI\"], \"\[GreaterSlantEqual]\", \"\[Ellipsis]\"}]\)."
GreaterThan::usage = "\!\(\*RowBox[{\"GreaterThan\", \"[\", StyleBox[\"y\", \"TI\"], \"]\"}]\) is an operator form that yields \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \">\", StyleBox[\"y\", \"TI\"]}]\) when applied to an expression \!\(\*StyleBox[\"x\", \"TI\"]\)."
GreaterTilde::usage = "\!\(\*RowBox[{\"GreaterTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterTilde]\", StyleBox[\"y\", \"TI\"], \"\[GreaterTilde]\", \"\[Ellipsis]\"}]\)."
Greater::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \">\", StyleBox[\"y\", \"TI\"]}]\) yields True if \!\(\*StyleBox[\"x\", \"TI\"]\) is determined to be greater than \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \">\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \">\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"3\", \"TR\"]]}]\) yields True if the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) form a strictly decreasing sequence. "
Green::usage = "Green represents the color green in graphics or style specifications. "
GridBaseline::usage = "GridBaseline is an option for GridBox that specifies what place in the grid should be considered its baseline for purposes of alignment with surrounding objects. "
GridBox::usage = "\!\(\*RowBox[{GridBox, \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a low-level box construct that represents a two-dimensional grid of boxes or strings in notebook expressions."
GridCreationSettings::usage = "\!\(\*RowBox[{\"GridCreationSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is a global option that specifies settings for the \!\(\*StyleBox[\"Create Table/Matrix\", \"DialogElementName\"]\) dialog."
GridDefaultElement::usage = "GridDefaultElement is an option for the low-level function GridBox that specifies what to insert when a new element is created interactively in a GridBox. "
GridFrameMargins::usage = "GridFrameMargins is an option for grids that specifies the spacing between the content of the grid and the frame surrounding it."
GridFrame::usage = "GridFrame is an option for grids that specifies whether a surrounding frame is drawn."
GridGraph::usage = "\!\(\*RowBox[{\"GridGraph\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the grid graph with \!\(\*RowBox[{StyleBox[\"m\", \"TI\"], \"\[Times]\", StyleBox[\"n\", \"TI\"]}]\) vertices \!\(\*SubscriptBox[StyleBox[\"G\", \"TI\"], RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}]]\).\n\!\(\*RowBox[{\"GridGraph\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-dimensional grid graph with \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Times]\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Times]\", \"\[CenterEllipsis]\", \"\[Times]\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]}]\) vertices \!\(\*SubscriptBox[StyleBox[\"G\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], \"2\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]}]]\)."
GridLinesStyle::usage = "GridLinesStyle is an option for 2D graphics functions that specifies how grid lines should be rendered."
GridLines::usage = "GridLines is an option for two-dimensional graphics functions that specifies grid lines. "
Grid::usage = "\!\(\*RowBox[{\"Grid\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is an object that formats with the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"ij\", \"TI\"]]\) arranged in a two-dimensional grid. "
GroebnerBasis::usage = "\!\(\*RowBox[{\"GroebnerBasis\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of polynomials that form a Gr\[ODoubleDot]bner basis for the set of polynomials \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"GroebnerBasis\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds a Gr\[ODoubleDot]bner basis in which the \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) have been eliminated. "
GroupActionBase::usage = "GroupActionBase is an option to specify a base for a group."
GroupBy::usage = "\!\(\*RowBox[{\"GroupBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) groups the \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) into lists associated with distinct keys \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\).\n\!\(\*RowBox[{\"GroupBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"k\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"v\", \"TI\"]]}]}], \"]\"}]\) groups the \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"v\", \"TI\"]], \"[\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) according to the \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"k\", \"TI\"]], \"[\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\).\n\!\(\*RowBox[{RowBox[{\"GroupBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"fs\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"fs\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}], \"]\"}]\) groups into nested associations using \!\(\*SubscriptBox[StyleBox[\"fs\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at level \!\(\*StyleBox[\"i\", \"TI\"]\).\n\!\(\*RowBox[{\"GroupBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"red\", \"TI\"]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"red\", \"TI\"]\) to reduce lists of values that are generated.\n\!\(\*RowBox[{\"GroupBy\", \"[\", StyleBox[\"spec\", \"TI\"], \"]\"}]\) represents an operator form of GroupBy that can be applied to an expression."
GroupCentralizer::usage = "\!\(\*RowBox[{\"GroupCentralizer\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) returns the centralizer of the element \!\(\*StyleBox[\"g\", \"TI\"]\) in \!\(\*StyleBox[\"group\", \"TI\"]\)."
GroupElementFromWord::usage = "\!\(\*RowBox[{\"GroupElementFromWord\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) returns the element of \!\(\*StyleBox[\"group\", \"TI\"]\) determined by the word \!\(\*StyleBox[\"w\", \"TI\"]\) in the generators of \!\(\*StyleBox[\"group\", \"TI\"]\)."
GroupElementPosition::usage = "\!\(\*RowBox[{\"GroupElementPosition\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) returns the position of the element \!\(\*StyleBox[\"g\", \"TI\"]\) in the list of elements of \!\(\*StyleBox[\"group\", \"TI\"]\).\n\!\(\*RowBox[{\"GroupElementPosition\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) returns the list of positions of the elements \!\(\*RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\) in \!\(\*StyleBox[\"group\", \"TI\"]\)."
GroupElementQ::usage = "\!\(\*RowBox[{\"GroupElementQ\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) returns True if the object \!\(\*StyleBox[\"g\", \"TI\"]\) is an element of \!\(\*StyleBox[\"group\", \"TI\"]\) and False otherwise."
GroupElements::usage = "\!\(\*RowBox[{\"GroupElements\", \"[\", StyleBox[\"group\", \"TI\"], \"]\"}]\) returns the list of all elements of \!\(\*StyleBox[\"group\", \"TI\"]\).\n\!\(\*RowBox[{\"GroupElements\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) returns the elements numbered \!\(\*RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"k\", \"TI\"]]}]\) in \!\(\*StyleBox[\"group\", \"TI\"]\) in the standard order."
GroupElementToWord::usage = "\!\(\*RowBox[{\"GroupElementToWord\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) decomposes the group element \!\(\*StyleBox[\"g\", \"TI\"]\) as a product of generators of \!\(\*StyleBox[\"group\", \"TI\"]\)."
GroupGenerators::usage = "\!\(\*RowBox[{\"GroupGenerators\", \"[\", StyleBox[\"group\", \"TI\"], \"]\"}]\) returns a list of generators of \!\(\*StyleBox[\"group\", \"TI\"]\). "
GroupMultiplicationTable::usage = "\!\(\*RowBox[{\"GroupMultiplicationTable\", \"[\", StyleBox[\"group\", \"TI\"], \"]\"}]\) gives the multiplication table of \!\(\*StyleBox[\"group\", \"TI\"]\) as an array."
GroupOrbits::usage = "\!\(\*RowBox[{\"GroupOrbits\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns the orbits of the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) under the action of the elements of \!\(\*StyleBox[\"group\", \"TI\"]\).\n\!\(\*RowBox[{\"GroupOrbits\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) finds the orbits under the group action given by a function \!\(\*StyleBox[\"f\", \"TI\"]\)."
GroupOrder::usage = "\!\(\*RowBox[{\"GroupOrder\", \"[\", StyleBox[\"group\", \"TI\"], \"]\"}]\) returns the number of elements of \!\(\*StyleBox[\"group\", \"TI\"]\)."
GroupPageBreakWithin::usage = "GroupPageBreakWithin is an option for Cell that specifies whether a page break should be allowed within the group of cells if the notebook that contains the group is printed. "
GroupSetwiseStabilizer::usage = "\!\(\*RowBox[{\"GroupSetwiseStabilizer\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) returns the subgroup of \!\(\*StyleBox[\"group\", \"TI\"]\) for which the images of the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are still in the list \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"GroupSetwiseStabilizer\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) returns the setwise stabilizer subgroup under the action given by the function \!\(\*StyleBox[\"f\", \"TI\"]\)."
GroupStabilizerChain::usage = "\!\(\*RowBox[{\"GroupStabilizerChain\", \"[\", StyleBox[\"group\", \"TI\"], \"]\"}]\) returns a list of successive stabilizers in \!\(\*StyleBox[\"group\", \"TI\"]\) of the points in a base of \!\(\*StyleBox[\"group\", \"TI\"]\)."
GroupStabilizer::usage = "\!\(\*RowBox[{\"GroupStabilizer\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) returns the subgroup of elements of \!\(\*StyleBox[\"group\", \"TI\"]\) that move none of the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \[Ellipsis], \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]\).\n\!\(\*RowBox[{\"GroupStabilizer\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) returns the stabilizer subgroup under the action given by the function \!\(\*StyleBox[\"f\", \"TI\"]\)."
GrowCutComponents::usage = "\!\(\*RowBox[{\"GrowCutComponents\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"marker\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"marker\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) creates a segmentation from \!\(\*StyleBox[\"image\", \"TI\"]\) by growing each \!\(\*SubscriptBox[StyleBox[\"marker\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
Gudermannian::usage = "\!\(\*RowBox[{\"Gudermannian\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Gudermannian function \!\(\*RowBox[{\"gd\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
GuidedFilter::usage = "\!\(\*RowBox[{\"GuidedFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"guide\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Epsilon]\", \"TR\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) using the guide image \!\(\*StyleBox[\"guide\", \"TI\"]\) over range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhoods with pixel-value regularizer \[Epsilon].\n\!\(\*RowBox[{\"GuidedFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Epsilon]\", \"TR\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) so as to reduce noise, using \!\(\*StyleBox[\"image\", \"TI\"]\) as a guide."
GumbelDistribution::usage = "\!\(\*RowBox[{\"GumbelDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a Gumbel distribution with location parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"GumbelDistribution\", \"[\", \"]\"}]\) represents a Gumbel distribution with location parameter 0 and scale parameter 1."
HaarWavelet::usage = "\!\(\*RowBox[{\"HaarWavelet\", \"[\", \"]\"}]\) represents a Haar wavelet. "
HadamardMatrix::usage = "\!\(\*RowBox[{\"HadamardMatrix\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns an \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) Hadamard matrix."
HalfLine::usage = "\!\(\*RowBox[{\"HalfLine\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents the half-line from the point \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). \n\!\(\*RowBox[{\"HalfLine\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents the half-line from the point \!\(\*StyleBox[\"p\", \"TI\"]\) in the direction \!\(\*StyleBox[\"v\", \"TI\"]\). "
HalfNormalDistribution::usage = "\!\(\*RowBox[{\"HalfNormalDistribution\", \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}]\) represents a half-normal distribution with scale inversely proportional to parameter \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\)."
HalfPlane::usage = "\!\(\*RowBox[{\"HalfPlane\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) represents the half-plane bounded by the line through \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) and extended in the direction \!\(\*StyleBox[\"w\", \"TI\"]\).\n\!\(\*RowBox[{\"HalfPlane\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) represents the half-plane bounded by the line through \!\(\*StyleBox[\"p\", \"TI\"]\) along \!\(\*StyleBox[\"v\", \"TI\"]\) and extended in the direction \!\(\*StyleBox[\"w\", \"TI\"]\). "
HalfSpace::usage = "\!\(\*RowBox[{\"HalfSpace\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents the half-space of points \!\(\*StyleBox[\"x\", \"TI\"]\) such that \!\(\*RowBox[{RowBox[{StyleBox[\"n\", \"TI\"], \".\", RowBox[{\"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"-\", StyleBox[\"p\", \"TI\"]}], \")\"}]}], \"\[LessEqual]\", \"0\"}]\).\n\!\(\*RowBox[{\"HalfSpace\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents the half-space of points \!\(\*StyleBox[\"x\", \"TI\"]\) such that \!\(\*RowBox[{RowBox[{StyleBox[\"n\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}], \"\[LessEqual]\", StyleBox[\"c\", \"TI\"]}]\). "
HamiltonianGraphQ::usage = "\!\(\*RowBox[{\"HamiltonianGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is Hamiltonian, and False otherwise."
HammingDistance::usage = "\!\(\*RowBox[{\"HammingDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Hamming distance between strings or vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
HammingWindow::usage = "\!\(\*RowBox[{\"HammingWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Hamming window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
HankelH1::usage = "\!\(\*RowBox[{\"HankelH1\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Hankel function of the first kind \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"H\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", \"1\", \")\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
HankelH2::usage = "\!\(\*RowBox[{\"HankelH2\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Hankel function of the second kind \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"H\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", \"2\", \")\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
HankelMatrix::usage = "\!\(\*RowBox[{\"HankelMatrix\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) Hankel matrix with first row and first column being successive integers.\n\!\(\*RowBox[{\"HankelMatrix\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the Hankel matrix whose first column consists of elements \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"HankelMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", \" \", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the Hankel matrix with elements \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) down the first column, and \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) across the last row."
HannPoissonWindow::usage = "\!\(\*RowBox[{\"HannPoissonWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Hann\[Dash]Poisson window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"HannPoissonWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
HannWindow::usage = "\!\(\*RowBox[{\"HannWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Hann window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"HannWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
HaradaNortonGroupHN::usage = "\!\(\*RowBox[{\"HaradaNortonGroupHN\", \"[\", \"]\"}]\) represents the sporadic simple Harada\[Dash]Norton group HN."
HararyGraph::usage = "\!\(\*RowBox[{\"HararyGraph\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates the minimal \!\(\*StyleBox[\"k\", \"TI\"]\)-connected graph on \!\(\*StyleBox[\"n\", \"TI\"]\) vertices \!\(\*SubscriptBox[StyleBox[\"H\", \"TI\"], RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}]]\)."
HarmonicMeanFilter::usage = "\!\(\*RowBox[{\"HarmonicMeanFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every value by the harmonic mean of the values in its range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"HarmonicMeanFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies harmonic mean filtering to an array of data."
HarmonicMean::usage = "\!\(\*RowBox[{\"HarmonicMean\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the harmonic mean of the values in \!\(\*StyleBox[\"list\", \"TI\"]\)."
HarmonicNumber::usage = "\!\(\*RowBox[{\"HarmonicNumber\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) harmonic number \!\(\*SubscriptBox[StyleBox[\"H\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"HarmonicNumber\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the harmonic number \!\(\*SubsuperscriptBox[StyleBox[\"H\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", StyleBox[\"r\", \"TI\"], \")\"}]]\) of order \!\(\*StyleBox[\"r\", \"TI\"]\). "
HashTable::usage = "HashTable is a part of the object which is returned by Dispatch."
Hash::usage = "\!\(\*RowBox[{\"Hash\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives an integer hash code for the expression \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"Hash\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives an integer hash code of the specified type for \!\(\*StyleBox[\"expr\", \"TI\"]\)."
Haversine::usage = "\!\(\*RowBox[{\"Haversine\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the haversine function \!\(\*RowBox[{\"hav\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
HazardFunction::usage = "\!\(\*RowBox[{\"HazardFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the hazard function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) evaluated at \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"HazardFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multivariate hazard function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) evaluated at \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"HazardFunction\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the hazard function as a pure function."
HeadCompose::usage = "\!\(\*RowBox[{\"HeadCompose\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", \" \", StyleBox[\"b\", \"TI\"], \",\", \" \", StyleBox[\"c\", \"TI\"], \",\", \" \", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \"[\", StyleBox[\"b\", \"TI\"], \"]\"}], \"[\", StyleBox[\"c\", \"TI\"], \"]\"}], \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\)."
HeaderLines::usage = "HeaderLines is an option for SemanticImport and related functions that specifies how many of the initial rows should be considered part of a column header."
Heads::usage = "Heads is an option for functions which use level specifications that specifies whether heads of expressions should be included. "
Head::usage = "\!\(\*RowBox[{\"Head\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the head of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
HeavisideLambda::usage = "\!\(\*RowBox[{\"HeavisideLambda\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the triangle distribution \!\(\*RowBox[{\"\[CapitalLambda]\", \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\) which is nonzero for \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", StyleBox[\"x\", \"TI\"], \"\[RightBracketingBar]\"}], \"<\", \"1\"}]\).\n\!\(\*RowBox[{\"HeavisideLambda\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the multidimensional triangle distribution \!\(\*RowBox[{\"\[CapitalLambda]\", \"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \")\"}]\) which is nonzero for \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[RightBracketingBar]\"}], \"<\", \"1\"}]\)."
HeavisidePi::usage = "\!\(\*RowBox[{\"HeavisidePi\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the box distribution \!\(\*RowBox[{\"\[CapitalPi]\", \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\), equal to 1 for \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", StyleBox[\"x\", \"TI\"], \"\[RightBracketingBar]\"}], \"<\", FractionBox[\"1\", \"2\"]}]\) and 0 for \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", StyleBox[\"x\", \"TI\"], \"\[RightBracketingBar]\"}], \">\", FractionBox[\"1\", \"2\"]}]\).\n\!\(\*RowBox[{\"HeavisidePi\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the multidimensional box distribution \!\(\*RowBox[{\"\[CapitalPi]\", \"(\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"2\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \")\"}]\) which is 1 if all \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[RightBracketingBar]\"}], \"<\", FractionBox[\"1\", \"2\"]}]\)."
HeavisideTheta::usage = "\!\(\*RowBox[{\"HeavisideTheta\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the Heaviside theta function \!\(\*RowBox[{\"\[Theta]\", \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\), equal to 0 for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<\", \"0\"}]\) and 1 for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \">\", \"0\"}]\). \n\!\(\*RowBox[{\"HeavisideTheta\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the multidimensional Heaviside theta function, which is 1 only if none of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are not positive. "
HeldGroupHe::usage = "\!\(\*RowBox[{\"HeldGroupHe\", \"[\", \"]\"}]\) represents the sporadic simple Held group He."
HelpBrowserSettings::usage = "\!\(\*RowBox[{\"HelpBrowserSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is a global option that specifies settings for the legacy Help Browser."
Here::usage = "Here represents the current deduced geo location."
HermiteDecomposition::usage = "\!\(\*RowBox[{\"HermiteDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the Hermite normal form decomposition of an integer matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
HermiteH::usage = "\!\(\*RowBox[{\"HermiteH\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Hermite polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"H\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
HermitianMatrixQ::usage = "\!\(\*RowBox[{\"HermitianMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly Hermitian, and False otherwise. "
HessenbergDecomposition::usage = "\!\(\*RowBox[{\"HessenbergDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the Hessenberg decomposition of a matrix \!\(\*StyleBox[\"m\", \"TI\"]\). "
HexadecimalCharacter::usage = "HexadecimalCharacter represents a hexadecimal digit character 0\[Dash]9, a\[Dash]f, A\[Dash]F in StringExpression."
Hexahedron::usage = "\!\(\*RowBox[{\"Hexahedron\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"8\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents a filled hexahedron with corners \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis], \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"8\", \"TR\"]]\).\n\!\(\*RowBox[{\"Hexahedron\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \",\", \"1\"}], \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \",\", \"2\"}], \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \",\", \"8\"}], \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \",\", \"1\"}], \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a collection of hexahedra."
HiddenMarkovProcess::usage = "\!\(\*RowBox[{\"HiddenMarkovProcess\", \"[\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"em\", \"TI\"]}], \"]\"}]\) represents a discrete-time, finite-state hidden Markov process with transition matrix \!\(\*StyleBox[\"m\", \"TI\"]\), emission matrix \!\(\*StyleBox[\"em\", \"TI\"]\), and initial hidden state \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"HiddenMarkovProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"m\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a hidden Markov process with emission distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"HiddenMarkovProcess\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a hidden Markov process with initial hidden state probability vector \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
HiddenSurface::usage = "HiddenSurface is an option for SurfaceGraphics which specifies whether hidden surfaces are to be eliminated. "
HierarchicalClustering`Agglomerate::usage = "\!\(\*RowBox[{\"Agglomerate\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a hierarchical clustering of the elements \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\).\n\!\(\*RowBox[{\"Agglomerate\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"->\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"->\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in each cluster. \n\!\(\*RowBox[{\"Agglomerate\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"->\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in each cluster."
HierarchicalClustering`ClusterFlatten::usage = "\!\(\*RowBox[{\"ClusterFlatten\", \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) gives a flat list of the data elements contained in the cluster \!\(\*StyleBox[\"c\", \"TI\"]\)."
HierarchicalClustering`ClusterSplit::usage = "\!\(\*RowBox[{\"ClusterSplit\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) splits the cluster \!\(\*StyleBox[\"c\", \"TI\"]\) into \!\(\*StyleBox[\"n\", \"TI\"]\) clusters."
HierarchicalClustering`Cluster::usage = "\!\(\*RowBox[{\"Cluster\", \"[\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"d\", \"TI\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) represents a merger of the clusters \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with dissimilarity \!\(\*StyleBox[\"d\", \"TI\"]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) data elements, respectively."
HierarchicalClustering`DendrogramPlot::usage = "\!\(\*RowBox[{\"DendrogramPlot\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) constructs a dendrogram from the hierarchical clustering of \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"DendrogramPlot\", \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) constructs a dendrogram from the Cluster object \!\(\*StyleBox[\"c\", \"TI\"]\)."
HierarchicalClustering`DirectAgglomerate::usage = "\!\(\*RowBox[{\"DirectAgglomerate\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) constructs a cluster hierarchy based on the distance or dissimilarity matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"DirectAgglomerate\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) associates the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) with the rows of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\) in the cluster hierarchy."
HierarchicalClustering`HighlightLevel::usage = "HighlightLevel is an option for DendrogramPlot that specifies the level at which to highlight the dendrogram."
HierarchicalClustering`HighlightStyle::usage = "HighlightStyle is an option for DendrogramPlot that specifies the style for highlighted clusters."
HierarchicalClustering`LeafLabels::usage = "LeafLabels is an option for DendrogramPlot that specifies labels for the dendrogram leaves."
HierarchicalClustering`Linkage::usage = "Linkage is an option for Agglomerate and DendrogramPlot that specifies the linkage method for agglomerative clustering."
HierarchicalClustering`Orientation::usage = "Orientation is an option for DendrogramPlot that specifies the orientation of the dendrogram."
HierarchicalClustering`TruncateDendrogram::usage = "TruncateDendrogram is an option for DendrogramPlot that specifies the fusion levels at which to truncate the dendrogram."
HighlightGraph::usage = "\!\(\*RowBox[{\"HighlightGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) highlights the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that can be vertices, edges, or subgraphs of \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"HighlightGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) highlights using the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]]\).\n\!\(\*RowBox[{\"HighlightGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
HighlightImage::usage = "\!\(\*RowBox[{\"HighlightImage\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a version of \!\(\*StyleBox[\"image\", \"TI\"]\) in which the pixels at positions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) have been highlighted.\n\!\(\*RowBox[{\"HighlightImage\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"region\", \"TI\"]}], \"]\"}]\) highlights the specified geometric region in \!\(\*StyleBox[\"image\", \"TI\"]\)."
HighlightMesh::usage = "\!\(\*RowBox[{\"HighlightMesh\", \"[\", RowBox[{StyleBox[\"mr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cellspec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cellspec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) highlights the cells specified by \!\(\*SubscriptBox[StyleBox[\"cellspec\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the mesh region \!\(\*StyleBox[\"mr\", \"TI\"]\).\n\!\(\*RowBox[{\"HighlightMesh\", \"[\", RowBox[{StyleBox[\"mr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", SubscriptBox[StyleBox[\"cellspec\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) highlights using the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]]\)."
HighpassFilter::usage = "\!\(\*RowBox[{\"HighpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"]\"}]\) applies a highpass filter with a cutoff frequency \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]\) to an array of data.\n\!\(\*RowBox[{\"HighpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses a filter kernel of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"HighpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to the filter kernel.\n\!\(\*RowBox[{\"HighpassFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a highpass filter to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"HighpassFilter\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a highpass filter to sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
HigmanSimsGroupHS::usage = "\!\(\*RowBox[{\"HigmanSimsGroupHS\", \"[\", \"]\"}]\) represents the sporadic simple Higman\[Dash]Sims group HS."
HilbertFilter::usage = "\!\(\*RowBox[{\"HilbertFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"]\"}]\) applies a Hilbert filter with a cutoff frequency \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]\) to an array of data.\n\!\(\*RowBox[{\"HilbertFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses a filter kernel of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"HilbertFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to the filter kernel.\n\!\(\*RowBox[{\"HilbertFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a Hilbert filter to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"HilbertFilter\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a Hilbert filter to sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
HilbertMatrix::usage = "\!\(\*RowBox[{\"HilbertMatrix\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) Hilbert matrix with elements of the form \!\(\*RowBox[{\"1\", \"/\", RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \"+\", StyleBox[\"j\", \"TI\"], \"-\", \"1\"}], \")\"}]}]\).\n\!\(\*RowBox[{\"HilbertMatrix\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the \!\(\*StyleBox[\"m\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) Hilbert matrix."
Histogram3D::usage = "\!\(\*RowBox[{\"Histogram3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a 3D histogram of the values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"Histogram3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) plots a 3D histogram with bins specified by \!\(\*StyleBox[\"bspec\", \"TI\"]\).\n\!\(\*RowBox[{\"Histogram3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) plots a 3D histogram with bin heights computed according to the specification \!\(\*StyleBox[\"hspec\", \"TI\"]\).\n\!\(\*RowBox[{\"Histogram3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots 3D histograms for multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
HistogramDistribution::usage = "\!\(\*RowBox[{\"HistogramDistribution\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents the probability distribution corresponding to a histogram of the data values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"HistogramDistribution\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a multivariate histogram distribution based on data values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"HistogramDistribution\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) represents a histogram distribution with bins specified by \!\(\*StyleBox[\"bspec\", \"TI\"]\)."
HistogramList::usage = "\!\(\*RowBox[{\"HistogramList\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of bins and histogram heights of the values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"HistogramList\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of bins and histogram heights of the values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"HistogramList\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) gives a list of bins and histogram heights with bins specified by \!\(\*StyleBox[\"bspec\", \"TI\"]\).\n\!\(\*RowBox[{\"HistogramList\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"bspec\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) gives a list of bins and histogram heights with bin heights computed according to the specification \!\(\*StyleBox[\"hspec\", \"TI\"]\)."
Histograms`ApproximateIntervals::usage = "ApproximateIntervals is an option of histogram functions that specifies whether the HistogramCategories or HistogramRange settings should be adjusted so that the interval boundaries are described by simple numbers."
Histograms`FrequencyData::usage = "FrequencyData is an option of histogram functions that specifies whether the data argument represents the original data or the frequencies with which the original data falls in the respective categories."
Histograms`HistogramCategories::usage = "HistogramCategories is an option of histogram functions that specifies the categories in the histogram."
Histograms`HistogramRange::usage = "HistogramRange is an option of histogram functions that specifies the lower and upper limits of the points to be included in the histogram."
Histograms`HistogramScale::usage = "HistogramScale is an option of histogram functions that specifies the way in which the bar heights are to be scaled."
HistogramTransformInterpolation::usage = "\!\(\*RowBox[{\"HistogramTransformInterpolation\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) finds a function \!\(\*StyleBox[\"f\", \"TI\"]\) so that the transformed values \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"(\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \")\"}]\) are distributed nearly uniformly.\n\!\(\*RowBox[{\"HistogramTransformInterpolation\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) finds \!\(\*StyleBox[\"f\", \"TI\"]\) so that \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"(\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \")\"}]\) are distributed with distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"HistogramTransformInterpolation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds a function that reshapes the histogram of \!\(\*StyleBox[\"image\", \"TI\"]\)."
HistogramTransform::usage = "\!\(\*RowBox[{\"HistogramTransform\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) transforms pixel values of \!\(\*StyleBox[\"image\", \"TI\"]\) so that its histogram is nearly flat.\n\!\(\*RowBox[{\"HistogramTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) modifies pixel values of \!\(\*StyleBox[\"image\", \"TI\"]\) so that its histogram matches the probability density function (PDF) of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"HistogramTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ref\", \"TI\"]}], \"]\"}]\) matches the histogram of \!\(\*StyleBox[\"image\", \"TI\"]\) with the histogram of the reference image \!\(\*StyleBox[\"ref\", \"TI\"]\).\n\!\(\*RowBox[{\"HistogramTransform\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) transforms values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Histogram::usage = "\!\(\*RowBox[{\"Histogram\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a histogram of the values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Histogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) plots a histogram with bin width specification \!\(\*StyleBox[\"bspec\", \"TI\"]\).\n\!\(\*RowBox[{\"Histogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) plots a histogram with bin heights computed according to the specification \!\(\*StyleBox[\"hspec\", \"TI\"]\).\n\!\(\*RowBox[{\"Histogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots histograms for multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
HistoricalPeriodData::usage = "\!\(\*RowBox[{\"HistoricalPeriodData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the historical period \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"HistoricalPeriodData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified historical period entities.\n\!\(\*RowBox[{\"HistoricalPeriodData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
HitMissTransform::usage = "\!\(\*RowBox[{\"HitMissTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the hit-and-miss transform of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to the composite structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"HitMissTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the union of the hit-and-miss transforms for all the structuring elements \!\(\*SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"HitMissTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) treats values above \!\(\*StyleBox[\"t\", \"TI\"]\) as foreground."
HITSCentrality::usage = "\!\(\*RowBox[{\"HITSCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of authority and hub centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"HITSCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
HodgeDual::usage = "\!\(\*RowBox[{\"HodgeDual\", \"[\", StyleBox[\"tensor\", \"TI\"], \"]\"}]\) gives the Hodge dual of the \!\(\*StyleBox[\"tensor\", \"TI\"]\)\n\!\(\*RowBox[{\"HodgeDual\", \"[\", RowBox[{StyleBox[\"tensor\", \"TI\"], \",\", StyleBox[\"dim\", \"TI\"]}], \"]\"}]\) dualizes \!\(\*StyleBox[\"tensor\", \"TI\"]\) in the slots with dimension \!\(\*StyleBox[\"dim\", \"TI\"]\)\n\!\(\*RowBox[{\"HodgeDual\", \"[\", RowBox[{StyleBox[\"tensor\", \"TI\"], \",\", StyleBox[\"dim\", \"TI\"], \",\", StyleBox[\"slots\", \"TI\"]}], \"]\"}]\) dualizes \!\(\*StyleBox[\"tensor\", \"TI\"]\) in the given \!\(\*StyleBox[\"slots\", \"TI\"]\)."
HoeffdingDTest::usage = "\!\(\*RowBox[{\"HoeffdingDTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"HoeffdingDTest\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], StyleBox[\",\", \"TI\"], StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
HoeffdingD::usage = "\!\(\*RowBox[{\"HoeffdingD\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Hoeffding's dependence measure \!\(\*StyleBox[\"\[ScriptCapitalD]\", \"TR\"]\) for the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"HoeffdingD\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives Hoeffding's dependence measure \!\(\*StyleBox[\"\[ScriptCapitalD]\", \"TR\"]\) for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"HoeffdingD\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Hoeffding's dependence measure \!\(\*StyleBox[\"\[ScriptCapitalD]\", \"TR\"]\) for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"HoeffdingD\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives Hoeffding's \!\(\*StyleBox[\"\[ScriptCapitalD]\", \"TR\"]\) matrix for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"HoeffdingD\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) element of \!\(\*StyleBox[\"\[ScriptCapitalD]\", \"TR\"]\) for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
HoldAllComplete::usage = "HoldAllComplete is an attribute which specifies that all arguments to a function are not to be modified or looked at in any way in the process of evaluation. "
HoldAll::usage = "HoldAll is an attribute that specifies that all arguments to a function are to be maintained in an unevaluated form. "
HoldComplete::usage = "\!\(\*RowBox[{\"HoldComplete\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) shields \!\(\*StyleBox[\"expr\", \"TI\"]\) completely from the standard \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) evaluation process, preventing even upvalues associated with \!\(\*StyleBox[\"expr\", \"TI\"]\) from being used. "
HoldFirst::usage = "HoldFirst is an attribute that specifies that the first argument to a function is to be maintained in an unevaluated form. "
HoldForm::usage = "\!\(\*RowBox[{\"HoldForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as the expression \!\(\*StyleBox[\"expr\", \"TI\"]\), with \!\(\*StyleBox[\"expr\", \"TI\"]\) maintained in an unevaluated form. "
HoldPattern::usage = "\!\(\*RowBox[{\"HoldPattern\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) is equivalent to \!\(\*StyleBox[\"expr\", \"TI\"]\) for pattern matching, but maintains \!\(\*StyleBox[\"expr\", \"TI\"]\) in an unevaluated form. "
HoldRest::usage = "HoldRest is an attribute which specifies that all but the first argument to a function are to be maintained in an unevaluated form. "
Hold::usage = "\!\(\*RowBox[{\"Hold\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) maintains \!\(\*StyleBox[\"expr\", \"TI\"]\) in an unevaluated form. "
HolidayCalendar::usage = "HolidayCalendar is an option that specifies the holiday calendar schedule in business day functions."
HorizontalForm::usage = "HorizontalForm is an internal symbol used for formatting and printing."
HorizontalGauge::usage = "\!\(\*RowBox[{\"HorizontalGauge\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}]\) draws a linear gauge showing \!\(\*StyleBox[\"value\", \"TI\"]\) in a range of 0 to 1.\n\!\(\*RowBox[{\"HorizontalGauge\", \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) draws a linear gauge showing \!\(\*StyleBox[\"value\", \"TI\"]\) in a range of \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"HorizontalGauge\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) allows \!\(\*StyleBox[\"value\", \"TI\"]\) to be set interactively using the gauge.\n\!\(\*RowBox[{\"HorizontalGauge\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) draws a gauge showing multiple values."
HornerForm::usage = "\!\(\*RowBox[{\"HornerForm\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) puts the polynomial \!\(\*StyleBox[\"poly\", \"TI\"]\) in Horner form.\n\!\(\*RowBox[{\"HornerForm\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) puts \!\(\*StyleBox[\"poly\", \"TI\"]\) in Horner form with respect to the variable or variable list \!\(\*StyleBox[\"vars\", \"TI\"]\).\n\!\(\*RowBox[{\"HornerForm\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"/\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) puts the rational function \!\(\*RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"/\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]\) in Horner form by nesting \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"HornerForm\", \"[\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"/\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", SubscriptBox[StyleBox[\"vars\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vars\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) puts \!\(\*RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"/\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]\) in Horner form using the variables or variable lists \!\(\*SubscriptBox[StyleBox[\"vars\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"vars\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) for \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), respectively."
HostLookup::usage = "\!\(\*RowBox[{\"HostLookup\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) gives the IP address for the host with the specified name.\n\!\(\*RowBox[{\"HostLookup\", \"[\", StyleBox[\"address\", \"TI\"], \"]\"}]\) gives the host name for the host at the specified IP address.\n\!\(\*RowBox[{\"HostLookup\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives a specified property of the host.\n\!\(\*RowBox[{\"HostLookup\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", \"All\"}], \"]\"}]\) gives an association of properties found for the host."
HotellingTSquareDistribution::usage = "\!\(\*RowBox[{\"HotellingTSquareDistribution\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) represents Hotelling's \!\(\*SuperscriptBox[StyleBox[\"T\", \"TI\"], \"2\"]\) distribution with dimensionality parameter \!\(\*StyleBox[\"p\", \"TI\"]\) and \!\(\*StyleBox[\"m\", \"TI\"]\) degrees of freedom."
HoytDistribution::usage = "\!\(\*RowBox[{\"HoytDistribution\", \"[\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) represents a Hoyt distribution with shape parameter \!\(\*StyleBox[\"q\", \"TI\"]\) and spread parameter \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
HTMLSave::usage = "\!\(\*RowBox[{\"HTMLSave\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).html\\\"\",ShowStringCharacters->True], \"]\"}]\) saves an HTML version of the current input notebook in the front end. \n\!\(\*RowBox[{\"HTMLSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).html\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"source\\\",\\\"TI\\\"]\\).nb\\\"\",ShowStringCharacters->True]}], \"]\"}]\) saves an HTML version of the notebook from the file \!\(\*RowBox[{StyleBox[\"source\", \"TI\"], \".\"}]\)nb.\n\!\(\*RowBox[{\"HTMLSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).html\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"notebook\", \"TI\"]}], \"]\"}]\) saves an HTML version of the notebook corresponding to the specified notebook object. "
HTTPErrorResponse::usage = "\!\(\*RowBox[{\"HTTPErrorResponse\", \"[\", StyleBox[\"code\", \"TI\"], \"]\"}]\) is an object that represents an error response to an HTTP request, with specified error code."
HTTPRedirect::usage = "\!\(\*RowBox[{\"HTTPRedirect\", \"[\", StyleBox[\"uri\", \"TI\"], \"]\"}]\) represents an HTTP redirect to the specified \!\(\*StyleBox[\"uri\", \"TI\"]\).\n\!\(\*RowBox[{\"HTTPRedirect\", \"[\", RowBox[{StyleBox[\"uri\", \"TI\"], \",\", StyleBox[\"metadata\", \"TI\"]}], \"]\"}]\) represents an HTTP redirect to \!\(\*StyleBox[\"uri\", \"TI\"]\) with the specified metadata."
HTTPRequestData::usage = "\!\(\*RowBox[{\"HTTPRequestData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the value of the specified property of the current HTTP request.\n\!\(\*RowBox[{\"HTTPRequestData\", \"[\", \"]\"}]\) gives an association with values of properties of the current HTTP request."
HTTPResponse::usage = "\!\(\*RowBox[{\"HTTPResponse\", \"[\", StyleBox[\"body\", \"TI\"], \"]\"}]\) is an object that represents a successful response to an HTTP request, with the specified body and default metadata.\n\!\(\*RowBox[{\"HTTPResponse\", \"[\", RowBox[{StyleBox[\"body\", \"TI\"], \",\", StyleBox[\"metadata\", \"TI\"]}], \"]\"}]\) represents a response to an HTTP request, including the specified body and metadata."
Hue::usage = "\!\(\*RowBox[{\"Hue\", \"[\", StyleBox[\"h\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that objects which follow are to be displayed, in a color corresponding to hue \!\(\*StyleBox[\"h\", \"TI\"]\). \n\!\(\*RowBox[{\"Hue\", \"[\", RowBox[{StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) specifies colors in terms of hue, saturation, and brightness. \n\!\(\*RowBox[{\"Hue\", \"[\", RowBox[{StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) specifies opacity \!\(\*StyleBox[\"a\", \"TI\"]\). "
HumanGrowthData::usage = "\!\(\*RowBox[{\"HumanGrowthData\", \"[\", StyleBox[\"spec\", \"TI\"], \"]\"}]\) returns the range of values within one standard deviation of the mean for all properties of human growth at the specification \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"HumanGrowthData\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) returns the range of values within one standard deviation of the mean of a property for the specification \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"HumanGrowthData\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"index\", \"TI\"]}], \"]\"}]\) returns the values for all properties of human growth for \!\(\*StyleBox[\"spec\", \"TI\"]\) at the specified percentile.\n\!\(\*RowBox[{\"HumanGrowthData\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"index\", \"TI\"]}], \"]\"}]\) returns the value at a specific index of a property for \!\(\*StyleBox[\"spec\", \"TI\"]\) at the specified percentile.\n\!\(\*RowBox[{\"HumanGrowthData\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"quantity\", \"TI\"]}], \"]\"}]\) returns the percentile and probability density for a specific value \!\(\*StyleBox[\"quantity\", \"TI\"]\) of the property at \!\(\*StyleBox[\"spec\", \"TI\"]\)."
HumpDownHump::usage = "\!\(\*RowBox[{\"HumpDownHump\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[HumpDownHump]\", StyleBox[\"y\", \"TI\"], \"\[HumpDownHump]\", \"\[Ellipsis]\"}]\)."
HumpEqual::usage = "\!\(\*RowBox[{\"HumpEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[HumpEqual]\", StyleBox[\"y\", \"TI\"], \"\[HumpEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
HurwitzLerchPhi::usage = "\!\(\*RowBox[{\"HurwitzLerchPhi\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives the Hurwitz\[Dash]Lerch transcendent \!\(\*RowBox[{\"\[CapitalPhi]\", \"(\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \")\"}]\)."
HurwitzZeta::usage = "\!\(\*RowBox[{\"HurwitzZeta\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives the Hurwitz zeta function \!\(\*RowBox[{\"\[Zeta]\", \"(\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \")\"}]\)."
HyperbolicDistribution::usage = "\!\(\*RowBox[{\"HyperbolicDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a hyperbolic distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\), shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\), and skewness parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"HyperbolicDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a generalized hyperbolic distribution with shape parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\)."
HypercubeGraph::usage = "\!\(\*RowBox[{\"HypercubeGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)-dimensional hypercube graph \!\(\*SubscriptBox[StyleBox[\"Q\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
HyperexponentialDistribution::usage = "\!\(\*RowBox[{\"HyperexponentialDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents an \!\(\*StyleBox[\"m\", \"TI\"]\)-phase hyperexponential distribution with phase probabilities \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\) and rates \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\)."
Hyperfactorial::usage = "\!\(\*RowBox[{\"Hyperfactorial\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the hyperfactorial function \!\(\*RowBox[{StyleBox[\"H\", \"TI\"], \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\)."
Hypergeometric0F1Regularized::usage = "\!\(\*RowBox[{\"Hypergeometric0F1Regularized\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the regularized confluent hypergeometric function \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[Null]\", \"0\"], \"\[InvisibleSpace]\", SubscriptBox[StyleBox[\"F\", \"TI\"], \"1\"], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"z\", \"TI\"]}], \")\"}], \"/\", RowBox[{\"\[CapitalGamma]\", \"(\", StyleBox[\"a\", \"TI\"], \")\"}]}]\). "
Hypergeometric0F1::usage = "\!\(\*RowBox[{\"Hypergeometric0F1\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the confluent hypergeometric function \!\(\*RowBox[{SubscriptBox[\"\[Null]\", \"0\"], \"\[InvisibleSpace]\", SubscriptBox[StyleBox[\"F\", \"TI\"], \"1\"], \"(\", RowBox[{\";\", StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"z\", \"TI\"]}], \")\"}]\). "
Hypergeometric1F1Regularized::usage = "\!\(\*RowBox[{\"Hypergeometric1F1Regularized\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the regularized confluent hypergeometric function \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[Null]\", \"1\"], \"\[InvisibleSpace]\", SubscriptBox[StyleBox[\"F\", \"TI\"], \"1\"], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"b\", \"TI\"], \";\", StyleBox[\"z\", \"TI\"]}], \")\"}], \"/\", RowBox[{\"\[CapitalGamma]\", \"(\", StyleBox[\"b\", \"TI\"], \")\"}]}]\). "
Hypergeometric1F1::usage = "\!\(\*RowBox[{\"Hypergeometric1F1\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the Kummer confluent hypergeometric function \!\(\*RowBox[{SubscriptBox[\"\[Null]\", \"1\"], \"\[InvisibleSpace]\", SubscriptBox[StyleBox[\"F\", \"TI\"], \"1\"], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"b\", \"TI\"], \";\", StyleBox[\"z\", \"TI\"]}], \")\"}]\). "
Hypergeometric2F1Regularized::usage = "\!\(\*RowBox[{\"Hypergeometric2F1Regularized\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the regularized hypergeometric function \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[Null]\", \"2\"], \"\[InvisibleSpace]\", SubscriptBox[StyleBox[\"F\", \"TI\"], \"1\"], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \";\", StyleBox[\"c\", \"TI\"], \";\", StyleBox[\"z\", \"TI\"]}], \")\"}], \"/\", RowBox[{\"\[CapitalGamma]\", \"(\", StyleBox[\"c\", \"TI\"], \")\"}]}]\). "
Hypergeometric2F1::usage = "\!\(\*RowBox[{\"Hypergeometric2F1\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the hypergeometric function \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[InvisiblePrefixScriptBase]\", \"2\"], SubscriptBox[\"F\", \"1\"]}], \"(\", RowBox[{\"a\", \",\", \"b\", \";\", \"c\", \";\", \"z\"}], \")\"}]\). "
HypergeometricDistribution::usage = "\!\(\*RowBox[{\"HypergeometricDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"succ\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"tot\", \"TI\"]]}], \"]\"}]\) represents a hypergeometric distribution."
HypergeometricPFQRegularized::usage = "\!\(\*RowBox[{\"HypergeometricPFQRegularized\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the regularized generalized hypergeometric function \!\(\*RowBox[{RowBox[{SubscriptBox[\"\[Null]\", StyleBox[\"p\", \"TI\"]], \"\[InvisibleSpace]\", SubscriptBox[StyleBox[\"F\", \"TI\"], StyleBox[\"q\", \"TI\"]], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"b\", \"TI\"], \";\", StyleBox[\"z\", \"TI\"]}], \")\"}], \"/\", RowBox[{\"(\", RowBox[{\"\[CapitalGamma]\", \"(\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], \"1\"], \")\"}], \"\[Ellipsis]\", RowBox[{\"\[CapitalGamma]\", \"(\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \")\"}], \")\"}]}]\). "
HypergeometricPFQ::usage = "\!\(\*RowBox[{\"HypergeometricPFQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the generalized hypergeometric function \!\(\*RowBox[{SubscriptBox[\"\[Null]\", StyleBox[\"p\", \"TI\"]], \"\[InvisibleSpace]\", SubscriptBox[StyleBox[\"F\", \"TI\"], StyleBox[\"q\", \"TI\"]], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"b\", \"TI\"], \";\", StyleBox[\"z\", \"TI\"]}], \")\"}]\). "
HypergeometricU::usage = "\!\(\*RowBox[{\"HypergeometricU\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the confluent hypergeometric function \!\(\*RowBox[{StyleBox[\"U\", \"TI\"], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\). "
Hyperlink::usage = "\!\(\*RowBox[{\"Hyperlink\", \"[\", StyleBox[\"uri\", \"TI\"], \"]\"}]\) represents a hyperlink that jumps to the specified URI when clicked. \n\!\(\*RowBox[{\"Hyperlink\", \"[\", RowBox[{StyleBox[\"label\", \"TI\"], \",\", StyleBox[\"uri\", \"TI\"]}], \"]\"}]\) represents a hyperlink to be displayed as \!\(\*StyleBox[\"label\", \"TI\"]\). "
Hyperplane::usage = "\!\(\*RowBox[{\"Hyperplane\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents the hyperplane with normal \!\(\*StyleBox[\"n\", \"TI\"]\) passing through the point \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"Hyperplane\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents the hyperplane with normal \!\(\*StyleBox[\"n\", \"TI\"]\) given by the points \!\(\*StyleBox[\"x\", \"TI\"]\) that satisfy \!\(\*RowBox[{RowBox[{StyleBox[\"n\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\). "
Hyphenation::usage = "Hyphenation is an option for Cell that specifies whether to allow hyphenation for words of text. "
HypoexponentialDistribution::usage = "\!\(\*RowBox[{\"HypoexponentialDistribution\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents an \!\(\*StyleBox[\"m\", \"TI\"]\)-phase hypoexponential distribution with rates \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\), \[Ellipsis], \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"m\", \"TI\"]]\)."
HypothesisTestData::usage = "\!\(\*RowBox[{\"HypothesisTestData\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents hypothesis test data such as generated by DistributionFitTest, AndersonDarlingTest, etc. "
HypothesisTesting`ChiSquareCI::usage = "\!\(\*RowBox[{\"ChiSquareCI\", \"[\", RowBox[{StyleBox[\"var\", \"TI\"], \",\", StyleBox[\"df\", \"TI\"]}], \"]\"}]\) gives a confidence interval based on a \!\(\*SuperscriptBox[\"\[Chi]\", \"2\"]\) distribution with \!\(\*StyleBox[\"df\", \"TI\"]\) degrees of freedom."
HypothesisTesting`ChiSquarePValue::usage = "\!\(\*RowBox[{\"ChiSquarePValue\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"df\", \"TI\"]}], \"]\"}]\) gives the cumulative probability beyond \!\(\*StyleBox[\"x\", \"TI\"]\) for the \!\(\*SuperscriptBox[\"\[Chi]\", \"2\"]\) distribution with \!\(\*StyleBox[\"df\", \"TI\"]\) degrees of freedom."
HypothesisTesting`EqualVariances::usage = "EqualVariances is an option to statistical confidence interval and hypothesis test functions of two samples that specifies that unknown population variances are equal."
HypothesisTesting`FRatioCI::usage = "\!\(\*RowBox[{\"FRatioCI\", \"[\", RowBox[{StyleBox[\"ratio\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives a confidence interval based on an F-ratio distribution with \!\(\*StyleBox[\"n\", \"TI\"]\) and \!\(\*StyleBox[\"m\", \"TI\"]\) degrees of freedom."
HypothesisTesting`FRatioPValue::usage = "\!\(\*RowBox[{\"FRatioPValue\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the cumulative probability beyond \!\(\*StyleBox[\"x\", \"TI\"]\) for the F-ratio distribution with \!\(\*StyleBox[\"n\", \"TI\"]\) and \!\(\*StyleBox[\"m\", \"TI\"]\) degrees of freedom."
HypothesisTesting`FullReport::usage = "FullReport is an option to hypothesis test functions that specifies whether all report information should be returned."
HypothesisTesting`KnownVariance::usage = "KnownVariance is an option to statistical confidence interval and hypothesis test functions that specifies the value of the population variance."
HypothesisTesting`MeanCI::usage = "\!\(\*RowBox[{\"MeanCI\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a confidence interval for the population mean estimated from \!\(\*StyleBox[\"list\", \"TI\"]\)."
HypothesisTesting`MeanDifferenceCI::usage = "\!\(\*RowBox[{\"MeanDifferenceCI\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives a confidence interval for the difference between the population means estimated from \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
HypothesisTesting`MeanDifferenceTest::usage = "\!\(\*RowBox[{\"MeanDifferenceTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[CapitalDelta]\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) performs a test with null hypothesis \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \"-\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"=\", SubscriptBox[StyleBox[\"\[CapitalDelta]\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}]\)."
HypothesisTesting`MeanTest::usage = "\!\(\*RowBox[{\"MeanTest\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) performs a test with null hypothesis \!\(\*RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \"=\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}]\)."
HypothesisTesting`NormalCI::usage = "\!\(\*RowBox[{\"NormalCI\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) gives a confidence interval based on a normal distribution."
HypothesisTesting`NormalPValue::usage = "\!\(\*RowBox[{\"NormalPValue\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the cumulative density beyond \!\(\*StyleBox[\"x\", \"TI\"]\) for a normal distribution with zero mean and unit variance."
HypothesisTesting`OneSidedPValue::usage = "OneSidedPValue is an element in hypothesis test output for one\[Hyphen]sided tests."
HypothesisTesting`StudentTCI::usage = "\!\(\*RowBox[{\"StudentTCI\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"df\", \"TI\"]}], \"]\"}]\) gives a confidence interval based on Student's \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with \!\(\*StyleBox[\"df\", \"TI\"]\) degrees of freedom."
HypothesisTesting`StudentTPValue::usage = "\!\(\*RowBox[{\"StudentTPValue\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"df\", \"TI\"]}], \"]\"}]\) gives the cumulative probability beyond \!\(\*StyleBox[\"x\", \"TI\"]\) for Student's \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with \!\(\*StyleBox[\"df\", \"TI\"]\) degrees of freedom."
HypothesisTesting`TwoSidedPValue::usage = "TwoSidedPValue is an element in hypothesis test output for two\[Hyphen]sided tests."
HypothesisTesting`TwoSided::usage = "TwoSided is an option to hypothesis test functions that specifies whether the test should be two\[Hyphen]sided."
HypothesisTesting`VarianceCI::usage = "\!\(\*RowBox[{\"VarianceCI\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a confidence interval for the population variance estimated from \!\(\*StyleBox[\"list\", \"TI\"]\)."
HypothesisTesting`VarianceRatioCI::usage = "\!\(\*RowBox[{\"VarianceRatioCI\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives a confidence interval for the ratio of the population variances estimated from \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and from \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
HypothesisTesting`VarianceRatioTest::usage = "\!\(\*RowBox[{\"VarianceRatioTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) performs a test with null hypothesis \!\(\*RowBox[{FractionBox[SubsuperscriptBox[\"\[Sigma]\", \"1\", \"2\"], SubsuperscriptBox[\"\[Sigma]\", \"2\", \"2\"]], \"\[LongEqual]\", StyleBox[\"r\", \"TI\"]}]\)."
IconData::usage = "\!\(\*RowBox[{\"IconData\", \"[\", RowBox[{StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"quantity\", \"TI\"]}], \"]\"}]\) generates an iconic view of the \!\(\*StyleBox[\"property\", \"TI\"]\) for the value \!\(\*StyleBox[\"quantity\", \"TI\"]\)."
IconRules::usage = "IconRules is an option for CloudObject and related objects that specifies icons to use in different deployments to represent an object."
IdentityMatrix::usage = "\!\(\*RowBox[{\"IdentityMatrix\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\[Cross]\!\(\*StyleBox[\"n\", \"TI\"]\) identity matrix. "
Identity::usage = "\!\(\*RowBox[{\"Identity\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives \!\(\*StyleBox[\"expr\", \"TI\"]\) (the identity operation). "
If::usage = "\!\(\*RowBox[{\"If\", \"[\", RowBox[{StyleBox[\"condition\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"t\", \"TI\"]\) if \!\(\*StyleBox[\"condition\", \"TI\"]\) evaluates to True, and \!\(\*StyleBox[\"f\", \"TI\"]\) if it evaluates to False. \n\!\(\*RowBox[{\"If\", \"[\", RowBox[{StyleBox[\"condition\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"u\", \"TI\"]\) if \!\(\*StyleBox[\"condition\", \"TI\"]\) evaluates to neither True nor False. "
IgnoreCase::usage = "IgnoreCase is an option for string manipulation and searching functions that specifies whether lowercase and uppercase letters should be treated as equivalent. "
IgnoreDiacritics::usage = "IgnoreDiacritics is an option for string, grammar, and related functions that specifies whether diacritics should be ignored in strings."
IgnorePunctuation::usage = "IgnorePunctuation is an option for AlphabeticSort and related functions that specifies whether to consider punctuation in determining sorting order."
IgnoringInactive::usage = "\!\(\*RowBox[{\"IgnoringInactive\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) is a pattern object that, for purposes of pattern matching, ignores occurrences of Inactive in both \!\(\*StyleBox[\"patt\", \"TI\"]\) and the expression being matched."
Image3DSlices::usage = "\!\(\*RowBox[{\"Image3DSlices\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a list of 2D images corresponding to the slices in the Image3D object \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"Image3DSlices\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) extracts the specified slices \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Image3DSlices\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \";;\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"]\"}]\) extracts slices \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"m\", \"TI\"]]\) through \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"n\", \"TI\"]]\).\n\!\(\*RowBox[{\"Image3DSlices\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) takes slices in dimension \!\(\*StyleBox[\"d\", \"TI\"]\)."
Image3D::usage = "\!\(\*RowBox[{\"Image3D\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) represents a 3D image with pixel values given by the array \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"Image3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a 3D image from a list of 2D images.\n\!\(\*RowBox[{\"Image3D\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) creates a 3D image of the specified data type."
ImageAccumulate::usage = "\!\(\*RowBox[{\"ImageAccumulate\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives an image in which each pixel represents a sum of all pixels below and to the left of that pixel in \!\(\*StyleBox[\"image\", \"TI\"]\)."
ImageAdd::usage = "\!\(\*RowBox[{\"ImageAdd\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) adds an amount \!\(\*StyleBox[\"x\", \"TI\"]\) to each channel value in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageAdd\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives an image in which each pixel is the sum of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ImageAdd\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) adds all \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to \!\(\*StyleBox[\"image\", \"TI\"]\), where each \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) can be either an image, a number, or a color value."
ImageAdjust::usage = "\!\(\*RowBox[{\"ImageAdjust\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) adjusts the levels in \!\(\*StyleBox[\"image\", \"TI\"]\), rescaling them to cover the range 0 to 1.\n\!\(\*RowBox[{\"ImageAdjust\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) adjusts the contrast of \!\(\*StyleBox[\"image\", \"TI\"]\) by an amount \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageAdjust\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]}], \"]\"}]\) adjusts the contrast by an amount \!\(\*StyleBox[\"c\", \"TI\"]\) and the brightness by an amount \!\(\*StyleBox[\"b\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageAdjust\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) also performs a gamma correction by raising values to the power \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\).\n\!\(\*RowBox[{\"ImageAdjust\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"corr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) first rescales so that the range of input values \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) is mapped to 0 to 1.\n\!\(\*RowBox[{\"ImageAdjust\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"corr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) rescales so that the range of input values \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) is mapped to \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"max\", \"TI\"]]\)."
ImageAlign::usage = "\!\(\*RowBox[{\"ImageAlign\", \"[\", RowBox[{StyleBox[\"ref\", \"TI\"], \",\", StyleBox[\"image\", \"TI\"]}], \"]\"}]\) returns a version of \!\(\*StyleBox[\"image\", \"TI\"]\) that is aligned with the reference image \!\(\*StyleBox[\"ref\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageAlign\", \"[\", RowBox[{StyleBox[\"ref\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the result of aligning each of the \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with the reference image \!\(\*StyleBox[\"ref\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageAlign\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) uses \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) as the reference image."
ImageApplyIndexed::usage = "\!\(\*RowBox[{\"ImageApplyIndexed\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"image\", \"TI\"]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the list of channel values for each pixel in \!\(\*StyleBox[\"image\", \"TI\"]\), giving the row and column index of each pixel as a second argument to \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageApplyIndexed\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the sequence of corresponding pixel values taken from each \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), giving the corresponding row and column index of pixels as the last argument to \!\(\*StyleBox[\"f\", \"TI\"]\)."
ImageApply::usage = "\!\(\*RowBox[{\"ImageApply\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"image\", \"TI\"]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the list of channel values for each pixel in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageApply\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the sequence of corresponding pixel values taken from each \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ImageAspectRatio::usage = "\!\(\*RowBox[{\"ImageAspectRatio\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the ratio of height to width for \!\(\*StyleBox[\"image\", \"TI\"]\)."
ImageAssemble::usage = "\!\(\*RowBox[{\"ImageAssemble\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) assembles a single image from an array of images."
ImageCapture::usage = "\!\(\*RowBox[{\"ImageCapture\", \"[\", \"]\"}]\) opens a graphical user interface for capturing images from connected cameras."
ImageChannels::usage = "\!\(\*RowBox[{\"ImageChannels\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the number of channels present in the data for the Image or Image3D object \!\(\*StyleBox[\"image\", \"TI\"]\)."
ImageClip::usage = "\!\(\*RowBox[{\"ImageClip\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) clips all channel values in \!\(\*StyleBox[\"image\", \"TI\"]\) to lie in the default range.\n\!\(\*RowBox[{\"ImageClip\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) clips channel values to lie in the range from \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageClip\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) for values below \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) for values above \!\(\*StyleBox[\"max\", \"TI\"]\)."
ImageCollage::usage = "\!\(\*RowBox[{\"ImageCollage\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a collage of images \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ImageCollage\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a collage of images \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) based on their corresponding weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{RowBox[{RowBox[{\"ImageCollage\", \"[\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]}], \"|>\"}], \"]\"}]\) also creates a collage of images \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) based on their corresponding weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ImageCollage\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) also creates a collage of images \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) based on their corresponding weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ImageCollage\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) also creates a collage of images \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) based on their corresponding weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ImageCollage\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"fitting\", \"TI\"]}], \"]\"}]\) uses the \!\(\*StyleBox[\"fitting\", \"TI\"]\) method to create the collage.\n\!\(\*RowBox[{\"ImageCollage\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"fitting\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) creates a collage of the specified \!\(\*StyleBox[\"size\", \"TI\"]\)."
ImageColorSpace::usage = "\!\(\*RowBox[{\"ImageColorSpace\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the name of the color space of \!\(\*StyleBox[\"image\", \"TI\"]\)."
ImageCompose::usage = "\!\(\*RowBox[{\"ImageCompose\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"overlay\", \"TI\"]}], \"]\"}]\) gives the result of overlaying \!\(\*StyleBox[\"overlay\", \"TI\"]\) onto \!\(\*StyleBox[\"image\", \"TI\"]\). \n\!\(\*RowBox[{\"ImageCompose\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"overlay\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the result of alpha blending \!\(\*StyleBox[\"overlay\", \"TI\"]\) into \!\(\*StyleBox[\"image\", \"TI\"]\) using blending fraction \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\).\n\!\(\*RowBox[{\"ImageCompose\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"overlay\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) places the center of \!\(\*StyleBox[\"overlay\", \"TI\"]\) at position \!\(\*StyleBox[\"pos\", \"TI\"]\) in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageCompose\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"overlay\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"opos\", \"TI\"]}], \"]\"}]\) places the point \!\(\*StyleBox[\"opos\", \"TI\"]\) in \!\(\*StyleBox[\"overlay\", \"TI\"]\) at position \!\(\*StyleBox[\"pos\", \"TI\"]\) in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageCompose\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"overlay\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"opos\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"o\", \"TI\"]], \",\", StyleBox[\"mode\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses the compositing fractions \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"k\", \"TI\"]]\) and the specified compositing mode."
ImageConvolve::usage = "\!\(\*RowBox[{\"ImageConvolve\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the convolution of \!\(\*StyleBox[\"image\", \"TI\"]\) with kernel \!\(\*StyleBox[\"ker\", \"TI\"]\)."
ImageCooccurrence::usage = "\!\(\*RowBox[{\"ImageCooccurrence\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) co-occurrence matrix for \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageCooccurrence\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) computes a co-occurrence matrix for arbitrary spatial relationships specified by a kernel \!\(\*StyleBox[\"ker\", \"TI\"]\)."
ImageCorners::usage = "\!\(\*RowBox[{\"ImageCorners\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds corners in \!\(\*StyleBox[\"image\", \"TI\"]\) and returns their coordinates.\n\!\(\*RowBox[{\"ImageCorners\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) finds corners at a pixel range \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageCorners\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) uses a threshold \!\(\*StyleBox[\"t\", \"TI\"]\) for selecting corners.\n\!\(\*RowBox[{\"ImageCorners\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) returns corners that are at least \!\(\*RowBox[{StyleBox[\"d\", \"TI\"], \"+\", \"1\"}]\) pixels apart."
ImageCorrelate::usage = "\!\(\*RowBox[{\"ImageCorrelate\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the correlation of \!\(\*StyleBox[\"image\", \"TI\"]\) with kernel \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageCorrelate\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) computes a generalized correlation in which the function \!\(\*StyleBox[\"f\", \"TI\"]\) is used in place of Dot."
ImageCorrespondingPoints::usage = "\!\(\*RowBox[{\"ImageCorrespondingPoints\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) finds a set of matching interest points in \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) and returns their pixel coordinates."
ImageCrop::usage = "\!\(\*RowBox[{\"ImageCrop\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) crops \!\(\*StyleBox[\"image\", \"TI\"]\) by removing borders of uniform color. \n\!\(\*RowBox[{\"ImageCrop\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) crops \!\(\*StyleBox[\"image\", \"TI\"]\) based on the size specification \!\(\*StyleBox[\"size\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageCrop\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"]}], \"]\"}]\) crops \!\(\*StyleBox[\"image\", \"TI\"]\) by removing pixels from sides specified by \!\(\*StyleBox[\"spec\", \"TI\"]\)."
ImageData::usage = "\!\(\*RowBox[{\"ImageData\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the array of pixel values in an Image or Image3D object \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageData\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the array of pixel values converted to the specified type."
ImageDeconvolve::usage = "\!\(\*RowBox[{\"ImageDeconvolve\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives a deconvolution of \!\(\*StyleBox[\"image\", \"TI\"]\) using kernel \!\(\*StyleBox[\"ker\", \"TI\"]\)."
ImageDemosaic::usage = "\!\(\*RowBox[{\"ImageDemosaic\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"cfa\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"row\", \"TI\"], \",\", StyleBox[\"col\", \"TI\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) reconstructs a color image using the specified color filter array \"\!\(\*\nStyleBox[\"cfa\", \"TI\"]\)\", aligning the top-left pixel of the pattern with the \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"row\", \"TI\"], \",\", StyleBox[\"col\", \"TI\"]}], \"}\"}]\) pixel of \!\(\*StyleBox[\"image\", \"TI\"]\)."
ImageDifference::usage = "\!\(\*RowBox[{\"ImageDifference\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives an image in which each pixel is the absolute difference of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
ImageDimensions::usage = "\!\(\*RowBox[{\"ImageDimensions\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the pixel dimensions of an Image or Image3D object \!\(\*StyleBox[\"image\", \"TI\"]\)."
ImageDistance::usage = "\!\(\*RowBox[{\"ImageDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) returns a distance measure between \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). \n\!\(\*RowBox[{\"ImageDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) places the center of \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) at position \!\(\*StyleBox[\"pos\", \"TI\"]\) in \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\).\n\!\(\*RowBox[{\"ImageDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) places the point \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) of \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) at position \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) in \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)."
ImageEffect::usage = "\!\(\*RowBox[{\"ImageEffect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"effect\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) applies the specified image effect to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageEffect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"effect\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"params\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses parameters \!\(\*StyleBox[\"params\", \"TI\"]\)."
ImageExposureCombine::usage = "\!\(\*RowBox[{\"ImageExposureCombine\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) combines differently exposed images \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) of the same scene to obtain a single image with good exposure. "
ImageFeatureTrack::usage = "\!\(\*RowBox[{\"ImageFeatureTrack\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) tracks features from \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"n\", \"TI\"]]\).\n\!\(\*RowBox[{\"ImageFeatureTrack\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"pts\", \"TI\"]}], \"]\"}]\) tracks features starting from the initial set of points \!\(\*StyleBox[\"pts\", \"TI\"]\) in \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)."
ImageFileApply::usage = "\!\(\*RowBox[{\"ImageFileApply\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"inputfile\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"outputfile\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the list of channel values for each pixel of the image stored in \"\!\(\*\nStyleBox[\"inputfile\", \"TI\"]\)\" and stores the result in \"\!\(\*\nStyleBox[\"outputfile\", \"TI\"]\)\"."
ImageFileFilter::usage = "\!\(\*RowBox[{\"ImageFileFilter\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"inputfile\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"outputfile\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the range \!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood of each pixel in each channel of the image stored in \"\!\(\*\nStyleBox[\"inputfile\", \"TI\"]\)\" and stores the result in \"\!\(\*\nStyleBox[\"outputfile\", \"TI\"]\)\"."
ImageFileScan::usage = "\!\(\*RowBox[{\"ImageFileScan\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"inputfile\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the list of channel values for each pixel of the image stored in \"\!\(\*\nStyleBox[\"inputfile\", \"TI\"]\)\"."
ImageFilter::usage = "\!\(\*RowBox[{\"ImageFilter\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood of each pixel in each channel of \!\(\*StyleBox[\"image\", \"TI\"]\)."
ImageFocusCombine::usage = "\!\(\*RowBox[{\"ImageFocusCombine\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) combines differently focused images \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) of the same scene to obtain a single well-focused image. "
ImageForestingComponents::usage = "\!\(\*RowBox[{\"ImageForestingComponents\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds a segmentation of \!\(\*StyleBox[\"image\", \"TI\"]\), returning an integer matrix in which positive integers label different components.\n\!\(\*RowBox[{\"ImageForestingComponents\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"]}], \"]\"}]\) tries to find a segmentation into components that include pixels indicated by \!\(\*StyleBox[\"marker\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageForestingComponents\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) finds components that are connected at a pixel scale given by \!\(\*StyleBox[\"r\", \"TI\"]\)."
ImageFormattingWidth::usage = "ImageFormattingWidth is an option that specifies the target width at which to wrap when formatting an object."
ImageForwardTransformation::usage = "\!\(\*RowBox[{\"ImageForwardTransformation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"function\", \"TI\"]}], \"]\"}]\) gives an image in which each pixel at position \!\(\*RowBox[{StyleBox[\"function\", \"TI\"], \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"]\"}]\) corresponds to the position \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageForwardTransformation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"function\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) gives an image of the specified size."
ImageHistogram::usage = "\!\(\*RowBox[{\"ImageHistogram\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) plots a histogram of the pixel levels for each channel in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageHistogram\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) uses bin specification \!\(\*StyleBox[\"bspec\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageHistogram\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"bspec\", \"TI\"], \",\", StyleBox[\"range\", \"TI\"]}], \"]\"}]\) plots the histogram of the pixel values in the given \!\(\*StyleBox[\"range\", \"TI\"]\)."
ImageIdentify::usage = "\!\(\*RowBox[{\"ImageIdentify\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) yields the result of attempting to identify what \!\(\*StyleBox[\"image\", \"TI\"]\) is a picture of. \n\!\(\*RowBox[{\"ImageIdentify\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"category\", \"TI\"]}], \"]\"}]\) restricts the identification of \!\(\*StyleBox[\"image\", \"TI\"]\) to objects within the specified category.\n\!\(\*RowBox[{\"ImageIdentify\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"category\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of up to \!\(\*StyleBox[\"n\", \"TI\"]\) possible identifications.\n\!\(\*RowBox[{\"ImageIdentify\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"category\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property for each identification."
ImageInstanceQ::usage = "\!\(\*RowBox[{\"ImageInstanceQ\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) gives True if \!\(\*StyleBox[\"image\", \"TI\"]\) appears to be an instance of the object \!\(\*StyleBox[\"obj\", \"TI\"]\), and gives False otherwise.\n\!\(\*RowBox[{\"ImageInstanceQ\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"|\", SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"|\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}], \"]\"}]\) gives True if \!\(\*StyleBox[\"image\", \"TI\"]\) appears to be an instance of any of \!\(\*SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and gives False otherwise.\n\!\(\*RowBox[{\"ImageInstanceQ\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"category\", \"TI\"]}], \"]\"}]\) assumes that the image is of something in the specified category."
ImageKeypoints::usage = "\!\(\*RowBox[{\"ImageKeypoints\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds key features in \!\(\*StyleBox[\"image\", \"TI\"]\) and returns their coordinates.\n\!\(\*RowBox[{\"ImageKeypoints\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives the specified property \!\(\*StyleBox[\"prop\", \"TI\"]\) for each keypoint."
ImageLevels::usage = "\!\(\*RowBox[{\"ImageLevels\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a list of pixel values and counts for each channel in \!\(\*StyleBox[\"image\", \"TI\"]\). \n\!\(\*RowBox[{\"ImageLevels\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) bins pixel values using bin specification \!\(\*StyleBox[\"bspec\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageLevels\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"bspec\", \"TI\"], \",\", StyleBox[\"range\", \"TI\"]}], \"]\"}]\) gives counts for bins in the given \!\(\*StyleBox[\"range\", \"TI\"]\)."
ImageLines::usage = "\!\(\*RowBox[{\"ImageLines\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds line segments in \!\(\*StyleBox[\"image\", \"TI\"]\) and returns the coordinates of their endpoints.\n\!\(\*RowBox[{\"ImageLines\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) uses the threshold \!\(\*StyleBox[\"t\", \"TI\"]\) for selecting image lines.\n\!\(\*RowBox[{\"ImageLines\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"d\", \"TI\"]\) to control the distinctness of the detected lines."
ImageMargins::usage = "ImageMargins is an option that specifies the absolute margins to leave around the image displayed for an object. "
ImageMeasurements::usage = "\!\(\*RowBox[{\"ImageMeasurements\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\" for the entire \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageMeasurements\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"format\", \"TI\"]}], \"]\"}]\) returns the values in the specified output \!\(\*StyleBox[\"format\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageMeasurements\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \" \", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) returns measurements for all \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ImageMultiply::usage = "\!\(\*RowBox[{\"ImageMultiply\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) multiplies each channel value in \!\(\*StyleBox[\"image\", \"TI\"]\) by a factor \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageMultiply\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives an image in which each pixel is the product of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ImageMultiply\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) multiplies all \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with \!\(\*StyleBox[\"image\", \"TI\"]\), where each \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) can be either an image, a number, or a color value."
ImagePadding::usage = "ImagePadding is an option for graphics functions that specifies what absolute extra padding should be left for extended objects such as thick lines and annotations such as tick and axis labels."
ImagePad::usage = "\!\(\*RowBox[{\"ImagePad\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) pads \!\(\*StyleBox[\"image\", \"TI\"]\) on all sides with \!\(\*StyleBox[\"m\", \"TI\"]\) background pixels.\n\!\(\*RowBox[{\"ImagePad\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"]}], \"]\"}]\) pads \!\(\*StyleBox[\"image\", \"TI\"]\) on all sides using the value or method specified by \!\(\*StyleBox[\"padding\", \"TI\"]\).\n\!\(\*RowBox[{\"ImagePad\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"left\", \"TI\"], \",\", StyleBox[\"right\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"bottom\", \"TI\"], \",\", StyleBox[\"top\", \"TI\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) pads \!\(\*StyleBox[\"image\", \"TI\"]\) with the specified numbers of pixels on each side.\n\!\(\*RowBox[{\"ImagePad\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"left\", \"TI\"], \",\", StyleBox[\"right\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"front\", \"TI\"], \",\", StyleBox[\"back\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"bottom\", \"TI\"], \",\", StyleBox[\"top\", \"TI\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) pads a 3D image with the specified numbers of pixels."
ImagePartition::usage = "\!\(\*RowBox[{\"ImagePartition\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) partitions an image into an array of \!\(\*StyleBox[\"s\", \"TI\"]\)\[Cross]\!\(\*StyleBox[\"s\", \"TI\"]\)-pixel subimages.\n\!\(\*RowBox[{\"ImagePartition\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]}], \"]\"}]\) partitions an image into an array of subimages of pixel width \!\(\*StyleBox[\"w\", \"TI\"]\) and pixel height \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"ImagePartition\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"dw\", \"TI\"], \",\", StyleBox[\"dh\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses pixel offsets \!\(\*StyleBox[\"dw\", \"TI\"]\) and \!\(\*StyleBox[\"dh\", \"TI\"]\)."
ImagePeriodogram::usage = "\!\(\*RowBox[{\"ImagePeriodogram\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) shows the squared magnitude of the discrete Fourier transform (power spectrum) of \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImagePeriodogram\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) shows the average of power spectra of non-overlapping partitions of size \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"ImagePeriodogram\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses partitions with offset \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"ImagePeriodogram\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to each partition.\n\!\(\*RowBox[{\"ImagePeriodogram\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) pads partitions with zeros to length \!\(\*StyleBox[\"m\", \"TI\"]\) prior to the computation of the transform."
ImagePerspectiveTransformation::usage = "\!\(\*RowBox[{\"ImagePerspectiveTransformation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) applies a linear fractional transform specified by a matrix \!\(\*StyleBox[\"m\", \"TI\"]\) to the positions of each pixel in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImagePerspectiveTransformation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"tf\", \"TI\"]}], \"]\"}]\) uses the TransformationFunction given by \!\(\*StyleBox[\"tf\", \"TI\"]\).\n\!\(\*RowBox[{\"ImagePerspectiveTransformation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) gives an image of the specified size."
ImageQ::usage = "\!\(\*RowBox[{\"ImageQ\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"image\", \"TI\"]\) has the form of a valid Image or Image3D object, and False otherwise."
ImageReflect::usage = "\!\(\*RowBox[{\"ImageReflect\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) reverses \!\(\*StyleBox[\"image\", \"TI\"]\) by top-bottom mirror reflection. \n\!\(\*RowBox[{\"ImageReflect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"side\", \"TI\"]}], \"]\"}]\) reverses \!\(\*StyleBox[\"image\", \"TI\"]\) by reflecting it so that the specified side goes to the opposite side.\n\!\(\*RowBox[{\"ImageReflect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{SubscriptBox[StyleBox[\"side\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"side\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"]\"}]\) reflects \!\(\*StyleBox[\"image\", \"TI\"]\) so that \!\(\*SubscriptBox[StyleBox[\"side\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) is interchanged with \!\(\*SubscriptBox[StyleBox[\"side\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ImageRegion::usage = "ImageRegion is an option for cells that specifies the size and position of the bounding box within which a graphic is rendered."
ImageResize::usage = "\!\(\*RowBox[{\"ImageResize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"width\", \"TI\"]}], \"]\"}]\) gives a resized version of \!\(\*StyleBox[\"image\", \"TI\"]\) that is \!\(\*StyleBox[\"width\", \"TI\"]\) pixels wide.\n\!\(\*RowBox[{\"ImageResize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"s\", \"TI\"], \"}\"}]}], \"]\"}]\) gives a resized version of \!\(\*StyleBox[\"image\", \"TI\"]\) with a maximum pixel width or height given by \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageResize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"width\", \"TI\"], \",\", StyleBox[\"height\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives a resized version of \!\(\*StyleBox[\"image\", \"TI\"]\) that has exactly the specified pixel width and height.\n\!\(\*RowBox[{\"ImageResize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"width\", \"TI\"], \",\", StyleBox[\"depth\", \"TI\"], \",\", StyleBox[\"height\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives a resized version of a 3D image with the specified dimensions."
ImageResolution::usage = "ImageResolution is an option for Export, Rasterize, and related functions that specifies at what resolution bitmap images should be rendered. "
ImageRotated::usage = "ImageRotated is an option for Export that specifies whether images should be rotated into landscape mode. "
ImageRotate::usage = "\!\(\*RowBox[{\"ImageRotate\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) rotates \!\(\*StyleBox[\"image\", \"TI\"]\) by 90\[Degree] about its center in the \!\(\*StyleBox[\"x\", \"TI\"]\)-\!\(\*StyleBox[\"y\", \"TI\"]\) plane. \n\!\(\*RowBox[{\"ImageRotate\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) rotates \!\(\*StyleBox[\"image\", \"TI\"]\) by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians.\n\!\(\*RowBox[{\"ImageRotate\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"w\", \"TI\"]}], \"}\"}]}], \"]\"}]\) rotates a 3D image around the 3D vector \!\(\*StyleBox[\"w\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageRotate\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) gives an image of the specified size."
ImageSaliencyFilter::usage = "\!\(\*RowBox[{\"ImageSaliencyFilter\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) returns a saliency map for \!\(\*StyleBox[\"image\", \"TI\"]\)."
ImageScaled::usage = "\!\(\*RowBox[{\"ImageScaled\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the position of a graphical object in terms of coordinates scaled to run from 0 to 1 across the whole image region in each direction. \n\!\(\*RowBox[{\"ImageScaled\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives a position obtained by starting at ordinary coordinates \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]\), then moving by an image\[Hyphen]scaled offset \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]\). "
ImageScan::usage = "\!\(\*RowBox[{\"ImageScan\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"image\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"f\", \"TI\"]\) applied to each pixel of \!\(\*StyleBox[\"image\", \"TI\"]\) in turn."
ImageSizeAction::usage = "ImageSizeAction is an option for Pane and related constructs that specifies what to do if the specified ImageSize setting does not match the size of the contents."
ImageSizeMultipliers::usage = "ImageSizeMultipliers is an option that specifies how much smaller to render graphics that appear within other constructs."
ImageSize::usage = "ImageSize is an option that specifies the overall size of an image to display for an object. "
ImageSubtract::usage = "\!\(\*RowBox[{\"ImageSubtract\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) subtracts a constant amount \!\(\*StyleBox[\"x\", \"TI\"]\) from each channel value in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageSubtract\", \"[\", RowBox[{SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives an image in which each pixel is obtained by subtracting the values of the corresponding pixels in \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"image\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ImageSubtract\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) subtracts all \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) from \!\(\*StyleBox[\"image\", \"TI\"]\), where each \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) can be either an image, a number, or a color value."
ImageTake::usage = "\!\(\*RowBox[{\"ImageTake\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives an image consisting of the first \!\(\*StyleBox[\"n\", \"TI\"]\) rows of \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageTake\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) gives an image consisting of the last \!\(\*StyleBox[\"n\", \"TI\"]\) rows of \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageTake\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives rows \!\(\*SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ImageTake\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the image that spans \!\(\*SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ImageTake\", \"[\", RowBox[{StyleBox[\"image3D\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"slice\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"slice\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"row\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the 3D image consisting of the specified slices, rows, and columns."
ImageTransformation::usage = "\!\(\*RowBox[{\"ImageTransformation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"function\", \"TI\"]}], \"]\"}]\) gives an image in which each pixel at position \!\(\*StyleBox[\"p\", \"TI\"]\) corresponds to the position \!\(\*RowBox[{StyleBox[\"function\", \"TI\"], \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageTransformation\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"function\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) gives an image of the specified size."
ImageTrim::usage = "\!\(\*RowBox[{\"ImageTrim\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the smallest subimage of \!\(\*StyleBox[\"image\", \"TI\"]\) that includes all of the specified points.\n\!\(\*RowBox[{\"ImageTrim\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) adds a margin of size \!\(\*StyleBox[\"r\", \"TI\"]\) back to the resulting image."
ImageType::usage = "\!\(\*RowBox[{\"ImageType\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the underlying type of values used for each pixel element in the Image or Image3D object \!\(\*StyleBox[\"image\", \"TI\"]\)."
Image::usage = "\!\(\*RowBox[{\"Image\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) represents a raster image with pixel values given by the array \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"Image\", \"[\", StyleBox[\"graphics\", \"TI\"], \"]\"}]\) creates a raster image from a graphics object. \n\!\(\*RowBox[{\"Image\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) gives an image that uses the specified options."
ImageValuePositions::usage = "\!\(\*RowBox[{\"ImageValuePositions\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) returns a list of pixel positions in \!\(\*StyleBox[\"image\", \"TI\"]\) that match the value \!\(\*StyleBox[\"val\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageValuePositions\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) returns all pixel positions that have values within a distance \!\(\*StyleBox[\"d\", \"TI\"]\) from \!\(\*StyleBox[\"val\", \"TI\"]\)."
ImageValue::usage = "\!\(\*RowBox[{\"ImageValue\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) gives the pixel value of \!\(\*StyleBox[\"image\", \"TI\"]\) at position \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"ImageValue\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the pixel value converted to the specified type."
ImagingDevice::usage = "ImagingDevice is an option to specify what device to use for capturing images."
ImplicitRegion::usage = "\!\(\*RowBox[{\"ImplicitRegion\", \"[\", RowBox[{StyleBox[\"cond\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a region in \!\(\*SuperscriptBox[\"\[DoubleStruckCapitalR]\", StyleBox[\"n\", \"TI\"]]\) that satisfies the conditions \!\(\*StyleBox[\"cond\", \"TI\"]\). \n\!\(\*RowBox[{\"ImplicitRegion\", \"[\", RowBox[{StyleBox[\"cond\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a region in \!\(\*SuperscriptBox[\"\[DoubleStruckCapitalR]\", StyleBox[\"n\", \"TI\"]]\) that satisfies the conditions \!\(\*StyleBox[\"cond\", \"TI\"]\) as well as \!\(\*RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], \"1\"], \"\[LessEqual]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \"\[LessEqual]\", SubscriptBox[StyleBox[\"b\", \"TI\"], \"1\"]}]\) etc."
Implies::usage = "\!\(\*RowBox[{\"Implies\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents the logical implication \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"\[DoubleRightArrow]\", StyleBox[\"q\", \"TI\"]}]\). "
ImportAutoReplacements::usage = "ImportAutoReplacements is an option for cells that specifies which replacement rules \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\"]\) automatically applies when importing text."
ImportOptions::usage = "ImportOptions is an option for Interpreter and related functions that specifies what options should be used in importing data."
ImportString::usage = "\!\(\*RowBox[{\"ImportString\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"data\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) imports data in the specified format from a string. \n\!\(\*RowBox[{\"ImportString\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"data\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"elements\", \"TI\"]}], \"]\"}]\) imports the specified elements.\n\!\(\*RowBox[{\"ImportString\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"data\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) attempts to determine the format of the string from its contents."
Import::usage = "\!\(\*RowBox[{\"Import\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) imports data from a file, returning a complete \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) version of it.\n\!\(\*RowBox[{\"Import\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"elements\", \"TI\"]}], \"]\"}]\) imports the specified elements from a file.\n\!\(\*RowBox[{\"Import\", \"[\", RowBox[{StyleBox[\"\\\"http://\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) and \!\(\*RowBox[{\"Import\", \"[\", RowBox[{StyleBox[\"\\\"ftp://\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) import from any accessible URL."
ImprovementImportance::usage = "\!\(\*RowBox[{\"ImprovementImportance\", \"[\", RowBox[{StyleBox[\"rdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the improvement importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"ImprovementImportance\", \"[\", RowBox[{StyleBox[\"fdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the improvement importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\)."
Im::usage = "\!\(\*RowBox[{\"Im\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the imaginary part of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
Inactivate::usage = "\!\(\*RowBox[{\"Inactivate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) replaces all instances of \!\(\*StyleBox[\"f\", \"TI\"]\) with \!\(\*RowBox[{\"Inactive\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) for symbols \!\(\*StyleBox[\"f\", \"TI\"]\) used as heads in \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"Inactivate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) inactivates all symbols in \!\(\*StyleBox[\"expr\", \"TI\"]\) that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\)."
Inactive::usage = "\!\(\*RowBox[{\"Inactive\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) is an inactive form of \!\(\*StyleBox[\"f\", \"TI\"]\)."
IncidenceGraph::usage = "\!\(\*RowBox[{\"IncidenceGraph\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the graph with incidence matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"IncidenceGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the graph with vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and incidence matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
IncidenceList::usage = "\!\(\*RowBox[{\"IncidenceList\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives a list of edges incident to vertex \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"IncidenceList\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of edges incident to vertices that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"IncidenceList\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives a list of incident edges \!\(\*StyleBox[\"d\", \"TI\"]\) steps away.\n\!\(\*RowBox[{\"IncidenceList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
IncidenceMatrix::usage = "\!\(\*RowBox[{\"IncidenceMatrix\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the vertex-edge incidence matrix of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"IncidenceMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
IncludeConstantBasis::usage = "IncludeConstantBasis is an option for LinearModelFit and other fitting functions that specifies whether a constant term should be included if not explicitly given in the list of basis functions."
IncludeFileExtension::usage = "IncludeFileExtension is an option for notebooks that specifies whether the suffix \".nb\" is automatically appended to a notebook\[CloseCurlyQuote]s name when it is first saved."
IncludeGeneratorTasks::usage = "IncludeGeneratorTasks is an option controlling the scope of scheduled task listings."
IncludeInflections::usage = "IncludeInflections is an option for linguistic functions that specifies whether inflected forms of words should be included in results."
IncludePods::usage = "IncludePods is an option for WolframAlpha that determines specific pod IDs to include in the results."
IncludeQuantities::usage = "IncludeQuantities is an option for DimensionalCombinations for additional quantities to include in the result."
IncludeSingularTerm::usage = "IncludeSingularTerm is an option for LerchPhi and Zeta. With \!\(\*RowBox[{\"IncludeSingularTerm\", \" \", \"->\", \" \", \"True\"}]\), terms involving \!\(\*SuperscriptBox[RowBox[{\"(\", SuperscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"k\", \"TI\"], \" \", \"+\", \" \", StyleBox[\"a\", \"TI\"]}], \")\"}], \"2\"], \")\"}], RowBox[{RowBox[{\"-\", StyleBox[\"s\", \"TI\"]}], \"/\", \"2\"}]]\) with \!\(\*RowBox[{RowBox[{StyleBox[\"k\", \"TI\"], \" \", \"+\", \" \", StyleBox[\"a\", \"TI\"]}], \" \", \"==\", \" \", \"0\"}]\) are included. With \!\(\*RowBox[{\"IncludeSingularTerm\", \" \", \"->\", \" \", \"False\"}]\), they are not."
IncludeWindowTimes::usage = "IncludeWindowTimes is an option to TimeSeriesWindow that specifies whether the endpoints in the time window should be included."
Increment::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"++\"}]\) increases the value of \!\(\*StyleBox[\"x\", \"TI\"]\) by 1, returning the old value of \!\(\*StyleBox[\"x\", \"TI\"]\). "
IndefiniteMatrixQ::usage = "\!\(\*RowBox[{\"IndefiniteMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly indefinite, and False otherwise. "
IndependenceTest::usage = "\!\(\*RowBox[{\"IndependenceTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"IndependenceTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"IndependenceTest\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], StyleBox[\",\", \"MR\"], StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
IndependentEdgeSetQ::usage = "\!\(\*RowBox[{\"IndependentEdgeSetQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"elist\", \"TI\"]}], \"]\"}]\) yields True if the edge list \!\(\*StyleBox[\"elist\", \"TI\"]\) is an independent edge set of the graph \!\(\*StyleBox[\"g\", \"TI\"]\), and False otherwise."
IndependentUnit::usage = "\!\(\*RowBox[{\"IndependentUnit\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) represents a unit \!\(\*StyleBox[\"string\", \"TI\"]\) with no relationship to other units within a Quantity."
IndependentVertexSetQ::usage = "\!\(\*RowBox[{\"IndependentVertexSetQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"vlist\", \"TI\"]}], \"]\"}]\) yields True if the vertex list \!\(\*StyleBox[\"vlist\", \"TI\"]\) is an independent vertex set in the graph \!\(\*StyleBox[\"g\", \"TI\"]\), and False otherwise."
IndeterminateThreshold::usage = "IndeterminateThreshold is an option for Classify, Predict, and related functions that specifies below what probability or probability density a result should be considered indeterminate."
Indeterminate::usage = "Indeterminate is a symbol that represents a numerical quantity whose magnitude cannot be determined. "
Indexed::usage = "\!\(\*RowBox[{\"Indexed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) represents the component of \!\(\*StyleBox[\"expr\", \"TI\"]\) with index \!\(\*StyleBox[\"i\", \"TI\"]\) and formats as \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Indexed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the component with indices \!\(\*StyleBox[\"i\", \"TI\"]\), \!\(\*StyleBox[\"j\", \"TI\"]\), \[Ellipsis] and formats as \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", \"\[Ellipsis]\"}]]\)."
IndexGraph::usage = "\!\(\*RowBox[{\"IndexGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) replaces the vertices of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) by its vertex indexes.\n\!\(\*RowBox[{\"IndexGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) replaces the vertices with integers \!\(\*StyleBox[\"r\", \"TI\"]\), \!\(\*RowBox[{StyleBox[\" \", \"TI\"], RowBox[{StyleBox[\"r\", \"TI\"], \"+\", \"1\"}]}]\), \[Ellipsis].\n\!\(\*RowBox[{\"IndexGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Inequality::usage = "Inequality represents a sequence of relational statements."
InexactNumberQ::usage = "\!\(\*RowBox[{\"InexactNumberQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is an inexact real or complex number, and returns False otherwise."
InexactNumbers::usage = "InexactNumbers represents an option value for CoefficientDomain which specifies that the computation should be done using approximate coefficient arithmetic."
InfiniteLine::usage = "\!\(\*RowBox[{\"InfiniteLine\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents the infinite straight line passing through the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). \n\!\(\*RowBox[{\"InfiniteLine\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents the infinite straight line passing through the point \!\(\*StyleBox[\"p\", \"TI\"]\) in the direction \!\(\*StyleBox[\"v\", \"TI\"]\). "
InfinitePlane::usage = "\!\(\*RowBox[{\"InfinitePlane\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents the plane passing through the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"3\", \"TR\"]]\).\n\!\(\*RowBox[{\"InfinitePlane\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents the plane passing through the point \!\(\*StyleBox[\"p\", \"TI\"]\) in the directions \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
Infinity::usage = "Infinity or \[Infinity] is a symbol that represents a positive infinite quantity. "
Infix::usage = "\!\(\*RowBox[{\"Infix\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \"]\"}]\) prints with \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) given in default infix form: \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"~\", StyleBox[\"f\", \"TI\"], \"~\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"~\", StyleBox[\"f\", \"TI\"], \"~\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]\). \n\!\(\*RowBox[{\"Infix\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) prints with arguments separated by \!\(\*StyleBox[\"h\", \"TI\"]\): \!\(\*RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \" \", StyleBox[\"h\", \"TI\"], \" \", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \" \", StyleBox[\"h\", \"TI\"], \" \", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"3\", \"TR\"]], StyleBox[\"\[Ellipsis]\", \"TR\"]}]\). "
InflationAdjust::usage = "\!\(\*RowBox[{\"InflationAdjust\", \"[\", RowBox[{StyleBox[\"quantity\", \"TI\"], \",\", StyleBox[\"targetdate\", \"TI\"]}], \"]\"}]\) attempts to adjust the specified \!\(\*StyleBox[\"quantity\", \"TI\"]\) purchasing power to \!\(\*StyleBox[\"targetdate\", \"TI\"]\).\n\!\(\*RowBox[{\"InflationAdjust\", \"[\", StyleBox[\"quantity\", \"TI\"], \"]\"}]\) uses the current year as \!\(\*StyleBox[\"targetdate\", \"TI\"]\).\n\!\(\*RowBox[{\"InflationAdjust\", \"[\", RowBox[{StyleBox[\"quantity\", \"TI\"], \",\", StyleBox[\"targetunit\", \"TI\"]}], \"]\"}]\) converts the currency to \!\(\*StyleBox[\"targetunit\", \"TI\"]\)\!\(\*StyleBox[\" \", \"TI\"]\)after adjusting to the current year.\n\!\(\*RowBox[{\"InflationAdjust\", \"[\", RowBox[{StyleBox[\"timeseries\", \"TI\"], \",\", StyleBox[\"targetdate\", \"TI\"]}], \"]\"}]\) attempts to adjust the specified \!\(\*StyleBox[\"timeseries\", \"TI\"]\) data purchasing power to \!\(\*StyleBox[\"targetdate\", \"TI\"]\)."
InflationMethod::usage = "InflationMethod is an option for InflationAdjust that specifies what time series data is to be used for adjustment in time."
Information::usage = "\!\(\*RowBox[{\"Information\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) prints information about a symbol. "
Inherited::usage = "Inherited represents an option value to be inherited from an enclosing style, cell, or notebook. "
InheritScope::usage = "InheritScope is an option for DynamicModule that specifies whether to attempt to bind variables referenced in the DynamicModule to a parent DynamicModule instance."
InhomogeneousPoissonProcess::usage = "\!\(\*RowBox[{\"InhomogeneousPoissonProcess\", \"[\", RowBox[{RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \"[\", StyleBox[\"t\", \"TI\"], \"]\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents an inhomogeneous Poisson process with intensity \!\(\*RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) given as a function of \!\(\*StyleBox[\"t\", \"TI\"]\)."
InitializationCellEvaluation::usage = "InitializationCellEvaluation is an option for notebooks that specifies whether initialization cells in a notebook are automatically evaluated when the notebook is opened."
InitializationCell::usage = "InitializationCell is an option for Cell that specifies whether the cell should be tagged to be evaluated by the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) kernel immediately before the first evaluation performed by the user after the notebook is opened. "
InitializationCellWarning::usage = "InitializationCellWarning is an option for notebooks that specifies whether a warning should be given when a notebook containing initialization cells is opened."
InitializationGroup::usage = "InitializationGroup is an option for the first cell of a cell group that specifies whether the group should be tagged to be evaluated by the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) kernel when the notebook that contains them is opened."
Initialization::usage = "Initialization is an option for Dynamic, DynamicModule, Manipulate, and related constructs that specifies an expression to be evaluated when the construct is first displayed. "
Inner::usage = "\!\(\*RowBox[{\"Inner\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) is a generalization of Dot in which \!\(\*StyleBox[\"f\", \"TI\"]\) plays the role of multiplication and \!\(\*StyleBox[\"g\", \"TI\"]\) of addition. "
Inpaint::usage = "\!\(\*RowBox[{\"Inpaint\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"region\", \"TI\"]}], \"]\"}]\) retouches parts of \!\(\*StyleBox[\"image\", \"TI\"]\) that correspond to nonzero elements in \!\(\*StyleBox[\"region\", \"TI\"]\)."
InputAliases::usage = "InputAliases is an option for cells and notebooks which specifies additional \!\(\*StyleBox[\"Esc\", \"KeyEvent\"]\)\!\(\*StyleBox[\"\[ThinSpace]\", \"InlineCode\"]\)\!\(\*StyleBox[\"name\", \"TI\"]\)\!\(\*StyleBox[\"\[ThinSpace]\", \"InlineCode\"]\)\!\(\*StyleBox[\"Esc\", \"KeyEvent\"]\) aliases to be allowed on input. "
InputAssumptions::usage = "InputAssumptions is an option for WolframAlpha that specifies assumptions for current query input."
InputAutoReplacements::usage = "InputAutoReplacements is an option for cells and notebooks which specifies strings of characters that should be replaced immediately on input. "
InputFieldBoxOptions::usage = "\!\(\*RowBox[{InputFieldBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for InputFieldBox objects."
InputField::usage = "\!\(\*RowBox[{\"InputField\", \"[\", \"]\"}]\) represents a blank editable input field. \n\!\(\*RowBox[{\"InputField\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents an editable input field that currently contains the expression \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"InputField\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\) takes the contents of the input field to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being reset if new contents are entered. \n\!\(\*RowBox[{\"InputField\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", \"String\"}], \"]\"}]\) represents an input field whose contents are taken to be a string. \n\!\(\*RowBox[{\"InputField\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", \"Number\"}], \"]\"}]\) represents an input field whose contents are taken to be a number. \n\!\(\*RowBox[{\"InputField\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) represents an input field whose contents are taken to be of the specified type. "
InputForm::usage = "\!\(\*RowBox[{\"InputForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as a version of \!\(\*StyleBox[\"expr\", \"TI\"]\) suitable for input to \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\"]\). "
InputNamePacket::usage = "\!\(\*RowBox[{\"InputNamePacket\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that contains in \!\(\*StyleBox[\"string\", \"TI\"]\) the name to be assigned to the next input."
InputNotebook::usage = "\!\(\*RowBox[{\"InputNotebook\", \"[\", \"]\"}]\) gives the current notebook into which keyboard input in the front end will be directed. "
InputPacket::usage = "\!\(\*RowBox[{\"InputPacket\", \"[\", \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that indicates a prompt for input as generated by Input."
InputStream::usage = "\!\(\*RowBox[{\"InputStream\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) is an object that represents an input stream for functions such as Read and Find. "
InputStringPacket::usage = "\!\(\*RowBox[{\"InputStringPacket\", \"[\", \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that requests input in string form."
InputString::usage = "\!\(\*RowBox[{\"InputString\", \"[\", \"]\"}]\) interactively reads in a character string. \n\!\(\*RowBox[{\"InputString\", \"[\", StyleBox[\"prompt\", \"TI\"], \"]\"}]\) requests input, displaying \!\(\*StyleBox[\"prompt\", \"TI\"]\) as a \"prompt\". \n\!\(\*RowBox[{\"InputString\", \"[\", RowBox[{StyleBox[\"prompt\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) in a notebook front end uses \!\(\*StyleBox[\"init\", \"TI\"]\) as the initial contents of the input field."
InputToBoxFormPacket::usage = "InputToBoxFormPacket is an internal symbol used for formatting."
Input::usage = "\!\(\*RowBox[{\"Input\", \"[\", \"]\"}]\) interactively reads in one \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) expression. \n\!\(\*RowBox[{\"Input\", \"[\", StyleBox[\"prompt\", \"TI\"], \"]\"}]\) requests input, displaying \!\(\*StyleBox[\"prompt\", \"TI\"]\) as a \"prompt\".\n\!\(\*RowBox[{\"Input\", \"[\", RowBox[{StyleBox[\"prompt\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) in a notebook front end uses \!\(\*StyleBox[\"init\", \"TI\"]\) as the initial contents of the input field."
InsertionFunction::usage = "InsertionFunction is an option for template functions that specifies how expressions are to be processed before they are inserted when the template is applied."
InsertLinebreaks::usage = "\!\(\*RowBox[{\"InsertLinebreaks\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) inserts newline characters into \!\(\*StyleBox[\"string\", \"TI\"]\) to make a string in which no line is longer than 78 characters.\n\!\(\*RowBox[{\"InsertLinebreaks\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) inserts newline characters to make no line longer than \!\(\*StyleBox[\"n\", \"TI\"]\) characters. "
InsertResults::usage = "InsertResults is an option for NotebookEvaluate that determines whether to place the results of evaluation in the notebook being evaluated."
Insert::usage = "\!\(\*RowBox[{\"Insert\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) inserts \!\(\*StyleBox[\"elem\", \"TI\"]\) at position \!\(\*StyleBox[\"n\", \"TI\"]\) in \!\(\*StyleBox[\"list\", \"TI\"]\). If \!\(\*StyleBox[\"n\", \"TI\"]\) is negative, the position is counted from the end. \n\!\(\*RowBox[{\"Insert\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) inserts \!\(\*StyleBox[\"elem\", \"TI\"]\) at position \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Insert\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) inserts \!\(\*StyleBox[\"elem\", \"TI\"]\) at several positions. \n\!\(\*RowBox[{\"Insert\", \"[\", RowBox[{StyleBox[\"elem\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) represents an operator form of Insert that can be applied to an expression."
Inset3DBoxOptions::usage = "\!\(\*RowBox[{Inset3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for Inset3DBox objects."
InsetBoxOptions::usage = "\!\(\*RowBox[{InsetBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for InsetBox objects."
Inset::usage = "\!\(\*RowBox[{\"Inset\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) represents an object \!\(\*StyleBox[\"obj\", \"TI\"]\) inset in a graphic. \n\!\(\*RowBox[{\"Inset\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) specifies that the inset should be placed at position \!\(\*StyleBox[\"pos\", \"TI\"]\) in the graphic. \n\!\(\*RowBox[{\"Inset\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"opos\", \"TI\"]}], \"]\"}]\) aligns the inset so that position \!\(\*StyleBox[\"opos\", \"TI\"]\) in the object lies at position \!\(\*StyleBox[\"pos\", \"TI\"]\) in the enclosing graphic. \n\!\(\*RowBox[{\"Inset\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"opos\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) specifies the size of the inset in the coordinate system of the enclosing graphic. \n\!\(\*RowBox[{\"Inset\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"opos\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"], \",\", StyleBox[\"dirs\", \"TI\"]}], \"]\"}]\) specifies that the axes of the inset should be oriented in directions \!\(\*StyleBox[\"dirs\", \"TI\"]\). "
Insphere::usage = "\!\(\*RowBox[{\"Insphere\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"n\", StyleBox[\"+\", FontSlant -> \"Plain\"], StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]]}], \"}\"}], \"]\"}]\) returns the largest Sphere that can be inscribed in the simplex (triangle, tetrahedron, etc.) defined by points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in \!\(\*SuperscriptBox[\"\[DoubleStruckCapitalR]\", StyleBox[\"n\", \"TI\"]]\)."
InstallService::usage = "\!\(\*RowBox[{\"InstallService\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) installs the web service operations in the WSDL description at the URL given.\n\!\(\*RowBox[{\"InstallService\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", \" \", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context`\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) installs web service operations, creating functions in the specified context."
Install::usage = "\!\(\*RowBox[{\"Install\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) starts a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\)-compatible external program and installs \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) definitions to call functions in it. "
InString::usage = "\!\(\*RowBox[{\"InString\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) is a global object that is assigned to be the text of the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) input line. "
IntegerDigits::usage = "\!\(\*RowBox[{\"IntegerDigits\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a list of the decimal digits in the integer \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"IntegerDigits\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives a list of the base \!\(\*StyleBox[\"b\", \"TI\"]\) digits in the integer \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"IntegerDigits\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"len\", \"TI\"]}], \"]\"}]\) pads the list on the left with zeros to give a list of length \!\(\*StyleBox[\"len\", \"TI\"]\). \n\!\(\*RowBox[{\"IntegerDigits\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"MixedRadix\", \"[\", StyleBox[\"blist\", \"TI\"], \"]\"}]}], \"]\"}]\) uses the mixed radix with list of bases \!\(\*StyleBox[\"blist\", \"TI\"]\)."
IntegerExponent::usage = "\!\(\*RowBox[{\"IntegerExponent\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the highest power of \!\(\*StyleBox[\"b\", \"TI\"]\) that divides \!\(\*StyleBox[\"n\", \"TI\"]\). "
IntegerLength::usage = "\!\(\*RowBox[{\"IntegerLength\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number of digits in the base 10 representation of the integer \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"IntegerLength\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the number of digits in the base \!\(\*StyleBox[\"b\", \"TI\"]\) representation of \!\(\*StyleBox[\"n\", \"TI\"]\)."
IntegerName::usage = "\!\(\*RowBox[{\"IntegerName\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a string containing the full English name of the integer \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"IntegerName\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a string of the specified type."
IntegerPartitions::usage = "\!\(\*RowBox[{\"IntegerPartitions\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a list of all possible ways to partition the integer \!\(\*StyleBox[\"n\", \"TI\"]\) into smaller integers. \n\!\(\*RowBox[{\"IntegerPartitions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives partitions into at most \!\(\*StyleBox[\"k\", \"TI\"]\) integers. \n\!\(\*RowBox[{\"IntegerPartitions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"k\", \"TI\"], \"}\"}]}], \"]\"}]\) gives partitions into exactly \!\(\*StyleBox[\"k\", \"TI\"]\) integers. \n\!\(\*RowBox[{\"IntegerPartitions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives partitions into between \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) integers. \n\!\(\*RowBox[{\"IntegerPartitions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"kspec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives partitions involving only the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"IntegerPartitions\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"kspec\", \"TI\"], \",\", StyleBox[\"sspec\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) limits the result to the first \!\(\*StyleBox[\"m\", \"TI\"]\) partitions. "
IntegerPart::usage = "\!\(\*RowBox[{\"IntegerPart\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the integer part of \!\(\*StyleBox[\"x\", \"TI\"]\). "
IntegerQ::usage = "\!\(\*RowBox[{\"IntegerQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is an integer, and False otherwise. "
IntegerReverse::usage = "\!\(\*RowBox[{\"IntegerReverse\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the integer whose digits are reversed with respect to those of the integer \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"IntegerReverse\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the integer whose digits in base \!\(\*StyleBox[\"b\", \"TI\"]\) are reversed with respect to those of \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"IntegerReverse\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"len\", \"TI\"]}], \"]\"}]\) gives the integer with reversed digits after padding \!\(\*StyleBox[\"n\", \"TI\"]\) with zeros on the left to have \!\(\*StyleBox[\"len\", \"TI\"]\) digits."
IntegerString::usage = "\!\(\*RowBox[{\"IntegerString\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a string consisting of the decimal digits in the integer \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"IntegerString\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives a string consisting of the base \!\(\*StyleBox[\"b\", \"TI\"]\) digits in the integer \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"IntegerString\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"len\", \"TI\"]}], \"]\"}]\) pads the string on the left with zero digits to give a string of length \!\(\*StyleBox[\"len\", \"TI\"]\). \n\!\(\*RowBox[{\"IntegerString\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"MixedRadix\", \"[\", StyleBox[\"blist\", \"TI\"], \"]\"}]}], \"]\"}]\) uses the mixed radix with list of bases \!\(\*StyleBox[\"blist\", \"TI\"]\).\n\!\(\*RowBox[{\"IntegerString\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\\\"Roman\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives the Roman numeral form of \!\(\*StyleBox[\"n\", \"TI\"]\)."
Integers::usage = "Integers represents the domain of integers, as in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", \"Integers\"}]\). "
Integer::usage = "Integer is the head used for integers. "
Integrate::usage = "\!\(\*RowBox[{\"Integrate\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the indefinite integral \!\(\*RowBox[{\"\[Integral]\", StyleBox[\"f\", \"TI\"], \" \", StyleBox[\"d\", \"TI\"], StyleBox[\"x\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Integrate\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the definite integral \!\(\*RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]], \" \", StyleBox[\"f\", \"TI\"], \" \", StyleBox[\"d\", \"TI\"], StyleBox[\"x\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Integrate\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the multiple integral \!\(\*RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]], RowBox[{StyleBox[\"d\", \"TI\"], StyleBox[\"x\", \"TI\"], RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]], RowBox[{StyleBox[\"d\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"y\", \"TI\"], \" \", \"\[Ellipsis]\", \" \", StyleBox[\"f\", \"TI\"]}]}]}]}]\). \n\!\(\*RowBox[{\"Integrate\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) integrates over the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
InteractiveTradingChart::usage = "\!\(\*RowBox[{\"InteractiveTradingChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"open\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"high\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"low\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"close\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"volume\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a chart showing prices and volume for each date. \n\!\(\*RowBox[{\"InteractiveTradingChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"daterange\", \"TI\"]}], StyleBox[\"}\", \"TI\"]}], \"]\"}]\) makes a financial chart for the financial entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" over the \!\(\*StyleBox[\"daterange\", \"TI\"]\). \n\!\(\*RowBox[{\"InteractiveTradingChart\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"ind\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ind\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) makes a financial chart with indicators \!\(\*SubscriptBox[StyleBox[\"ind\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"ind\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] . "
Interactive::usage = "Interactive is an option to notebook manipulation functions that specifies whether the function should create a user prompt when mimicking an action that would have created a user prompt if invoked manually."
Interleaving::usage = "Interleaving is an option for Image and related functions that specifies whether data corresponding to different channels in an object such as an image should be interleaved."
InternallyBalancedDecomposition::usage = "\!\(\*RowBox[{\"InternallyBalancedDecomposition\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) yields the internally balanced decomposition of the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
InterpolatingFunction::usage = "\!\(\*RowBox[{\"InterpolatingFunction\", \"[\", RowBox[{StyleBox[\"domain\", \"TI\"], \",\", StyleBox[\"table\", \"TI\"]}], \"]\"}]\) represents an approximate function whose values are found by interpolation. "
InterpolatingPolynomial::usage = "\!\(\*RowBox[{\"InterpolatingPolynomial\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) constructs an interpolating polynomial in \!\(\*StyleBox[\"x\", \"TI\"]\) which reproduces the function values \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at successive integer values 1, 2, \[Ellipsis] of \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"InterpolatingPolynomial\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) constructs an interpolating polynomial for the function values \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to \!\(\*StyleBox[\"x\", \"TI\"]\) values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"InterpolatingPolynomial\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs a multidimensional interpolating polynomial in the variables \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis].\n\!\(\*RowBox[{\"InterpolatingPolynomial\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"df\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs an interpolating polynomial that reproduces derivatives as well as function values."
InterpolationOrder::usage = "InterpolationOrder is an option for Interpolation, as well as ListLinePlot, ListPlot3D, ListContourPlot, and related functions, that specifies what order of interpolation to use."
InterpolationPoints::usage = "InterpolationPoints is an option to SmoothKernelDistribution and FunctionInterpolation that specifies the initial number of interpolation points to use. "
Interpolation::usage = "\!\(\*RowBox[{\"Interpolation\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) constructs an interpolation of the function values \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), assumed to correspond to \!\(\*StyleBox[\"x\", \"TI\"]\) values 1, 2, \[Ellipsis] . \n\!\(\*RowBox[{\"Interpolation\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) constructs an interpolation of the function values \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to \!\(\*StyleBox[\"x\", \"TI\"]\) values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Interpolation\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) constructs an interpolation of multidimensional data.\n\!\(\*RowBox[{\"Interpolation\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"df\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) constructs an interpolation that reproduces derivatives as well as function values.\n\!\(\*RowBox[{\"Interpolation\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) find an interpolation of \!\(\*StyleBox[\"data\", \"TI\"]\) at the point \!\(\*StyleBox[\"x\", \"TI\"]\)."
InterpretationBoxOptions::usage = "\!\(\*RowBox[{InterpretationBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for selections that specifies settings for InterpretationBox constructs."
InterpretationBox::usage = "\!\(\*RowBox[{InterpretationBox, \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) is a low-level box construct that displays as \!\(\*StyleBox[\"boxes\", \"TI\"]\) but is interpreted on input as \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Interpretation::usage = "\!\(\*RowBox[{\"Interpretation\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) represents an object that displays as \!\(\*StyleBox[\"e\", \"TI\"]\), but is interpreted as the unevaluated form of \!\(\*StyleBox[\"expr\", \"TI\"]\) if supplied as input. \n\!\(\*RowBox[{\"Interpretation\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", RowBox[{StyleBox[\"y\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) allows local variables \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis] in \!\(\*StyleBox[\"e\", \"TI\"]\) and \!\(\*StyleBox[\"expr\", \"TI\"]\)."
Interpreter::usage = "\!\(\*RowBox[{\"Interpreter\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) represents an interpreter object that can be applied to an input to try to interpret it as an object of the specified form. \n\!\(\*RowBox[{\"Interpreter\", \"[\", RowBox[{StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) returns the interpreted object only if applying \!\(\*StyleBox[\"test\", \"TI\"]\) to it yields True; otherwise it returns a Failure object.\n\!\(\*RowBox[{\"Interpreter\", \"[\", RowBox[{StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"fail\", \"TI\"]}], \"]\"}]\) returns the result of applying the function \!\(\*StyleBox[\"fail\", \"TI\"]\) if the test fails."
InterpretTemplate::usage = "InterpretTemplate is an experimental function used for interpreting \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) input."
InterquartileRange::usage = "\!\(\*RowBox[{\"InterquartileRange\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the difference between the upper and lower quartiles for the elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"InterquartileRange\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the difference between the upper and lower quartiles for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
Interrupt::usage = "\!\(\*RowBox[{\"Interrupt\", \"[\", \"]\"}]\) generates an interrupt. "
IntersectingQ::usage = "\!\(\*RowBox[{\"IntersectingQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) have at least one element in common, and False otherwise."
Intersection::usage = "\!\(\*RowBox[{\"Intersection\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a sorted list of the elements common to all the \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
IntervalIntersection::usage = "\!\(\*RowBox[{\"IntervalIntersection\", \"[\", RowBox[{SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the interval representing all points common to each of the \!\(\*SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
IntervalMemberQ::usage = "\!\(\*RowBox[{\"IntervalMemberQ\", \"[\", RowBox[{StyleBox[\"interval\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives True if the number \!\(\*StyleBox[\"x\", \"TI\"]\) lies within the specified interval, and False otherwise. \n\!\(\*RowBox[{\"IntervalMemberQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives True if \!\(\*SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) is completely contained within \!\(\*SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"1\", \"TR\"]]\). "
IntervalSlider::usage = "\!\(\*RowBox[{\"IntervalSlider\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"xmin\", \"TI\"], \",\", StyleBox[\"xmax\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a slider with setting \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"xmin\", \"TI\"], \",\", StyleBox[\"xmax\", \"TI\"]}], \"}\"}]\) in the range 0 to 1.\n\!\(\*RowBox[{\"IntervalSlider\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"int\", \"TI\"], \"]\"}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"int\", \"TI\"]\), with the value of \!\(\*StyleBox[\"int\", \"TI\"]\) being reset if the slider is moved.\n\!\(\*RowBox[{\"IntervalSlider\", \"[\", RowBox[{StyleBox[\"int\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents a slider with range \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"IntervalSlider\", \"[\", RowBox[{StyleBox[\"int\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents a slider that jumps in steps \!\(\*StyleBox[\"dx\", \"TI\"]\)."
IntervalUnion::usage = "\!\(\*RowBox[{\"IntervalUnion\", \"[\", RowBox[{SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the interval representing the set of all points in any of the \!\(\*SubscriptBox[StyleBox[\"interval\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
Interval::usage = "\!\(\*RowBox[{\"Interval\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \"]\"}]\) represents the range of values between \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*StyleBox[\"max\", \"TI\"]\). \n\!\(\*RowBox[{\"Interval\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"min\", \"TI\"], StyleBox[\"1\", \"TR\"]], RowBox[{\",\", SubscriptBox[StyleBox[\"max\", \"TI\"], StyleBox[\"1\", \"TR\"]]}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"min\", \"TI\"], StyleBox[\"2\", \"TR\"]], RowBox[{\",\", SubscriptBox[StyleBox[\"max\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the union of the ranges \!\(\*SubscriptBox[StyleBox[\"min\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"max\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"min\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"max\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. "
In::usage = "\!\(\*RowBox[{\"In\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) is a global object that is assigned to have a delayed value of the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) input line. "
InverseBetaRegularized::usage = "\!\(\*RowBox[{\"InverseBetaRegularized\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the inverse of the regularized incomplete beta function. "
InverseCDF::usage = "\!\(\*RowBox[{\"InverseCDF\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the inverse of the cumulative distribution function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variable \!\(\*StyleBox[\"q\", \"TI\"]\)."
InverseChiSquareDistribution::usage = "\!\(\*RowBox[{\"InverseChiSquareDistribution\", \"[\", StyleBox[\"\[Nu]\", \"TR\"], \"]\"}]\) represents an inverse \!\(\*SuperscriptBox[\"\[Chi]\", \"2\"]\) distribution with \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom.\n\!\(\*RowBox[{\"InverseChiSquareDistribution\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"\[Xi]\", \"TR\"]}], \"]\"}]\) represents a scaled inverse \!\(\*SuperscriptBox[\"\[Chi]\", \"2\"]\) distribution with \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom and scale \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\)."
InverseContinuousWaveletTransform::usage = "\!\(\*RowBox[{\"InverseContinuousWaveletTransform\", \"[\", StyleBox[\"cwd\", \"TI\"], \"]\"}]\) gives the inverse continuous wavelet transform of a ContinuousWaveletData object \!\(\*StyleBox[\"cwd\", \"TI\"]\). \n\!\(\*RowBox[{\"InverseContinuousWaveletTransform\", \"[\", StyleBox[RowBox[{\"cwd\", \",\", \"wave\"}], \"TI\"], \"]\"}]\) gives the inverse transform using the wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\).\n\!\(\*RowBox[{\"InverseContinuousWaveletTransform\", \"[\", RowBox[{StyleBox[\"cwd\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"octvoc\", \"TI\"]}], \"]\"}]\) gives the inverse transform from the wavelet coefficients specified by \!\(\*StyleBox[\"octvoc\", \"TI\"]\)."
InverseDistanceTransform::usage = "\!\(\*RowBox[{\"InverseDistanceTransform\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the inverse distance transform of \!\(\*StyleBox[\"image\", \"TI\"]\), returning the result as a binary image."
InverseEllipticNomeQ::usage = "\!\(\*RowBox[{\"InverseEllipticNomeQ\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives the parameter \!\(\*StyleBox[\"m\", \"TI\"]\) corresponding to the nome \!\(\*StyleBox[\"q\", \"TI\"]\) in an elliptic function. "
InverseErfc::usage = "\!\(\*RowBox[{\"InverseErfc\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives the inverse complementary error function obtained as the solution for \!\(\*StyleBox[\"z\", \"TI\"]\) in \!\(\*RowBox[{StyleBox[\"s\", \"TI\"], \"=\", RowBox[{\"erfc\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]}]\). "
InverseErf::usage = "\!\(\*RowBox[{\"InverseErf\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives the inverse error function obtained as the solution for \!\(\*StyleBox[\"z\", \"TI\"]\) in \!\(\*RowBox[{StyleBox[\"s\", \"TI\"], \"=\", RowBox[{\"erf\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]}]\). "
InverseFourierCosTransform::usage = "\!\(\*RowBox[{\"InverseFourierCosTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the symbolic inverse Fourier cosine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"InverseFourierCosTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional inverse Fourier cosine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
InverseFourierSequenceTransform::usage = "\!\(\*RowBox[{\"InverseFourierSequenceTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the inverse discrete-time Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"InverseFourierSequenceTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional inverse Fourier sequence transform."
InverseFourierSinTransform::usage = "\!\(\*RowBox[{\"InverseFourierSinTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the symbolic inverse Fourier sine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"InverseFourierSinTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional inverse Fourier sine transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
InverseFourierTransform::usage = "\!\(\*RowBox[{\"InverseFourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"\[Omega]\", \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the symbolic inverse Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"InverseFourierTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[\"\[Omega]\", StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[\"\[Omega]\", StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional inverse Fourier transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
InverseFourier::usage = "\!\(\*RowBox[{\"InverseFourier\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds the discrete inverse Fourier transform of a list of complex numbers.\n\!\(\*RowBox[{\"InverseFourier\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns the specified positions of the discrete inverse Fourier transform. "
InverseFunctions::usage = "InverseFunctions is an option for Solve and related functions that specifies whether inverse functions should be used. "
InverseFunction::usage = "\!\(\*RowBox[{\"InverseFunction\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents the inverse of the function \!\(\*StyleBox[\"f\", \"TI\"]\), defined so that \!\(\*RowBox[{RowBox[{\"InverseFunction\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}], \"[\", StyleBox[\"y\", \"TI\"], \"]\"}]\) gives the value of \!\(\*StyleBox[\"x\", \"TI\"]\) for which \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) is equal to \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{\"InverseFunction\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"tot\", \"TI\"]}], \"]\"}]\) represents the inverse with respect to the \!\(\*StyleBox[RowBox[{StyleBox[\"n\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) argument when there are \!\(\*StyleBox[\"tot\", \"TI\"]\) arguments in all. "
InverseGammaDistribution::usage = "\!\(\*RowBox[{\"InverseGammaDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents an inverse gamma distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"InverseGammaDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a generalized inverse gamma distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\), and location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
InverseGammaRegularized::usage = "\!\(\*RowBox[{\"InverseGammaRegularized\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the inverse of the regularized incomplete gamma function. "
InverseGaussianDistribution::usage = "\!\(\*RowBox[{\"InverseGaussianDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"]\"}]\) represents an inverse Gaussian distribution with mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\).\n\!\(\*RowBox[{\"InverseGaussianDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) represents a generalized inverse Gaussian distribution with parameters \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\)."
InverseGudermannian::usage = "\!\(\*RowBox[{\"InverseGudermannian\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the inverse Gudermannian function \!\(\*RowBox[{SuperscriptBox[\"gd\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
InverseHaversine::usage = "\!\(\*RowBox[{\"InverseHaversine\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the inverse haversine function \!\(\*RowBox[{SuperscriptBox[\"hav\", RowBox[{\"-\", \"1\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
InverseJacobiCD::usage = "\!\(\*RowBox[{\"InverseJacobiCD\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"cd\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiCN::usage = "\!\(\*RowBox[{\"InverseJacobiCN\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"cn\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiCS::usage = "\!\(\*RowBox[{\"InverseJacobiCS\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"cs\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiDC::usage = "\!\(\*RowBox[{\"InverseJacobiDC\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"dc\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiDN::usage = "\!\(\*RowBox[{\"InverseJacobiDN\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"dn\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiDS::usage = "\!\(\*RowBox[{\"InverseJacobiDS\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"ds\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiNC::usage = "\!\(\*RowBox[{\"InverseJacobiNC\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"nc\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiND::usage = "\!\(\*RowBox[{\"InverseJacobiND\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"nd\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiNS::usage = "\!\(\*RowBox[{\"InverseJacobiNS\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"ns\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiSC::usage = "\!\(\*RowBox[{\"InverseJacobiSC\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"sc\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiSD::usage = "\!\(\*RowBox[{\"InverseJacobiSD\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"sd\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{\"v\", \"\[VerticalSeparator]\", \"m\"}], \")\"}]\)."
InverseJacobiSN::usage = "\!\(\*RowBox[{\"InverseJacobiSN\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the inverse Jacobi elliptic function \!\(\*RowBox[{SuperscriptBox[\"sn\", RowBox[{\"-\", \"1\"}]], \"(\", RowBox[{StyleBox[\"v\", \"TI\"], \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]\)."
InverseLaplaceTransform::usage = "\!\(\*RowBox[{\"InverseLaplaceTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the inverse Laplace transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"InverseLaplaceTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional inverse Laplace transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
InversePermutation::usage = "\!\(\*RowBox[{\"InversePermutation\", \"[\", StyleBox[\"perm\", \"TI\"], \"]\"}]\) returns the inverse of permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
InverseRadon::usage = "\!\(\*RowBox[{\"InverseRadon\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the inverse discrete Radon transform of \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"InverseRadon\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], StyleBox[RowBox[{\"w\", \",\", \"h\"}], \"TI\"], \"}\"}]}], \"]\"}]\) specifies the width \!\(\*StyleBox[\"w\", \"TI\"]\) and the height \!\(\*StyleBox[\"h\", \"TI\"]\) of the resulting image."
InverseSeries::usage = "\!\(\*RowBox[{\"InverseSeries\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) takes the series \!\(\*StyleBox[\"s\", \"TI\"]\), and gives a series for the inverse of the function represented by \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"InverseSeries\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) uses the variable \!\(\*StyleBox[\"x\", \"TI\"]\) in the inverse series."
InverseSurvivalFunction::usage = "\!\(\*RowBox[{\"InverseSurvivalFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the inverse of the survival function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variable \!\(\*StyleBox[\"q\", \"TI\"]\)."
InverseTransformedRegion::usage = "\!\(\*RowBox[{\"InverseTransformedRegion\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents the inverse transformed region \!\(\*RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"p\", \"TI\"], \"\[Element]\", SuperscriptBox[\"\[DoubleStruckCapitalR]\", StyleBox[\"n\", \"TI\"]]}], \"|\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"p\", \"TI\"], \")\"}], \"\[Element]\", StyleBox[\"reg\", FontSlant -> \"Italic\"]}]}], \"}\"}]\), where \!\(\*StyleBox[\"reg\", \"TI\"]\) is a region and \!\(\*StyleBox[\"f\", \"TI\"]\) is a function. "
Inverse::usage = "\!\(\*RowBox[{\"Inverse\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the inverse of a square matrix \!\(\*StyleBox[\"m\", \"TI\"]\). "
InverseWaveletTransform::usage = "\!\(\*RowBox[{\"InverseWaveletTransform\", \"[\", StyleBox[\"dwd\", \"TI\"], \"]\"}]\) gives the inverse wavelet transform of a DiscreteWaveletData object \!\(\*StyleBox[\"dwd\", \"TI\"]\).\n\!\(\*RowBox[{\"InverseWaveletTransform\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"]}], \"]\"}]\) gives the inverse transform using the wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\).\n\!\(\*RowBox[{\"InverseWaveletTransform\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"wind\", \"TI\"]}], \"]\"}]\) gives the inverse transform from the wavelet coefficients specified by \!\(\*StyleBox[\"wind\", \"TI\"]\)."
InverseWeierstrassP::usage = "\!\(\*RowBox[{\"InverseWeierstrassP\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives a value of \!\(\*StyleBox[\"u\", \"TI\"]\) for which the Weierstrass function \!\(\*RowBox[{\"\[WeierstrassP]\", RowBox[{\"(\", RowBox[{StyleBox[\"u\", \"TI\"], \";\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"2\"], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"3\"]}], \")\"}]}]\) is equal to \!\(\*StyleBox[\"p\", \"TI\"]\). "
InverseWishartMatrixDistribution::usage = "\!\(\*RowBox[{\"InverseWishartMatrixDistribution\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TI\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents an inverse Wishart matrix distribution with \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom and covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\)."
InverseZTransform::usage = "\!\(\*RowBox[{\"InverseZTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the inverse Z transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"InverseZTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multiple inverse Z transform of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
Invisible::usage = "\!\(\*RowBox[{\"Invisible\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as space that is the same size as the formatted version of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
IPAddress::usage = "\!\(\*RowBox[{\"IPAddress\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"address\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) is a symbolic representation of an IPv4 or IPv6 IP address."
IrreduciblePolynomialQ::usage = "\!\(\*RowBox[{\"IrreduciblePolynomialQ\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"poly\", \"TI\"]\) is an irreducible polynomial over the rationals.\n\!\(\*RowBox[{\"IrreduciblePolynomialQ\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"poly\", \"TI\"]\) is irreducible modulo a prime \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"IrreduciblePolynomialQ\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"Extension\", \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"poly\", \"TI\"]\) is irreducible over the field extension generated by the algebraic numbers \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"IrreduciblePolynomialQ\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"Extension\", \"\[Rule]\", \"All\"}]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"poly\", \"TI\"]\) is absolutely irreducible over the complex numbers."
IslandData::usage = "\!\(\*RowBox[{\"IslandData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the island \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"IslandData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified island entities.\n\!\(\*RowBox[{\"IslandData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
IsolatingInterval::usage = "\!\(\*RowBox[{\"IsolatingInterval\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives a rational isolating interval for the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\).\n\!\(\*RowBox[{\"IsolatingInterval\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"dx\", \"TI\"]}], \"]\"}]\) gives an isolating interval of width at most \!\(\*StyleBox[\"dx\", \"TI\"]\)."
IsomorphicGraphQ::usage = "\!\(\*RowBox[{\"IsomorphicGraphQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if the graphs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are isomorphic, and False otherwise."
IsotopeData::usage = "\!\(\*RowBox[{\"IsotopeData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"Z\", \"TI\"], \",\", StyleBox[\"A\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the isotope with atomic number \!\(\*StyleBox[\"Z\", \"TI\"]\) and mass number \!\(\*StyleBox[\"A\", \"TI\"]\).\n\!\(\*RowBox[{\"IsotopeData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the property for the named isotope."
Italic::usage = "Italic represents an italic font slant."
ItemAspectRatio::usage = "ItemAspectRatio is an option for GraphicsGrid which specifies the ratio of height to width for the regions in which items are placed in the graphics grid."
ItemBoxOptions::usage = "\!\(\*RowBox[{ItemBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for ItemBox objects."
ItemSize::usage = "ItemSize is an option for Grid, Column, and related constructs that specifies the sizes to allow for items."
ItemStyle::usage = "ItemStyle is an option for Grid, Column, and related constructs that specifies styles to use for items."
Item::usage = "\!\(\*RowBox[{\"Item\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) represents an item within constructs such as Grid, Overlay, and Manipulate that displays with \!\(\*StyleBox[\"expr\", \"TI\"]\) as the content, and with the specified options applied to the region containing \!\(\*StyleBox[\"expr\", \"TI\"]\). "
ItoProcess::usage = "\!\(\*RowBox[{\"ItoProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents an Ito process \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\), where \!\(\*RowBox[{RowBox[{\"\[DifferentialD]\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \"\[LongEqual]\", RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}], RowBox[{\"\[DifferentialD]\", StyleBox[\"t\", \"TI\"]}]}], \"+\", RowBox[{RowBox[{StyleBox[\"b\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}], \".\", RowBox[{\"\[DifferentialD]\", RowBox[{StyleBox[\"w\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}]}]}]}]\).\n\!\(\*RowBox[{\"ItoProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents an Ito process \!\(\*RowBox[{RowBox[{StyleBox[\"y\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \"\[LongEqual]\", RowBox[{StyleBox[\"c\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}]}]\), where \!\(\*RowBox[{RowBox[{\"\[DifferentialD]\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \"\[LongEqual]\", RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}], RowBox[{\"\[DifferentialD]\", StyleBox[\"t\", \"TI\"]}]}], \"+\", RowBox[{RowBox[{StyleBox[\"b\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}], \".\", RowBox[{\"\[DifferentialD]\", RowBox[{StyleBox[\"w\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \" \"}]}]}]}]\).\n\!\(\*RowBox[{\"ItoProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) uses initial condition \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"(\", SubscriptBox[StyleBox[\"t\", \"TI\"], \"0\"], \")\"}], \"\[LongEqual]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"0\"]}]\).\n\!\(\*RowBox[{\"ItoProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) uses a Wiener process \!\(\*RowBox[{StyleBox[\"w\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\), with covariance \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"ItoProcess\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) converts \!\(\*StyleBox[\"proc\", \"TI\"]\) to a standard Ito process whenever possible. \n\!\(\*RowBox[{\"ItoProcess\", \"[\", RowBox[{StyleBox[\"sdeqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"w\", \"TI\"], \"\[Distributed]\", StyleBox[\"dproc\", \"TI\"]}]}], \"]\"}]\) represents an Ito process specified by a stochastic differential equation \!\(\*StyleBox[\"sdeqns\", \"TI\"]\), output expression \!\(\*StyleBox[\"expr\", \"TI\"]\), with state \!\(\*StyleBox[\"x\", \"TI\"]\) and time \!\(\*StyleBox[\"t\", \"TI\"]\), driven by \!\(\*StyleBox[\"w\", \"TI\"]\) following the process \!\(\*StyleBox[\"dproc\", \"TI\"]\). "
I::usage = "I represents the imaginary unit \!\(\*SqrtBox[RowBox[{\"-\", \"1\"}]]\). "
JaccardDissimilarity::usage = "\!\(\*RowBox[{\"JaccardDissimilarity\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Jaccard dissimilarity between Boolean vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
JacobiAmplitude::usage = "\!\(\*RowBox[{\"JacobiAmplitude\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the amplitude \!\(\*RowBox[{\"am\", \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]\) for Jacobi elliptic functions. "
Jacobian::usage = "Jacobian is an option for FindRoot. \!\(\*RowBox[{\"Jacobian\", \" \", \"->\", \" \", \"Automatic\"}]\) attempts symbolic computation of the Jacobian of the system of functions whose root is being sought. A typical setting is \!\(\*RowBox[{\"Jacobian\", \" \", \"->\", \" \", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"2\", \" \", StyleBox[\"x\", \"TI\"]}], \",\", \" \", RowBox[{\"Sign\", \"[\", StyleBox[\"y\", \"TI\"], \"]\"}]}], \"}\"}], \",\", \" \", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", \" \", StyleBox[\"x\", \"TI\"]}], \"}\"}]}], \"}\"}]}]\)."
JacobiCD::usage = "\!\(\*RowBox[{\"JacobiCD\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"cd\", \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \"|\", StyleBox[\"m\", \"TI\"]}], \")\"}]\)."
JacobiCN::usage = "\!\(\*RowBox[{\"JacobiCN\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"cn\", \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \"|\", StyleBox[\"m\", \"TI\"]}], \")\"}]\)."
JacobiCS::usage = "\!\(\*RowBox[{\"JacobiCS\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"cs\", \"(\", RowBox[{\"u\", \"|\", \"m\"}], \")\"}]\)."
JacobiDC::usage = "\!\(\*RowBox[{\"JacobiDC\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"dc\", \"(\", RowBox[{\"u\", \"|\", \"m\"}], \")\"}]\)."
JacobiDN::usage = "\!\(\*RowBox[{\"JacobiDN\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"dn\", \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \"|\", StyleBox[\"m\", \"TI\"]}], \")\"}]\)."
JacobiDS::usage = "\!\(\*RowBox[{\"JacobiDS\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"ds\", \"(\", RowBox[{\"u\", \"|\", \"m\"}], \")\"}]\)."
JacobiNC::usage = "\!\(\*RowBox[{\"JacobiNC\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"nc\", \"(\", RowBox[{\"u\", \"|\", \"m\"}], \")\"}]\)."
JacobiND::usage = "\!\(\*RowBox[{\"JacobiND\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"nd\", \"(\", RowBox[{\"u\", \"|\", \"m\"}], \")\"}]\)."
JacobiNS::usage = "\!\(\*RowBox[{\"JacobiNS\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"ns\", \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \"|\", StyleBox[\"m\", \"TI\"]}], \")\"}]\)."
JacobiP::usage = "\!\(\*RowBox[{\"JacobiP\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Jacobi polynomial \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"P\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \")\"}]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
JacobiSC::usage = "\!\(\*RowBox[{\"JacobiSC\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"sc\", \"(\", RowBox[{\"u\", \"|\", \"m\"}], \")\"}]\)."
JacobiSD::usage = "\!\(\*RowBox[{\"JacobiSD\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"sd\", \"(\", RowBox[{\"u\", \"|\", \"m\"}], \")\"}]\)."
JacobiSN::usage = "\!\(\*RowBox[{\"JacobiSN\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi elliptic function \!\(\*RowBox[{\"sn\", \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \"|\", StyleBox[\"m\", \"TI\"]}], \")\"}]\)."
JacobiSymbol::usage = "\!\(\*RowBox[{\"JacobiSymbol\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi symbol \!\(\*RowBox[{\"(\", FractionBox[StyleBox[\"n\", \"TI\"], StyleBox[\"m\", \"TI\"]], \")\"}]\). "
JacobiZeta::usage = "\!\(\*RowBox[{\"JacobiZeta\", \"[\", RowBox[{StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Jacobi zeta function \!\(\*RowBox[{StyleBox[\"Z\", \"TI\"], \"(\", RowBox[{\"\[Phi]\", \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]\). "
JankoGroupJ1::usage = "\!\(\*RowBox[{\"JankoGroupJ1\", \"[\", \"]\"}]\) represents the sporadic simple Janko group \!\(\*SubscriptBox[StyleBox[\"J\", \"TI\"], \"1\"]\)."
JankoGroupJ2::usage = "\!\(\*RowBox[{\"JankoGroupJ2\", \"[\", \"]\"}]\) represents the sporadic simple Janko group \!\(\*SubscriptBox[StyleBox[\"J\", \"TI\"], \"2\"]\)."
JankoGroupJ3::usage = "\!\(\*RowBox[{\"JankoGroupJ3\", \"[\", \"]\"}]\) represents the sporadic simple Janko group \!\(\*SubscriptBox[StyleBox[\"J\", \"TI\"], \"3\"]\)."
JankoGroupJ4::usage = "\!\(\*RowBox[{\"JankoGroupJ4\", \"[\", \"]\"}]\) represents the sporadic simple Janko group \!\(\*SubscriptBox[StyleBox[\"J\", \"TI\"], \"4\"]\)."
JarqueBeraALMTest::usage = "\!\(\*RowBox[{\"JarqueBeraALMTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed using the Jarque\[Dash]Bera ALM test.\n\!\(\*RowBox[{\"JarqueBeraALMTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
JohnsonDistribution::usage = "\!\(\*RowBox[{\"JohnsonDistribution\", \"[\", RowBox[{StyleBox[\"\\\"SB\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a bounded Johnson distribution with shape parameters \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\), \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\), location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"JohnsonDistribution\", \"[\", RowBox[{StyleBox[\"\\\"SL\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a semi-bounded Johnson distribution.\n\!\(\*RowBox[{\"JohnsonDistribution\", \"[\", RowBox[{StyleBox[\"\\\"SU\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents an unbounded Johnson distribution.\n\!\(\*RowBox[{\"JohnsonDistribution\", \"[\", RowBox[{StyleBox[\"\\\"SN\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a normal Johnson distribution."
JoinAcross::usage = "\!\(\*RowBox[{\"JoinAcross\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"key\", \"TI\"]}], \"]\"}]\) gives a list of associations obtained by joining those pairs of associations \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) in which the values associated with \!\(\*StyleBox[\"key\", \"TI\"]\) are the same. \n\!\(\*RowBox[{\"JoinAcross\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) joins pairs of associations only when the values associated with all keys \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are the same.\n\!\(\*RowBox[{\"JoinAcross\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"a\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"b\", \"TI\"]]}]}], \"]\"}]\) joins pairs of associations \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) in which the values associated with \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"a\", \"TI\"]]\) in the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are the same as those associated with \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"b\", \"TI\"]]\) in the \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"j\", \"TI\"]]\).\n\!\(\*RowBox[{\"JoinAcross\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[StyleBox[RowBox[{\"a\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[StyleBox[RowBox[{\"b\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) joins pairs of associations in which pairs of corresponding values agree.\n\!\(\*RowBox[{\"JoinAcross\", \"[\", RowBox[{StyleBox[\"alist\", \"TI\"], \",\", StyleBox[\"blist\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"jspec\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses \!\(\*StyleBox[\"jspec\", \"TI\"]\) to determine when to allow associations that contain missing elements to be generated."
JoinedCurveBoxOptions::usage = "\!\(\*RowBox[{JoinedCurveBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for JoinedCurveBox objects."
JoinedCurve::usage = "\!\(\*RowBox[{\"JoinedCurve\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"segment\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"segment\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a curve consisting of \!\(\*SubscriptBox[StyleBox[\"segment\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) followed by \!\(\*SubscriptBox[StyleBox[\"segment\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) etc. \n\!\(\*RowBox[{\"JoinedCurve\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a list of separate component curves \!\(\*SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc. "
Joined::usage = "Joined is an option for ListPlot and related functions that specifies whether points in each dataset should be joined into a line, or should be plotted as separate points. "
JoinForm::usage = "\!\(\*RowBox[{\"JoinForm\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) is a graphics directive that specifies what type of joins should be used to connect segments of lines, tubes, edges, and related primitives."
Join::usage = "\!\(\*RowBox[{\"Join\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) concatenates lists or other expressions that share the same head.\n\!\(\*RowBox[{\"Join\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) joins the objects at level \!\(\*StyleBox[\"n\", \"TI\"]\) in each of the \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
JordanDecomposition::usage = "\!\(\*RowBox[{\"JordanDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) yields the Jordan decomposition of a square matrix \!\(\*StyleBox[\"m\", \"TI\"]\). The result is a list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"}\"}]\) where \!\(\*StyleBox[\"s\", \"TI\"]\) is a similarity matrix and \!\(\*StyleBox[\"j\", \"TI\"]\) is the Jordan canonical form of \!\(\*StyleBox[\"m\", \"TI\"]\)."
JordanModelDecomposition::usage = "\!\(\*RowBox[{\"JordanModelDecomposition\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) yields the Jordan decomposition of the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\). "
JulianDate::usage = "\!\(\*RowBox[{\"JulianDate\", \"[\", \"]\"}]\) gives the current number of days since noon on November 24, 4714 BCE in the GMT time zone. \n\!\(\*RowBox[{\"JulianDate\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) gives the number of days for the specified date.\n\!\(\*RowBox[{\"JulianDate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the Julian date variant of the specified type.\n\!\(\*RowBox[{\"JulianDate\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"date\", \"TI\"]}], \"]\"}]\) gives the variant for the specified date."
JuliaSetBoettcher::usage = "\!\(\*RowBox[{\"JuliaSetBoettcher\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives an approximation of the B\[ODoubleDot]ttcher function of \!\(\*StyleBox[\"z\", \"TI\"]\), which maps the complement of the Julia set conformally to the complement of the closed unit disk."
JuliaSetIterationCount::usage = "\!\(\*RowBox[{\"JuliaSetIterationCount\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) returns the number of iterations, beginning with the complex number \!\(\*RowBox[{StyleBox[\"z\", \"TI\"], \"\[LongEqual]\", StyleBox[\"p\", \"TI\"]}]\), of the function \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\) needed to determine whether \!\(\*StyleBox[\"p\", \"TI\"]\) is in the Julia set of \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"JuliaSetIterationCount\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) returns the number of iterations, beginning with the complex number \!\(\*RowBox[{StyleBox[\"z\", \"TI\"], \"\[LongEqual]\", StyleBox[\"p\", \"TI\"]}]\), of the function \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}], \"\[LongEqual]\", RowBox[{SuperscriptBox[StyleBox[\"z\", \"TI\"], \"2\"], \"+\", StyleBox[\"c\", \"TI\"]}]}]\) needed to determine whether \!\(\*StyleBox[\"p\", \"TI\"]\) is in the Julia set of \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}], \"\[LongEqual]\", RowBox[{SuperscriptBox[StyleBox[\"z\", \"TI\"], \"2\"], \"+\", StyleBox[\"c\", \"TI\"]}]}]\).\n\!\(\*RowBox[{\"JuliaSetIterationCount\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns a list of the number of iterations required to determine whether each member of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) is in the Julia set of \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"JuliaSetIterationCount\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns a list of the number of iterations required to determine whether each member of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) is in the Julia set of \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}], \"\[LongEqual]\", RowBox[{SuperscriptBox[StyleBox[\"z\", \"TI\"], \"2\"], \"+\", StyleBox[\"c\", \"TI\"]}]}]\)."
JuliaSetPlot::usage = "\!\(\*RowBox[{\"JuliaSetPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) plots the Julia set of the rational function \!\(\*StyleBox[\"f\", \"TI\"]\) of the variable \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"JuliaSetPlot\", \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) plots the Julia set of the function \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}], \"\[LongEqual]\", RowBox[{SuperscriptBox[StyleBox[\"z\", \"TI\"], \"2\"], \"+\", StyleBox[\"c\", \"TI\"]}]}]\). "
JuliaSetPoints::usage = "\!\(\*RowBox[{\"JuliaSetPoints\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) returns a list of coordinates approximating the real and imaginary parts of the complex numbers in the Julia set of the rational function \!\(\*StyleBox[\"f\", \"TI\"]\) of the variable \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"JuliaSetPoints\", \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) returns a list of coordinates of points approximating the Julia set of the function \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}], \"\[LongEqual]\", RowBox[{SuperscriptBox[StyleBox[\"z\", \"TI\"], \"2\"], \"+\", StyleBox[\"c\", \"TI\"]}]}]\)."
KagiChart::usage = "\!\(\*RowBox[{\"KagiChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a Kagi chart with prices \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at date \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"KagiChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"daterange\", \"TI\"]}], \"}\"}], \"]\"}]\) makes a Kagi chart of closing prices for the financial entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" over the date range \!\(\*StyleBox[\"daterange\", \"TI\"]\).\n\!\(\*RowBox[{\"KagiChart\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", StyleBox[\"rt\", \"TI\"]}], \"]\"}]\) makes a Kagi chart with reversal threshold \!\(\*StyleBox[\"rt\", \"TI\"]\)."
KaiserBesselWindow::usage = "\!\(\*RowBox[{\"KaiserBesselWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Kaiser\[Dash]Bessel window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
KaiserWindow::usage = "\!\(\*RowBox[{\"KaiserWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Kaiser window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"KaiserWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
KalmanEstimator::usage = "\!\(\*RowBox[{\"KalmanEstimator\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) constructs the Kalman estimator for the StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\) with process and measurement noise covariance matrices \!\(\*StyleBox[\"w\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\). \n\!\(\*RowBox[{\"KalmanEstimator\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]}], \"]\"}]\) includes the cross-covariance matrix \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"KalmanEstimator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"sensors\", \"TI\"]\) as the noisy measurements of \!\(\*StyleBox[\"ssm\", \"TI\"]\).\n\!\(\*RowBox[{\"KalmanEstimator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"dinputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"dinputs\", \"TI\"]\) as the deterministic inputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
KalmanFilter::usage = "\!\(\*RowBox[{\"KalmanFilter\", \"[\", RowBox[{StyleBox[\"tproc\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"data\", \"TI\"]\) using the time series model given by \!\(\*StyleBox[\"tproc\", \"TI\"]\)."
KarhunenLoeveDecomposition::usage = "\!\(\*RowBox[{\"KarhunenLoeveDecomposition\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the Karhunen\[Dash]Loeve transform \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"]}], \"}\"}]\) of the numerical arrays \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), where \!\(\*RowBox[{RowBox[{StyleBox[\"m\", \"TI\"], \".\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"\[Equal]\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"KarhunenLoeveDecomposition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) uses the inverse of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\) for transforming \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
KaryTree::usage = "\!\(\*RowBox[{\"KaryTree\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a binary tree with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices.\n\!\(\*RowBox[{\"KaryTree\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a \!\(\*StyleBox[\"k\", \"TI\"]\)-ary tree with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices."
KatzCentrality::usage = "\!\(\*RowBox[{\"KatzCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) gives a list of Katz centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) and weight \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\).\n\!\(\*RowBox[{\"KatzCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) gives a list of Katz centralities using weight \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and initial centralities \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"KatzCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
KCoreComponents::usage = "\!\(\*RowBox[{\"KCoreComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-core components of the underlying simple graph of \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"KCoreComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\\\"In\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-core components with vertex in-degrees at least \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"KCoreComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\\\"Out\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-core components with vertex out-degrees at least \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"KCoreComponents\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
KDistribution::usage = "\!\(\*RowBox[{\"KDistribution\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) represents a K distribution with shape parameters \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) and \!\(\*StyleBox[\"w\", \"TI\"]\)."
KEdgeConnectedComponents::usage = "\!\(\*RowBox[{\"KEdgeConnectedComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-edge-connected components of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"KEdgeConnectedComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-edge-connected components that include at least one of the vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"KEdgeConnectedComponents\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
KEdgeConnectedGraphQ::usage = "\!\(\*RowBox[{\"KEdgeConnectedGraphQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is \!\(\*StyleBox[\"k\", \"TI\"]\)-edge-connected and False otherwise."
KelvinBei::usage = "\!\(\*RowBox[{\"KelvinBei\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Kelvin function \!\(\*RowBox[{\"bei\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"KelvinBei\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Kelvin function \!\(\*RowBox[{SubscriptBox[\"bei\", StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
KelvinBer::usage = "\!\(\*RowBox[{\"KelvinBer\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Kelvin function \!\(\*RowBox[{\"ber\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"KelvinBer\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Kelvin function \!\(\*RowBox[{SubscriptBox[\"ber\", StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
KelvinKei::usage = "\!\(\*RowBox[{\"KelvinKei\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Kelvin function \!\(\*RowBox[{\"kei\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"KelvinKei\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Kelvin function \!\(\*RowBox[{SubscriptBox[\"kei\", StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
KelvinKer::usage = "\!\(\*RowBox[{\"KelvinKer\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Kelvin function \!\(\*RowBox[{\"ker\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"KelvinKer\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Kelvin function \!\(\*RowBox[{SubscriptBox[\"ker\", StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
KendallTauTest::usage = "\!\(\*RowBox[{\"KendallTauTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"KendallTauTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"KendallTauTest\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], StyleBox[\",\", \"MR\"], StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
KendallTau::usage = "\!\(\*RowBox[{\"KendallTau\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Kendall's rank correlation coefficient \[Tau] for the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"KendallTau\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives Kendall's rank correlation coefficients \[Tau] for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"KendallTau\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Kendall's rank correlation coefficients \[Tau] for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"KendallTau\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives Kendall's rank correlation matrix for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"KendallTau\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) Kendall rank correlation for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
KernelMixtureDistribution::usage = "\!\(\*RowBox[{\"KernelMixtureDistribution\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a kernel mixture distribution based on the data values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"KernelMixtureDistribution\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a multivariate kernel mixture distribution based on data values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"KernelMixtureDistribution\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"bw\", \"TI\"]}], \"]\"}]\) represents a kernel mixture distribution with bandwidth \!\(\*StyleBox[\"bw\", \"TI\"]\).\n\!\(\*RowBox[{\"KernelMixtureDistribution\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"bw\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) represents a kernel mixture distribution with bandwidth \!\(\*StyleBox[\"bw\", \"TI\"]\) and smoothing kernel \!\(\*StyleBox[\"ker\", \"TI\"]\)."
KernelObject::usage = "\!\(\*RowBox[{\"KernelObject\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a kernel available for parallel computing."
Kernels::usage = "\!\(\*RowBox[{\"Kernels\", \"[\", \"]\"}]\) gives the list of running kernels available for parallel computing."
KeyCollisionFunction::usage = "KeyCollisionFunction is an option for JoinAcross that specifies how to handle pairs of elements that are not being joined but nevertheless have the same key."
KeyComplement::usage = "\!\(\*RowBox[{\"KeyComplement\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"all\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates an association in which only elements whose keys appear in \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"all\", \"TI\"]]\) but not in any of the \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are retained."
KeyDropFrom::usage = "\!\(\*RowBox[{\"KeyDropFrom\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"key\", \"TI\"]}], \"]\"}]\) changes the association \!\(\*StyleBox[\"a\", \"TI\"]\) by dropping the element with the specified key.\n\!\(\*RowBox[{\"KeyDropFrom\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) drops the elements with keys \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
KeyDrop::usage = "\!\(\*RowBox[{\"KeyDrop\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields an association from which elements with keys \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) have been dropped. \n\!\(\*RowBox[{\"KeyDrop\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"keys\", \"TI\"]}], \"]\"}]\) gives a list of associations.\n\!\(\*RowBox[{\"KeyDrop\", \"[\", StyleBox[\"keys\", \"TI\"], \"]\"}]\) represents an operator form of KeyDrop that can be applied to an expression."
KeyExistsQ::usage = "\!\(\*RowBox[{\"KeyExistsQ\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", StyleBox[\"key\", \"TI\"]}], \"]\"}]\) returns True if the specified \!\(\*StyleBox[\"key\", \"TI\"]\) exists in the association \!\(\*StyleBox[\"assoc\", \"TI\"]\), and False otherwise.\n\!\(\*RowBox[{\"KeyExistsQ\", \"[\", StyleBox[\"key\", \"TI\"], \"]\"}]\) represents an operator form of KeyExistsQ that can be applied to an expression."
KeyFreeQ::usage = "\!\(\*RowBox[{\"KeyFreeQ\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) yields True if no key in the association \!\(\*StyleBox[\"assoc\", \"TI\"]\) matches form, and yields False otherwise.\n\!\(\*RowBox[{\"KeyFreeQ\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) represents an operator form of KeyFreeQ that can be applied to an expression."
KeyIntersection::usage = "\!\(\*RowBox[{\"KeyIntersection\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a list of associations in which only elements whose keys appear in all the \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are retained."
KeyMap::usage = "\!\(\*RowBox[{\"KeyMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]}], \"]\"}]\) maps \!\(\*StyleBox[\"f\", \"TI\"]\) over the keys in an association, giving \!\(\*RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"]\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"]\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]\).\n\!\(\*RowBox[{\"KeyMap\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of KeyMap that can be applied to an expression."
KeyMemberQ::usage = "\!\(\*RowBox[{\"KeyMemberQ\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) yields True if a key in the association \!\(\*StyleBox[\"assoc\", \"TI\"]\) matches \!\(\*StyleBox[\"form\", \"TI\"]\), and False otherwise.\n\!\(\*RowBox[{\"KeyMemberQ\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) represents an operator form of KeyMemberQ that can be applied to an expression."
KeypointStrength::usage = "KeypointStrength is an option for ImageKeypoints and related functions to specify a minimum strength of detected keypoints."
KeySelect::usage = "\!\(\*RowBox[{\"KeySelect\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) selects elements in the association \!\(\*StyleBox[\"assoc\", \"TI\"]\) for which \!\(\*StyleBox[\"crit\", \"TI\"]\) applied to their keys is True.\n\!\(\*RowBox[{\"KeySelect\", \"[\", StyleBox[\"crit\", \"TI\"], \"]\"}]\) represents an operator form of KeySelect that can be applied to an expression."
KeySortBy::usage = "\!\(\*RowBox[{\"KeySortBy\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) sorts the elements of an association in the order defined by applying \!\(\*StyleBox[\"f\", \"TI\"]\) to each of their keys.\n\!\(\*RowBox[{\"KeySortBy\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of KeySortBy that can be applied to an expression."
KeySort::usage = "\!\(\*RowBox[{\"KeySort\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) orders the elements of an association by sorting its keys."
Keys::usage = "\!\(\*RowBox[{\"Keys\", \"[\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}], \"]\"}]\) gives a list of the keys \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in an association.\n\!\(\*RowBox[{\"Keys\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of the \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in a list of rules."
KeyTake::usage = "\!\(\*RowBox[{\"KeyTake\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields an association containing only the elements with keys \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"KeyTake\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"keys\", \"TI\"]}], \"]\"}]\) gives a list of associations.\n\!\(\*RowBox[{\"KeyTake\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an operator form of KeyTake that can be applied to an expression."
KeyUnion::usage = "\!\(\*RowBox[{\"KeyUnion\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a list of associations in which each association has the union of the keys of the \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), padding by inserting values of \!\(\*RowBox[{\"Missing\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) if necessary.\n\!\(\*RowBox[{\"KeyUnion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) uses \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"key\", \"TI\"], \"]\"}]\) as the value associated with a missing key. "
Key::usage = "\!\(\*RowBox[{\"Key\", \"[\", StyleBox[\"key\", \"TI\"], \"]\"}]\) represents a key used to access a value in an association.\n\!\(\*RowBox[{RowBox[{\"Key\", \"[\", StyleBox[\"key\", \"TI\"], \"]\"}], \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) extracts the value corresponding to \!\(\*StyleBox[\"key\", \"TI\"]\) in the association \!\(\*StyleBox[\"assoc\", \"TI\"]\)."
KeyValueMap::usage = "\!\(\*RowBox[{\"KeyValueMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"<|\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"|>\"}]}], \"]\"}]\) gives the list \!\(\*RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"KeyValueMap\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of KeyValueMap that can be applied to an expression."
Khinchin::usage = "Khinchin is Khinchin's constant, with numerical value \!\(\*RowBox[{\"\[TildeEqual]\", \"2.68545\"}]\). "
KillProcess::usage = "\!\(\*RowBox[{\"KillProcess\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) kills the external process represented by the ProcessObject \!\(\*StyleBox[\"proc\", \"TI\"]\)."
KirchhoffGraph::usage = "\!\(\*RowBox[{\"KirchhoffGraph\", \"[\", StyleBox[\"kmat\", \"TI\"], \"]\"}]\) gives the graph with Kirchhoff matrix \!\(\*StyleBox[\"kmat\", \"TI\"]\).\n\!\(\*RowBox[{\"KirchhoffGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"kmat\", \"TI\"]}], \"]\"}]\) gives the graph with vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and Kirchhoff matrix \!\(\*StyleBox[\"kmat\", \"TI\"]\)."
KirchhoffMatrix::usage = "\!\(\*RowBox[{\"KirchhoffMatrix\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the Kirchhoff matrix of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"KirchhoffMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
KleinInvariantJ::usage = "\!\(\*RowBox[{\"KleinInvariantJ\", \"[\", StyleBox[\"\[Tau]\", \"TR\"], \"]\"}]\) gives the Klein invariant modular elliptic function \!\(\*RowBox[{StyleBox[\"J\", \"TI\"], \"(\", \"\[Tau]\", \")\"}]\). "
KnightTourGraph::usage = "\!\(\*RowBox[{\"KnightTourGraph\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a Knight's tour graph on an \!\(\*StyleBox[\"m\", \"TI\"]\)\[Cross]\!\(\*StyleBox[\"n\", \"TI\"]\) chessboard."
KnotData::usage = "\!\(\*RowBox[{\"KnotData\", \"[\", RowBox[{StyleBox[\"knot\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property for a knot.\n\!\(\*RowBox[{\"KnotData\", \"[\", StyleBox[\"knot\", \"TI\"], \"]\"}]\) gives an image of the knot.\n\!\(\*RowBox[{\"KnotData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"class\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of knots in the specified class."
KnownUnitQ::usage = "\!\(\*RowBox[{\"KnownUnitQ\", \"[\", StyleBox[\"exp\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"exp\", \"TI\"]\) is a canonical unit."
KolmogorovSmirnovTest::usage = "\!\(\*RowBox[{\"KolmogorovSmirnovTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed using the Kolmogorov\[Dash]Smirnov test.\n\!\(\*RowBox[{\"KolmogorovSmirnovTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is distributed according to \!\(\*StyleBox[\"dist\", \"TI\"]\) using the Kolmogorov\[Dash]Smirnov test.\n\!\(\*RowBox[{\"KolmogorovSmirnovTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
KroneckerDelta::usage = "\!\(\*RowBox[{\"KroneckerDelta\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the Kronecker delta \!\(\*SubscriptBox[\"\[Delta]\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], \"1\"], \" \", SubscriptBox[StyleBox[\"n\", \"TI\"], \"2\"], \" \", \"\[Ellipsis]\"}]]\), equal to 1 if all the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are equal, and 0 otherwise. "
KroneckerModelDecomposition::usage = "\!\(\*RowBox[{\"KroneckerModelDecomposition\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) yields the Kronecker decomposition of a descriptor state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\). "
KroneckerProduct::usage = "\!\(\*RowBox[{\"KroneckerProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) constructs the Kronecker product of the arrays \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
KroneckerSymbol::usage = "\!\(\*RowBox[{\"KroneckerSymbol\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Kronecker symbol \!\(\*RowBox[{\"(\", FractionBox[StyleBox[\"n\", \"TI\"], StyleBox[\"m\", \"TI\"]], \")\"}]\). "
KuiperTest::usage = "\!\(\*RowBox[{\"KuiperTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed using the Kuiper test.\n\!\(\*RowBox[{\"KuiperTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is distributed according to \!\(\*StyleBox[\"dist\", \"TI\"]\) using the Kuiper test.\n\!\(\*RowBox[{\"KuiperTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
KumaraswamyDistribution::usage = "\!\(\*RowBox[{\"KumaraswamyDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a Kumaraswamy distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\)."
Kurtosis::usage = "\!\(\*RowBox[{\"Kurtosis\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the coefficient of kurtosis for the elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Kurtosis\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the coefficient of kurtosis for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
K::usage = "K is a default generic name for a summation index in a symbolic sum."
KuwaharaFilter::usage = "\!\(\*RowBox[{\"KuwaharaFilter\", \"[\", StyleBox[RowBox[{\"image\", \",\", \"r\"}], \"TI\"], StyleBox[\"]\", \"TI\"]}]\) computes for each pixel \!\(\*StyleBox[\"p\", \"TI\"]\) in \!\(\*StyleBox[\"image\", \"TI\"]\) the variance of the values in the four \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"r\", \"TI\"], \"+\", \"1\"}], \")\"}]\)\[Times]\!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"r\", \"TI\"], \"+\", \"1\"}], \")\"}]\) squares that have \!\(\*StyleBox[\"p\", \"TI\"]\) as a corner, and replaces \!\(\*StyleBox[\"p\", \"TI\"]\) with the mean of the values of the square with least variance."
KVertexConnectedComponents::usage = "\!\(\*RowBox[{\"KVertexConnectedComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-vertex-connected components of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"KVertexConnectedComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-vertex-connected components that include at least one of the vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] ."
KVertexConnectedGraphQ::usage = "\!\(\*RowBox[{\"KVertexConnectedGraphQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is \!\(\*StyleBox[\"k\", \"TI\"]\)-vertex-connected and False otherwise."
LABColor::usage = "\!\(\*RowBox[{\"LABColor\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) is a color directive with lightness \!\(\*StyleBox[\"l\", \"TI\"]\) and color components \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\). \n\!\(\*RowBox[{\"LABColor\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) specifies opacity \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\). "
Labeled::usage = "\!\(\*RowBox[{\"Labeled\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"lbl\", \"TI\"]}], \"]\"}]\) displays \!\(\*StyleBox[\"expr\", \"TI\"]\) labeled with \!\(\*StyleBox[\"lbl\", \"TI\"]\). \n\!\(\*RowBox[{\"Labeled\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"lbl\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) places \!\(\*StyleBox[\"lbl\", \"TI\"]\) at a position specified by \!\(\*StyleBox[\"pos\", \"TI\"]\). \n\!\(\*RowBox[{\"Labeled\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) places the \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at positions \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Labeled\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"4\", \"TR\"]]}], \"}\"}], \",\", \"All\"}], \"]\"}]\) places the \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at the bottom, left, top, and right, respectively. "
LabelingFunction::usage = "LabelingFunction is an option for charting functions that specifies a function to apply to determine labeling of chart elements."
LabelStyle::usage = "LabelStyle is an option for formatting and related constructs that specifies the style to use in displaying their label-like elements. "
Label::usage = "\!\(\*RowBox[{\"Label\", \"[\", StyleBox[\"tag\", \"TI\"], \"]\"}]\) represents a point in a compound expression to which control can be transferred using Goto. "
LaguerreL::usage = "\!\(\*RowBox[{\"LaguerreL\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Laguerre polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"L\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"LaguerreL\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the generalized Laguerre polynomial \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"L\", \"TI\"], StyleBox[\"n\", \"TI\"], StyleBox[\"a\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
LakeData::usage = "\!\(\*RowBox[{\"LakeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the lake \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"LakeData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified lake entities.\n\!\(\*RowBox[{\"LakeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
LambdaComponents::usage = "\!\(\*RowBox[{\"LambdaComponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the lambda components of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"LambdaComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the lambda components that include at least one of the vertices \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"LambdaComponents\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
LaminaData::usage = "\!\(\*RowBox[{\"LaminaData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the lamina \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"LaminaData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified lamina entities.\n\!\(\*RowBox[{\"LaminaData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
LanczosWindow::usage = "\!\(\*RowBox[{\"LanczosWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Lanczos window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
LandauDistribution::usage = "\!\(\*RowBox[{\"LandauDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a Landau distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"LandauDistribution\", \"[\", \"]\"}]\) represents a Landau distribution with location parameter 0 and scale parameter 1."
LanguageCategory::usage = "LanguageCategory is an option for Cell that determines in what category of language the contents of the cell should be assumed to be for purposes of spell checking and hyphenation. "
LanguageData::usage = "\!\(\*RowBox[{\"LanguageData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the language \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"LanguageData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified language entities.\n\!\(\*RowBox[{\"LanguageData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
LanguageIdentify::usage = "\!\(\*RowBox[{\"LanguageIdentify\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) attempts to determine what human language text in \!\(\*StyleBox[\"string\", \"TI\"]\) is in, predominantly."
Language::usage = "Language is a global option that specifies the language in which menus, dialog boxes, error messages, and help files are displayed."
LaplaceDistribution::usage = "\!\(\*RowBox[{\"LaplaceDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a Laplace double-exponential distribution with mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"LaplaceDistribution\", \"[\", \"]\"}]\) represents a Laplace double-exponential distribution with mean 0 and scale parameter 1."
LaplaceTransform::usage = "\!\(\*RowBox[{\"LaplaceTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the Laplace transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"LaplaceTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Laplace transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
LaplacianFilter::usage = "\!\(\*RowBox[{\"LaplacianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) convolves \!\(\*StyleBox[\"image\", \"TI\"]\) with a range-\!\(\*StyleBox[\"r\", \"TI\"]\) Laplacian kernel.\n\!\(\*RowBox[{\"LaplacianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) uses ranges \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the vertical and horizontal directions.\n\!\(\*RowBox[{\"LaplacianFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies Laplacian filtering to an array of data."
LaplacianGaussianFilter::usage = "\!\(\*RowBox[{\"LaplacianGaussianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) convolves \!\(\*StyleBox[\"image\", \"TI\"]\) with a Laplacian of Gaussian kernel of pixel radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{RowBox[{\"LaplacianGaussianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}]}], \"]\"}], \" \"}]\) convolves \!\(\*StyleBox[\"image\", \"TI\"]\) with a Laplacian of Gaussian kernel of radius \!\(\*StyleBox[\"r\", \"TI\"]\) and standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"LaplacianGaussianFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies Laplacian of Gaussian filtering to an array of data."
Laplacian::usage = "\!\(\*RowBox[{\"Laplacian\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the Laplacian \!\(\*RowBox[{RowBox[{RowBox[{SuperscriptBox[\"\[PartialD]\", \"2\"], StyleBox[\"f\", \"TI\"]}], \"/\", RowBox[{\"\[PartialD]\", SuperscriptBox[SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \"2\"]}]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"+\", RowBox[{RowBox[{SuperscriptBox[\"\[PartialD]\", \"2\"], StyleBox[\"f\", \"TI\"]}], \"/\", RowBox[{\"\[PartialD]\", SuperscriptBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"2\"]}]}]}]\).\n\!\(\*RowBox[{\"Laplacian\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) gives the Laplacian in the given coordinates \!\(\*StyleBox[\"chart\", \"TI\"]\)."
Larger::usage = "Larger is a style or option setting that specifies that objects should be larger."
Large::usage = "Large is a style or option setting that specifies that objects should be large."
Last::usage = "\!\(\*RowBox[{\"Last\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the last element in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Last\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"def\", \"TI\"]}], \"]\"}]\) gives the last element if there are any elements, or \!\(\*StyleBox[\"def\", \"TI\"]\) otherwise."
LatitudeLongitude::usage = "\!\(\*RowBox[{\"LatitudeLongitude\", \"[\", StyleBox[\"pos\", \"TI\"], \"]\"}]\) gives a list of the latitude and longitude in degrees of a geographic position specified by \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"LatitudeLongitude\", \"[\", RowBox[{StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"datum\", \"TI\"]}], \"]\"}]\) gives the latitude and longitude referring to the specified geodetic datum."
Latitude::usage = "\!\(\*RowBox[{\"Latitude\", \"[\", StyleBox[\"pos\", \"TI\"], \"]\"}]\) gives the latitude in degrees of a geographic position specified by \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"Latitude\", \"[\", RowBox[{StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"datum\", \"TI\"]}], \"]\"}]\) gives the latitude referring to the specified geodetic datum."
LatticeData::usage = "\!\(\*RowBox[{\"LatticeData\", \"[\", RowBox[{StyleBox[\"lattice\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property for a lattice.\n\!\(\*RowBox[{\"LatticeData\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a list of named lattices of dimension \!\(\*StyleBox[\"n\", \"TI\"]\)."
LatticeReduce::usage = "\!\(\*RowBox[{\"LatticeReduce\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a reduced basis for the set of vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
LaunchKernels::usage = "\!\(\*RowBox[{\"LaunchKernels\", \"[\", \"]\"}]\) launches all currently configured parallel subkernels.\n\!\(\*RowBox[{\"LaunchKernels\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) launches \!\(\*StyleBox[\"n\", \"TI\"]\) local subkernels on the current computer.\n\!\(\*RowBox[{\"LaunchKernels\", \"[\", StyleBox[\"ker\", \"TI\"], \"]\"}]\) launches the kernel specified by \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"LaunchKernels\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) launches the kernels \!\(\*SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
LayeredGraphPlot::usage = "\!\(\*RowBox[{\"LayeredGraphPlot\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) generates a layered plot of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"LayeredGraphPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a layered plot of the graph in which vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"ik\", \"TI\"]]\) is connected to vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"jk\", \"TI\"]]\).\n\!\(\*RowBox[{\"LayeredGraphPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]]}], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) associates labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"k\", \"TI\"]]\) with edges in the graph.\n\!\(\*RowBox[{\"LayeredGraphPlot\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) places the dominant vertices in the plot at position \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"LayeredGraphPlot\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) generates a layered plot of the graph represented by the adjacency matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
LayerSizeFunction::usage = "LayerSizeFunction is an option for TreePlot that gives a function to specify the relative height to allow for each layer."
LCHColor::usage = "\!\(\*RowBox[{\"LCHColor\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) is a color directive with lightness \!\(\*StyleBox[\"l\", \"TI\"]\), chroma \!\(\*StyleBox[\"c\", \"TI\"]\), and hue \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"LCHColor\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) specifies opacity \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\). "
LCM::usage = "\!\(\*RowBox[{\"LCM\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the least common multiple of the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
LeafCount::usage = "\!\(\*RowBox[{\"LeafCount\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the total number of indivisible subexpressions in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
LeapYearQ::usage = "\!\(\*RowBox[{\"LeapYearQ\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) returns True if the year corresponding to \!\(\*StyleBox[\"date\", \"TI\"]\) is a leap year."
LeastSquaresFilterKernel::usage = "\!\(\*RowBox[{\"LeastSquaresFilterKernel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[RowBox[{\"k\", StyleBox[\"-\", FontSlant -> \"Plain\"], StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) creates a \!\(\*StyleBox[\"k\", \"TI\"]\)-band finite impulse response (FIR) filter kernel of length \!\(\*StyleBox[\"n\", \"TI\"]\) designed using a least squares method, given the specified frequencies \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\) and amplitudes \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"LeastSquaresFilterKernel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses the full filter specification \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"spec\", \"TI\"]}], \"}\"}]\)."
LeastSquares::usage = "\!\(\*RowBox[{\"LeastSquares\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) finds an \!\(\*StyleBox[\"x\", \"TI\"]\) that solves the linear least-squares problem for the matrix equation \!\(\*RowBox[{RowBox[{StyleBox[\"m\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}], \"==\", StyleBox[\"b\", \"TI\"]}]\)."
LeftArrowBar::usage = "\!\(\*RowBox[{\"LeftArrowBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftArrowBar]\", StyleBox[\"y\", \"TI\"], \"\[LeftArrowBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftArrowRightArrow::usage = "\!\(\*RowBox[{\"LeftArrowRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftArrowRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[LeftArrowRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftArrow::usage = "\!\(\*RowBox[{\"LeftArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftArrow]\", StyleBox[\"y\", \"TI\"], \"\[LeftArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftDownTeeVector::usage = "\!\(\*RowBox[{\"LeftDownTeeVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftDownTeeVector]\", StyleBox[\"y\", \"TI\"], \"\[LeftDownTeeVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftDownVectorBar::usage = "\!\(\*RowBox[{\"LeftDownVectorBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftDownVectorBar]\", StyleBox[\"y\", \"TI\"], \"\[LeftDownVectorBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftDownVector::usage = "\!\(\*RowBox[{\"LeftDownVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftDownVector]\", StyleBox[\"y\", \"TI\"], \"\[LeftDownVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftRightArrow::usage = "\!\(\*RowBox[{\"LeftRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[LeftRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftRightVector::usage = "\!\(\*RowBox[{\"LeftRightVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftRightVector]\", StyleBox[\"y\", \"TI\"], \"\[LeftRightVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftTeeArrow::usage = "\!\(\*RowBox[{\"LeftTeeArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftTeeArrow]\", StyleBox[\"y\", \"TI\"], \"\[LeftTeeArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftTee::usage = "\!\(\*RowBox[{\"LeftTee\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftTee]\", StyleBox[\"y\", \"TI\"]}]\)."
LeftTeeVector::usage = "\!\(\*RowBox[{\"LeftTeeVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftTeeVector]\", StyleBox[\"y\", \"TI\"], \"\[LeftTeeVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftTriangleBar::usage = "\!\(\*RowBox[{\"LeftTriangleBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftTriangleBar]\", StyleBox[\"y\", \"TI\"], \"\[LeftTriangleBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftTriangleEqual::usage = "\!\(\*RowBox[{\"LeftTriangleEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftTriangleEqual]\", StyleBox[\"y\", \"TI\"], \"\[LeftTriangleEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftTriangle::usage = "\!\(\*RowBox[{\"LeftTriangle\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftTriangle]\", StyleBox[\"y\", \"TI\"], \"\[LeftTriangle]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftUpDownVector::usage = "\!\(\*RowBox[{\"LeftUpDownVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftUpDownVector]\", StyleBox[\"y\", \"TI\"], \"\[LeftUpDownVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftUpTeeVector::usage = "\!\(\*RowBox[{\"LeftUpTeeVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftUpTeeVector]\", StyleBox[\"y\", \"TI\"], \"\[LeftUpTeeVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftUpVectorBar::usage = "\!\(\*RowBox[{\"LeftUpVectorBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftUpVectorBar]\", StyleBox[\"y\", \"TI\"], \"\[LeftUpVectorBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftUpVector::usage = "\!\(\*RowBox[{\"LeftUpVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftUpVector]\", StyleBox[\"y\", \"TI\"], \"\[LeftUpVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Left::usage = "Left is a symbol that represents the left-hand side for purposes of alignment and positioning. "
LeftVectorBar::usage = "\!\(\*RowBox[{\"LeftVectorBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftVectorBar]\", StyleBox[\"y\", \"TI\"], \"\[LeftVectorBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LeftVector::usage = "\!\(\*RowBox[{\"LeftVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LeftVector]\", StyleBox[\"y\", \"TI\"], \"\[LeftVector]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LegendAppearance::usage = "LegendAppearance is an option for charting functions that specifies the appearance of any legends that are generated."
Legended::usage = "\!\(\*RowBox[{\"Legended\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"leg\", \"TI\"]}], \"]\"}]\) displays \!\(\*StyleBox[\"expr\", \"TI\"]\) with legend \!\(\*StyleBox[\"leg\", \"TI\"]\). \n\!\(\*RowBox[{\"Legended\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"lbl\", \"TI\"]}], \"]\"}]\) indicates in plotting and charting functions that a legend entry for \!\(\*StyleBox[\"expr\", \"TI\"]\) should be created, with label \!\(\*StyleBox[\"lbl\", \"TI\"]\)."
LegendFunction::usage = "LegendFunction is an option for legends that specifies an overall function to apply to the generated legend."
LegendLabel::usage = "LegendLabel is an option for legends that specifies an overall label for a legend."
LegendLayout::usage = "LegendLayout is an option for legends that specifies how to format the legend content."
LegendMargins::usage = "LegendMargins is an option for legends that specifies the margins to leave around the legend."
LegendMarkerSize::usage = "LegendMarkerSize is an option for legends such as PointLegend that specifies the size of marker regions for each element."
LegendMarkers::usage = "LegendMarkers is an option for legends such as PointLegend that specifies markers for each element."
LegendreP::usage = "\!\(\*RowBox[{\"LegendreP\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Legendre polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"P\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"LegendreP\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the associated Legendre polynomial \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"P\", \"TI\"], StyleBox[\"n\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\). "
LegendreQ::usage = "\!\(\*RowBox[{\"LegendreQ\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Legendre function of the second kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"Q\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"LegendreQ\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the associated Legendre function of the second kind \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"Q\", \"TI\"], StyleBox[\"n\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
Length::usage = "\!\(\*RowBox[{\"Length\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the number of elements in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
LengthWhile::usage = "\!\(\*RowBox[{\"LengthWhile\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) gives the number of continuous elements \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) starting at the beginning of \!\(\*StyleBox[\"list\", \"TI\"]\) for which \!\(\*RowBox[{StyleBox[\"crit\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True."
LerchPhi::usage = "\!\(\*RowBox[{\"LerchPhi\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives the Lerch transcendent \!\(\*RowBox[{StyleBox[\"\[CapitalPhi]\", \"TR\"], RowBox[{\"(\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \")\"}]}]\). "
LessEqualGreater::usage = "\!\(\*RowBox[{\"LessEqualGreater\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LessEqualGreater]\", StyleBox[\"y\", \"TI\"], \"\[LessEqualGreater]\", \"\[Ellipsis]\"}]\)."
LessEqualThan::usage = "\!\(\*RowBox[{\"LessEqualThan\", \"[\", StyleBox[\"y\", \"TI\"], \"]\"}]\) is an operator form that yields \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LessEqual]\", StyleBox[\"y\", \"TI\"]}]\) when applied to an expression \!\(\*StyleBox[\"x\", \"TI\"]\)."
LessEqual::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<=\", StyleBox[\"y\", \"TI\"]}]\) or \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LessEqual]\", StyleBox[\"y\", \"TI\"]}]\) yields True if \!\(\*StyleBox[\"x\", \"TI\"]\) is determined to be less than or equal to \!\(\*StyleBox[\"y\", \"TI\"]\).\n\!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[LessEqual]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[LessEqual]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"3\", \"TR\"]]}]\) yields True if the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TR\"]]\) form a nondecreasing sequence. "
LessFullEqual::usage = "\!\(\*RowBox[{\"LessFullEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LessFullEqual]\", StyleBox[\"y\", \"TI\"], \"\[LessFullEqual]\", \"\[Ellipsis]\"}]\)."
LessGreater::usage = "\!\(\*RowBox[{\"LessGreater\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LessGreater]\", StyleBox[\"y\", \"TI\"], \"\[LessGreater]\", \"\[Ellipsis]\"}]\)."
LessLess::usage = "\!\(\*RowBox[{\"LessLess\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LessLess]\", StyleBox[\"y\", \"TI\"], \"\[LessLess]\", \"\[Ellipsis]\"}]\)."
LessSlantEqual::usage = "\!\(\*RowBox[{\"LessSlantEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LessSlantEqual]\", StyleBox[\"y\", \"TI\"], \"\[LessSlantEqual]\", \"\[Ellipsis]\"}]\)."
LessThan::usage = "\!\(\*RowBox[{\"LessThan\", \"[\", StyleBox[\"y\", \"TI\"], \"]\"}]\) is an operator form that yields \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<\", StyleBox[\"y\", \"TI\"]}]\) when applied to an expression \!\(\*StyleBox[\"x\", \"TI\"]\)."
LessTilde::usage = "\!\(\*RowBox[{\"LessTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LessTilde]\", StyleBox[\"y\", \"TI\"], \"\[LessTilde]\", \"\[Ellipsis]\"}]\)."
Less::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<\", StyleBox[\"y\", \"TI\"]}]\) yields True if \!\(\*StyleBox[\"x\", \"TI\"]\) is determined to be less than \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"<\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"<\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"3\", \"TR\"]]}]\) yields True if the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) form a strictly increasing sequence. "
LetterCharacter::usage = "LetterCharacter represents a letter character in StringExpression."
LetterCounts::usage = "\!\(\*RowBox[{\"LetterCounts\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives an association whose keys are the distinct letters in \!\(\*StyleBox[\"string\", \"TI\"]\), and whose values give the number of times those letters appear in \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"LetterCounts\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives counts of the distinct \!\(\*StyleBox[\"n\", \"TI\"]\)-grams consisting of runs of \!\(\*StyleBox[\"n\", \"TI\"]\) letters in \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"LetterCounts\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) allows the characters \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to appear in \!\(\*StyleBox[\"n\", \"TI\"]\)-grams, in addition to ordinary letters."
LetterQ::usage = "\!\(\*RowBox[{\"LetterQ\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) yields True if all the characters in the string are letters, and yields False otherwise. "
Level::usage = "\!\(\*RowBox[{\"Level\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) gives a list of all subexpressions of \!\(\*StyleBox[\"expr\", \"TI\"]\) on levels specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"Level\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the sequence of subexpressions. "
LeveneTest::usage = "\!\(\*RowBox[{\"LeveneTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the variance of \!\(\*StyleBox[\"data\", \"TI\"]\) is 1. \n\!\(\*RowBox[{\"LeveneTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the variances of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"LeveneTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests a dispersion measure against \!\(\*SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"LeveneTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
LeviCivitaTensor::usage = "\!\(\*RowBox[{\"LeviCivitaTensor\", \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"d\", \"TI\"]\)-dimensional Levi-Civita totally antisymmetric tensor."
LevyDistribution::usage = "\!\(\*RowBox[{\"LevyDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a L\[EAcute]vy distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and dispersion parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
Lexicographic::usage = "Lexicographic represents the lexicographic ordering of monomials."
LibraryDataType::usage = "\!\(\*RowBox[{\"LibraryDataType\", \"[\", StyleBox[\"datatype\", \"TI\"], \"]\"}]\) specifies the data type for a LibraryFunction argument or result to be \!\(\*StyleBox[\"datatype\", \"TI\"]\).\n\!\(\*RowBox[{\"LibraryDataType\", \"[\", RowBox[{StyleBox[\"datatype\", \"TI\"], \",\", StyleBox[\"etype\", \"TI\"]}], \"]\"}]\) specifies an element type \!\(\*StyleBox[\"etype\", \"TI\"]\) for data structures.\n\!\(\*RowBox[{\"LibraryDataType\", \"[\", RowBox[{StyleBox[\"datatype\", \"TI\"], \",\", StyleBox[\"etype\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) specifies an array depth \!\(\*StyleBox[\"d\", \"TI\"]\) for array data types."
LibraryFunctionError::usage = "\!\(\*RowBox[{\"LibraryFunctionError\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"code\", \"TI\"]}], \"]\"}]\) represents an error returned from a LibraryFunction."
LibraryFunctionInformation::usage = "\!\(\*RowBox[{\"LibraryFunctionInformation\", \"[\", StyleBox[\"fun\", \"TI\"], \"]\"}]\) returns information about a LibraryFunction\!\(\*StyleBox[\".\", \"MR\"]\)"
LibraryFunctionLoad::usage = "\!\(\*RowBox[{\"LibraryFunctionLoad\", \"[\", RowBox[{StyleBox[\"lib\", \"TI\"], \",\", StyleBox[\"fun\", \"TI\"], \",\", StyleBox[\"argtype\", \"TI\"], \",\", StyleBox[\"rettype\", \"TI\"]}], \"]\"}]\) loads Wolfram Library \!\(\*StyleBox[\"lib\", \"TI\"]\) and makes the library function \!\(\*StyleBox[\"fun\", \"TI\"]\) available in \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\"]\)."
LibraryFunctionUnload::usage = "\!\(\*RowBox[{\"LibraryFunctionUnload\", \"[\", StyleBox[\"fun\", \"TI\"], \"]\"}]\) unloads a LibraryFunction so that it cannot be used."
LibraryFunction::usage = "\!\(\*RowBox[{\"LibraryFunction\", \"[\", \" \", StyleBox[\"args\", \"TI\"], \"]\"}]\) represents a function that has been loaded from a Wolfram Library."
LibraryLink`LibraryVersionInformation::usage = "\!\(\*RowBox[{\"LibraryVersionInformation\", \"[\", StyleBox[\"lib\", \"TI\"], \"]\"}]\) returns a list of rules of library version information."
LibraryLink`LibraryVersionString::usage = "\!\(\*RowBox[{\"LibraryVersionString\", \"[\", StyleBox[\"lib\", \"TI\"], \"]\"}]\) returns a string of library version information."
LibraryLink`$LibraryError::usage = "$LibraryError returns the system-dependent error message from loading a library, or None if there was no error."
LibraryLoad::usage = "\!\(\*RowBox[{\"LibraryLoad\", \"[\", StyleBox[\"lib\", \"TI\"], \"]\"}]\) loads the dynamic library \!\(\*StyleBox[\"lib\", \"TI\"]\) into the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) runtime."
LibraryUnload::usage = "\!\(\*RowBox[{\"LibraryUnload\", \"[\", StyleBox[\"lib\", \"TI\"], \"]\"}]\) unloads all functions that have been loaded from a Wolfram Library, then it unloads the library."
LicenseID::usage = "LicenseID is an option to Encode which specifies the required value of $LicenseID on the computer that reads the encoded file. If no value is specified, any value of $LicenseID is allowed on the file-reading computer. A setting for LicenseID must be a string."
LiftingFilterData::usage = "\!\(\*RowBox[{\"LiftingFilterData\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents lifting-filter data used to compute forward and inverse lifting wavelet transforms."
LiftingWaveletTransform::usage = "\!\(\*RowBox[{\"LiftingWaveletTransform\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) gives the lifting wavelet transform (LWT) of an array of \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"LiftingWaveletTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"]}], \"]\"}]\) gives the lifting wavelet transform using the wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\).\n\!\(\*RowBox[{\"LiftingWaveletTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the lifting wavelet transform using \!\(\*StyleBox[\"r\", \"TI\"]\) levels of refinement.\n\!\(\*RowBox[{\"LiftingWaveletTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the lifting wavelet transform of an image.\n\!\(\*RowBox[{\"LiftingWaveletTransform\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the lifting wavelet transform of sampled sound."
LightBlue::usage = "LightBlue represents a light blue color in graphics or style specifications."
LightBrown::usage = "LightBrown represents a light brown color in graphics or style specifications."
LightCyan::usage = "LightCyan represents a light cyan color in graphics or style specifications."
Lighter::usage = "\!\(\*RowBox[{\"Lighter\", \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) represents a lighter version of the specified color. \n\!\(\*RowBox[{\"Lighter\", \"[\", RowBox[{StyleBox[\"color\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) represents a version of the specified color lightened by a fraction \!\(\*StyleBox[\"f\", \"TI\"]\). \n\!\(\*RowBox[{\"Lighter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a lighter version of an image."
LightGray::usage = "LightGray represents a light gray color in graphics or style specifications."
LightGreen::usage = "LightGreen represents a light green color in graphics or style specifications."
LightingAngle::usage = "LightingAngle is an option for ReliefPlot and related functions that specifies the angle from which simulated illumination is taken to come."
Lighting::usage = "Lighting is an option for Graphics3D and related functions that specifies what simulated lighting to use in coloring 3D surfaces. "
LightMagenta::usage = "LightMagenta represents a light magenta color in graphics or style specifications."
LightOrange::usage = "LightOrange represents a light orange color in graphics or style specifications."
LightPink::usage = "LightPink represents a light pink color in graphics or style specifications."
LightPurple::usage = "LightPurple represents a light purple color in graphics or style specifications."
LightRed::usage = "LightRed represents a light red color in graphics or style specifications."
LightSources::usage = "LightSources is an option for Graphics3D and related functions that specifies the properties of point light sources for simulated illumination. "
LightYellow::usage = "LightYellow represents a light yellow color in graphics or style specifications."
Likelihood::usage = "\!\(\*RowBox[{\"Likelihood\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the likelihood function for observations \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] from the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"Likelihood\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the likelihood function for the observations \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at time \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) from the process \!\(\*StyleBox[\"proc\", \"TI\"]\).\n\!\(\*RowBox[{\"Likelihood\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"path\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"path\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the likelihood function for observations from \!\(\*SubscriptBox[StyleBox[\"path\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"path\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] from the process \!\(\*StyleBox[\"proc\", \"TI\"]\)."
LimitsPositioningTokens::usage = "LimitsPositioningTokens is an option for selections that specifies a set of characters for which the option LimitsPositioning is set to True by default."
LimitsPositioning::usage = "LimitsPositioning is an option for UnderoverscriptBox and related boxes that specifies whether to change the positioning of underscripts and overscripts in the way conventional for limits. "
Limit::usage = "\!\(\*RowBox[{\"Limit\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Rule]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]}], \"]\"}]\) finds the limiting value of \!\(\*StyleBox[\"expr\", \"TI\"]\) when \!\(\*StyleBox[\"x\", \"TI\"]\) approaches \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\). "
LindleyDistribution::usage = "\!\(\*RowBox[{\"LindleyDistribution\", \"[\", StyleBox[\"\[Delta]\", \"TR\"], \"]\"}]\) represents a Lindley distribution with shape parameter \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\)."
Line3DBoxOptions::usage = "\!\(\*RowBox[{Line3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for Line3DBox objects."
LinearFractionalTransform::usage = "\!\(\*RowBox[{\"LinearFractionalTransform\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a TransformationFunction that represents a linear fractional transformation defined by the homogeneous matrix \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"LinearFractionalTransform\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a linear fractional transformation that maps \!\(\*StyleBox[\"r\", \"TI\"]\) to \!\(\*RowBox[{RowBox[{\"(\", RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"r\", \"TI\"]}], \"+\", StyleBox[\"b\", \"TI\"]}], \")\"}], \"/\", RowBox[{\"(\", RowBox[{RowBox[{StyleBox[\"c\", \"TI\"], \".\", StyleBox[\"r\", \"TI\"]}], \"+\", StyleBox[\"d\", \"TI\"]}], \")\"}]}]\). "
LinearGradientImage::usage = "\!\(\*RowBox[{\"LinearGradientImage\", \"[\", StyleBox[\"gcol\", \"TI\"], \"]\"}]\) returns an image with values linearly changing from left to right based on gradient color \!\(\*StyleBox[\"gcol\", \"TI\"]\).\n\!\(\*RowBox[{\"LinearGradientImage\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"\[Rule]\", StyleBox[\"gcol\", \"TI\"]}], \"]\"}]\) returns an image where the gradient starts at \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and ends at \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"LinearGradientImage\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) returns a linear gradient image of the specified \!\(\*StyleBox[\"size\", \"TI\"]\)."
LinearizingTransformationData::usage = "\!\(\*RowBox[{\"LinearizingTransformationData\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents data of an AffineStateSpaceModel linearized by functions such as FeedbackLinearize and StateTransformationLinearize using transformation of variables."
LinearModelFit::usage = "\!\(\*RowBox[{\"LinearModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) constructs a linear model of the form \!\(\*RowBox[{SubscriptBox[\"\[Beta]\", \"0\"], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"2\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) that fits the \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for successive \!\(\*StyleBox[\"x\", \"TI\"]\) values 1, 2, \[Ellipsis].\n\!\(\*RowBox[{\"LinearModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs a linear model of the form \!\(\*RowBox[{SubscriptBox[\"\[Beta]\", \"0\"], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"2\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) where the \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) depend on the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]]\). \n\!\(\*RowBox[{\"LinearModelFit\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"]\"}]\) constructs a linear model from the design matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and response vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
LinearOffsetFunction::usage = "LinearOffsetFunction is an option for linear and generalized linear model fitting functions that specifies a component for the model that is to be assumed known."
LinearProgramming::usage = "\!\(\*RowBox[{\"LinearProgramming\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) finds a vector \!\(\*StyleBox[\"x\", \"TI\"]\) that minimizes the quantity \!\(\*RowBox[{StyleBox[\"c\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}]\) subject to the constraints \!\(\*RowBox[{StyleBox[\"m\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \"\[GreaterEqual]\", StyleBox[\"b\", \"TI\"]}]\) and \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterEqual]\", \"0\"}]\). \n\!\(\*RowBox[{\"LinearProgramming\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) finds a vector \!\(\*StyleBox[\"x\", \"TI\"]\) that minimizes \!\(\*RowBox[{StyleBox[\"c\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}]\) subject to \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterEqual]\", \"0\"}]\) and linear constraints specified by the matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and the pairs \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\). For each row \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) of \!\(\*StyleBox[\"m\", \"TI\"]\), the corresponding constraint is \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]], \".\", StyleBox[\"x\", \"TI\"]}], \"\[GreaterEqual]\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\) if \!\(\*RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"==\", \"1\"}]\), or \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]], \".\", StyleBox[\"x\", \"TI\"]}], \"==\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\) if \!\(\*RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"==\", \"0\"}]\), or \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]], \".\", StyleBox[\"x\", \"TI\"]}], \"\[LessEqual]\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\) if \!\(\*RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"==\", RowBox[{\"-\", \"1\"}]}]\). \n\!\(\*RowBox[{\"LinearProgramming\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) minimizes \!\(\*RowBox[{StyleBox[\"c\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}]\) subject to the constraints specified by \!\(\*StyleBox[\"m\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\) and \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterEqual]\", StyleBox[\"l\", \"TI\"]}]\). \n\!\(\*RowBox[{\"LinearProgramming\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) minimizes \!\(\*RowBox[{StyleBox[\"c\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}]\) subject to the constraints specified by \!\(\*StyleBox[\"m\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\) and \!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[GreaterEqual]\", SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"LinearProgramming\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) minimizes \!\(\*RowBox[{StyleBox[\"c\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}]\) subject to the constraints specified by \!\(\*StyleBox[\"m\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\) and \!\(\*RowBox[{SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[LessEqual]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[LessEqual]\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"LinearProgramming\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"lu\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) takes the elements of \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the domain \!\(\*StyleBox[\"dom\", \"TI\"]\), either Reals or Integers.\n\!\(\*RowBox[{\"LinearProgramming\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"lu\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dom\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dom\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to be in the domain \!\(\*SubscriptBox[StyleBox[\"dom\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
LinearRecurrence::usage = "\!\(\*RowBox[{\"LinearRecurrence\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the sequence of length \!\(\*StyleBox[\"n\", \"TI\"]\) obtained by iterating the linear recurrence with kernel \!\(\*StyleBox[\"ker\", \"TI\"]\) starting with initial values \!\(\*StyleBox[\"init\", \"TI\"]\).\n\!\(\*RowBox[{\"LinearRecurrence\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) yields terms \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) through \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) in the linear recurrence sequence. "
LinearRegression`BasisNames::usage = "BasisNames is an option for Regress and DesignedRegress which specifies headings for basis functions in the output."
LinearRegression`DesignedRegress::usage = "\!\(\*RowBox[{\"DesignedRegress\", \"[\", RowBox[{StyleBox[\"matrix\", \"TI\"], \",\", StyleBox[\"vector\", \"TI\"]}], \"]\"}]\) finds a least\[Dash]squares fit given the design matrix \!\(\*StyleBox[\"matrix\", \"TI\"]\) and response vector \!\(\*StyleBox[\"vector\", \"TI\"]\).\n\!\(\*RowBox[{\"DesignedRegress\", \"[\", RowBox[{StyleBox[\"svd\", \"TI\"], \",\", StyleBox[\"vector\", \"TI\"]}], \"]\"}]\) finds a fit given the singular value decomposition \!\(\*StyleBox[\"svd\", \"TI\"]\) of a design matrix."
LinearRegression`IncludeConstant::usage = "IncludeConstant is an option for Regress and DesignMatrix that specifies whether a constant term is automatically included in the model."
LinearRegression`Regress::usage = "\!\(\*RowBox[{\"Regress\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"funs\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) finds a least\[Dash]squares fit to a list of \!\(\*StyleBox[\"data\", \"TI\"]\) as a linear combination of the functions \!\(\*StyleBox[\"funs\", \"TI\"]\) of variables \!\(\*StyleBox[\"vars\", \"TI\"]\)."
LinearSolveFunction::usage = "\!\(\*RowBox[{\"LinearSolveFunction\", \"[\", RowBox[{StyleBox[\"dimensions\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) represents a function for providing solutions to a matrix equation. "
LinearSolve::usage = "\!\(\*RowBox[{\"LinearSolve\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) finds an \!\(\*StyleBox[\"x\", \"TI\"]\) that solves the matrix equation \!\(\*RowBox[{RowBox[{StyleBox[\"m\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}], \"==\", StyleBox[\"b\", \"TI\"]}]\). \n\!\(\*RowBox[{\"LinearSolve\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) generates a \!\(\*RowBox[{\"LinearSolveFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied repeatedly to different \!\(\*StyleBox[\"b\", \"TI\"]\). "
LineBoxOptions::usage = "\!\(\*RowBox[{LineBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for LineBox objects."
LinebreakAdjustments::usage = "LinebreakAdjustments is an option for selections that sets parameters used for calculating where automatic line breaks should be inserted."
LineBreakChart::usage = "\!\(\*RowBox[{\"LineBreakChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a line break chart with prices \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at date \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"LineBreakChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"daterange\", \"TI\"]}], \"}\"}], \"]\"}]\) makes a line break chart of closing prices for the financial entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" over the date range \!\(\*StyleBox[\"daterange\", \"TI\"]\).\n\!\(\*RowBox[{\"LineBreakChart\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) makes a line break chart where \!\(\*StyleBox[\"n\", \"TI\"]\) bars in a row cause a reversal."
LineBreakWithin::usage = "LineBreakWithin is an option for selections that specifies whether line breaks occur automatically when the end of a line is reached."
LineForm::usage = "\!\(\*RowBox[{\"LineForm\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) is a three-dimensional graphics directive that specifies that lines are to be drawn with the graphics directive \!\(\*StyleBox[\"g\", \"TI\"]\) or the list of graphics directives \!\(\*StyleBox[\"g\", \"TI\"]\)."
LineGraph::usage = "\!\(\*RowBox[{\"LineGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the line graph of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"LineGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
LineIndentMaxFraction::usage = "LineIndentMaxFraction is an option for Cell, StyleBox, and Style that specifies the maximum fraction of the total page width to indent at the beginnings of lines. "
LineIndent::usage = "LineIndent is an option for Style and Cell that specifies how many ems of indentation to add at the beginnings of lines for each level of nesting in an expression. "
LineIntegralConvolutionPlot::usage = "\!\(\*RowBox[{\"LineIntegralConvolutionPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"image\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a line integral convolution plot of \!\(\*StyleBox[\"image\", \"TI\"]\) convolved with the vector field \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\).\n\!\(\*RowBox[{\"LineIntegralConvolutionPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a line integral convolution plot of white noise with the vector field \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]\)."
LineIntegralConvolutionScale::usage = "LineIntegralConvolutionScale is an option to LineIntegralConvolutionPlot and related functions that determines the scale of the line integral convolution to be used."
LineLegend::usage = "\!\(\*RowBox[{\"LineLegend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates a legend that associates color \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with label \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n \!\(\*RowBox[{\"LineLegend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"Automatic\"}], \"]\"}]\) generates a legend with placeholder labels for the colors \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n \!\(\*RowBox[{\"LineLegend\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a legend with inherited colors within visualization functions."
LineSpacing::usage = "LineSpacing is an option for Style and Cell that specifies the spacing between successive lines of text. "
Line::usage = "\!\(\*RowBox[{\"Line\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents the line segments joining a sequence for points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Line\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a collection of lines. "
LinkActivate::usage = "\!\(\*RowBox[{\"LinkActivate\", \"[\", StyleBox[\"lnk\", \"TI\"], \"]\"}]\) activates a WSTP connection, waiting for the program at the other end to respond."
LinkClose::usage = "\!\(\*RowBox[{\"LinkClose\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) closes an open \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connection. "
LinkConnect::usage = "\!\(\*RowBox[{\"LinkConnect\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) connects to a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) link created by another program. "
LinkCreate::usage = "\!\(\*RowBox[{\"LinkCreate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) creates a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) link with the specified name for another program to connect to. \n\!\(\*RowBox[{\"LinkCreate\", \"[\", \"]\"}]\) creates a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) link and picks an unused name for the link."
LinkError::usage = "\!\(\*RowBox[{\"LinkError\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) returns error information for link in the form \!\(\*RowBox[{\"{\", \" \", RowBox[{StyleBox[\"errorNumber\", \"TI\"], \",\", \" \", StyleBox[\"errorExplanation\", \"TI\"]}], \" \", \"}\"}]\)."
LinkFlush::usage = "\!\(\*RowBox[{\"LinkFlush\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) transmits immediately any locally buffered outgoing expressions."
LinkFunction::usage = "LinkFunction is an option for GeneralizedLinearModelFit that specifies the link function for the generalized linear model."
LinkInterrupt::usage = "\!\(\*RowBox[{\"LinkInterrupt\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) sends an interrupt to the program at the other end of the specified \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connection. "
LinkLaunch::usage = "\!\(\*RowBox[{\"LinkLaunch\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prog\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) starts the external program \!\(\*StyleBox[\"prog\", \"TI\"]\) and opens a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connection to it. "
LinkObject::usage = "\!\(\*RowBox[{\"LinkObject\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) is an object that represents an active \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connection for functions such as LinkRead and LinkWrite. "
LinkPatterns::usage = "\!\(\*RowBox[{\"LinkPatterns\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) gives a list of the patterns for which definitions were set up when the external program associated with the specified \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connection was installed. "
LinkProtocol::usage = "LinkProtocol is an option to LinkLaunch, Install, and related functions that specifies the underlying data transport protocol to use for a new \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) link. "
LinkRankCentrality::usage = "\!\(\*RowBox[{\"LinkRankCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) gives the link-rank centralities for edges in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) and weight \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\).\n\!\(\*RowBox[{\"LinkRankCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) gives the link-rank centralities, using weight \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and initial vertex page-rank centralities \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"LinkRankCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
LinkReadHeld::usage = "\!\(\*RowBox[{\"LinkReadHeld\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) reads an expression via \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"MathLink\", FontSlant -> \"Italic\"]]\) from \!\(\*StyleBox[\"link\", \"TI\"]\) and returns it wrapped in Hold."
LinkRead::usage = "\!\(\*RowBox[{\"LinkRead\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) reads one expression from the specified \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connection. \n\!\(\*RowBox[{\"LinkRead\", \"[\", RowBox[{StyleBox[\"link\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) wraps \!\(\*StyleBox[\"h\", \"TI\"]\) around the expression read before evaluating it. "
LinkReadyQ::usage = "\!\(\*RowBox[{\"LinkReadyQ\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) tests whether there is an expression ready to read from the specified \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connection. \n\!\(\*RowBox[{\"LinkReadyQ\", \"[\", RowBox[{StyleBox[\"link\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) waits for up to \!\(\*StyleBox[\"t\", \"TI\"]\) seconds to see if an expression becomes ready to read.\n\!\(\*RowBox[{\"LinkReadyQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"link\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"link\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) tests all the \!\(\*SubscriptBox[StyleBox[\"link\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in parallel, returning as soon as any of them are ready to read from."
Links::usage = "\!\(\*RowBox[{\"Links\", \"[\", \"]\"}]\) gives a list of all \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connections that are currently open. \n\!\(\*RowBox[{\"Links\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) lists only links whose names match the specified string pattern."
LinkWriteHeld::usage = "\!\(\*RowBox[{\"LinkWriteHeld\", \"[\", RowBox[{StyleBox[\"link\", \"TI\"], \",\", \" \", RowBox[{\"Hold\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}], \",\", \" \", RowBox[{\"(\", RowBox[{StyleBox[\"flush\", \"TI\"], \":\", \"True\"}], \")\"}]}], \"]\"}]\) writes \!\(\*StyleBox[\"expr\", \"TI\"]\) (without the Hold) via \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"MathLink\", FontSlant -> \"Italic\"]]\) to link (synchronizing unless \!\(\*StyleBox[\"flush\", \"TI\"]\) is False)."
LinkWrite::usage = "\!\(\*RowBox[{\"LinkWrite\", \"[\", RowBox[{StyleBox[\"link\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) writes \!\(\*StyleBox[\"expr\", \"TI\"]\) to the specified \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) connection. "
LiouvilleLambda::usage = "\!\(\*RowBox[{\"LiouvilleLambda\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Liouville function \!\(\*RowBox[{\"\[Lambda]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\)."
Listable::usage = "Listable is an attribute that can be assigned to a symbol \!\(\*StyleBox[\"f\", \"TI\"]\) to indicate that the function \!\(\*StyleBox[\"f\", \"TI\"]\) should automatically be threaded over lists that appear as its arguments. "
ListAnimate::usage = "\!\(\*RowBox[{\"ListAnimate\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates an animation whose frames are the successive \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"ListAnimate\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"fps\", \"TI\"]}], \"]\"}]\) displays \!\(\*StyleBox[\"fps\", \"TI\"]\) frames per second. "
ListContourPlot3D::usage = "\!\(\*RowBox[{\"ListContourPlot3D\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a contour plot from a three-dimensional array of values. \n\!\(\*RowBox[{\"ListContourPlot3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a contour plot from values defined at specified points in three\[Hyphen]dimensional space. "
ListContourPlot::usage = "\!\(\*RowBox[{\"ListContourPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a contour plot from an array of height values. \n\!\(\*RowBox[{\"ListContourPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a contour plot from values defined at specified points. "
ListConvolve::usage = "\!\(\*RowBox[{\"ListConvolve\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) forms the convolution of the kernel \!\(\*StyleBox[\"ker\", \"TI\"]\) with \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"ListConvolve\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) forms the cyclic convolution in which the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) element of \!\(\*StyleBox[\"ker\", \"TI\"]\) is aligned with each element in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"ListConvolve\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) forms the cyclic convolution whose first element contains \!\(\*RowBox[{RowBox[{StyleBox[\"list\", \"TI\"], \"[\", RowBox[{\"[\", \"1\", \"]\"}], \"]\"}], RowBox[{StyleBox[\"ker\", \"TI\"], \"[\", RowBox[{\"[\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \"]\"}], \"]\"}]}]\) and whose last element contains \!\(\*RowBox[{RowBox[{StyleBox[\"list\", \"TI\"], \"[\", RowBox[{\"[\", RowBox[{\"-\", \"1\"}], \"]\"}], \"]\"}], RowBox[{StyleBox[\"ker\", \"TI\"], \"[\", RowBox[{\"[\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]], \"]\"}], \"]\"}]}]\). \n\!\(\*RowBox[{\"ListConvolve\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"klist\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) forms the convolution in which \!\(\*StyleBox[\"list\", \"TI\"]\) is padded at each end with repetitions of the element \!\(\*StyleBox[\"p\", \"TI\"]\). \n\!\(\*RowBox[{\"ListConvolve\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"klist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) forms the convolution in which \!\(\*StyleBox[\"list\", \"TI\"]\) is padded at each end with cyclic repetitions of the \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"ListConvolve\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"klist\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) forms a generalized convolution in which \!\(\*StyleBox[\"g\", \"TI\"]\) is used in place of Times and \!\(\*StyleBox[\"h\", \"TI\"]\) in place of Plus. \n\!\(\*RowBox[{\"ListConvolve\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"klist\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"lev\", \"TI\"]}], \"]\"}]\) forms a convolution using elements at level \!\(\*StyleBox[\"lev\", \"TI\"]\) in \!\(\*StyleBox[\"ker\", \"TI\"]\) and \!\(\*StyleBox[\"list\", \"TI\"]\). "
ListCorrelate::usage = "\!\(\*RowBox[{\"ListCorrelate\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) forms the correlation of the kernel \!\(\*StyleBox[\"ker\", \"TI\"]\) with \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"ListCorrelate\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) forms the cyclic correlation in which the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) element of \!\(\*StyleBox[\"ker\", \"TI\"]\) is aligned with each element in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"ListCorrelate\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) forms the cyclic correlation whose first element contains \!\(\*RowBox[{RowBox[{StyleBox[\"list\", \"TI\"], \"[\", RowBox[{\"[\", \"1\", \"]\"}], \"]\"}], RowBox[{StyleBox[\"ker\", \"TI\"], \"[\", RowBox[{\"[\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \"]\"}], \"]\"}]}]\) and whose last element contains \!\(\*RowBox[{RowBox[{StyleBox[\"list\", \"TI\"], \"[\", RowBox[{\"[\", RowBox[{\"-\", \"1\"}], \"]\"}], \"]\"}], RowBox[{StyleBox[\"ker\", \"TI\"], \"[\", RowBox[{\"[\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]], \"]\"}], \"]\"}]}]\). \n\!\(\*RowBox[{\"ListCorrelate\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"klist\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) forms the correlation in which \!\(\*StyleBox[\"list\", \"TI\"]\) is padded at each end with repetitions of the element \!\(\*StyleBox[\"p\", \"TI\"]\). \n\!\(\*RowBox[{\"ListCorrelate\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"klist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) forms the correlation in which \!\(\*StyleBox[\"list\", \"TI\"]\) is padded at each end with cyclic repetitions of the \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"ListCorrelate\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"klist\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) forms a generalized correlation in which \!\(\*StyleBox[\"g\", \"TI\"]\) is used in place of Times and \!\(\*StyleBox[\"h\", \"TI\"]\) in place of Plus. \n\!\(\*RowBox[{\"ListCorrelate\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"klist\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"lev\", \"TI\"]}], \"]\"}]\) forms a correlation using elements at level \!\(\*StyleBox[\"lev\", \"TI\"]\) in \!\(\*StyleBox[\"ker\", \"TI\"]\) and \!\(\*StyleBox[\"list\", \"TI\"]\). "
ListCurvePathPlot::usage = "\!\(\*RowBox[{\"ListCurvePathPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a curve that corresponds to a smooth path through the specified points. "
ListDeconvolve::usage = "\!\(\*RowBox[{\"ListDeconvolve\", \"[\", RowBox[{StyleBox[\"ker\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) gives a deconvolution of \!\(\*StyleBox[\"list\", \"TI\"]\) using kernel \!\(\*StyleBox[\"ker\", \"TI\"]\)."
ListDensityPlot3D::usage = "\!\(\*RowBox[{\"ListDensityPlot3D\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a smooth density plot from an array of values. \n\!\(\*RowBox[{\"ListDensityPlot3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a density plot with values \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at the specified points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\)."
ListDensityPlot::usage = "\!\(\*RowBox[{\"ListDensityPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a smooth density plot from an array of values. \n\!\(\*RowBox[{\"ListDensityPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a density plot with values defined at specified points. "
ListFormat::usage = "ListFormat is an option to TextString and related functions that determines how lists are formatted."
ListFourierSequenceTransform::usage = "\!\(\*RowBox[{\"ListFourierSequenceTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) gives the discrete-time Fourier transform (DTFT) of a list as a function of the parameter \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\).\n\!\(\*RowBox[{\"ListFourierSequenceTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) places the first element of \!\(\*StyleBox[\"list\", \"TI\"]\) at integer time \!\(\*StyleBox[\"k\", \"TI\"]\) on the infinite time axis.\n\!\(\*RowBox[{\"ListFourierSequenceTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional discrete-time Fourier transform"
ListInterpolation::usage = "\!\(\*RowBox[{\"ListInterpolation\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) constructs an InterpolatingFunction object that represents an approximate function that interpolates the array of values given. \n\!\(\*RowBox[{\"ListInterpolation\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) specifies the domain of the grid from which the values in \!\(\*StyleBox[\"array\", \"TI\"]\) are assumed to come. "
ListLineIntegralConvolutionPlot::usage = "\!\(\*RowBox[{\"ListLineIntegralConvolutionPlot\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"image\", \"TI\"]}], \"}\"}], \"]\"}]\) generates a line integral convolution plot of \!\(\*StyleBox[\"image\", \"TI\"]\) convolved with the vector field defined by an array of vector field values.\n\!\(\*RowBox[{\"ListLineIntegralConvolutionPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a line integral convolution plot of white noise convolved with the vector field defined by \!\(\*StyleBox[\"array\", \"TI\"]\).\n\!\(\*RowBox[{\"ListLineIntegralConvolutionPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"image\", \"TI\"]}], \"}\"}], \"]\"}]\) generates a line integral convolution plot of \!\(\*StyleBox[\"image\", \"TI\"]\) convolved with the vector field defined by vectors \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) at specified points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"ListLineIntegralConvolutionPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a line integral convolution plot of white noise convolved with the vector field defined by \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\)."
ListLinePlot::usage = "\!\(\*RowBox[{\"ListLinePlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a line through a list of values, assumed to correspond to \!\(\*StyleBox[\"x\", \"TI\"]\) coordinates 1, 2, \!\(\*StyleBox[\"\[Ellipsis] \", \"TR\"]\). \n\!\(\*RowBox[{\"ListLinePlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a line through specific \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) positions. \n\!\(\*RowBox[{\"ListLinePlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lines. "
ListLogLinearPlot::usage = "\!\(\*RowBox[{\"ListLogLinearPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a log-linear plot of the specified list of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) values.\n\!\(\*RowBox[{\"ListLogLinearPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of values."
ListLogLogPlot::usage = "\!\(\*RowBox[{\"ListLogLogPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a log-log plot of the specified list of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) values.\n\!\(\*RowBox[{\"ListLogLogPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of values."
ListLogPlot::usage = "\!\(\*RowBox[{\"ListLogPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a log plot of the \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), assumed to correspond to \!\(\*StyleBox[\"x\", \"TI\"]\) coordinates 1, 2, \[Ellipsis].\n\!\(\*RowBox[{\"ListLogPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a log plot of the specified list of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) values.\n\!\(\*RowBox[{\"ListLogPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of values."
ListPickerBoxOptions::usage = "\!\(\*RowBox[{ListPickerBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for ListPickerBox objects."
ListPickerBox::usage = "\!\(\*RowBox[{ListPickerBox, \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) is a low-level box structure that represents a list pane control."
ListPicker::usage = "\!\(\*RowBox[{\"ListPicker\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a list pane with setting \!\(\*StyleBox[\"list\", \"TI\"]\) that can contain possible values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ListPicker\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"list\", \"TI\"]\), with members added or removed each time an item is selected or deselected.\n\!\(\*RowBox[{\"ListPicker\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a list pane in which the possible value \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is indicated by \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ListPlay::usage = "\!\(\*RowBox[{\"ListPlay\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates an object that plays as a sound whose amplitude is given by the sequence of levels \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
ListPlot3D::usage = "\!\(\*RowBox[{\"ListPlot3D\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a three-dimensional plot of a surface representing an array of height values. \n\!\(\*RowBox[{\"ListPlot3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a plot of the surface with heights \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at positions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"ListPlot3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the surfaces corresponding to each of the \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ListPlot::usage = "\!\(\*RowBox[{\"ListPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots points corresponding to a list of values, assumed to correspond to \!\(\*StyleBox[\"x\", \"TI\"]\) coordinates 1, 2, \[Ellipsis]. \n\!\(\*RowBox[{\"ListPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a list of points with specified \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) coordinates. \n\!\(\*RowBox[{\"ListPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of points. "
ListPointPlot3D::usage = "\!\(\*RowBox[{\"ListPointPlot3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a 3D scatter plot of points with coordinates \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"ListPointPlot3D\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a 3D scatter plot of points with a 2D array of height values.\n\!\(\*RowBox[{\"ListPointPlot3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several collections of points, by default in different colors. "
ListPolarPlot::usage = "\!\(\*RowBox[{\"ListPolarPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots points equally spaced in angle at radii \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ListPolarPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots points at polar coordinates \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"ListPolarPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of values."
ListQ::usage = "\!\(\*RowBox[{\"ListQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if the head of \!\(\*StyleBox[\"expr\", \"TI\"]\) is List, and False otherwise."
ListSliceContourPlot3D::usage = "\!\(\*RowBox[{\"ListSliceContourPlot3D\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"surf\", \"TI\"]}], \"]\"}]\) generates a contour plot of the three-dimensional \!\(\*StyleBox[\"array\", \"TI\"]\) of values sliced to the surface \!\(\*StyleBox[\"surf\", \"TI\"]\).\n\!\(\*RowBox[{\"ListSliceContourPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"surf\", \"TI\"]}], \"]\"}]\) generates a slice contour plot for the values \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"ListSliceContourPlot3D\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates slice contour plots over several slices \!\(\*SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\)."
ListSliceDensityPlot3D::usage = "\!\(\*RowBox[{\"ListSliceDensityPlot3D\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"surf\", \"TI\"]}], \"]\"}]\) generates a density plot of the three-dimensional \!\(\*StyleBox[\"array\", \"TI\"]\) of values sliced to the surface \!\(\*StyleBox[\"surf\", \"TI\"]\).\n\!\(\*RowBox[{\"ListSliceDensityPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"surf\", \"TI\"]}], \"]\"}]\) generates a slice density plot for the values \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"ListSliceDensityPlot3D\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates slice density plots over several slices \!\(\*SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\)."
ListSliceVectorPlot3D::usage = "\!\(\*RowBox[{\"ListSliceVectorPlot3D\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"surf\", \"TI\"]}], \"]\"}]\) generates a vector plot from a 3D array of vector field values over the slice surface \!\(\*StyleBox[\"surf\", \"TI\"]\).\n\!\(\*RowBox[{\"ListSliceVectorPlot3D\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates a slice vector plot over several surfaces \!\(\*SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\). "
ListStepPlot::usage = "\!\(\*RowBox[{\"ListStepPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the values \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in steps at points 1, 2, \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\).\n\!\(\*RowBox[{\"ListStepPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the values \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) in steps at points \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\).\n\!\(\*RowBox[{\"ListStepPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots several lists of values \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\).\n\!\(\*RowBox[{\"ListStepPlot\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"step\", \"TI\"]}], \"]\"}]\) plots using steps specified by \!\(\*StyleBox[\"step\", \"TI\"]\)."
ListStreamDensityPlot::usage = "\!\(\*RowBox[{\"ListStreamDensityPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a stream density plot from a 2D array of vector and scalar field values \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"ij\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"ij\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"ij\", \"TI\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"ListStreamDensityPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a stream density plot from vector and scalar field values \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) given at specified points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"ListStreamDensityPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots data for several vector and scalar fields. "
ListStreamPlot::usage = "\!\(\*RowBox[{\"ListStreamPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a stream plot from an array of vector field values.\n\!\(\*RowBox[{\"ListStreamPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a stream plot from vector field values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) given at specified points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"ListStreamPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots data for several vector fields. "
ListSurfacePlot3D::usage = "\!\(\*RowBox[{\"ListSurfacePlot3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a three-dimensional surface constructed to fit the specified points. "
List::usage = "\!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) is a list of elements. "
ListVectorDensityPlot::usage = "\!\(\*RowBox[{\"ListVectorDensityPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a vector plot from a 2D array of vector and scalar field values \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"ij\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"ij\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"ij\", \"TI\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"ListVectorDensityPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a vector plot from vector and scalar field values \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) given at specified points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"ListVectorDensityPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots data for several vector and scalar fields. "
ListVectorPlot3D::usage = "\!\(\*RowBox[{\"ListVectorPlot3D\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a 3D vector plot from a 3D array of vector field values.\n\!\(\*RowBox[{\"ListVectorPlot3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots data for several vector fields. "
ListVectorPlot::usage = "\!\(\*RowBox[{\"ListVectorPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a vector plot from an array of vector field values.\n\!\(\*RowBox[{\"ListVectorPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a vector plot from vector field values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"vx\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"vy\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) given at specified points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"ListVectorPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots data for several vector fields. "
ListZTransform::usage = "\!\(\*RowBox[{\"ListZTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Z transform of \!\(\*StyleBox[\"list\", \"TI\"]\) as a function of \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"ListZTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) places the first element of \!\(\*StyleBox[\"list\", \"TI\"]\) at integer time \!\(\*StyleBox[\"k\", \"TI\"]\) on the infinite time axis.\n\!\(\*RowBox[{\"ListZTransform\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Z transform."
LocalAdaptiveBinarize::usage = "\!\(\*RowBox[{\"LocalAdaptiveBinarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) creates a binary image from \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing values above the mean of the range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood with 1 and others with 0.\n\!\(\*RowBox[{\"LocalAdaptiveBinarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) replaces values above \!\(\*RowBox[{RowBox[{\"\[Alpha]\", \" \", \"\[Mu]\"}], \"+\", RowBox[{\"\[Beta]\", \" \", \"\[Sigma]\"}], \"+\", \"\[Gamma]\"}]\) with 1 and others with 0, where \[Mu] and \[Sigma] are the local mean and standard deviation."
LocalClusteringCoefficient::usage = "\!\(\*RowBox[{\"LocalClusteringCoefficient\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of local clustering coefficients of all vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"LocalClusteringCoefficient\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the local clustering coefficient of the vertex \!\(\*StyleBox[\"v\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"LocalClusteringCoefficient\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
LocalizeVariables::usage = "LocalizeVariables is an option to Manipulate that determines whether the values of variables associated with controls should be localized."
LocalObject::usage = "\!\(\*RowBox[{\"LocalObject\", \"[\", \"]\"}]\) represents a new anonymous local object.\n\!\(\*RowBox[{\"LocalObject\", \"[\", \"file:///StyleBox[\[Ellipsis], TR]\", \"]\"}]\) represents a local object with a given file path.\n\!\(\*RowBox[{\"LocalObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"relpath\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents a local object with the given relative path.\n\!\(\*RowBox[{\"LocalObject\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"relpath\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"lbase\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents a local object relative to the base \!\(\*StyleBox[\"lbase\", \"TI\"]\)."
LocalSymbol::usage = "\!\(\*RowBox[{\"LocalSymbol\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents a symbol whose value is persistently stored in the local file system.\n\!\(\*RowBox[{\"LocalSymbol\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) represents a persistent symbol corresponding to the local object \!\(\*StyleBox[\"obj\", \"TI\"]\)."
LocalTime::usage = "\!\(\*RowBox[{\"LocalTime\", \"[\", \"]\"}]\) gives a DateObject corresponding to the current local time at the current geo location.\n\!\(\*RowBox[{\"LocalTime\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) gives the current local time at the geo location specified by \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"LocalTime\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"time\", \"TI\"]}], \"]\"}]\) gives the local time corresponding to the date object \!\(\*StyleBox[\"time\", \"TI\"]\) at the geo location \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"LocalTime\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"time\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"func\", \"TI\"]\) to determine what to return for extended geographic regions."
LocalTimeZone::usage = "\!\(\*RowBox[{\"LocalTimeZone\", \"[\", \"]\"}]\) gives the current time zone for the current geo location.\n\!\(\*RowBox[{\"LocalTimeZone\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) gives the current time zone for the geo location specified by \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"LocalTimeZone\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"date\", \"TI\"]}], \"]\"}]\) gives the time zone for the geo location \!\(\*StyleBox[\"loc\", \"TI\"]\) on the specified date.\n\!\(\*RowBox[{\"LocalTimeZone\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property of the time zone."
LocationEquivalenceTest::usage = "\!\(\*RowBox[{\"LocationEquivalenceTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) tests whether the means or medians of the \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are equal. \n\!\(\*RowBox[{\"LocationEquivalenceTest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
LocationTest::usage = "\!\(\*RowBox[{\"LocationTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the mean or median of the \!\(\*StyleBox[\"data\", \"TI\"]\) is zero. \n\!\(\*RowBox[{\"LocationTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the means or medians of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"LocationTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) tests a location measure against \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"LocationTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
LocatorAutoCreate::usage = "LocatorAutoCreate is an option for LocatorPane, Manipulate, and related functions that specifies whether new locators should be created when clicking away from existing locators."
LocatorBoxOptions::usage = "\!\(\*RowBox[{LocatorBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for LocatorBox objects."
LocatorPaneBoxOptions::usage = "\!\(\*RowBox[{LocatorPaneBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for LocatorPaneBox objects."
LocatorPane::usage = "\!\(\*RowBox[{\"LocatorPane\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"back\", \"TI\"]}], \"]\"}]\) represents a pane with a locator at position \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) and background \!\(\*StyleBox[\"back\", \"TI\"]\).\n\!\(\*RowBox[{\"LocatorPane\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"pt\", \"TI\"], \"]\"}], \",\", StyleBox[\"back\", \"TI\"]}], \"]\"}]\) takes the locator position to be the dynamically updated current value of \!\(\*StyleBox[\"pt\", \"TI\"]\), with the value of \!\(\*StyleBox[\"pt\", \"TI\"]\) being reset if the locator is moved.\n\!\(\*RowBox[{\"LocatorPane\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"back\", \"TI\"]}], \"]\"}]\) sets up multiple locators at positions \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. \n\!\(\*RowBox[{\"LocatorPane\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \",\", StyleBox[\"back\", \"TI\"]}], \"]\"}]\) takes the locator positions to be dynamically updated current values of the \!\(\*SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"LocatorPane\", \"[\", RowBox[{StyleBox[\"pts\", \"TI\"], \",\", StyleBox[\"back\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) specifies the range of coordinates for the locator.\n\!\(\*RowBox[{\"LocatorPane\", \"[\", RowBox[{StyleBox[\"pts\", \"TI\"], \",\", StyleBox[\"back\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses jumps \!\(\*StyleBox[\"dx\", \"TI\"]\), \!\(\*StyleBox[\"dy\", \"TI\"]\). "
LocatorRegion::usage = "LocatorRegion is an option for Locator that specifies where the locator object should by default be allowed to go when it is dragged."
Locator::usage = "\!\(\*RowBox[{\"Locator\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a locator object at position \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) in a graphic. \n\!\(\*RowBox[{\"Locator\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"pos\", \"TI\"], \"]\"}], \"]\"}]\) takes the position to be the dynamically updated current value of \!\(\*StyleBox[\"pos\", \"TI\"]\), with this value being reset if the locator object is moved. \n\!\(\*RowBox[{\"Locator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) displays \!\(\*StyleBox[\"obj\", \"TI\"]\) as the locator object. \n\!\(\*RowBox[{\"Locator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", \"None\"}], \"]\"}]\) displays nothing visible as the locator object. "
Locked::usage = "Locked is an attribute that, once assigned, prevents modification of any attributes of a symbol. "
Log10::usage = "\!\(\*RowBox[{\"Log10\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the base-10 logarithm of \!\(\*StyleBox[\"x\", \"TI\"]\)."
Log2::usage = "\!\(\*RowBox[{\"Log2\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the base-2 logarithm of \!\(\*StyleBox[\"x\", \"TI\"]\)."
LogBarnesG::usage = "\!\(\*RowBox[{\"LogBarnesG\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the logarithm of the Barnes \!\(\*StyleBox[\"G\", FontSlant -> \"Italic\"]\)-function \!\(\*RowBox[{\"logG\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
LogGammaDistribution::usage = "\!\(\*RowBox[{\"LogGammaDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a log-gamma distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) and location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
LogGamma::usage = "\!\(\*RowBox[{\"LogGamma\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the logarithm of the gamma function \!\(\*RowBox[{\"log\", \" \", RowBox[{\"\[CapitalGamma]\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]}]\). "
LogicalExpand::usage = "\!\(\*RowBox[{\"LogicalExpand\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands out logical combinations of equations, inequalities, and other functions. "
LogIntegral::usage = "\!\(\*RowBox[{\"LogIntegral\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) is the logarithmic integral function \!\(\*RowBox[{\"li\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
LogisticDistribution::usage = "\!\(\*RowBox[{\"LogisticDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a logistic distribution with mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"LogisticDistribution\", \"[\", \"]\"}]\) represents a logistic distribution with mean 0 and scale parameter 1."
LogisticSigmoid::usage = "\!\(\*RowBox[{\"LogisticSigmoid\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the logistic sigmoid function."
LogitModelFit::usage = "\!\(\*RowBox[{\"LogitModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) constructs a binomial logistic regression model of the form \!\(\*RowBox[{\"1\", \"/\", RowBox[{\"(\", RowBox[{\"1\", \"+\", SuperscriptBox[\"\[ExponentialE]\", RowBox[{\"-\", RowBox[{\"(\", RowBox[{SubscriptBox[\"\[Beta]\", \"0\"], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \" \", \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"2\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \" \", \"+\", \"\[Ellipsis]\"}], \")\"}]}]]}], \")\"}]}]\) that fits the \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for successive \!\(\*StyleBox[\"x\", \"TI\"]\) values 1, 2, \[Ellipsis].\n\!\(\*RowBox[{\"LogitModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs a binomial logistic regression model of the form \!\(\*RowBox[{\"1\", \"/\", RowBox[{\"(\", RowBox[{\"1\", \"+\", SuperscriptBox[\"\[ExponentialE]\", RowBox[{\"-\", RowBox[{\"(\", RowBox[{SubscriptBox[\"\[Beta]\", \"0\"], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \" \", \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"2\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \" \", \"+\", \"\[Ellipsis]\"}], \")\"}]}]]}], \")\"}]}]\) where the \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) depend on the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"LogitModelFit\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"]\"}]\) constructs a binomial logistic regression model from the design matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and response vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
LogLikelihood::usage = "\!\(\*RowBox[{\"LogLikelihood\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the log\[Hyphen]likelihood function for observations \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] from the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{RowBox[{\"LogLikelihood\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]}]}], \"]\"}]\) gives the log-likelihood function for the observations \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at time \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) from the process \!\(\*StyleBox[\"proc\", \"TI\"]\).\n\!\(\*RowBox[{\"LogLikelihood\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"path\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"path\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the log-likelihood function for the observations from \!\(\*SubscriptBox[StyleBox[\"path\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"path\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] from the process \!\(\*StyleBox[\"proc\", \"TI\"]\)."
LogLinearPlot::usage = "\!\(\*RowBox[{\"LogLinearPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a log-linear plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"LogLinearPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates log-linear plots of several functions \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
LogLogisticDistribution::usage = "\!\(\*RowBox[{\"LogLogisticDistribution\", \"[\", RowBox[{StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a log-logistic distribution with shape parameter \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
LogLogPlot::usage = "\!\(\*RowBox[{\"LogLogPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a log-log plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as function of \!\(\*StyleBox[\"x\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"LogLogPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates log-log plots of several functions \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
LogMultinormalDistribution::usage = "\!\(\*RowBox[{\"LogMultinormalDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a log-multinormal distribution with parameters \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\)."
LogNormalDistribution::usage = "\!\(\*RowBox[{\"LogNormalDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a lognormal distribution derived from a normal distribution with mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
LogPlot::usage = "\!\(\*RowBox[{\"LogPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a log plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"LogPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates log plots of several functions \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
LogRankTest::usage = "\!\(\*RowBox[{\"LogRankTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) tests for equal hazard rates among the \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) using a log-rank type test. \n\!\(\*RowBox[{\"LogRankTest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"wspec\", \"TI\"]}], \"]\"}]\) performs a weighted log-rank test with weights \!\(\*StyleBox[\"wspec\", \"TI\"]\). \n\!\(\*RowBox[{\"LogRankTest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"wspec\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
LogSeriesDistribution::usage = "\!\(\*RowBox[{\"LogSeriesDistribution\", \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}]\) represents a logarithmic series distribution with parameter \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\)."
Log::usage = "\!\(\*RowBox[{\"Log\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the natural logarithm of \!\(\*StyleBox[\"z\", \"TI\"]\) (logarithm to base \!\(\*StyleBox[\"e\", \"TI\"]\)). \n\!\(\*RowBox[{\"Log\", \"[\", RowBox[{StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the logarithm to base \!\(\*StyleBox[\"b\", \"TI\"]\). "
LongestCommonSequencePositions::usage = "\!\(\*RowBox[{\"LongestCommonSequencePositions\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) finds the longest sequence of contiguous or disjoint elements common to the strings or lists \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) and returns their positions."
LongestCommonSequence::usage = "\!\(\*RowBox[{\"LongestCommonSequence\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) finds the longest sequence of contiguous or disjoint elements common to the strings or lists \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
LongestCommonSubsequencePositions::usage = "\!\(\*RowBox[{\"LongestCommonSubsequencePositions\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) finds the longest contiguous subsequence of elements common to the strings or lists \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) and returns their positions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\) in \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
LongestCommonSubsequence::usage = "\!\(\*RowBox[{\"LongestCommonSubsequence\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) finds the longest contiguous subsequence of elements common to the strings or lists \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
LongestMatch::usage = "LongestMatch[\!\(\*StyleBox[\"p\", \"TI\"]\)] is a string pattern object matching the longest sequence of characters consistent with the string pattern \!\(\*StyleBox[\"p\", \"TI\"]\)."
LongestOrderedSequence::usage = "\!\(\*RowBox[{\"LongestOrderedSequence\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds the longest ordered sequence of contiguous or disjoint elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"LongestOrderedSequence\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) finds the longest ordered sequence using the ordering function \!\(\*StyleBox[\"p\", \"TI\"]\)."
Longest::usage = "\!\(\*RowBox[{\"Longest\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) is a pattern object that matches the longest sequence consistent with the pattern \!\(\*StyleBox[\"p\", \"TI\"]\). "
LongForm::usage = "LongForm is an option for Information. With \!\(\*RowBox[{\"LongForm\", \" \", \"->\", \" \", \"True\"}]\), the full information of a symbol is printed. With \!\(\*RowBox[{\"LongForm\", \" \", \"->\", \" \", \"False\"}]\) the usage of a symbol is printed."
Longitude::usage = "\!\(\*RowBox[{\"Longitude\", \"[\", StyleBox[\"pos\", \"TI\"], \"]\"}]\) gives the longitude in degrees of a geographic position specified by \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"Longitude\", \"[\", RowBox[{StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"datum\", \"TI\"]}], \"]\"}]\) gives the longitude referring to the specified geodetic datum."
LongLeftArrow::usage = "\!\(\*RowBox[{\"LongLeftArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LongLeftArrow]\", StyleBox[\"y\", \"TI\"], \"\[LongLeftArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LongLeftRightArrow::usage = "\!\(\*RowBox[{\"LongLeftRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LongLeftRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[LongLeftRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LongRightArrow::usage = "\!\(\*RowBox[{\"LongRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LongRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[LongRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Lookup::usage = "\!\(\*RowBox[{\"Lookup\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", StyleBox[\"key\", \"TI\"]}], \"]\"}]\) looks up the value associated with \!\(\*StyleBox[\"key\", \"TI\"]\) in the association \!\(\*StyleBox[\"assoc\", \"TI\"]\); if the key is not present, \!\(\*RowBox[{\"Missing\", \"[\", RowBox[{StyleBox[\"\\\"KeyAbsent\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"key\", \"TI\"]}], \"]\"}]\) is returned.\n\!\(\*RowBox[{\"Lookup\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of the values associated with the \!\(\*SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Lookup\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"key\", \"TI\"]}], \"]\"}]\) gives a list corresponding to the value of \!\(\*StyleBox[\"key\", \"TI\"]\) in each \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Lookup\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", StyleBox[\"key\", \"TI\"], \",\", StyleBox[\"default\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"default\", \"TI\"]\) if the \!\(\*StyleBox[\"key\", \"TI\"]\) is not present.\n\!\(\*RowBox[{\"Lookup\", \"[\", StyleBox[\"key\", \"TI\"], \"]\"}]\) represents an operator form of Lookup that can be applied to an expression."
LoopFreeGraphQ::usage = "\!\(\*RowBox[{\"LoopFreeGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) has no self-loops, and False otherwise."
LowerCaseQ::usage = "\!\(\*RowBox[{\"LowerCaseQ\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) yields True if all the characters in the string are lowercase letters, and yields False otherwise. "
LowerLeftArrow::usage = "\!\(\*RowBox[{\"LowerLeftArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LowerLeftArrow]\", StyleBox[\"y\", \"TI\"], \"\[LowerLeftArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LowerRightArrow::usage = "\!\(\*RowBox[{\"LowerRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[LowerRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[LowerRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
LowerTriangularize::usage = "\!\(\*RowBox[{\"LowerTriangularize\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a matrix in which all but the lower triangular elements of \!\(\*StyleBox[\"m\", \"TI\"]\) are replaced with zeros. \n\!\(\*RowBox[{\"LowerTriangularize\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) replaces with zeros only the elements above the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) subdiagonal of \!\(\*StyleBox[\"m\", \"TI\"]\)."
LowpassFilter::usage = "\!\(\*RowBox[{\"LowpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]}], \"]\"}]\) applies a lowpass filter with a cutoff frequency \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]]\) to an array of data.\n\!\(\*RowBox[{\"LowpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses a filter kernel of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"LowpassFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"c\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to the filter kernel.\n\!\(\*RowBox[{\"LowpassFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a lowpass filter to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"LowpassFilter\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies a lowpass filter to a sampled sound object."
LQEstimatorGains::usage = "\!\(\*RowBox[{\"LQEstimatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the optimal estimator gain matrix for the StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\), with process and measurement noise covariance matrices \!\(\*StyleBox[\"w\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"LQEstimatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]}], \"]\"}]\) includes the cross-covariance matrix \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"LQEstimatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"sensors\", \"TI\"]\) as the noisy measurements of \!\(\*StyleBox[\"ssm\", \"TI\"]\).\n\!\(\*RowBox[{\"LQEstimatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"dinputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"dinputs\", \"TI\"]\) as the deterministic inputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
LQGRegulator::usage = "\!\(\*RowBox[{\"LQGRegulator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"finputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"}\"}]}], \"]\"}]\) constructs the optimal feedback regulator for the StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\) using noisy measurements \!\(\*StyleBox[\"sensors\", \"TI\"]\) and feedback inputs \!\(\*StyleBox[\"finputs\", \"TI\"]\). The process, measurement, and cross-covariance matrices are \!\(\*StyleBox[\"w\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"h\", \"TI\"]\); and the state, input, and state-input weighting matrices are \!\(\*StyleBox[\"q\", \"TI\"]\), \!\(\*StyleBox[\"r\", \"TI\"]\), and \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"LQGRegulator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"finputs\", \"TI\"], \",\", StyleBox[\"einputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"einputs\", \"TI\"]\) as the exogenous deterministic inputs."
LQOutputRegulatorGains::usage = "\!\(\*RowBox[{\"LQOutputRegulatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the optimal state feedback gain matrix for the StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\) and the quadratic cost function, with output and control weighting matrices \!\(\*StyleBox[\"q\", \"TI\"]\) and \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"LQOutputRegulatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"}\"}]}], \"]\"}]\) includes the output-control cross-coupling matrix \!\(\*StyleBox[\"p\", \"TI\"]\) in the cost function.\n\!\(\*RowBox[{\"LQOutputRegulatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"sensors\", \"TI\"]\) as the measured outputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\).\n\!\(\*RowBox[{\"LQOutputRegulatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"finputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"finputs\", \"TI\"]\) as the feedback inputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
LQRegulatorGains::usage = "\!\(\*RowBox[{\"LQRegulatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the optimal state feedback gain matrix for the StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\) and the quadratic cost function, with state and control weighting matrices \!\(\*StyleBox[\"q\", \"TI\"]\) and \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"LQRegulatorGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"}\"}]}], \"]\"}]\) includes the state-control cross-coupling matrix \!\(\*StyleBox[\"p\", \"TI\"]\) in the cost function.\n\!\(\*RowBox[{\"LQRegulatorGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"finputs\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}]}], \"]\"}]\) specifies \!\(\*StyleBox[\"finputs\", \"TI\"]\) as the feedback inputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
LucasL::usage = "\!\(\*RowBox[{\"LucasL\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Lucas number \!\(\*SubscriptBox[StyleBox[\"L\", \"TI\"], StyleBox[\"n\", \"TI\"]]\).\n\!\(\*RowBox[{\"LucasL\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Lucas polynomial \!\(\*RowBox[{SubscriptBox[StyleBox[\"L\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\)."
LuccioSamiComponents::usage = "\!\(\*RowBox[{\"LuccioSamiComponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the Luccio\[Dash]Sami components of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"LuccioSamiComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the components that include at least one of the vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"LuccioSamiComponents\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
LUDecomposition::usage = "\!\(\*RowBox[{\"LUDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) generates a representation of the LU decomposition of a square matrix\[NonBreakingSpace]\!\(\*StyleBox[\"m\", \"TI\"]\). "
LunarEclipse::usage = "\!\(\*RowBox[{\"LunarEclipse\", \"[\", \"]\"}]\) gives the time of the next lunar eclipse.\n\!\(\*RowBox[{\"LunarEclipse\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the time for the next lunar eclipse after the specified date.\n\!\(\*RowBox[{\"LunarEclipse\", \"[\", StyleBox[\"propertyspec\", \"TI\"], \"]\"}]\) gives the specified property value for the next lunar eclipse.\n\!\(\*RowBox[{\"LunarEclipse\", \"[\", RowBox[{StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"propertyspec\", \"TI\"]}], \"]\"}]\) gives the specified property value for the next lunar eclipse after the specified date."
LUVColor::usage = "\!\(\*RowBox[{\"LUVColor\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) is a color directive with lightness \!\(\*StyleBox[\"l\", \"TI\"]\) and color components \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"LUVColor\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) specifies opacity \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\). "
LyapunovSolve::usage = "\!\(\*RowBox[{\"LyapunovSolve\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) finds a solution \!\(\*StyleBox[\"x\", \"TI\"]\) of the matrix Lyapunov equation \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}], \"+\", RowBox[{StyleBox[\"x\", \"TI\"], \".\", RowBox[{StyleBox[\"a\", \"TI\"], \"\[ConjugateTranspose]\"}]}]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\).\n\!\(\*RowBox[{\"LyapunovSolve\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) solves \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"]}], \"+\", RowBox[{StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"]}]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\).\n\!\(\*RowBox[{\"LyapunovSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) solves \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", RowBox[{StyleBox[\"d\", \"TI\"], \"\[ConjugateTranspose]\"}]}], \"+\", RowBox[{StyleBox[\"d\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", RowBox[{StyleBox[\"a\", \"TI\"], \"\[ConjugateTranspose]\"}]}]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\).\n\!\(\*RowBox[{\"LyapunovSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"e\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) solves \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"e\", \"TI\"]}], \"+\", RowBox[{StyleBox[\"d\", \"TI\"], \".\", StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"]}]}], \"\[LongEqual]\", StyleBox[\"c\", \"TI\"]}]\)."
LyonsGroupLy::usage = "\!\(\*RowBox[{\"LyonsGroupLy\", \"[\", \"]\"}]\) represents the sporadic simple Lyons group Ly."
MachineID::usage = "MachineID is an option to Encode which specifies the required value of $MachineID on the computer that reads the encoded file. If no value is specified, any value of $MachineID is allowed on the file-reading computer. A setting for MachineID must be a string."
MachineName::usage = "MachineName is an option to Encode which specifies the required value of $MachineName on the computer that reads the encoded file. If no value is specified, any value of $MachineName is allowed on the file-reading computer. A setting for MachineName must be a string."
MachineNumberQ::usage = "\!\(\*RowBox[{\"MachineNumberQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a machine\[Hyphen]precision real or complex number, and returns False otherwise. "
MachinePrecision::usage = "MachinePrecision is a symbol used to indicate machine\[Hyphen]number precision. "
Magenta::usage = "Magenta represents the color magenta in graphics or style specifications. "
Magnification::usage = "Magnification is an option for Style and Cell that specifies what magnification to use for display. "
Magnify::usage = "\!\(\*RowBox[{\"Magnify\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents an object to be displayed with magnification \!\(\*StyleBox[\"r\", \"TI\"]\). \n\!\(\*RowBox[{\"Magnify\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays with \!\(\*StyleBox[\"expr\", \"TI\"]\) magnified by a fixed factor."
MailReceiverFunction::usage = "\!\(\*RowBox[{\"MailReceiverFunction\", \"[\", StyleBox[\"fun\", \"TI\"], \"]\"}]\) represents a mail receiver function that applies \!\(\*StyleBox[\"fun\", \"TI\"]\) to any mail message it receives."
MailResponseFunction::usage = "MailResponseFunction is an option for MailReceiverFunction that specifies what function to apply to respond to the sender of mail received by a MailReceiverFunction."
MainSolve::usage = "\!\(\*RowBox[{\"MainSolve\", \"[\", StyleBox[\"eqns\", \"TI\"], \"]\"}]\) is the underlying function for transforming systems of equations. Solve and Eliminate call it. The equations must be of the form \!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \" \", \"==\", \" \", StyleBox[\"rhs\", \"TI\"]}]\). They can be combined using && and ||. MainSolve returns False if no solutions to the equations exist, and True if all values of variables are solutions. MainSolve rearranges the equations using certain directives. \!\(\*RowBox[{\"MainSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", \" \", StyleBox[\"vars\", \"TI\"], \",\", \" \", StyleBox[\"elim\", \"TI\"], \",\", \" \", StyleBox[\"rest\", \"TI\"]}], \"]\"}]\) attempts to rearrange the equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) so as to solve for the variables \!\(\*StyleBox[\"vars\", \"TI\"]\), and eliminate the variables \!\(\*StyleBox[\"elim\", \"TI\"]\). The list \!\(\*StyleBox[\"rest\", \"TI\"]\) can be included to specify the elimination order for any remaining variables."
Majority::usage = "\!\(\*RowBox[{\"Majority\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives True if the majority of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are True, and False if the majority are False."
MakeBoxes::usage = "\!\(\*RowBox[{MakeBoxes, \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) is the low\[Hyphen]level function used in \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) sessions to convert expressions into boxes. \n\!\(\*RowBox[{MakeBoxes, \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) is the function to convert \!\(\*StyleBox[\"expr\", \"TI\"]\) to StandardForm boxes."
MakeExpression::usage = "\!\(\*RowBox[{\"MakeExpression\", \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) is the low\[Hyphen]level function used in \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) sessions to construct expressions from boxes. "
MakeRules::usage = "MakeRules is an option to Solve and related functions. With \!\(\*RowBox[{\"MakeRules\", \" \", \"->\", \" \", \"True\"}]\), the result is presented as an AlgebraicRulesData object. With \!\(\*RowBox[{\"MakeRules\", \" \", \"->\", \" \", \"False\"}]\), the result is presented as a list of rules."
ManagedLibraryExpressionID::usage = "\!\(\*RowBox[{\"ManagedLibraryExpressionID\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the positive integer ID associated with \!\(\*StyleBox[\"expr\", \"TI\"]\) if it is a managed library expression and $Failed otherwise.\n\!\(\*RowBox[{\"ManagedLibraryExpressionID\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"mname\", \"TI\"]}], \"]\"}]\) only returns the ID if \!\(\*StyleBox[\"expr\", \"TI\"]\) is associated with the registered manager having name \!\(\*StyleBox[\"mname\", \"TI\"]\)."
ManagedLibraryExpressionQ::usage = "\!\(\*RowBox[{\"ManagedLibraryExpressionQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a managed library expression and False otherwise.\n\!\(\*RowBox[{\"ManagedLibraryExpressionQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"mname\", \"TI\"]}], \"]\"}]\) only returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is associated with the registered manager having name \!\(\*StyleBox[\"mname\", \"TI\"]\)."
MandelbrotSetBoettcher::usage = "\!\(\*RowBox[{\"MandelbrotSetBoettcher\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives an approximation of the B\[ODoubleDot]ttcher function of \!\(\*StyleBox[\"z\", \"TI\"]\), which maps the complement of the Mandelbrot set conformally to the complement of the closed unit disk."
MandelbrotSetDistance::usage = "\!\(\*RowBox[{\"MandelbrotSetDistance\", \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) estimates the distance from \!\(\*StyleBox[\"c\", \"TI\"]\) to the nearest point in the Mandelbrot set.\n\!\(\*RowBox[{\"MandelbrotSetDistance\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"\\\"Interior\\\"\",ShowStringCharacters->True]}], \"]\"}]\) estimates the distance from \!\(\*StyleBox[\"c\", \"TI\"]\) to the nearest point in the complement of the Mandelbrot set."
MandelbrotSetIterationCount::usage = "\!\(\*RowBox[{\"MandelbrotSetIterationCount\", \"[\", StyleBox[\"c\", \"TI\"], \"]\"}]\) returns the number of iterations of the function \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}], \"\[LongEqual]\", RowBox[{SuperscriptBox[StyleBox[\"z\", \"TI\"], \"2\"], \"+\", StyleBox[\"c\", \"TI\"]}]}]\), beginning with \!\(\*RowBox[{StyleBox[\"z\", \"TI\"], \"\[LongEqual]\", \"0\"}]\), that are needed to determine whether \!\(\*StyleBox[\"c\", \"TI\"]\) is in the Mandelbrot set."
MandelbrotSetMemberQ::usage = "\!\(\*RowBox[{\"MandelbrotSetMemberQ\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"z\", \"TI\"]\) is in the Mandelbrot set, and False otherwise."
MandelbrotSetPlot::usage = "\!\(\*RowBox[{\"MandelbrotSetPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \"]\"}]\) plots the portion of the Mandelbrot set inside the rectangle with corners \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"MandelbrotSetPlot\", \"[\", \"]\"}]\) plots the Mandelbrot set over a default rectangle."
MangoldtLambda::usage = "\!\(\*RowBox[{\"MangoldtLambda\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the von Mangoldt function \!\(\*RowBox[{\"\[CapitalLambda]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\)."
ManhattanDistance::usage = "\!\(\*RowBox[{\"ManhattanDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Manhattan or \"city block\" distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
Manipulate::usage = "\!\(\*RowBox[{\"Manipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a version of \!\(\*StyleBox[\"expr\", \"TI\"]\) with controls added to allow interactive manipulation of the value of \!\(\*StyleBox[\"u\", \"TI\"]\). \n\!\(\*RowBox[{\"Manipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"du\", \"TI\"]}], \"}\"}]}], \"]\"}]\) allows the value of \!\(\*StyleBox[\"u\", \"TI\"]\) to vary between \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) in steps \!\(\*StyleBox[\"du\", \"TI\"]\). \n\!\(\*RowBox[{\"Manipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"init\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the initial value of \!\(\*StyleBox[\"u\", \"TI\"]\) to be \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"init\", \"TI\"]]\). \n\!\(\*RowBox[{\"Manipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"init\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"lbl\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) labels the controls for \!\(\*StyleBox[\"u\", \"TI\"]\) with \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"lbl\", \"TI\"]]\). \n\!\(\*RowBox[{\"Manipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) allows \!\(\*StyleBox[\"u\", \"TI\"]\) to take on discrete values \!\(\*RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\). \n\!\(\*RowBox[{\"Manipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) provides controls to manipulate each of the \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\). \n\!\(\*RowBox[{\"Manipulate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"u\", \"TI\"]], \"\[Rule]\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"v\", \"TI\"]], \"\[Rule]\", RowBox[{\"{\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) links the controls to the specified controllers on an external device."
Manipulator::usage = "\!\(\*RowBox[{\"Manipulator\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a manipulator with setting \!\(\*StyleBox[\"x\", \"TI\"]\) in the range 0 to 1. \n\!\(\*RowBox[{\"Manipulator\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being reset if the manipulator is moved. \n\!\(\*RowBox[{\"Manipulator\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a manipulator with range \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"Manipulator\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents a manipulator that jumps in steps \!\(\*StyleBox[\"dx\", \"TI\"]\). "
MannedSpaceMissionData::usage = "\!\(\*RowBox[{\"MannedSpaceMissionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the manned space mission \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"MannedSpaceMissionData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified manned space mission entities.\n\!\(\*RowBox[{\"MannedSpaceMissionData\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
MannWhitneyTest::usage = "\!\(\*RowBox[{\"MannWhitneyTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the medians of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"MannWhitneyTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) tests the median difference against \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"MannWhitneyTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
MantissaExponent::usage = "\!\(\*RowBox[{\"MantissaExponent\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives a list containing the mantissa and exponent of a number \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"MantissaExponent\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the base\[Hyphen]\!\(\*StyleBox[\"b\", \"TI\"]\) mantissa and exponent of \!\(\*StyleBox[\"x\", \"TI\"]\). "
Manual::usage = "Manual represents an option or other value that is to be selected manually, usually by some form of interactive manipulation."
MapAll::usage = "\!\(\*RowBox[{\"MapAll\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"//@\", StyleBox[\"expr\", \"TI\"]}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to every subexpression in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
MapAt::usage = "\!\(\*RowBox[{\"MapAt\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the element at position \!\(\*StyleBox[\"n\", \"TI\"]\) in \!\(\*StyleBox[\"expr\", \"TI\"]\). If \!\(\*StyleBox[\"n\", \"TI\"]\) is negative, the position is counted from the end. \n\!\(\*RowBox[{\"MapAt\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the part of \!\(\*StyleBox[\"expr\", \"TI\"]\) at position \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"MapAt\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) at several positions. \n\!\(\*RowBox[{\"MapAt\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) represents an operator form of MapAt that can be applied to an expression."
MapIndexed::usage = "\!\(\*RowBox[{\"MapIndexed\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the elements of \!\(\*StyleBox[\"expr\", \"TI\"]\), giving the part specification of each element as a second argument to \!\(\*StyleBox[\"f\", \"TI\"]\). \n\!\(\*RowBox[{\"MapIndexed\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to all parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) on levels specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"MapIndexed\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of MapIndexed that can be applied to an expression."
MAProcess::usage = "\!\(\*RowBox[{\"MAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents a moving-average process of order \!\(\*StyleBox[\"q\", \"TI\"]\) with normal white noise variance \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"MAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a vector MA process with multinormal white noise covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"MAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) represents an MA process with initial data \!\(\*StyleBox[\"init\", \"TI\"]\). \n\!\(\*RowBox[{\"MAProcess\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents an MA process with a constant \!\(\*StyleBox[\"c\", \"TI\"]\)."
MapThread::usage = "\!\(\*RowBox[{\"MapThread\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"MapThread\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the parts of the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at level \!\(\*StyleBox[\"n\", \"TI\"]\). "
Map::usage = "\!\(\*RowBox[{\"Map\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"/@\", StyleBox[\"expr\", \"TI\"]}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to each element on the first level in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Map\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"Map\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of Map that can be applied to an expression."
MarchenkoPasturDistribution::usage = "\!\(\*RowBox[{\"MarchenkoPasturDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a Marchenko\[Dash]Pastur distribution with asymptotic ratio \[Lambda] and scale parameter \[Sigma].\n\!\(\*RowBox[{\"MarchenkoPasturDistribution\", \"[\", StyleBox[\"\[Lambda]\", \"TR\"], \"]\"}]\) represents a Marchenko\[Dash]Pastur distribution with unit scale parameter."
MarcumQ::usage = "\!\(\*RowBox[{\"MarcumQ\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives Marcum's Q function \!\(\*RowBox[{SubscriptBox[StyleBox[\"Q\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \")\"}]\).\n\!\(\*RowBox[{\"MarcumQ\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}]\) gives Marcum's Q function \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"Q\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], \"0\"]}], \")\"}], \"-\", RowBox[{SubscriptBox[StyleBox[\"Q\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], \"1\"]}], \")\"}]}]\)."
MardiaCombinedTest::usage = "\!\(\*RowBox[{\"MardiaCombinedTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) follows a MultinormalDistribution using the Mardia combined test.\n\!\(\*RowBox[{\"MardiaCombinedTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
MardiaKurtosisTest::usage = "\!\(\*RowBox[{\"MardiaKurtosisTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) follows a MultinormalDistribution using the Mardia kurtosis test.\n\!\(\*RowBox[{\"MardiaKurtosisTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
MardiaSkewnessTest::usage = "\!\(\*RowBox[{\"MardiaSkewnessTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) follows a MultinormalDistribution using the Mardia skewness test.\n\!\(\*RowBox[{\"MardiaSkewnessTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
MarginalDistribution::usage = "\!\(\*RowBox[{\"MarginalDistribution\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents a univariate marginal distribution of the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) coordinate from the multivariate distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"MarginalDistribution\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a multivariate marginal distribution of the \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) coordinates."
MarkovProcessProperties::usage = "\!\(\*RowBox[{\"MarkovProcessProperties\", \"[\", StyleBox[\"mproc\", \"TI\"], \"]\"}]\) gives a summary of properties for the finite state Markov process \!\(\*StyleBox[\"mproc\", \"TI\"]\).\n\!\(\*RowBox[{\"MarkovProcessProperties\", \"[\", RowBox[{StyleBox[\"mproc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\" for the process \!\(\*StyleBox[\"mproc\", \"TI\"]\)."
Masking::usage = "Masking is an option for various image analysis and processing functions that specifies on which regions they should operate."
MatchingDissimilarity::usage = "\!\(\*RowBox[{\"MatchingDissimilarity\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the matching dissimilarity between Boolean vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
MatchLocalNameQ::usage = "MatchLocalNameQ is an internal symbol."
MatchLocalNames::usage = "MatchLocalNames is an option for Trace and related functions that specifies whether symbols such as \!\(\*StyleBox[\"x\", \"TI\"]\) should match symbols with local names of the form \!\(\*StyleBox[RowBox[{StyleBox[\"x\", \"TI\"], \"$\", StyleBox[\"nnn\", \"TI\"]}]]\). "
MatchQ::usage = "\!\(\*RowBox[{\"MatchQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) returns True if the pattern \!\(\*StyleBox[\"form\", \"TI\"]\) matches \!\(\*StyleBox[\"expr\", \"TI\"]\), and returns False otherwise.\n\!\(\*RowBox[{\"MatchQ\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) represents an operator form of MatchQ that can be applied to an expression."
MathematicalFunctionData::usage = "\!\(\*RowBox[{\"MathematicalFunctionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the mathematical function specified by \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"MathematicalFunctionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the sub-property \!\(\*StyleBox[\"annotation\", \"TI\"]\) corresponding to the given \!\(\*StyleBox[\"entity\", \"TI\"]\) and \!\(\*StyleBox[\"property\", \"TI\"]\).\t\n\!\(\*RowBox[{\"MathematicalFunctionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}]}], \"]\"}]\) gives the property value with the property qualifiers \!\(\*SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) set to the given values.\n\!\(\*RowBox[{\"MathematicalFunctionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}]}], \"]\"}]\) gives the sub-property \!\(\*StyleBox[\"annotation\", \"TI\"]\) corresponding to the given \!\(\*StyleBox[\"entity\", \"TI\"]\) and \!\(\*StyleBox[\"property\", \"TI\"]\) with the property qualifiers \!\(\*SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"qual\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) set to the given values."
MathieuCharacteristicA::usage = "\!\(\*RowBox[{\"MathieuCharacteristicA\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the characteristic value \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"r\", \"TI\"]]\) for even Mathieu functions with characteristic exponent \!\(\*StyleBox[\"r\", \"TI\"]\) and parameter \!\(\*StyleBox[\"q\", \"TI\"]\). "
MathieuCharacteristicB::usage = "\!\(\*RowBox[{\"MathieuCharacteristicB\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the characteristic value \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"r\", \"TI\"]]\) for odd Mathieu functions with characteristic exponent \!\(\*StyleBox[\"r\", \"TI\"]\) and parameter \!\(\*StyleBox[\"q\", \"TI\"]\). "
MathieuCharacteristicExponent::usage = "\!\(\*RowBox[{\"MathieuCharacteristicExponent\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the characteristic exponent \!\(\*StyleBox[\"r\", \"TI\"]\) for Mathieu functions with characteristic value \!\(\*StyleBox[\"a\", \"TI\"]\) and parameter \!\(\*StyleBox[\"q\", \"TI\"]\). "
MathieuCPrime::usage = "\!\(\*RowBox[{\"MathieuCPrime\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the derivative with respect to \!\(\*StyleBox[\"z\", \"TI\"]\) of the even Mathieu function with characteristic value \!\(\*StyleBox[\"a\", \"TI\"]\) and parameter \!\(\*StyleBox[\"q\", \"TI\"]\). "
MathieuC::usage = "\!\(\*RowBox[{\"MathieuC\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the even Mathieu function with characteristic value \!\(\*StyleBox[\"a\", \"TI\"]\) and parameter\[NonBreakingSpace]\!\(\*StyleBox[\"q\", \"TI\"]\). "
MathieuGroupM11::usage = "\!\(\*RowBox[{\"MathieuGroupM11\", \"[\", \"]\"}]\) represents the sporadic simple Mathieu group \!\(\*SubscriptBox[StyleBox[\"M\", \"TI\"], \"11\"]\)."
MathieuGroupM12::usage = "\!\(\*RowBox[{\"MathieuGroupM12\", \"[\", \"]\"}]\) represents the sporadic simple Mathieu group \!\(\*SubscriptBox[StyleBox[\"M\", \"TI\"], \"12\"]\)."
MathieuGroupM22::usage = "\!\(\*RowBox[{\"MathieuGroupM22\", \"[\", \"]\"}]\) represents the sporadic simple Mathieu group \!\(\*SubscriptBox[StyleBox[\"M\", \"TI\"], \"22\"]\)."
MathieuGroupM23::usage = "\!\(\*RowBox[{\"MathieuGroupM23\", \"[\", \"]\"}]\) represents the sporadic simple Mathieu group \!\(\*SubscriptBox[StyleBox[\"M\", \"TI\"], \"23\"]\)."
MathieuGroupM24::usage = "\!\(\*RowBox[{\"MathieuGroupM24\", \"[\", \"]\"}]\) represents the sporadic simple Mathieu group \!\(\*SubscriptBox[StyleBox[\"M\", \"TI\"], \"24\"]\)."
MathieuSPrime::usage = "\!\(\*RowBox[{\"MathieuSPrime\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the derivative with respect to \!\(\*StyleBox[\"z\", \"TI\"]\) of the odd Mathieu function with characteristic value \!\(\*StyleBox[\"a\", \"TI\"]\) and parameter \!\(\*StyleBox[\"q\", \"TI\"]\). "
MathieuS::usage = "\!\(\*RowBox[{\"MathieuS\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the odd Mathieu function with characteristic value \!\(\*StyleBox[\"a\", \"TI\"]\) and parameter\[NonBreakingSpace]\!\(\*StyleBox[\"q\", \"TI\"]\). "
MathMLForm::usage = "\!\(\*RowBox[{\"MathMLForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as a MathML form of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Matrices::usage = "\!\(\*RowBox[{\"Matrices\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents the domain of matrices of dimensions \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"Matrices\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) represents the domain of matrices of dimensions \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), with components in the domain \!\(\*StyleBox[\"dom\", \"TI\"]\).\n\!\(\*RowBox[{\"Matrices\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"dom\", \"TI\"], \",\", StyleBox[\"sym\", \"TI\"]}], \"]\"}]\) represents the subdomain of matrices \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with symmetry \!\(\*StyleBox[\"sym\", \"TI\"]\)."
MatrixExp::usage = "\!\(\*RowBox[{\"MatrixExp\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the matrix exponential of \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"MatrixExp\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the matrix exponential of \!\(\*StyleBox[\"m\", \"TI\"]\) applied to the vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
MatrixForm::usage = "\!\(\*RowBox[{\"MatrixForm\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) prints with the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) arranged in a regular array. "
MatrixFunction::usage = "\!\(\*RowBox[{\"MatrixFunction\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the matrix generated by the scalar function \!\(\*StyleBox[\"f\", \"TI\"]\) at the matrix argument \!\(\*StyleBox[\"m\", \"TI\"]\)."
MatrixLog::usage = "\!\(\*RowBox[{\"MatrixLog\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the matrix logarithm of a matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
MatrixNormalDistribution::usage = "\!\(\*RowBox[{\"MatrixNormalDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"row\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"col\", \"TI\"]]}], \"]\"}]\) represents zero mean matrix normal distribution with row covariance matrix \!\(\*SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"row\", \"TI\"]]\) and column covariance matrix \!\(\*SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"col\", \"TI\"]]\).\n\!\(\*RowBox[{\"MatrixNormalDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"row\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"col\", \"TI\"]]}], \"]\"}]\) represents matrix normal distribution with mean matrix \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
MatrixPlot::usage = "\!\(\*RowBox[{\"MatrixPlot\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) generates a plot that gives a visual representation of the values of elements in a matrix."
MatrixPower::usage = "\!\(\*RowBox[{\"MatrixPower\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[RowBox[{StyleBox[\"n\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) matrix power of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"MatrixPower\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) matrix power of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\) applied to the vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
MatrixPropertyDistribution::usage = "\!\(\*RowBox[{\"MatrixPropertyDistribution\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"mdist\", \"TI\"]}]}], \"]\"}]\) represents the distribution of the matrix property \!\(\*StyleBox[\"expr\", \"TI\"]\) where the matrix-valued random variable \!\(\*StyleBox[\"x\", \"TI\"]\) follows the matrix distribution \!\(\*StyleBox[\"mdist\", \"TI\"]\).\n\!\(\*RowBox[{\"MatrixPropertyDistribution\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"mdist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"mdist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the distribution where \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] are independent and follow the matrix distributions \!\(\*SubscriptBox[StyleBox[\"mdist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"mdist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
MatrixQ::usage = "\!\(\*RowBox[{\"MatrixQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a list of lists or a two-dimensional SparseArray object that can represent a matrix, and gives False otherwise. \n\!\(\*RowBox[{\"MatrixQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) gives True only if \!\(\*StyleBox[\"test\", \"TI\"]\) yields True when applied to each of the matrix elements in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
MatrixRank::usage = "\!\(\*RowBox[{\"MatrixRank\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the rank of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\). "
MatrixTDistribution::usage = "\!\(\*RowBox[{\"MatrixTDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"row\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"col\", \"TI\"]], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents zero mean matrix \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with row covariance matrix \!\(\*SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"row\", \"TI\"]]\), column covariance matrix \!\(\*SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"col\", \"TI\"]]\), and degrees of freedom parameter \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\).\n\!\(\*RowBox[{\"MatrixTDistribution\", \"[\", RowBox[{\"\[Mu]\", \",\", SubscriptBox[\"\[CapitalSigma]\", StyleBox[\"row\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[CapitalSigma]\", \"TR\"], StyleBox[\"col\", \"TI\"]], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents matrix \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with mean matrix \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
MaxCellMeasure::usage = "MaxCellMeasure is an option for DiscretizeRegion and related functions that specifies the maximum cell measure for the result."
MaxDetect::usage = "\!\(\*RowBox[{\"MaxDetect\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a binary image in which white pixels correspond to constant extended maxima in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"MaxDetect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) finds extended maxima where the range of values is not greater than \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"MaxDetect\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies maxima detection to an array of data."
MaxExtraBandwidths::usage = "MaxExtraBandwidths is an option to SmoothKernelDistribution that controls the behavior outside that data range."
MaxExtraConditions::usage = "MaxExtraConditions is an option to Solve and related functions that specifies how many extra equational conditions on continuous parameters to allow in solutions that are given."
MaxFeatureDisplacement::usage = "MaxFeatureDisplacement is an option that specifies the maximum displacement allowed for any feature."
MaxFeatures::usage = "MaxFeatures is an option that specifies the maximum number of features that will be returned from feature detection algorithms."
MaxFilter::usage = "\!\(\*RowBox[{\"MaxFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every value by the maximum in its range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"MaxFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies max filtering to an array of data."
MaximalBy::usage = "\!\(\*RowBox[{\"MaximalBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) returns a list of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for which the value of \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is maximal.\n\!\(\*RowBox[{\"MaximalBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns a list of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the \!\(\*StyleBox[\"n\", \"TI\"]\) largest \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\).\n\!\(\*RowBox[{\"MaximalBy\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of MaximalBy that can be applied to an expression."
Maximize::usage = "\!\(\*RowBox[{\"Maximize\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) maximizes \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"Maximize\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) maximizes \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis]. \n\!\(\*RowBox[{\"Maximize\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) maximizes \!\(\*StyleBox[\"f\", \"TI\"]\) subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"Maximize\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"Maximize\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) constrains variables to the domain \!\(\*StyleBox[\"dom\", \"TI\"]\), typically Reals or Integers."
MaxItems::usage = "MaxItems is an option that specifies the maximum number of items to be used or shown."
MaxIterations::usage = "MaxIterations is an option that specifies the maximum number of iterations that should be tried in various built-in functions and algorithms."
MaxMemoryUsed::usage = "\!\(\*RowBox[{\"MaxMemoryUsed\", \"[\", \"]\"}]\) gives the maximum number of bytes used to store all data for the current \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) session.\n\!\(\*RowBox[{\"MaxMemoryUsed\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the maximum number of bytes used during the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
MaxMixtureKernels::usage = "MaxMixtureKernels is an option for SmoothKernelDistribution and related functions that specifies the maximum number and location of kernel functions to use in the estimation."
MaxPlotPoints::usage = "MaxPlotPoints is an option for plotting functions like ArrayPlot and ListPlot3D that specifies the maximum number of points that will explicitly be included in the output. "
MaxPoints::usage = "MaxPoints is an option for NIntegrate specifying the maximum total number of times to sample the integrand."
MaxRecursion::usage = "MaxRecursion is an option for functions like NIntegrate and Plot that specifies how many recursive subdivisions can be made. "
MaxStableDistribution::usage = "\!\(\*RowBox[{\"MaxStableDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"\[Xi]\", \"TR\"]}], \"]\"}]\) represents a generalized maximum extreme value distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\), and shape parameter \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\)."
MaxStepFraction::usage = "MaxStepFraction is an option to functions like NDSolve that specifies the maximum fraction of the total range to cover in a single step."
MaxStepSize::usage = "MaxStepSize is an option to functions like NDSolve that specifies the maximum size of a single step used in generating a result."
MaxSteps::usage = "MaxSteps is an option to functions like NDSolve that specifies the maximum number of steps to take in generating a result."
Max::usage = "\!\(\*RowBox[{\"Max\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields the numerically largest of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Max\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields the largest element of any of the lists. "
MaxValue::usage = "\!\(\*RowBox[{\"MaxValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the maximum value of \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"MaxValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the maximum value of \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis]. \n\!\(\*RowBox[{\"MaxValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the maximum value of \!\(\*StyleBox[\"f\", \"TI\"]\) subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"MaxValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"MaxValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) constrains variables to the domain \!\(\*StyleBox[\"dom\", \"TI\"]\), typically Reals or Integers."
MaxwellDistribution::usage = "\!\(\*RowBox[{\"MaxwellDistribution\", \"[\", StyleBox[\"\[Sigma]\", \"TR\"], \"]\"}]\) represents a Maxwell distribution with scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
McLaughlinGroupMcL::usage = "\!\(\*RowBox[{\"McLaughlinGroupMcL\", \"[\", \"]\"}]\) represents the sporadic simple McLaughlin group McL."
MeanClusteringCoefficient::usage = "\!\(\*RowBox[{\"MeanClusteringCoefficient\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the mean clustering coefficient of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"MeanClusteringCoefficient\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
MeanDegreeConnectivity::usage = "\!\(\*RowBox[{\"MeanDegreeConnectivity\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of \!\(\*StyleBox[\"k\", \"TI\"]\)-mean degree connectivity for the graph \!\(\*StyleBox[\"g\", \"TI\"]\) for successive \!\(\*RowBox[{RowBox[{StyleBox[\"k\", \"TI\"], \"=\", \"0\"}], \",\", \"1\", \",\", RowBox[{\"2\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]\) .\n\!\(\*RowBox[{\"MeanDegreeConnectivity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"In\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"k\", \"TI\"]\)-mean in-degree connectivity for the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"MeanDegreeConnectivity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"Out\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"k\", \"TI\"]\)-mean out-degree connectivity for the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"MeanDegreeConnectivity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
MeanDeviation::usage = "\!\(\*RowBox[{\"MeanDeviation\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the mean absolute deviation from the mean of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\)."
MeanFilter::usage = "\!\(\*RowBox[{\"MeanFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every value by the mean value in its range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"MeanFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies mean filtering to an array of data."
MeanGraphDistance::usage = "\!\(\*RowBox[{\"MeanGraphDistance\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the mean distance between all pairs of vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"MeanGraphDistance\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
MeanNeighborDegree::usage = "\!\(\*RowBox[{\"MeanNeighborDegree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of mean neighbor degrees of vertices for the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"MeanNeighborDegree\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"In\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of mean neighbor in-degrees.\n\!\(\*RowBox[{\"MeanNeighborDegree\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"Out\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of mean neighbor out-degrees.\n\!\(\*RowBox[{\"MeanNeighborDegree\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
MeanShiftFilter::usage = "\!\(\*RowBox[{\"MeanShiftFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) replaces each pixel with the mean of the pixels in a range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood and whose value is within a distance \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"MeanShiftFilter\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) applies mean-shift filtering to a data array."
MeanShift::usage = "\!\(\*RowBox[{\"MeanShift\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) replaces each element in \!\(\*StyleBox[\"list\", \"TI\"]\) by the mean of the values of all elements that differ by less than \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"MeanShift\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns the list where only the specified parts \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are replaced with mean-shifted values.\n\!\(\*RowBox[{\"MeanShift\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) mean shift of the pixel values in \!\(\*StyleBox[\"image\", \"TI\"]\)."
Mean::usage = "\!\(\*RowBox[{\"Mean\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the statistical mean of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Mean\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the mean of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
MedianDeviation::usage = "\!\(\*RowBox[{\"MedianDeviation\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the median absolute deviation from the median of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\)."
MedianFilter::usage = "\!\(\*RowBox[{\"MedianFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every value by the median in its range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"MedianFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies median filtering to an array of data."
Median::usage = "\!\(\*RowBox[{\"Median\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the median of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Median\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the median of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). "
MedicalTestData::usage = "\!\(\*RowBox[{\"MedicalTestData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the medical test \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"MedicalTestData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified medical test entities.\n\!\(\*RowBox[{\"MedicalTestData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
Medium::usage = "Medium is a style or option setting that specifies that objects should be medium sized."
MeijerG::usage = "\!\(\*RowBox[{\"MeijerG\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \"+\", StyleBox[\"1\", \"TR\"]}]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], RowBox[{StyleBox[\"m\", \"TI\"], \"+\", StyleBox[\"1\", \"TR\"]}]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the Meijer G function \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"G\", \"TI\"], RowBox[{StyleBox[\"p\", \"TI\"], StyleBox[\"q\", \"TI\"]}], RowBox[{StyleBox[\"m\", \"TI\"], StyleBox[\"n\", \"TI\"]}]], \"(\", RowBox[{StyleBox[\"z\", \"TI\"], \"\[VerticalSeparator]\", GridBox[{{RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}]}, {RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}]}}]}], \")\"}]\). "
MeixnerDistribution::usage = "\!\(\*RowBox[{\"MeixnerDistribution\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) represents a Meixner distribution with location parameter \!\(\*StyleBox[\"m\", \"TI\"]\), scale parameter \!\(\*StyleBox[\"a\", \"TI\"]\), skew parameter \!\(\*StyleBox[\"b\", \"TI\"]\), and shape parameter \!\(\*StyleBox[\"d\", \"TI\"]\)."
MemberQ::usage = "\!\(\*RowBox[{\"MemberQ\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) returns True if an element of \!\(\*StyleBox[\"list\", \"TI\"]\) matches \!\(\*StyleBox[\"form\", \"TI\"]\), and False otherwise. \n\!\(\*RowBox[{\"MemberQ\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) tests all parts of \!\(\*StyleBox[\"list\", \"TI\"]\) specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"MemberQ\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) represents an operator form of MemberQ that can be applied to an expression."
MemoryConstrained::usage = "\!\(\*RowBox[{\"MemoryConstrained\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), stopping if more than \!\(\*StyleBox[\"b\", \"TI\"]\) bytes of memory are requested. \n\!\(\*RowBox[{\"MemoryConstrained\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"failexpr\", \"TI\"]}], \"]\"}]\) returns \!\(\*StyleBox[\"failexpr\", \"TI\"]\) if the memory constraint is not met. "
MemoryConstraint::usage = "MemoryConstraint is an option for TestReport and VerificationTest that specifies how much memory (in bytes) the test is allowed to use."
MemoryInUse::usage = "\!\(\*RowBox[{\"MemoryInUse\", \"[\", \"]\"}]\) gives the number of bytes currently being used to store all data in the current \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) kernel session. \n\!\(\*RowBox[{\"MemoryInUse\", \"[\", \"$FrontEnd\", \"]\"}]\) gives the number of bytes used in the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) front end."
MenuCommandKey::usage = "MenuCommandKey is an option for cells that specifies the keyboard shortcut to be associated with a style listed in the \!\(\*StyleBox[\"Format \[FilledRightTriangle] Style\", \"MenuName\"]\) submenu."
MenuPacket::usage = "\!\(\*RowBox[{\"MenuPacket\", \"[\", RowBox[{StyleBox[\"integer\", \"TI\"], \",\", StyleBox[\"string\", \"TI\"]}], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet indicating a menu request with title \!\(\*StyleBox[\"string\", \"TI\"]\)."
MenuSortingValue::usage = "MenuSortingValue is an option for cells and notebooks that specifies where a cell style, stylesheet, or palette is listed in the \!\(\*StyleBox[\"Format \[FilledRightTriangle] Style\", \"MenuName\"]\) submenu, \!\(\*StyleBox[\"Format \[FilledRightTriangle] Stylesheet\", \"MenuName\"]\) submenu, or \!\(\*StyleBox[\"Palettes\", \"MenuName\"]\) menu respectively."
MenuStyle::usage = "MenuStyle is an option for menu-generating constructs that specifies the style to use in displaying menu items. "
MenuView::usage = "\!\(\*RowBox[{\"MenuView\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an object in which selecting the menu item with label \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) displays \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"MenuView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) makes the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) item be the one currently selected.\n\!\(\*RowBox[{\"MenuView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) associates values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with successive menu items, and makes the item with value \!\(\*StyleBox[\"v\", \"TI\"]\) be the one currently selected. \n\!\(\*RowBox[{\"MenuView\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) takes the menu items' labels to be successive integers."
Merge::usage = "\!\(\*RowBox[{\"Merge\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) merges the associations \!\(\*SubscriptBox[StyleBox[\"assoc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), using the function \!\(\*StyleBox[\"f\", \"TI\"]\) to combine values with the same key. \n\!\(\*RowBox[{\"Merge\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gives an association in which values corresponding to identical keys are combined using \!\(\*StyleBox[\"f\", \"TI\"]\). \n\!\(\*RowBox[{\"Merge\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of Merge that can be applied to an expression."
MeshCellCentroid::usage = "MeshCellCentroid is a property of MeshRegion and BoundaryMeshRegion objects that gives the centroids of mesh cells."
MeshCellCount::usage = "\!\(\*RowBox[{\"MeshCellCount\", \"[\", StyleBox[\"mreg\", \"TI\"], \"]\"}]\) gives a list \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) of counts \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"d\", \"TI\"]]\) of cells of dimension \!\(\*StyleBox[\"d\", \"TI\"]\) in the mesh region \!\(\*StyleBox[\"mreg\", \"TI\"]\). \n\!\(\*RowBox[{\"MeshCellCount\", \"[\", RowBox[{StyleBox[\"mreg\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the total count of cells of dimension \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"MeshCellCount\", \"[\", RowBox[{StyleBox[\"mreg\", \"TI\"], \",\", StyleBox[\"cellspec\", \"TI\"]}], \"]\"}]\) gives the total count of cells specified by \!\(\*StyleBox[\"cellspec\", \"TI\"]\)."
MeshCellHighlight::usage = "MeshCellHighlight is an option and property of MeshRegion, BoundaryMeshRegion, and related functions that specifies mesh cells to highlight."
MeshCellIndex::usage = "\!\(\*RowBox[{\"MeshCellIndex\", \"[\", RowBox[{StyleBox[\"mreg\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the cell indices for cells of dimension \!\(\*StyleBox[\"d\", \"TI\"]\) in the mesh region \!\(\*StyleBox[\"mreg\", \"TI\"]\).\n\!\(\*RowBox[{\"MeshCellIndex\", \"[\", RowBox[{StyleBox[\"mreg\", \"TI\"], \",\", StyleBox[\"cellspec\", \"TI\"]}], \"]\"}]\) gives the cell indices for the cells specified by \!\(\*StyleBox[\"cellspec\", \"TI\"]\)."
MeshCellLabel::usage = "MeshCellLabel is an option to MeshRegion, BoundaryMeshRegion and related functions that specifies labels and placements for mesh cells. "
MeshCellMarker::usage = "MeshCellMarker is an option to MeshRegion and BoundaryMeshRegion that specifies integer markers to associate with mesh cells. "
MeshCellMeasure::usage = "MeshCellMeasure is a property of MeshRegion and BoundaryMeshRegion objects that gives the measures of mesh cells."
MeshCellQuality::usage = "MeshCellQuality is a property of MeshRegion and BoundaryMeshRegion objects that gives a quality measure for mesh cells."
MeshCellShapeFunction::usage = "MeshCellShapeFunction is an option and property for MeshRegion, BoundaryMeshRegion, and related functions that specifies functions to use to generate primitives for rendering mesh cells."
MeshCellStyle::usage = "MeshCellStyle is an option and property of MeshRegion, BoundaryMeshRegion, and related functions that specifies styles to use for mesh cells. "
MeshCells::usage = "\!\(\*RowBox[{\"MeshCells\", \"[\", RowBox[{StyleBox[\"mreg\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the cells of dimension \!\(\*StyleBox[\"d\", \"TI\"]\) in the mesh region \!\(\*StyleBox[\"mreg\", \"TI\"]\).\n\!\(\*RowBox[{\"MeshCells\", \"[\", RowBox[{StyleBox[\"mreg\", \"TI\"], \",\", StyleBox[\"cellspec\", \"TI\"]}], \"]\"}]\) gives the cells specified by \!\(\*StyleBox[\"cellspec\", \"TI\"]\). "
MeshCoordinates::usage = "\!\(\*RowBox[{\"MeshCoordinates\", \"[\", StyleBox[\"mreg\", \"TI\"], \"]\"}]\) gives a list of coordinates in the mesh region \!\(\*StyleBox[\"mreg\", \"TI\"]\)."
MeshFunctions::usage = "MeshFunctions is an option for plotting functions that specifies functions to use to determine the placement of mesh divisions. "
MeshPrimitives::usage = "\!\(\*RowBox[{\"MeshPrimitives\", \"[\", RowBox[{StyleBox[\"mreg\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the graphics primitives for cells of dimension \!\(\*StyleBox[\"d\", \"TI\"]\) in the mesh region \!\(\*StyleBox[\"mreg\", \"TI\"]\).\n\!\(\*RowBox[{\"MeshPrimitives\", \"[\", RowBox[{StyleBox[\"mreg\", \"TI\"], \",\", StyleBox[\"cellspec\", \"TI\"]}], \"]\"}]\) gives the primitives specified by \!\(\*StyleBox[\"cellspec\", \"TI\"]\)."
MeshQualityGoal::usage = "MeshQualityGoal is an option for DiscretizeRegion and related functions that specifies a mesh cell quality goal for the result."
MeshRefinementFunction::usage = "MeshRefinementFunction is an option for DiscretizeRegion and related functions that specifies a function to indicate whether mesh cells should be refined or not."
MeshRegionQ::usage = "\!\(\*RowBox[{\"MeshRegionQ\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) yields True if the region \!\(\*StyleBox[\"reg\", \"TI\"]\) is a valid MeshRegion object and False otherwise."
MeshRegion::usage = "\!\(\*RowBox[{\"MeshRegion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"mcell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"mcell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields a mesh with cells \!\(\*SubscriptBox[StyleBox[\"mcell\", \"TI\"], StyleBox[\"j\", \"TI\"]]\), where coordinates given as integer \!\(\*StyleBox[\"i\", \"TI\"]\) are taken to be \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"MeshRegion\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"mcell\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields a mesh with cell properties defined by the symbolic wrapper \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
MeshShading::usage = "MeshShading is an option for plotting functions that gives lists of colors to use for regions between mesh divisions. "
MeshStyle::usage = "MeshStyle is an option for Plot3D, DensityPlot, and other plotting functions that specifies the style in which to draw a mesh. "
Mesh::usage = "Mesh is an option for Plot3D, DensityPlot, and other plotting functions that specifies what mesh should be drawn. "
MessageDialog::usage = "\!\(\*RowBox[{\"MessageDialog\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) puts up a standard message dialog that displays \!\(\*StyleBox[\"expr\", \"TI\"]\) together with an \!\(\*StyleBox[\"OK\", \"DialogElementName\"]\) button.\n\!\(\*RowBox[{\"MessageDialog\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \":>\", SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \":>\", SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) includes buttons with labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that evaluate the corresponding \!\(\*SubscriptBox[StyleBox[\"act\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) if clicked."
MessageList::usage = "\!\(\*RowBox[{\"MessageList\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) is a global object assigned to be a list of the names of messages generated during the processing of the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) input line. "
MessageName::usage = "\!\(\*RowBox[{StyleBox[\"symbol\", \"TI\"], \"::\", StyleBox[\"tag\", \"TI\"]}]\) is a name for a message. "
MessagePacket::usage = "\!\(\*RowBox[{\"MessagePacket\", \"[\", RowBox[{StyleBox[\"symbol\", \"TI\"], \",\", StyleBox[\"string\", \"TI\"]}], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet containing a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) message identifier of the form \!\(\*RowBox[{StyleBox[\"symbol\", \"TI\"], \"::\", StyleBox[\"string\", \"TI\"]}]\)."
Messages::usage = "\!\(\*RowBox[{\"Messages\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) gives all the messages assigned to a particular symbol. "
Message::usage = "\!\(\*RowBox[{\"Message\", \"[\", RowBox[{StyleBox[\"symbol\", \"TI\"], \"::\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) prints the message \!\(\*RowBox[{StyleBox[\"symbol\", \"TI\"], \"::\", StyleBox[\"tag\", \"TI\"]}]\) unless it has been switched off. \n\!\(\*RowBox[{\"Message\", \"[\", RowBox[{RowBox[{StyleBox[\"symbol\", \"TI\"], \"::\", StyleBox[\"tag\", \"TI\"]}], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) prints a message, inserting the values of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as needed. "
MetaCharacters::usage = "MetaCharacters is an option to StringPosition. With \!\(\*RowBox[{\"MetaCharacters\", \" \", \"->\", \" \", \"None\"}]\), no strings have special meanings. \!\(\*RowBox[{\"MetaCharacters\", \" \", \"->\", \" \", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \" \", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \" \", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]}]\) specifies the metacharacters for pattern escape, single character matching and multiple character matching. \!\(\*RowBox[{\"MetaCharacters\", \" \", \"->\", \" \", \"Automatic\"}]\) is equivalent to MetaCharacters -> {\"\\\\\", \".\", \"*\"}."
MetaInformation::usage = "MetaInformation is an option giving meta-information for Image, CloudObject, and other objects."
MeteorShowerData::usage = "\!\(\*RowBox[{\"MeteorShowerData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the meteor shower \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"MeteorShowerData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified meteor shower entities.\n\!\(\*RowBox[{\"MeteorShowerData\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
Method::usage = "Method is an option for various algorithm-intensive functions that specifies what internal methods they should use."
MexicanHatWavelet::usage = "\!\(\*RowBox[{\"MexicanHatWavelet\", \"[\", \"]\"}]\) represents the Mexican hat wavelet of width 1.\n\!\(\*RowBox[{\"MexicanHatWavelet\", \"[\", StyleBox[\"\[Sigma]\", \"TR\"], \"]\"}]\) represents the Mexican hat wavelet of width \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
MeyerWavelet::usage = "\!\(\*RowBox[{\"MeyerWavelet\", \"[\", \"]\"}]\) represents the Meyer wavelet of order 3.\n\!\(\*RowBox[{\"MeyerWavelet\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the Meyer wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\) evaluated on the equally spaced interval \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"-\", \"10\"}], \",\", \"10\"}], \"}\"}]\).\n\!\(\*RowBox[{\"MeyerWavelet\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"lim\", \"TI\"]}], \"]\"}]\) represents the Meyer wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\) evaluated on the equally spaced interval \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"-\", StyleBox[\"lim\", \"TI\"]}], \",\", StyleBox[\"lim\", \"TI\"]}], StyleBox[\"}\", \"TI\"]}]\). "
MinColorDistance::usage = "MinColorDistance is an option for DominantColors that specifies the minimum distance between returned colors."
MinDetect::usage = "\!\(\*RowBox[{\"MinDetect\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a binary image in which white pixels correspond to constant extended minima in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"MinDetect\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) finds extended minima where the range of values is not greater than \!\(\*StyleBox[\"h\", \"TI\"]\).\n\!\(\*RowBox[{\"MinDetect\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies minima detection to an array of data."
MineralData::usage = "\!\(\*RowBox[{\"MineralData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the mineral \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"MineralData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified mineral entities.\n\!\(\*RowBox[{\"MineralData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
MinFilter::usage = "\!\(\*RowBox[{\"MinFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every value by the minimum in its range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"MinFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies min filtering to an array of data."
MinimalBy::usage = "\!\(\*RowBox[{\"MinimalBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) returns a list of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for which the value of \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is minimal.\n\!\(\*RowBox[{\"MinimalBy\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns a list of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the \!\(\*StyleBox[\"n\", \"TI\"]\) smallest \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\).\n\!\(\*RowBox[{\"MinimalBy\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of MinimalBy that can be applied to an expression."
MinimalPolynomial::usage = "\!\(\*RowBox[{\"MinimalPolynomial\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the minimal polynomial in \!\(\*StyleBox[\"x\", \"TI\"]\) for which the algebraic number \!\(\*StyleBox[\"s\", \"TI\"]\) is a root. "
MinimalStateSpaceModel::usage = "\!\(\*RowBox[{\"MinimalStateSpaceModel\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives the minimal state-space model of the state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\).\n\!\(\*RowBox[{\"MinimalStateSpaceModel\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) specifies the new coordinates \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Minimize::usage = "\!\(\*RowBox[{\"Minimize\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) minimizes \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"Minimize\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) minimizes \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis]. \n\!\(\*RowBox[{\"Minimize\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) minimizes \!\(\*StyleBox[\"f\", \"TI\"]\) subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"Minimize\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"Minimize\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) constrains variables to the domain \!\(\*StyleBox[\"dom\", \"TI\"]\), typically Reals or Integers."
MinimumTimeIncrement::usage = "\!\(\*RowBox[{\"MinimumTimeIncrement\", \"[\", StyleBox[\"tseries\", \"TI\"], \"]\"}]\) gives the minimum time increment in the time series \!\(\*StyleBox[\"tseries\", \"TI\"]\)."
MinIntervalSize::usage = "MinIntervalSize is an option for IntervalSlider that specifies the minimum size of the interval during interactive editing."
MinkowskiQuestionMark::usage = "\!\(\*RowBox[{\"MinkowskiQuestionMark\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives Minkowski's question mark function \!\(\*RowBox[{\"?\", \"(x)\"}]\)."
MinMax::usage = "\!\(\*RowBox[{\"MinMax\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the list \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"Min\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \",\", RowBox[{\"Max\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]}], \"}\"}]\).\n\!\(\*RowBox[{\"MinMax\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"\[Delta]\", \"TR\"]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"Min\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \"-\", StyleBox[\"\[Delta]\", \"TR\"]}], \",\", \" \", RowBox[{RowBox[{\"Max\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \"+\", StyleBox[\"\[Delta]\", \"TR\"]}]}], \"}\"}]\).\n\!\(\*RowBox[{\"MinMax\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"Scaled\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"Min\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \"-\", StyleBox[\"\[Delta]\", \"TR\"]}], \",\", \" \", RowBox[{RowBox[{\"Max\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \"+\", StyleBox[\"\[Delta]\", \"TR\"]}]}], \"}\"}]\) where \!\(\*RowBox[{StyleBox[\"\[Delta]\", \"TR\"], \"=\", RowBox[{StyleBox[\"s\", \"TI\"], \"\[Times]\", RowBox[{\"(\", RowBox[{RowBox[{\"Max\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \"-\", RowBox[{\"Min\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]}], \")\"}]}]}]\).\n\!\(\*RowBox[{\"MinMax\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Delta]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Delta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"Min\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \"-\", SubscriptBox[StyleBox[\"\[Delta]\", \"TR\"], StyleBox[\"min\", \"TI\"]]}], \",\", RowBox[{RowBox[{\"Max\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}], \"+\", SubscriptBox[StyleBox[\"\[Delta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}]}], \"}\"}]\)."
MinorPlanetData::usage = "\!\(\*RowBox[{\"MinorPlanetData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the minor planet \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"MinorPlanetData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified minor planet entities.\n\!\(\*RowBox[{\"MinorPlanetData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
Minors::usage = "\!\(\*RowBox[{\"Minors\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the minors of a matrix \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"Minors\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[RowBox[{StyleBox[\"k\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) minors. "
MinRecursion::usage = "MinRecursion is an option for NIntegrate and other numerical functions that use a recursive algorithm. With \!\(\*RowBox[{\"MinRecursion\", \" \", \"->\", \" \", StyleBox[\"n\", \"TI\"]}]\), a minimum depth of recursion of \!\(\*StyleBox[\"n\", \"TI\"]\) is used before tests for convergence begin."
MinSize::usage = "MinSize is an option of certain BoxForm primitives."
MinStableDistribution::usage = "\!\(\*RowBox[{\"MinStableDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"\[Xi]\", \"TR\"]}], \"]\"}]\) represents a generalized minimum extreme value distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\), and shape parameter \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\)."
Min::usage = "\!\(\*RowBox[{\"Min\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields the numerically smallest of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Min\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) yields the smallest element of any of the lists. "
MinusPlus::usage = "\!\(\*RowBox[{\"MinusPlus\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) displays as \!\(\*RowBox[{\"\[MinusPlus]\", StyleBox[\"x\", \"TI\"]}]\).\n\!\(\*RowBox[{\"MinusPlus\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"\[MinusPlus]\", StyleBox[\"y\", \"TI\"]}], \"\[MinusPlus]\", \"\[Ellipsis]\"}]\)."
Minus::usage = "\!\(\*RowBox[{\"-\", StyleBox[\"x\", \"TI\"]}]\) is the arithmetic negation of \!\(\*StyleBox[\"x\", \"TI\"]\). "
MinValue::usage = "\!\(\*RowBox[{\"MinValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the minimum value of \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"MinValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the minimum value of \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis]. \n\!\(\*RowBox[{\"MinValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the minimum value of \!\(\*StyleBox[\"f\", \"TI\"]\) subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"MinValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"MinValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) constrains variables to the domain \!\(\*StyleBox[\"dom\", \"TI\"]\), typically Reals or Integers."
MissingBehavior::usage = "MissingBehavior is an option to Query and related functions that specifies how expressions with head Missing should be interpreted in the context of other functions."
MissingDataMethod::usage = "MissingDataMethod is an option to TemporalData and other functions that controls how to process missing data. "
MissingDataRules::usage = "MissingDataRules is an option for SemanticImport and related functions that specifies what should be considered \"missing\" and what to replace it with."
MissingQ::usage = "\!\(\*RowBox[{\"MissingQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) has head Missing."
MissingString::usage = "MissingString is an option for TextString and related functions that indicates how an expression with head Missing should be converted to a string."
MissingStyle::usage = "MissingStyle is an option for GeoRegionValuePlot that specifies how locations with missing data should be displayed."
Missing::usage = "\!\(\*RowBox[{\"Missing\", \"[\", \"]\"}]\) represents data that is missing.\n\!\(\*RowBox[{\"Missing\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"reason\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) specifies a reason for the data's being missing.\n\!\(\*RowBox[{\"Missing\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"reason\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) associates the expression \!\(\*StyleBox[\"expr\", \"TI\"]\) with the missing data. "
MittagLefflerE::usage = "\!\(\*RowBox[{\"MittagLefflerE\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Mittag\[Dash]Leffler function \!\(\*RowBox[{SubscriptBox[StyleBox[\"E\", \"TI\"], \"\[Alpha]\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"MittagLefflerE\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the generalized Mittag\[Dash]Leffler function \!\(\*RowBox[{SubscriptBox[StyleBox[\"E\", \"TI\"], RowBox[{\"\[Alpha]\", \",\", \"\[Beta]\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
MixedGraphQ::usage = "\!\(\*RowBox[{\"MixedGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a mixed graph and False otherwise. "
MixedRadixQuantity::usage = "\!\(\*RowBox[{\"MixedRadixQuantity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"unit\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"unit\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a single Quantity expressed using an additive sequence of compatible \!\(\*StyleBox[\"units\", \"TI\"]\) with magnitude \!\(\*StyleBox[\"values\", \"TI\"]\)."
MixedRadix::usage = "\!\(\*RowBox[{\"MixedRadix\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents the list of bases of a numerical system in which different digits have different bases."
MixtureDistribution::usage = "\!\(\*RowBox[{\"MixtureDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a mixture distribution whose CDF is given as a sum of the CDFs of the component distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), each with weight \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Modal::usage = "Modal is an option to functions such as CreateDialog that specifies whether the dialog that is created should be modal to the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) front end."
Mode::usage = "Mode is an option to Solve and related functions that specifies in what sense the equations are to be solved. The possible settings for Mode are Generic, Modular, and Rational."
ModularLambda::usage = "\!\(\*RowBox[{\"ModularLambda\", \"[\", StyleBox[\"\[Tau]\", \"TR\"], \"]\"}]\) gives the modular lambda elliptic function \!\(\*RowBox[{\"\[Lambda]\", \"(\", \"\[Tau]\", \")\"}]\). "
Modular::usage = "Modular is a setting for the option Mode in Solve and related functions, which specifies that equations need be satisfied only modulo an integer."
Module::usage = "\!\(\*RowBox[{\"Module\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) specifies that occurrences of the symbols \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis] in \!\(\*StyleBox[\"expr\", \"TI\"]\) should be treated as local. \n\!\(\*RowBox[{\"Module\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) defines initial values for \!\(\*StyleBox[\"x\", \"TI\"]\), \[Ellipsis]. "
Modulus::usage = "\!\(\*RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"n\", \"TI\"]}]\) is an option that can be given in certain algebraic functions to specify that integers should be treated modulo \!\(\*StyleBox[\"n\", \"TI\"]\). "
Mod::usage = "\!\(\*RowBox[{\"Mod\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the remainder on division of \!\(\*StyleBox[\"m\", \"TI\"]\) by \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"Mod\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses an offset \!\(\*StyleBox[\"d\", \"TI\"]\). "
MoebiusMu::usage = "\!\(\*RowBox[{\"MoebiusMu\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the M\[ODoubleDot]bius function \!\(\*RowBox[{\"\[Mu]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\). "
MomentConvert::usage = "\!\(\*RowBox[{\"MomentConvert\", \"[\", RowBox[{StyleBox[\"mexpr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) converts the moment expression \!\(\*StyleBox[\"mexpr\", \"TI\"]\) to the specified form. "
MomentEvaluate::usage = "\!\(\*RowBox[{\"MomentEvaluate\", \"[\", RowBox[{StyleBox[\"mexpr\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) evaluates formal moments in the moment expression \!\(\*StyleBox[\"mexpr\", \"TI\"]\) on the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"MomentEvaluate\", \"[\", RowBox[{StyleBox[\"mexpr\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) evaluates formal moments and formal sample moments in \!\(\*StyleBox[\"mexpr\", \"TI\"]\) on the data \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"MomentEvaluate\", \"[\", RowBox[{StyleBox[\"mexpr\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) evaluates formal moments on the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) and formal sample moments on the data \!\(\*StyleBox[\"list\", \"TI\"]\). "
MomentGeneratingFunction::usage = "\!\(\*RowBox[{\"MomentGeneratingFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the moment-generating function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variable \!\(\*StyleBox[\"t\", \"TI\"]\). \n\!\(\*RowBox[{\"MomentGeneratingFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the moment-generating function for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) as a function of the variables \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] . "
Moment::usage = "\!\(\*RowBox[{\"Moment\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) sample moment of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Moment\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) moment of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"Moment\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) multivariate moment. \n\!\(\*RowBox[{\"Moment\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) represents the \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) formal moment. "
Monday::usage = "Monday is a day of the week."
Monitor::usage = "\!\(\*RowBox[{\"Monitor\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"mon\", \"TI\"]}], \"]\"}]\) generates a temporary monitor cell in which the continually updated current value of \!\(\*StyleBox[\"mon\", \"TI\"]\) is displayed during the course of evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
MonomialList::usage = "\!\(\*RowBox[{\"MonomialList\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) gives the list of all monomials in the polynomial \!\(\*StyleBox[\"poly\", \"TI\"]\).\n\!\(\*RowBox[{\"MonomialList\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the list of monomials with respect to the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in poly.\n\!\(\*RowBox[{\"MonomialList\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"order\", \"TI\"]}], \"]\"}]\) puts the monomials in the specified order."
MonomialOrder::usage = "MonomialOrder is an option for GroebnerBasis, PolynomialReduce and NSolve which specifies the monomial order to be used in computations."
MonsterGroupM::usage = "\!\(\*RowBox[{\"MonsterGroupM\", \"[\", \"]\"}]\) represents the sporadic simple monster group \!\(\*StyleBox[\"M\", FontSlant -> \"Plain\"]\)."
MoonPhase::usage = "\!\(\*RowBox[{\"MoonPhase\", \"[\", \"]\"}]\) gives moon phase fraction of illumination for the current date.\n\!\(\*RowBox[{\"MoonPhase\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives moon phase fraction of illumination for the specified date.\n\!\(\*RowBox[{\"MoonPhase\", \"[\", StyleBox[\"property\", \"TI\"], \"]\"}]\) gives the property of the moon phase for the current date.\n\!\(\*RowBox[{\"MoonPhase\", \"[\", RowBox[{StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the property of the moon phase for the specified date."
MoonPosition::usage = "\!\(\*RowBox[{\"MoonPosition\", \"[\", \"]\"}]\) gives the position of the Moon for the current date and location.\n\!\(\*RowBox[{\"MoonPosition\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the position of the Moon for the specified date.\n\!\(\*RowBox[{\"MoonPosition\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the position of the Moon for the specified location.\n\!\(\*RowBox[{\"MoonPosition\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the position of the Moon for the specified date and location.\n\!\(\*RowBox[{\"MoonPosition\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the positions of the Moon for all specified locations on the specified dates.\n\!\(\*RowBox[{\"MoonPosition\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"func\", \"TI\"]\) to determine what to return for extended locations."
MorletWavelet::usage = "\!\(\*RowBox[{\"MorletWavelet\", \"[\", \"]\"}]\) represents a Morlet wavelet. "
MorphologicalBinarize::usage = "\!\(\*RowBox[{\"MorphologicalBinarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], StyleBox[\",\", \"TI\"], RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) creates a binary image from \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing all values above the upper threshold \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with 1, also including pixels with intensities above the lower threshold \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) that are connected to the foreground.\n\!\(\*RowBox[{\"MorphologicalBinarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"t\", \"TI\"]\) as the upper threshold, automatically choosing a suitable value for the lower threshold.\n\!\(\*RowBox[{\"MorphologicalBinarize\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) chooses the lower and the upper threshold automatically."
MorphologicalBranchPoints::usage = "\!\(\*RowBox[{\"MorphologicalBranchPoints\", \"[\", StyleBox[\"image\", \"TI\"], StyleBox[\"]\", \"TI\"]}]\) gives a version of a binary image \!\(\*StyleBox[\"image\", \"TI\"]\) in which white pixels represent the morphological branch points."
MorphologicalComponents::usage = "\!\(\*RowBox[{\"MorphologicalComponents\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives an array in which each pixel of \!\(\*StyleBox[\"image\", \"TI\"]\) is replaced by an integer index representing the connected foreground image component in which the pixel lies.\n\!\(\*RowBox[{\"MorphologicalComponents\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) treats values above \!\(\*StyleBox[\"t\", \"TI\"]\) as foreground."
MorphologicalEulerNumber::usage = "\!\(\*RowBox[{\"MorphologicalEulerNumber\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) computes the morphological Euler number of regions in a binary image.\n\!\(\*RowBox[{\"MorphologicalEulerNumber\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) treats values above \!\(\*StyleBox[\"t\", \"TI\"]\) as foreground."
MorphologicalGraph::usage = "\!\(\*RowBox[{\"MorphologicalGraph\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a graph object that represents the connectivity of the morphological branch points and endpoints of the objects in \!\(\*StyleBox[\"image\", \"TI\"]\) after applying morphological thinning."
MorphologicalPerimeter::usage = "\!\(\*RowBox[{\"MorphologicalPerimeter\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) picks out the morphological perimeter of regions of foreground in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"MorphologicalPerimeter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) treats values above \!\(\*StyleBox[\"t\", \"TI\"]\) as foreground."
MorphologicalTransform::usage = "\!\(\*RowBox[{\"MorphologicalTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the 3\[Times]3 neighborhood of each pixel in a binary image \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"MorphologicalTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"rule\", \"TI\"]}], \"]\"}]\) applies a morphological transformation specified by a rule number \!\(\*StyleBox[\"rule\", \"TI\"]\).\n\!\(\*RowBox[{\"MorphologicalTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses a named transformation \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"MorphologicalTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"transformation\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"n\", \"TI\"]\) iterations of \!\(\*StyleBox[\"transformation\", \"TI\"]\) on \!\(\*StyleBox[\"image\", \"TI\"]\)."
MortalityData::usage = "\!\(\*RowBox[{\"MortalityData\", \"[\", StyleBox[\"spec\", \"TI\"], \"]\"}]\) gives the values of all properties for the specified demographic.\n\!\(\*RowBox[{\"MortalityData\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the specified demographic."
Most::usage = "\!\(\*RowBox[{\"Most\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives \!\(\*StyleBox[\"expr\", \"TI\"]\) with the last element removed. "
MountainData::usage = "\!\(\*RowBox[{\"MountainData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the mountain \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"MountainData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified mountain entities.\n\!\(\*RowBox[{\"MountainData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
MouseAnnotation::usage = "\!\(\*RowBox[{\"MouseAnnotation\", \"[\", \"]\"}]\) gives any mouse annotation associated with the expression at the current mouse position. "
MouseAppearance::usage = "\!\(\*RowBox[{\"MouseAppearance\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"graphic\", \"TI\"]}], \"]\"}]\) changes the mouse cursor to appear as \!\(\*StyleBox[\"graphic\", \"TI\"]\) when the mouse pointer is in the area where \!\(\*StyleBox[\"expr\", \"TI\"]\) is displayed.\n\!\(\*RowBox[{\"MouseAppearance\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"graphic\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses the coordinates \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) in the graphic as the hotspot for the mouse cursor.\n\!\(\*RowBox[{\"MouseAppearance\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"graphic\", \"TI\"], \",\", RowBox[{\"Scaled\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"]\"}]}], \"]\"}]\) uses the scaled coordinates \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) as the hotspot for the mouse cursor.\n\!\(\*RowBox[{\"MouseAppearance\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"cursorname\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses the named cursor \"\!\(\*\nStyleBox[\"cursorname\", \"TI\"]\)\" as the mouse cursor.\n\!\(\*RowBox[{\"MouseAppearance\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"Automatic\"}], \"]\"}]\) reverts to normal mouse cursor behavior."
MouseButtons::usage = "\!\(\*RowBox[{\"MouseButtons\", \"[\", \"]\"}]\) gives a list of the mouse buttons currently being pressed."
Mouseover::usage = "\!\(\*RowBox[{\"Mouseover\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"over\", \"TI\"]}], \"]\"}]\) represents an object that displays as \!\(\*StyleBox[\"over\", \"TI\"]\) when the mouse pointer is over it, and as \!\(\*StyleBox[\"expr\", \"TI\"]\) otherwise. "
MousePosition::usage = "\!\(\*RowBox[{\"MousePosition\", \"[\", \"]\"}]\) gives the current mouse position in the notebook front end. \n\!\(\*RowBox[{\"MousePosition\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"coords\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the mouse position with respect to the specified coordinate system.\n\!\(\*RowBox[{\"MousePosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"coords\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"def\", \"TI\"]}], \"]\"}]\) returns \!\(\*StyleBox[\"def\", \"TI\"]\) if the mouse is not over an object that defines the specified coordinate system."
MovieData::usage = "\!\(\*RowBox[{\"MovieData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the movie \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"MovieData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified movie entities.\n\!\(\*RowBox[{\"MovieData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
MovingAverage::usage = "\!\(\*RowBox[{\"MovingAverage\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the moving average of \!\(\*StyleBox[\"list\", \"TI\"]\), computed by averaging runs of \!\(\*StyleBox[\"r\", \"TI\"]\) elements.\n\!\(\*RowBox[{\"MovingAverage\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the moving average of \!\(\*StyleBox[\"list\", \"TI\"]\), computed with weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
MovingMap::usage = "\!\(\*RowBox[{\"MovingMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to size \!\(\*StyleBox[\"w\", \"TI\"]\) windows in the specified \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"MovingMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wspec\", \"TI\"]}], \"]\"}]\) uses windows specified by \!\(\*StyleBox[\"wspec\", \"TI\"]\).\n\!\(\*RowBox[{\"MovingMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wspec\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"]}], \"]\"}]\) pads \!\(\*StyleBox[\"data\", \"TI\"]\) using \!\(\*StyleBox[\"padding\", \"TI\"]\)."
MovingMedian::usage = "\!\(\*RowBox[{\"MovingMedian\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the moving median of \!\(\*StyleBox[\"list\", \"TI\"]\), computed using spans of \!\(\*StyleBox[\"r\", \"TI\"]\) elements."
MoyalDistribution::usage = "\!\(\*RowBox[{\"MoyalDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a Moyal distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"MoyalDistribution\", \"[\", \"]\"}]\) represents a Moyal distribution with location parameter 0 and scale parameter 1."
Multicolumn::usage = "\!\(\*RowBox[{\"Multicolumn\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"cols\", \"TI\"]}], \"]\"}]\) is an object that formats with the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) arranged in a grid with the indicated number of columns.\n\!\(\*RowBox[{\"Multicolumn\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"rows\", \"TI\"], \",\", \"Automatic\"}], \"}\"}]}], \"]\"}]\) formats as a grid with the indicated number of rows.\n\!\(\*RowBox[{\"Multicolumn\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"rows\", \"TI\"], \",\", StyleBox[\"cols\", \"TI\"]}], \"}\"}]}], \"]\"}]\) formats as a grid with the indicated number of rows and columns.\n\!\(\*RowBox[{\"Multicolumn\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) formats with the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) in a roughly square arrangement."
MultiedgeStyle::usage = "MultiedgeStyle is an option for GraphPlot and related functions that specifies how to draw multiple edges."
MultigraphQ::usage = "\!\(\*RowBox[{\"MultigraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a multigraph and False otherwise."
MultilaunchWarning::usage = "MultilaunchWarning is a global option that specifies whether a warning is given when you try to modify user preferences while running two copies of \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) simultaneously."
MultilineFunction::usage = "MultilineFunction is an option for UnderscriptBox and related box objects that specifies what to do when the contents of a box object are too long to fit on one line."
MultinomialDistribution::usage = "\!\(\*RowBox[{\"MultinomialDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a multinomial distribution with \!\(\*StyleBox[\"n\", \"TI\"]\) trials and probabilities \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Multinomial::usage = "\!\(\*RowBox[{\"Multinomial\", \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the multinomial coefficient \!\(\*RowBox[{RowBox[{RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], \"1\"], \"+\", SubscriptBox[StyleBox[\"n\", \"TI\"], \"2\"], \"+\", \"\[Ellipsis]\"}], \")\"}], \"!\"}], \"/\", RowBox[{\"(\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], \"1\"], \"!\"}], \" \", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], \"2\"], \"!\"}], \" \", \"\[Ellipsis]\"}], \")\"}]}]\). "
MultinormalDistribution::usage = "\!\(\*RowBox[{\"MultinormalDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a multivariate normal (Gaussian) distribution with mean vector \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\)."
MultiplicativeOrder::usage = "\!\(\*RowBox[{\"MultiplicativeOrder\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the multiplicative order of \!\(\*StyleBox[\"k\", \"TI\"]\) modulo \!\(\*StyleBox[\"n\", \"TI\"]\), defined as the smallest integer \!\(\*StyleBox[\"m\", \"TI\"]\) such that \!\(\*RowBox[{SuperscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"\[Congruent]\", RowBox[{\"1\", \"mod\", \" \", StyleBox[\"n\", \"TI\"]}]}]\). \n\!\(\*RowBox[{\"MultiplicativeOrder\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the generalized multiplicative order of \!\(\*StyleBox[\"k\", \"TI\"]\) modulo \!\(\*StyleBox[\"n\", \"TI\"]\), defined as the smallest integer \!\(\*StyleBox[\"m\", \"TI\"]\) such that \!\(\*RowBox[{SuperscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"\[Congruent]\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"mod\", \" \", StyleBox[\"n\", \"TI\"]}]}]\) for some \!\(\*StyleBox[\"i\", \"TI\"]\). "
Multiplicity::usage = "Multiplicity is an option to Roots. \!\(\*RowBox[{\"Multiplicity\", \" \", \"->\", \" \", StyleBox[\"n\", \"TI\"]}]\) specifies that the multiplicity of each of the roots is \!\(\*StyleBox[\"n\", \"TI\"]\) in the final result."
Multiselection::usage = "Multiselection is an option to ListPicker that specifies whether multiple values may be selected."
MultivariateHypergeometricDistribution::usage = "\!\(\*RowBox[{\"MultivariateHypergeometricDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a multivariate hypergeometric distribution with \!\(\*StyleBox[\"n\", \"TI\"]\) draws without replacement from a collection containing \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) objects of type \!\(\*StyleBox[\"i\", \"TI\"]\). "
MultivariatePoissonDistribution::usage = "\!\(\*RowBox[{\"MultivariatePoissonDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a multivariate Poisson distribution with mean vector \!\(\*RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \"+\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \"+\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
MultivariateStatistics`EllipsoidProbability::usage = "\!\(\*RowBox[{\"EllipsoidProbability\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"ellipse\", \"TI\"]}], \"]\"}]\) gives the cumulative probability of \!\(\*StyleBox[\"dist\", \"TI\"]\) over \!\(\*StyleBox[\"ellipse\", \"TI\"]\) centered at the mean of \!\(\*StyleBox[\"dist\", \"TI\"]\)."
MultivariateStatistics`EllipsoidQuantile::usage = "\!\(\*RowBox[{\"EllipsoidQuantile\", \"[\", RowBox[{StyleBox[\"matrix\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the ellipsoidal locus of the \!\(\*StyleBox[\"q\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) quantile of \!\(\*StyleBox[\"matrix\", \"TI\"]\).\n\!\(\*RowBox[{\"EllipsoidQuantile\", \"[\", RowBox[{StyleBox[\"matrix\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives ellipsoidal loci for multiple quantiles \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
MultivariateStatistics`EllipsoidQuartiles::usage = "\!\(\*RowBox[{\"EllipsoidQuartiles\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives the ellipsoidal loci of the quartiles of \!\(\*StyleBox[\"matrix\", \"TI\"]\)."
MultivariateStatistics`Ellipsoid::usage = "\!\(\*RowBox[{\"Ellipsoid\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a \!\(\*StyleBox[\"p\", \"TI\"]\)-dimensional ellipsoid centered at the point \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]\) with semi-axis radii \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) aligned with the coordinate axes.\n\!\(\*RowBox[{\"Ellipsoid\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a \!\(\*StyleBox[\"p\", \"TI\"]\)-dimensional ellipsoid with semi-axis radii \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) aligned with the direction \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
MultivariateStatistics`GeneralizedVariance::usage = "\!\(\*RowBox[{\"GeneralizedVariance\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives the generalized variance for \!\(\*StyleBox[\"matrix\", \"TI\"]\)."
MultivariateStatistics`KendallRankCorrelation::usage = "\!\(\*RowBox[{\"KendallRankCorrelation\", \"[\", RowBox[{StyleBox[\"xlist\", \"TI\"], \",\", StyleBox[\"ylist\", \"TI\"]}], \"]\"}]\) gives Kendall's rank correlation coefficient \[Tau] for the real-valued vectors \!\(\*StyleBox[\"xlist\", \"TI\"]\) and \!\(\*StyleBox[\"ylist\", \"TI\"]\)."
MultivariateStatistics`MedianMethod::usage = "MedianMethod is an option for MultivariateMedianDeviation that specifies the multivariate median to use."
MultivariateStatistics`MultiPoissonDistribution::usage = "\!\(\*RowBox[{\"MultiPoissonDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a multivariate Poisson distribution with mean vector \!\(\*RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \"+\", StyleBox[\"\[Mu]\", \"TR\"]}]\)."
MultivariateStatistics`MultivariateKurtosis::usage = "\!\(\*RowBox[{\"MultivariateKurtosis\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives a multivariate kurtosis coefficient for \!\(\*StyleBox[\"matrix\", \"TI\"]\)."
MultivariateStatistics`MultivariateMeanDeviation::usage = "\!\(\*RowBox[{\"MultivariateMeanDeviation\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives the mean of the Euclidean distances between the elements of \!\(\*StyleBox[\"matrix\", \"TI\"]\) and their mean."
MultivariateStatistics`MultivariateMedianDeviation::usage = "\!\(\*RowBox[{\"MultivariateMedianDeviation\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives the median Euclidean distance from the median of the elements in \!\(\*StyleBox[\"matrix\", \"TI\"]\)."
MultivariateStatistics`MultivariateSkewness::usage = "\!\(\*RowBox[{\"MultivariateSkewness\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives a multivariate coefficient of skewness for \!\(\*StyleBox[\"matrix\", \"TI\"]\)."
MultivariateStatistics`MultivariateTrimmedMean::usage = "\!\(\*RowBox[{\"MultivariateTrimmedMean\", \"[\", RowBox[{StyleBox[\"matrix\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gives the mean of the bivariate data \!\(\*StyleBox[\"matrix\", \"TI\"]\) after dropping a fraction \!\(\*StyleBox[\"f\", \"TI\"]\) of the outermost vectors. "
MultivariateStatistics`PolytopeQuantile::usage = "\!\(\*RowBox[{\"PolytopeQuantile\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the locus of the \!\(\*StyleBox[\"q\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) quantile of the bivariate data, where the data has been ordered using convex hulls centered on \!\(\*RowBox[{\"ConvexHullMedian\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]]}], \"}\"}]}], \"}\"}], \"]\"}]\)."
MultivariateStatistics`PolytopeQuartiles::usage = "\!\(\*RowBox[{\"PolytopeQuartiles\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives a list of the loci of the quartiles of the bivariate data \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*StyleBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", FontSlant -> \"Plain\"]], \"TI\"]\), \[Ellipsis] where the data has been ordered using convex hulls centered on \!\(\*RowBox[{\"ConvexHullMedian\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\)."
MultivariateStatistics`Polytope::usage = "\!\(\*RowBox[{\"Polytope\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"connectivity\", \"TI\"]}], \"]\"}]\) represents a \!\(\*StyleBox[\"p\", \"TI\"]\)-dimensional polytope with \!\(\*StyleBox[\"p\", \"TI\"]\)-variate vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis], where the connections between the vertices is specified by \!\(\*StyleBox[\"connectivity\", \"TI\"]\)."
MultivariateStatistics`QuadraticFormDistribution::usage = "\!\(\*RowBox[{\"QuadraticFormDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the distribution of a quadratic form \!\(\*RowBox[{RowBox[{StyleBox[\"z\", \"TI\"], \".\", StyleBox[\"a\", \"TI\"], \".\", StyleBox[\"z\", \"TI\"]}], \"+\", RowBox[{StyleBox[\"b\", \"TI\"], \".\", StyleBox[\"z\", \"TI\"]}], \"+\", StyleBox[\"c\", \"TI\"]}]\) for multivariate normal \!\(\*StyleBox[\"z\", \"TI\"]\)."
MultivariateStatistics`SimplexMedian::usage = "\!\(\*RowBox[{\"SimplexMedian\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives a simplex median of the elements in \!\(\*StyleBox[\"matrix\", \"TI\"]\)."
MultivariateStatistics`SpatialMedian::usage = "\!\(\*RowBox[{\"SpatialMedian\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives the spatial median of the elements in \!\(\*StyleBox[\"matrix\", \"TI\"]\)."
MultivariateStatistics`SpearmanRankCorrelation::usage = "\!\(\*RowBox[{\"SpearmanRankCorrelation\", \"[\", RowBox[{StyleBox[\"xlist\", \"TI\"], \",\", StyleBox[\"ylist\", \"TI\"]}], \"]\"}]\) gives Spearman's rank correlation coefficient \[Rho] for the real\[Hyphen]valued vectors \!\(\*StyleBox[\"xlist\", \"TI\"]\) and \!\(\*StyleBox[\"ylist\", \"TI\"]\)."
MultivariateStatistics`TotalVariation::usage = "\!\(\*RowBox[{\"TotalVariation\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) gives the total variation for \!\(\*StyleBox[\"matrix\", \"TI\"]\)."
MultivariateStatistics`WishartDistribution::usage = "\!\(\*RowBox[{\"WishartDistribution\", \"[\", RowBox[{StyleBox[\"\[CapitalSigma]\", \"TR\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) represents a Wishart distribution with scale matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\) and degrees of freedom parameter \!\(\*StyleBox[\"m\", \"TI\"]\)."
MultivariateTDistribution::usage = "\!\(\*RowBox[{\"MultivariateTDistribution\", \"[\", RowBox[{StyleBox[\"\[CapitalSigma]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents the multivariate Student \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with scale matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\) and degrees of freedom parameter \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\).\n\!\(\*RowBox[{\"MultivariateTDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents the multivariate Student \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with location \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), scale matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom."
Music`A0::usage = "A0 gives the frequency of the note A in octave 0."
Music`A1::usage = "A1 gives the frequency of the note A in octave 1."
Music`A2::usage = "A2 gives the frequency of the note A in octave 2."
Music`A3::usage = "A3 gives the frequency of the note A in octave 3."
Music`A4::usage = "A4 gives the frequency of the note A in octave 4."
Music`A5::usage = "A5 gives the frequency of the note A in octave 5."
Music`A6::usage = "A6 gives the frequency of the note A in octave 6."
Music`A7::usage = "A7 gives the frequency of the note A in octave 7."
Music`Aflat0::usage = "Aflat0 gives the frequency of the note A-flat in octave 0."
Music`Aflat1::usage = "Aflat1 gives the frequency of the note A-flat in octave 1."
Music`Aflat2::usage = "Aflat2 gives the frequency of the note A-flat in octave 2."
Music`Aflat3::usage = "Aflat3 gives the frequency of the note A-flat in octave 3."
Music`Aflat4::usage = "Aflat4 gives the frequency of the note A-flat in octave 4."
Music`Aflat5::usage = "Aflat5 gives the frequency of the note A-flat in octave 5."
Music`Aflat6::usage = "Aflat6 gives the frequency of the note A-flat in octave 6."
Music`Aflat7::usage = "Aflat7 gives the frequency of the note A-flat in octave 7."
Music`Asharp0::usage = "Asharp0 gives the frequency of the note A-sharp in octave 0."
Music`Asharp1::usage = "Asharp1 gives the frequency of the note A-sharp in octave 1."
Music`Asharp2::usage = "Asharp2 gives the frequency of the note A-sharp in octave 2."
Music`Asharp3::usage = "Asharp3 gives the frequency of the note A-sharp in octave 3."
Music`Asharp4::usage = "Asharp4 gives the frequency of the note A-sharp in octave 4."
Music`Asharp5::usage = "Asharp5 gives the frequency of the note A-sharp in octave 5."
Music`Asharp6::usage = "Asharp6 gives the frequency of the note A-sharp in octave 6."
Music`Asharp7::usage = "Asharp7 gives the frequency of the note A-sharp in octave 7."
Music`B0::usage = "B0 gives the frequency of the note B in octave 0."
Music`B1::usage = "B1 gives the frequency of the note B in octave 1."
Music`B2::usage = "B2 gives the frequency of the note B in octave 2."
Music`B3::usage = "B3 gives the frequency of the note B in octave 3."
Music`B4::usage = "B4 gives the frequency of the note B in octave 4."
Music`B5::usage = "B5 gives the frequency of the note B in octave 5."
Music`B6::usage = "B6 gives the frequency of the note B in octave 6."
Music`B7::usage = "B7 gives the frequency of the note B in octave 7."
Music`Bflat0::usage = "Bflat0 gives the frequency of the note B-flat in octave 0."
Music`Bflat1::usage = "Bflat1 gives the frequency of the note B-flat in octave 1."
Music`Bflat2::usage = "Bflat2 gives the frequency of the note B-flat in octave 2."
Music`Bflat3::usage = "Bflat3 gives the frequency of the note B-flat in octave 3."
Music`Bflat4::usage = "Bflat4 gives the frequency of the note B-flat in octave 4."
Music`Bflat5::usage = "Bflat5 gives the frequency of the note B-flat in octave 5."
Music`Bflat6::usage = "Bflat6 gives the frequency of the note B-flat in octave 6."
Music`Bflat7::usage = "Bflat7 gives the frequency of the note B-flat in octave 7."
Music`Bsharp0::usage = "Bsharp0 gives the frequency of the note B-sharp in octave 0."
Music`Bsharp1::usage = "Bsharp1 gives the frequency of the note B-sharp in octave 1."
Music`Bsharp2::usage = "Bsharp2 gives the frequency of the note B-sharp in octave 2."
Music`Bsharp3::usage = "Bsharp3 gives the frequency of the note B-sharp in octave 3."
Music`Bsharp4::usage = "Bsharp4 gives the frequency of the note B-sharp in octave 4."
Music`Bsharp5::usage = "Bsharp5 gives the frequency of the note B-sharp in octave 5."
Music`Bsharp6::usage = "Bsharp6 gives the frequency of the note B-sharp in octave 6."
Music`Bsharp7::usage = "Bsharp7 gives the frequency of the note B-sharp in octave 7."
Music`C0::usage = "C0 gives the frequency of the note C in octave 0."
Music`C1::usage = "C1 gives the frequency of the note C in octave 1."
Music`C2::usage = "C2 gives the frequency of the note C in octave 2."
Music`C3::usage = "C3 gives the frequency of the note C in octave 3."
Music`C4::usage = "C4 gives the frequency of the note C in octave 4."
Music`C5::usage = "C5 gives the frequency of the note C in octave 5."
Music`C6::usage = "C6 gives the frequency of the note C in octave 6."
Music`C7::usage = "C7 gives the frequency of the note C in octave 7."
Music`CentsToHertz::usage = "\!\(\*RowBox[{\"CentsToHertz\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) converts a list of intervals \!\(\*RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) measured in cents to a list of frequencies measured in Hertz, beginning at 440 Hertz.\n\!\(\*RowBox[{\"CentsToHertz\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"freq\", \"TI\"]}], \"]\"}]\) gives a list of frequencies beginning at frequency \!\(\*StyleBox[\"freq\", \"TI\"]\)."
Music`Cflat0::usage = "Cflat0 gives the frequency of the note C-flat in octave 0."
Music`Cflat1::usage = "Cflat1 gives the frequency of the note C-flat in octave 1."
Music`Cflat2::usage = "Cflat2 gives the frequency of the note C-flat in octave 2."
Music`Cflat3::usage = "Cflat3 gives the frequency of the note C-flat in octave 3."
Music`Cflat4::usage = "Cflat4 gives the frequency of the note C-flat in octave 4."
Music`Cflat5::usage = "Cflat5 gives the frequency of the note C-flat in octave 5."
Music`Cflat6::usage = "Cflat6 gives the frequency of the note C-flat in octave 6."
Music`Cflat7::usage = "Cflat7 gives the frequency of the note C-flat in octave 7."
Music`Csharp0::usage = "Csharp0 gives the frequency of the note C-sharp in octave 0."
Music`Csharp1::usage = "Csharp1 gives the frequency of the note C-sharp in octave 1."
Music`Csharp2::usage = "Csharp2 gives the frequency of the note C-sharp in octave 2."
Music`Csharp3::usage = "Csharp3 gives the frequency of the note C-sharp in octave 3."
Music`Csharp4::usage = "Csharp4 gives the frequency of the note C-sharp in octave 4."
Music`Csharp5::usage = "Csharp5 gives the frequency of the note C-sharp in octave 5."
Music`Csharp6::usage = "Csharp6 gives the frequency of the note C-sharp in octave 6."
Music`Csharp7::usage = "Csharp7 gives the frequency of the note C-sharp in octave 7."
Music`D0::usage = "D0 gives the frequency of the note D in octave 0."
Music`D1::usage = "D1 gives the frequency of the note D in octave 1."
Music`D2::usage = "D2 gives the frequency of the note D in octave 2."
Music`D3::usage = "D3 gives the frequency of the note D in octave 3."
Music`D4::usage = "D4 gives the frequency of the note D in octave 4."
Music`D5::usage = "D5 gives the frequency of the note D in octave 5."
Music`D6::usage = "D6 gives the frequency of the note D in octave 6."
Music`D7::usage = "D7 gives the frequency of the note D in octave 7."
Music`Dflat0::usage = "Dflat0 gives the frequency of the note D-flat in octave 0."
Music`Dflat1::usage = "Dflat1 gives the frequency of the note D-flat in octave 1."
Music`Dflat2::usage = "Dflat2 gives the frequency of the note D-flat in octave 2."
Music`Dflat3::usage = "Dflat3 gives the frequency of the note D-flat in octave 3."
Music`Dflat4::usage = "Dflat4 gives the frequency of the note D-flat in octave 4."
Music`Dflat5::usage = "Dflat5 gives the frequency of the note D-flat in octave 5."
Music`Dflat6::usage = "Dflat6 gives the frequency of the note D-flat in octave 6."
Music`Dflat7::usage = "Dflat7 gives the frequency of the note D-flat in octave 7."
Music`Dsharp0::usage = "Dsharp0 gives the frequency of the note D-sharp in octave 0. "
Music`Dsharp1::usage = "Dsharp1 gives the frequency of the note D-sharp in octave 1."
Music`Dsharp2::usage = "Dsharp2 gives the frequency of the note D-sharp in octave 2."
Music`Dsharp3::usage = "Dsharp3 gives the frequency of the note D-sharp in octave 3."
Music`Dsharp4::usage = "Dsharp4 gives the frequency of the note D-sharp in octave 4."
Music`Dsharp5::usage = "Dsharp5 gives the frequency of the note D-sharp in octave 5."
Music`Dsharp6::usage = "Dsharp6 gives the frequency of the note D-sharp in octave 6."
Music`Dsharp7::usage = "Dsharp7 gives the frequency of the note D-sharp in octave 7."
Music`E0::usage = "E0 gives the frequency of the note E in octave 0."
Music`E1::usage = "E1 gives the frequency of the note E in octave 1."
Music`E2::usage = "E2 gives the frequency of the note E in octave 2."
Music`E3::usage = "E3 gives the frequency of the note E in octave 3."
Music`E4::usage = "E4 gives the frequency of the note E in octave 4."
Music`E5::usage = "E5 gives the frequency of the note E in octave 5."
Music`E6::usage = "E6 gives the frequency of the note E in octave 6."
Music`E7::usage = "E7 gives the frequency of the note E in octave 7."
Music`Eflat0::usage = "Eflat0 gives the frequency of the note E-flat in octave 0."
Music`Eflat1::usage = "Eflat1 gives the frequency of the note E-flat in octave 1."
Music`Eflat2::usage = "Eflat2 gives the frequency of the note E-flat in octave 2."
Music`Eflat3::usage = "Eflat3 gives the frequency of the note E-flat in octave 3."
Music`Eflat4::usage = "Eflat4 gives the frequency of the note E-flat in octave 4."
Music`Eflat5::usage = "Eflat5 gives the frequency of the note E-flat in octave 5."
Music`Eflat6::usage = "Eflat6 gives the frequency of the note E-flat in octave 6."
Music`Eflat7::usage = "Eflat7 gives the frequency of the note E-flat in octave 7."
Music`Esharp0::usage = "Esharp0 gives the frequency of the note E-sharp in octave 0."
Music`Esharp1::usage = "Esharp1 gives the frequency of the note E-sharp in octave 1."
Music`Esharp2::usage = "Esharp2 gives the frequency of the note E-sharp in octave 2."
Music`Esharp3::usage = "Esharp3 gives the frequency of the note E-sharp in octave 3."
Music`Esharp4::usage = "Esharp4 gives the frequency of the note E-sharp in octave 4."
Music`Esharp5::usage = "Esharp5 gives the frequency of the note E-sharp in octave 5."
Music`Esharp6::usage = "Esharp6 gives the frequency of the note E-sharp in octave 6."
Music`Esharp7::usage = "Esharp7 gives the frequency of the note E-sharp in octave 7."
Music`F0::usage = "F0 gives the frequency of the note F in octave 0."
Music`F1::usage = "F1 gives the frequency of the note F in octave 1."
Music`F2::usage = "F2 gives the frequency of the note F in octave 2."
Music`F3::usage = "F3 gives the frequency of the note F in octave 3."
Music`F4::usage = "F4 gives the frequency of the note F in octave 4."
Music`F5::usage = "F5 gives the frequency of the note F in octave 5."
Music`F6::usage = "F6 gives the frequency of the note F in octave 6."
Music`F7::usage = "F7 gives the frequency of the note F in octave 7."
Music`Fflat0::usage = "Fflat0 gives the frequency of the note F-flat in octave 0."
Music`Fflat1::usage = "Fflat1 gives the frequency of the note F-flat in octave 1."
Music`Fflat2::usage = "Fflat2 gives the frequency of the note F-flat in octave 2."
Music`Fflat3::usage = "Fflat3 gives the frequency of the note F-flat in octave 3."
Music`Fflat4::usage = "Fflat4 gives the frequency of the note F-flat in octave 4."
Music`Fflat5::usage = "Fflat5 gives the frequency of the note F-flat in octave 5."
Music`Fflat6::usage = "Fflat6 gives the frequency of the note F-flat in octave 6."
Music`Fflat7::usage = "Fflat7 gives the frequency of the note F-flat in octave 7."
Music`Fsharp0::usage = "Fsharp0 gives the frequency of the note F-sharp in octave 0."
Music`Fsharp1::usage = "Fsharp1 gives the frequency of the note F-sharp in octave 1."
Music`Fsharp2::usage = "Fsharp2 gives the frequency of the note F-sharp in octave 2."
Music`Fsharp3::usage = "Fsharp3 gives the frequency of the note F-sharp in octave 3."
Music`Fsharp4::usage = "Fsharp4 gives the frequency of the note F-sharp in octave 4."
Music`Fsharp5::usage = "Fsharp5 gives the frequency of the note F-sharp in octave 5."
Music`Fsharp6::usage = "Fsharp6 gives the frequency of the note F-sharp in octave 6."
Music`Fsharp7::usage = "Fsharp7 gives the frequency of the note F-sharp in octave 7."
Music`G0::usage = "G0 gives the frequency of the note G in octave 0."
Music`G1::usage = "G1 gives the frequency of the note G in octave 1."
Music`G2::usage = "G2 gives the frequency of the note G in octave 2."
Music`G3::usage = "G3 gives the frequency of the note G in octave 3."
Music`G4::usage = "G4 gives the frequency of note G in octave 4."
Music`G5::usage = "G5 gives the frequency of the note G in octave 5."
Music`G6::usage = "G6 gives the frequency of the note G in octave 6."
Music`G7::usage = "G7 gives the frequency of the note G in octave 7."
Music`Gflat0::usage = "Gflat0 gives the frequency of the note G-flat in octave 0."
Music`Gflat1::usage = "Gflat1 gives the frequency of the note G-flat in octave 1."
Music`Gflat2::usage = "Gflat2 gives the frequency of the note G-flat in octave 2."
Music`Gflat3::usage = "Gflat3 gives the frequency of the note G-flat in octave 3."
Music`Gflat4::usage = "Gflat4 gives the frequency of the note G-flat in octave 4."
Music`Gflat5::usage = "Gflat5 gives the frequency of the note G-flat in octave 5."
Music`Gflat6::usage = "Gflat6 gives the frequency of the note G-flat in octave 6."
Music`Gflat7::usage = "Gflat7 gives the frequency of the note G-flat in octave 7."
Music`Gsharp0::usage = "Gsharp0 gives the frequency of the note G-sharp in octave 0."
Music`Gsharp1::usage = "Gsharp1 gives the frequency of the note G-sharp in octave 1."
Music`Gsharp2::usage = "Gsharp2 gives the frequency of the note G-sharp in octave 2."
Music`Gsharp3::usage = "Gsharp3 gives the frequency of the note G-sharp in octave 3."
Music`Gsharp4::usage = "Gsharp4 gives the frequency of the note G-sharp in octave 4."
Music`Gsharp5::usage = "Gsharp5 gives the frequency of the note G-sharp in octave 5."
Music`Gsharp6::usage = "Gsharp6 gives the frequency of the note G-sharp in octave 6."
Music`Gsharp7::usage = "Gsharp7 gives the frequency of the note G-sharp in octave 7."
Music`HertzToCents::usage = "\!\(\*RowBox[{\"HertzToCents\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"freq\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"freq\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) converts a list of frequencies \!\(\*RowBox[{SubscriptBox[StyleBox[\"freq\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"freq\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\), measured in Hertz to a list of intervals measured in cents."
Music`JustMajor::usage = "JustMajor is an interval list for the Just Major scale."
Music`JustMinor::usage = "JustMinor is an interval list for the minor version of the Just Major scale."
Music`MeanChromatic::usage = "MeanChromatic is an interval list for the Mean Chromatic scale."
Music`MeanMajor::usage = "MeanMajor is an interval list derived from the Mean Chromatic scale."
Music`MeanMinor::usage = "MeanMinor is an interval list derived from the Mean Chromatic scale."
Music`MusicScale::usage = "\!\(\*RowBox[{\"MusicScale\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"freq\", \"TI\"], \",\", StyleBox[\"dur\", \"TI\"]}], \"]\"}]\) creates a Sound object that is a sequence of pitches corresponding to numbers \!\(\*RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\), a list of intervals measured in cents, starting at \!\(\*StyleBox[\"freq\", \"TI\"]\) Hertz and lasting \!\(\*StyleBox[\"dur\", \"TI\"]\) seconds."
Music`PythagoreanChromatic::usage = "PythagoreanChromatic is an interval list for the Pythagorean Chromatic scale."
Music`PythagoreanMajor::usage = "PythagoreanMajor is an interval list for the Pythagorean Major scale."
Music`QuarterTone::usage = "QuarterTone is an interval list in which each semitone (100 cents) is split in two."
Music`SixthTone::usage = "SixthTone is an interval list in which each semitone (100 cents) is split in three."
Music`TemperedChromatic::usage = "TemperedChromatic is an interval list corresponding to an equal tempered scale. "
Music`TemperedMajor::usage = "TemperedMajor is an interval list derived from the Tempered Chromatic scale."
Music`TemperedMinor::usage = "TemperedMinor is an interval list derived from the Tempered Chromatic scale."
NakagamiDistribution::usage = "\!\(\*RowBox[{\"NakagamiDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) represents a Nakagami distribution with shape parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and spread parameter \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
NameQ::usage = "\!\(\*RowBox[{\"NameQ\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) yields True if there are any symbols whose names match the string pattern given, and yields False otherwise. "
Names::usage = "\!\(\*RowBox[{\"Names\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the names of symbols that match the string. \n\!\(\*RowBox[{\"Names\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) gives a list of names matching the arbitrary string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\)."
Nand::usage = "\!\(\*RowBox[{\"Nand\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is the logical NAND function. It evaluates its arguments in order, giving True immediately if any of them are False, and False if they are all True. "
NArgMax::usage = "\!\(\*RowBox[{\"NArgMax\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a position \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) at which \!\(\*StyleBox[\"f\", \"TI\"]\) is numerically maximized.\n\!\(\*RowBox[{\"NArgMax\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) at which \!\(\*StyleBox[\"f\", \"TI\"]\) is numerically maximized.\n\!\(\*RowBox[{\"NArgMax\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position at which \!\(\*StyleBox[\"f\", \"TI\"]\) is numerically maximized subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"NArgMax\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
NArgMin::usage = "\!\(\*RowBox[{\"NArgMin\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a position \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) at which \!\(\*StyleBox[\"f\", \"TI\"]\) is numerically minimized.\n\!\(\*RowBox[{\"NArgMin\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) at which \!\(\*StyleBox[\"f\", \"TI\"]\) is numerically minimized.\n\!\(\*RowBox[{\"NArgMin\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position at which \!\(\*StyleBox[\"f\", \"TI\"]\) is numerically minimized subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"NArgMin\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
NBernoulliB::usage = "\!\(\*RowBox[{\"NBernoulliB\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the numerical value of the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) Bernoulli number. \n\!\(\*RowBox[{\"NBernoulliB\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", \" \", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the result to \!\(\*StyleBox[\"d\", \"TI\"]\)-digit precision."
NCache::usage = "\!\(\*RowBox[{\"NCache\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"xn\", \"TI\"]}], \"]\"}]\) represents a numeric cache object for a quantity with exact value \!\(\*StyleBox[\"x\", \"TI\"]\) and approximate numerical value \!\(\*StyleBox[\"xn\", \"TI\"]\)."
NDEigensystem::usage = "\!\(\*RowBox[{\"NDEigensystem\", \"[\", RowBox[{RowBox[{StyleBox[\"\[ScriptCapitalL]\", \"TI\"], \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \"]\"}], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) smallest magnitude eigenvalues and eigenfunctions for the linear differential operator \!\(\*StyleBox[\"\[ScriptCapitalL]\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{RowBox[{\"NDEigensystem\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"\[ScriptCapitalL]\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \",\", RowBox[{StyleBox[\"v\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"\[ScriptCapitalL]\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"[\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \",\", RowBox[{StyleBox[\"v\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}], \" \"}]\) gives eigenvalues and eigenfunctions for the coupled differential operators \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"op\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"op\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"NDEigensystem\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the eigenvalues and eigenfunctions in the spatial variables \!\(\*StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"]\) for solutions \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) of the coupled time-dependent differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\)."
NDEigenvalues::usage = "\!\(\*RowBox[{\"NDEigenvalues\", \"[\", RowBox[{RowBox[{StyleBox[\"\[ScriptCapitalL]\", \"TI\"], \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \"]\"}], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) smallest magnitude eigenvalues for the linear differential operator \!\(\*StyleBox[\"\[ScriptCapitalL]\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{RowBox[{\"NDEigenvalues\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"\[ScriptCapitalL]\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \",\", RowBox[{StyleBox[\"v\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"\[ScriptCapitalL]\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"[\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \",\", RowBox[{StyleBox[\"v\", \"TI\"], \"[\", StyleBox[RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}], \" \"}]\) gives eigenvalues for the coupled differential operators \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"op\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"op\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"NDEigenvalues\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the eigenvalues in the spatial variables \!\(\*StyleBox[RowBox[{\"{\", RowBox[{\"x\", \",\", \"y\", \",\", \"\[Ellipsis]\"}], \"}\"}], \"TI\"]\) for solutions \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) of the coupled time-dependent differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\)."
NDSolve::usage = "\!\(\*RowBox[{\"NDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) finds a numerical solution to the ordinary differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) for the function \!\(\*StyleBox[\"u\", \"TI\"]\) with the independent variable \!\(\*StyleBox[\"x\", \"TI\"]\) in the range \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"NDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) solves the partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over a rectangular region.\n\!\(\*RowBox[{\"NDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], StyleBox[\"\[Element]\", \"TR\"], StyleBox[\"\[CapitalOmega]\", \"TR\"]}]}], \"]\"}]\) solves the partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"NDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], StyleBox[\"\[Element]\", \"TR\"], StyleBox[\"\[CapitalOmega]\", \"TR\"]}]}], \"]\"}]\) solves the time-dependent partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"NDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) solves for the functions\[NonBreakingSpace]\!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
NDSolveValue::usage = "\!\(\*RowBox[{\"NDSolveValue\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the value of \!\(\*StyleBox[\"expr\", \"TI\"]\) with functions determined by a numerical solution to the ordinary differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) with the independent variable \!\(\*StyleBox[\"x\", \"TI\"]\) in the range \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"NDSolveValue\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) solves the partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over a rectangular region.\n\!\(\*RowBox[{\"NDSolveValue\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}]}], \"]\"}]\) solves the partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"NDSolveValue\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], StyleBox[\"\[Element]\", \"TR\"], StyleBox[\"\[CapitalOmega]\", \"TR\"]}]}], \"]\"}]\) solves the time-dependent partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\)."
NearestFunction::usage = "\!\(\*RowBox[{\"NearestFunction\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) represents a function whose values give the elements closest to an element that is supplied."
NearestNeighborGraph::usage = "\!\(\*RowBox[{\"NearestNeighborGraph\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a graph with vertices \!\(\*RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) and edges connecting each \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to its nearest neighbors.\n\!\(\*RowBox[{\"NearestNeighborGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a graph connecting each \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to its \!\(\*StyleBox[\"k\", \"TI\"]\) nearest neighbors.\n\!\(\*RowBox[{\"NearestNeighborGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives a graph connecting each \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to at most \!\(\*StyleBox[\"k\", \"TI\"]\) nearest vertices within radius \!\(\*StyleBox[\"r\", \"TI\"]\) of \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"NearestNeighborGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{\"All\", \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives a graph connecting each \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to all vertices within radius \!\(\*StyleBox[\"r\", \"TI\"]\) of \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Nearest::usage = "\!\(\*RowBox[{\"Nearest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the list of \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to which \!\(\*StyleBox[\"x\", \"TI\"]\) is nearest. \n\!\(\*RowBox[{\"Nearest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to which \!\(\*StyleBox[\"x\", \"TI\"]\) is nearest. \n\!\(\*RowBox[{\"Nearest\", \"[\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the same result. \n\!\(\*RowBox[{\"Nearest\", \"[\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", \"Automatic\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) takes the \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to be successive integers \!\(\*StyleBox[\"i\", \"TI\"]\). \n\!\(\*RowBox[{\"Nearest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) effectively gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"Nearest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}], \",\", RowBox[{\"Nearest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"Nearest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) nearest \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Nearest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) or fewer nearest \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to \!\(\*StyleBox[\"x\", \"TI\"]\) that are within radius \!\(\*StyleBox[\"r\", \"TI\"]\) of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"Nearest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) generates a \!\(\*RowBox[{\"NearestFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied repeatedly to different \!\(\*StyleBox[\"x\", \"TI\"]\). "
NebulaData::usage = "\!\(\*RowBox[{\"NebulaData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the nebula \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"NebulaData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified nebula entities.\n\!\(\*RowBox[{\"NebulaData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
NeedlemanWunschSimilarity::usage = "\!\(\*RowBox[{\"NeedlemanWunschSimilarity\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives a number representing the Needleman\[Dash]Wunsch similarity between strings or vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
Needs::usage = "\!\(\*RowBox[{\"Needs\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \"]\"}]\) loads an appropriate file if the specified context is not already in $Packages. \n\!\(\*RowBox[{\"Needs\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) loads \!\(\*StyleBox[\"file\", \"TI\"]\) if the specified context is not already in $Packages. "
NegativeBinomialDistribution::usage = "\!\(\*RowBox[{\"NegativeBinomialDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents a negative binomial distribution with parameters \!\(\*StyleBox[\"n\", \"TI\"]\) and \!\(\*StyleBox[\"p\", \"TI\"]\)."
NegativeDefiniteMatrixQ::usage = "\!\(\*RowBox[{\"NegativeDefiniteMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly negative definite, and False otherwise."
NegativeMultinomialDistribution::usage = "\!\(\*RowBox[{\"NegativeMultinomialDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents a negative multinomial distribution with parameter \!\(\*StyleBox[\"n\", \"TI\"]\) and failure probability vector \!\(\*StyleBox[\"p\", \"TI\"]\)."
NegativeSemidefiniteMatrixQ::usage = "\!\(\*RowBox[{\"NegativeSemidefiniteMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly negative semidefinite, and False otherwise."
Negative::usage = "\!\(\*RowBox[{\"Negative\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"x\", \"TI\"]\) is a negative number. "
NeighborhoodData::usage = "\!\(\*RowBox[{\"NeighborhoodData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the neighborhood \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"NeighborhoodData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified neighborhood entities.\n\!\(\*RowBox[{\"NeighborhoodData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
NeighborhoodGraph::usage = "\!\(\*RowBox[{\"NeighborhoodGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the graph neighborhood of a vertex \!\(\*StyleBox[\"v\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"NeighborhoodGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the graph neighborhood of the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that can be vertices, edges, or subgraphs of \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"NeighborhoodGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives the graph neighborhood of the vertices and edges that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"NeighborhoodGraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the neighborhood up to distance \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"NeighborhoodGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
NestedGreaterGreater::usage = "\!\(\*RowBox[{\"NestedGreaterGreater\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NestedGreaterGreater]\", StyleBox[\"y\", \"TI\"], \"\[NestedGreaterGreater]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
NestedLessLess::usage = "\!\(\*RowBox[{\"NestedLessLess\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NestedLessLess]\", StyleBox[\"y\", \"TI\"], \"\[NestedLessLess]\", \"\[Ellipsis]\"}]\)."
NestGraph::usage = "\!\(\*RowBox[{\"NestGraph\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the graph obtained by starting with \!\(\*StyleBox[\"expr\", \"TI\"]\) and applying \!\(\*StyleBox[\"f\", \"TI\"]\) successively \!\(\*StyleBox[\"n\", \"TI\"]\) times.\n\!\(\*RowBox[{\"NestGraph\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the graph obtained by applying \!\(\*StyleBox[\"f\", \"TI\"]\) to \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\).\n\!\(\*RowBox[{\"NestGraph\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"graph\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the graph obtained by applying \!\(\*StyleBox[\"f\", \"TI\"]\) to the vertices of \!\(\*StyleBox[\"graph\", \"TI\"]\) and extending the \!\(\*StyleBox[\"graph\", \"TI\"]\)."
NestList::usage = "\!\(\*RowBox[{\"NestList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of the results of applying \!\(\*StyleBox[\"f\", \"TI\"]\) to \!\(\*StyleBox[\"expr\", \"TI\"]\) 0 through \!\(\*StyleBox[\"n\", \"TI\"]\) times. "
Nest::usage = "\!\(\*RowBox[{\"Nest\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives an expression with \!\(\*StyleBox[\"f\", \"TI\"]\) applied \!\(\*StyleBox[\"n\", \"TI\"]\) times to \!\(\*StyleBox[\"expr\", \"TI\"]\). "
NestWhileList::usage = "\!\(\*RowBox[{\"NestWhileList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) generates a list of the results of applying \!\(\*StyleBox[\"f\", \"TI\"]\) repeatedly, starting with \!\(\*StyleBox[\"expr\", \"TI\"]\), and continuing until applying \!\(\*StyleBox[\"test\", \"TI\"]\) to the result no longer yields True. \n\!\(\*RowBox[{\"NestWhileList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) supplies the most recent \!\(\*StyleBox[\"m\", \"TI\"]\) results as arguments for \!\(\*StyleBox[\"test\", \"TI\"]\) at each step. \n\!\(\*RowBox[{\"NestWhileList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", \"All\"}], \"]\"}]\) supplies all results so far as arguments for \!\(\*StyleBox[\"test\", \"TI\"]\) at each step. \n\!\(\*RowBox[{\"NestWhileList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) at most \!\(\*StyleBox[\"max\", \"TI\"]\) times. "
NestWhile::usage = "\!\(\*RowBox[{\"NestWhile\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) starts with \!\(\*StyleBox[\"expr\", \"TI\"]\), then repeatedly applies \!\(\*StyleBox[\"f\", \"TI\"]\) until applying \!\(\*StyleBox[\"test\", \"TI\"]\) to the result no longer yields True. \n\!\(\*RowBox[{\"NestWhile\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) supplies the most recent \!\(\*StyleBox[\"m\", \"TI\"]\) results as arguments for \!\(\*StyleBox[\"test\", \"TI\"]\) at each step. \n\!\(\*RowBox[{\"NestWhile\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", \"All\"}], \"]\"}]\) supplies all results so far as arguments for \!\(\*StyleBox[\"test\", \"TI\"]\) at each step. \n\!\(\*RowBox[{\"NestWhile\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) at most \!\(\*StyleBox[\"max\", \"TI\"]\) times. \n\!\(\*RowBox[{\"NestWhile\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) an extra \!\(\*StyleBox[\"n\", \"TI\"]\) times. \n\!\(\*RowBox[{\"NestWhile\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) returns the result found when \!\(\*StyleBox[\"f\", \"TI\"]\) had been applied \!\(\*StyleBox[\"n\", \"TI\"]\) fewer times. "
NETLink`ActivateWindow::usage = "ActivateWindow is an option to DoNETModeless that specifies whether to make the window visible."
NETLink`AddEventHandler::usage = "\!\(\*RowBox[{\"AddEventHandler\", \"[\", RowBox[{StyleBox[RowBox[{\"obj\", \"@\", \"event\"}], \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) assigns the specified \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) function \!\(\*StyleBox[\"func\", \"TI\"]\) to be called when the given event \!\(\*StyleBox[\"event\", \"TI\"]\) fires."
NETLink`AllowShortContext::usage = "AllowShortContext is an option to LoadJavaClass (in \!\(\*StyleBox[\"J/Link\", FontSlant -> \"Italic\"]\)) and LoadNETType (in \!\(\*StyleBox[\".NET/Link\", FontSlant -> \"Italic\"]\)) that specifies whether the class-specific context in which static method and field definitions are created should be placed on $ContextPath."
NETLink`BeginNETBlock::usage = "\!\(\*RowBox[{\"BeginNETBlock\", \"[\", \"]\"}]\) and \!\(\*RowBox[{\"EndNETBlock\", \"[\", \"]\"}]\) are equivalent to the NETBlock function, except that they work across a larger span than the evaluation of a single expression."
NETLink`CallingConvention::usage = "CallingConvention is an option to DefineDLLFunction that specifies what calling convention the DLL function uses."
NETLink`CastNETObject::usage = "\!\(\*RowBox[{\"CastNETObject\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) casts the specified object to a different type."
NETLink`CreateCOMObject::usage = "\!\(\*RowBox[{\"CreateCOMObject\", \"[\", StyleBox[\"str\", \"TI\"], \"]\"}]\) creates a COM object specified by the string \!\(\*StyleBox[\"str\", \"TI\"]\)."
NETLink`DefineDLLFunction::usage = "\!\(\*RowBox[{\"DefineDLLFunction\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"func\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dll\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"rtype\", \"TI\"], \",\", StyleBox[\"atypes\", \"TI\"]}], \"]\"}]\) returns a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) function that calls the specified function \!\(\*StyleBox[\"func\", \"TI\"]\) with argument types \!\(\*StyleBox[\"atypes\", \"TI\"]\) and return type \!\(\*StyleBox[\"rtype\", \"TI\"]\) in the specified unmanaged DLL \!\(\*StyleBox[\"dll\", \"TI\"]\).\n\!\(\*RowBox[{\"DefineDLLFunction\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"declaration\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) lets you write a full C#-syntax \!\(\*StyleBox[\"'extern'\", \"InlineCode\"]\) function declaration. Use this form when you need to write a complex function declaration that requires features not available using options to DefineDLLFunction, such as specific \!\(\*StyleBox[StyleBox[\"\\\"MarshalAs\\\"\",ShowStringCharacters->True], \"InlineCode\"]\) attributes on each of the parameters."
NETLink`DefineNETDelegate::usage = "\!\(\*RowBox[{\"DefineNETDelegate\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"rtype\", \"TI\"], \",\", StyleBox[\"ptypes\", \"TI\"]}], \"]\"}]\) creates a new .NET delegate type with the given name \!\(\*StyleBox[\"name\", \"TI\"]\), return type \!\(\*StyleBox[\"rtype\", \"TI\"]\), and parameter types \!\(\*StyleBox[\"ptypes\", \"TI\"]\)."
NETLink`DoNETModal::usage = "\!\(\*RowBox[{\"DoNETModal\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) displays the specified .NET form in the foreground and does not return until the form window is closed.\n\!\(\*RowBox[{\"DoNETModal\", \"[\", RowBox[{StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) just before the form is closed and returns the result."
NETLink`DoNETModeless::usage = "\!\(\*RowBox[{\"DoNETModeless\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) displays the specified .NET form in the foreground and then returns."
NETLink`EndNETBlock::usage = "\!\(\*RowBox[{\"EndNETBlock\", \"[\", \"]\"}]\) and a preceding BeginNETBlock are equivalent to the NETBlock function, except that they work across a larger span than the evaluation of a single expression."
NETLink`FixCRLF::usage = "\!\(\*RowBox[{\"FixCRLF\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"str\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) changes the linefeeds in the given string to the CR/LF Windows convention."
NETLink`FormStartPosition::usage = "FormStartPosition is an option to DoNETModal, DoNETModeless, ShowNETWindow, and ShowNETConsole that controls the onscreen location of the form when it first appears."
NETLink`GetActiveCOMObject::usage = "\!\(\*RowBox[{\"GetActiveCOMObject\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) acquires an already-running COM object specified by \!\(\*StyleBox[\"string\", \"TI\"]\), which can be either a ProgID (such as \!\(\*StyleBox[\"\"Excel.Application\"\", \"InlineCode\"]\)) or a CLSID (such as \!\(\*StyleBox[\"\"{8E27C92B-1264-101C-8A2F-040224009C02}\"\", \"InlineCode\"]\))."
NETLink`GetAssemblyObject::usage = "\!\(\*RowBox[{\"GetAssemblyObject\", \"[\", StyleBox[\"asm\", \"TI\"], \"\[InvisibleSpace]\", \"]\"}]\) returns the .NET Assembly object corresponding to the specified NETAssembly expression \!\(\*StyleBox[\"asm\", \"TI\"]\)."
NETLink`GetComplexType::usage = "\!\(\*RowBox[{\"GetComplexType\", \"[\", \"]\"}]\) returns the .NET type that is currently mapped to \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) Complex numbers."
NETLink`GetNETException::usage = "\!\(\*RowBox[{\"GetNETException\", \"[\", \"]\"}]\) returns the .NET exception object that was thrown in the most recent call from \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) to .NET."
NETLink`GetTypeObject::usage = "\!\(\*RowBox[{\"GetTypeObject\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \"\[InvisibleSpace]\", \"_\", \"NETType\"}], \"]\"}]\) returns the .NET Type object corresponding to the specified NETType expression."
NETLink`InstallNET::usage = "\!\(\*RowBox[{\"InstallNET\", \"[\", \"]\"}]\) launches the .NET runtime and prepares it to be used from \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\)."
NETLink`InstanceOf::usage = "\!\(\*RowBox[{\"InstanceOf\", \"[\", RowBox[{StyleBox[\"netobject\", \"TI\"], \",\", StyleBox[\"nettype\", \"TI\"]}], \"]\"}]\) gives True if \!\(\*StyleBox[\"netobject\", \"TI\"]\) is an instance of the type \!\(\*StyleBox[\"nettype\", \"TI\"]\), or a subtype, and False otherwise."
NETLink`KeepNETObject::usage = "\!\(\*RowBox[{\"KeepNETObject\", \"[\", StyleBox[\"object\", \"TI\"], \"]\"}]\) causes the specified object(s) not to be released when the current NETBlock ends. \n\!\(\*RowBox[{\"KeepNETObject\", \"[\", RowBox[{StyleBox[\"object\", \"TI\"], \",\", \"Manual\"}], \"]\"}]\) causes the specified object to escape from all enclosing NETBlock expressions, meaning that the object will only be released if you manually call ReleaseNETObject."
NETLink`LanguageSyntax::usage = "LanguageSyntax is an option to NETTypeInfo that specifies which language syntax will be used to display the type information."
NETLink`LoadCOMTypeLibrary::usage = "\!\(\*RowBox[{\"LoadCOMTypeLibrary\", \"[\", StyleBox[\"library\", \"TI\"], \"]\"}]\) creates a so-called \"interop\" assembly from the named type library and loads that assembly. "
NETLink`LoadedNETAssemblies::usage = "\!\(\*RowBox[{\"LoadedNETAssemblies\", \"[\", \"]\"}]\) returns a list of all the .NET assemblies that have been loaded into the current session."
NETLink`LoadedNETObjects::usage = "\!\(\*RowBox[{\"LoadedNETObjects\", \"[\", \"]\"}]\) returns a list of all the .NET objects that have been loaded into the current session."
NETLink`LoadedNETTypes::usage = "\!\(\*RowBox[{\"LoadedNETTypes\", \"[\", \"]\"}]\) returns a list of all the .NET types that have been loaded into the current session."
NETLink`LoadNETAssembly::usage = "\!\(\*RowBox[{\"LoadNETAssembly\", \"[\", StyleBox[\"assembly\", \"TI\"], \"]\"}]\) loads the specified assembly into the .NET runtime and returns a NETAssembly expression that can be used to identify the assembly. \n\!\(\*RowBox[{\"LoadNETAssembly\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"directory\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) loads all the assemblies in the given directory and returns a list of NETAssembly expressions.\n\!\(\*RowBox[{\"LoadNETAssembly\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True], \"]\"}]\) loads all the assemblies in the \"assembly\" subdirectory of the main application directory corresponding to the given context.\n\!\(\*RowBox[{\"LoadNETAssembly\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"directory\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) loads the named assembly from the given directory, if possible. \n\!\(\*RowBox[{\"LoadNETAssembly\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True]}], \"]\"}]\) loads the named assembly from the \"assembly\" subdirectory of the main application directory corresponding to the given context, if possible."
NETLink`LoadNETType::usage = "\!\(\*RowBox[{\"LoadNETType\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) loads the specified type into the .NET runtime and returns a NETType expression that can be used to identify the type.\n\!\(\*RowBox[{\"LoadNETType\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"assembly\", \"TI\"]}], \"]\"}]\) loads the type from the given assembly. "
NETLink`MakeNETObject::usage = "\!\(\*RowBox[{\"MakeNETObject\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) constructs a .NET object that represents the given \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) expression. \n\!\(\*RowBox[{\"MakeNETObject\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) creates an object of the specified type from \!\(\*StyleBox[\"expr\", \"TI\"]\)."
NETLink`MarshalStringsAs::usage = "MarshalStringsAs is an option to DefineDLLFunction that specifies how string arguments should be marshaled into the DLL function. This applies to any arguments that are mapped to the System.String class, which includes types specified in your declaration as \"char*\", \"string\", or \"ByVal As String\"."
NETLink`NETAssembly::usage = "\!\(\*RowBox[{\"NETAssembly\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a .NET assembly with the specified name."
NETLink`NETBlock::usage = "\!\(\*RowBox[{\"NETBlock\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) causes all new .NET objects returned to \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) during the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\) to be released when \!\(\*StyleBox[\"expr\", \"TI\"]\) finishes."
NETLink`NETLink::usage = "\!\(\*RowBox[{\"NETLink\", \"[\", \"]\"}]\) returns the \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"MathLink\", FontSlant -> \"Italic\"]]\) LinkObject that is used to communicate with the \!\(\*StyleBox[\".NET/Link\", FontSlant -> \"Italic\"]\) .NET runtime. "
NETLink`NETNewDelegate::usage = "\!\(\*RowBox[{\"NETNewDelegate\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) creates a new instance of the specified .NET delegate type whose action is to call the named \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) function when triggered."
NETLink`NETNew::usage = "\!\(\*RowBox[{\"NETNew\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) constructs a new object of the specified .NET type.\n\!\(\*RowBox[{\"NETNew\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], StyleBox[\",\", \"MR\"], StyleBox[\"args\[Ellipsis]\", \"TI\"]}], \"]\"}]\) constructs a new object of the specified .NET type, passing the supplied argument sequence to the constructor.\n\!\(\*RowBox[{\"NETNew\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"assembly\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"args\[Ellipsis]\", \"TI\"]}], \"]\"}]\) constructs the object from the named type in the specified assembly. \n\!\(\*RowBox[{\"NETNew\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"assembly\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dir\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}], \",\", StyleBox[\"args\[Ellipsis]\", \"TI\"]}], \"]\"}]\) uses the named assembly from the specified directory, if possible.\n\!\(\*RowBox[{\"NETNew\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"assembly\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}], \",\", StyleBox[\"args\[Ellipsis]\", \"TI\"]}], \"]\"}]\) uses the named assembly from the \"assembly\" subdirectory of the main application directory corresponding to the given context, if possible."
NETLink`NETObjectQ::usage = "\!\(\*RowBox[{\"NETObjectQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a valid reference to a .NET object, and False otherwise."
NETLink`NETObjectToExpression::usage = "\!\(\*RowBox[{\"NETObjectToExpression\", \"[\", StyleBox[\"netObject\", \"TI\"], \"]\"}]\) converts the specified .NET object reference into its value as a \"native\" \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) expression. "
NETLink`NETTypeInfo::usage = "\!\(\*RowBox[{\"NETTypeInfo\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) prints information about the specified type, including its inheritance hierarchy, assembly name, and its public members (constructors, methods, properties, and so on). \n\!\(\*RowBox[{\"NETTypeInfo\", \"[\", StyleBox[\"obj\", \"TI\"], StyleBox[\"]\", \"MR\"]}]\) prints information about the object's type.\n\!\(\*RowBox[{\"NETTypeInfo\", \"[\", StyleBox[\"assembly\", \"TI\"], \"]\"}]\) prints information about the types in the assembly specified by the given NETAssembly expression.\n\!\(\*RowBox[{\"NETTypeInfo\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"members\", \"TI\"]}], \"]\"}]\) prints information about only the specified members, which can be any of the following strings (or a list of them): \"Type\", \"Constructors\", \"Methods\", \"Fields\", \"Properties\", or \"Events\". \n\!\(\*RowBox[{\"NETTypeInfo\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"members\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) prints only the members whose names match the given string pattern."
NETLink`NETType::usage = "\!\(\*RowBox[{\"NETType\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents a .NET type with the specified name."
NETLink`NETUILink::usage = "\!\(\*RowBox[{\"NETUILink\", \"[\", \"]\"}]\) returns the \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"MathLink\", FontSlant -> \"Italic\"]]\) LinkObject used by calls to \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) that originate from .NET user-interface actions, or Null if no such link is present."
NETLink`ReferencedAssemblies::usage = "ReferencedAssemblies is an option to DefineDLLFunction that specifies assemblies needed to compile your function declaration."
NETLink`ReinstallNET::usage = "\!\(\*RowBox[{\"ReinstallNET\", \"[\", \"]\"}]\) is a convenience function that calls \!\(\*RowBox[{\"UninstallNET\", \"[\", \"]\"}]\) and then \!\(\*RowBox[{\"InstallNET\", \"[\", \"]\"}]\)."
NETLink`ReleaseCOMObject::usage = "\!\(\*RowBox[{\"ReleaseCOMObject\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) releases COM resources held by the specified .NET object."
NETLink`ReleaseNETObject::usage = "\!\(\*RowBox[{\"ReleaseNETObject\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) tells the .NET memory-management system to forget any references to the specified NETObject that are being maintained solely for the sake of \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\)."
NETLink`RemoveEventHandler::usage = "\!\(\*RowBox[{\"RemoveEventHandler\", \"[\", RowBox[{StyleBox[RowBox[{\"obj\", \"@\", \"event\"}], \"TI\"], \",\", StyleBox[\"delegate\", \"TI\"]}], \"]\"}]\) removes the specified delegate from the named event."
NETLink`ReturnAsNETObject::usage = "\!\(\*RowBox[{\"ReturnAsNETObject\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) causes a .NET call during the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\) to return its result as an object reference (i.e. a NETObject expression), not a value."
NETLink`SafeArrayAsArray::usage = "SafeArrayAsArray is an option to LoadCOMTypeLibrary that specifies whether to import all SAFEARRAYs as System.Array rather than a typed, single-dimensional managed array."
NETLink`SameObjectQ::usage = "\!\(\*RowBox[{\"SameObjectQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) returns True if and only if the NETObject expressions \!\(\*SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) refer to the same .NET object."
NETLink`SaveAssemblyAs::usage = "SaveAssemblyAs is an option to LoadCOMTypeLibrary that allows you to specify a file name into which to write the interop assembly that gets generated."
NETLink`SendDelegateArguments::usage = "SendDelegateArguments is an option to AddEventHandler and NETNewDelegate that specifies which of the delegate arguments you want to be passed to your \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) callback function."
NETLink`SetComplexType::usage = "\!\(\*RowBox[{\"SetComplexType\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) tells \!\(\*StyleBox[\".NET/Link\", FontSlant -> \"Italic\"]\) to map the specified type to \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) Complex numbers."
NETLink`ShowNETConsole::usage = "\!\(\*RowBox[{\"ShowNETConsole\", \"[\", \"]\"}]\) displays the .NET console window and begins capturing output sent to the \!\(\*StyleBox[\"Console.Out\", \"InlineCode\"]\) and \!\(\*StyleBox[\"Console.Error\", \"InlineCode\"]\) streams.\n\!\(\*RowBox[{\"ShowNETConsole\", \"[\", StyleBox[\"\\\"stdout\\\"\",ShowStringCharacters->True], \"]\"}]\) captures only \!\(\*StyleBox[\"Console.out\", \"InlineCode\"]\).\n\!\(\*RowBox[{\"ShowNETConsole\", \"[\", StyleBox[\"\\\"stderr\\\"\",ShowStringCharacters->True], \"]\"}]\) captures only \!\(\*StyleBox[\"Console.Error\", \"InlineCode\"]\)."
NETLink`ShowNETWindow::usage = "\!\(\*RowBox[{\"ShowNETWindow\", \"[\", StyleBox[\"form\", \"TI\"], \"]\"}]\) displays the specified .NET form in the foreground."
NETLink`StaticsVisible::usage = "StaticsVisible is an option to LoadNETType that specifies whether the class-specific context in which static method and field definitions are created should be placed on $ContextPath."
NETLink`UninstallNET::usage = "\!\(\*RowBox[{\"UninstallNET\", \"[\", \"]\"}]\) shuts down the .NET runtime that was started by InstallNET."
NETLink`WrapInNETBlock::usage = "WrapInNETBlock is an option to AddEventHandler and NETNewDelegate that specifies whether or not the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) callback function assigned to the delegate should be implicitly wrapped in NETBlock."
NETLink`$NETExceptionHandler::usage = "$NETExceptionHandler allows you to control how exceptions thrown in .NET are handled in \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\)."
NeumannValue::usage = "\!\(\*RowBox[{\"NeumannValue\", \"[\", RowBox[{StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"pred\", \"TI\"]}], \"]\"}]\) represents a Neumann boundary value, \!\(\*StyleBox[\"val\", \"TI\"]\), specified on the part of the boundary of the region given to NDSolve where \!\(\*StyleBox[\"pred\", \"TI\"]\) is True."
NevilleThetaC::usage = "\!\(\*RowBox[{\"NevilleThetaC\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Neville theta function \!\(\*RowBox[{SubscriptBox[\"\[CurlyTheta]\", StyleBox[\"c\", \"TI\"]], \" \", RowBox[{\"(\", RowBox[{StyleBox[\"z\", \"TI\"], \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]}]\). "
NevilleThetaD::usage = "\!\(\*RowBox[{\"NevilleThetaD\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Neville theta function \!\(\*RowBox[{SubscriptBox[\"\[CurlyTheta]\", StyleBox[\"d\", \"TI\"]], \" \", RowBox[{\"(\", RowBox[{StyleBox[\"z\", \"TI\"], \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]}]\). "
NevilleThetaN::usage = "\!\(\*RowBox[{\"NevilleThetaN\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Neville theta function \!\(\*RowBox[{SubscriptBox[\"\[CurlyTheta]\", StyleBox[\"n\", \"TI\"]], \" \", RowBox[{\"(\", RowBox[{StyleBox[\"z\", \"TI\"], \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]}]\). "
NevilleThetaS::usage = "\!\(\*RowBox[{\"NevilleThetaS\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Neville theta function \!\(\*RowBox[{SubscriptBox[\"\[CurlyTheta]\", StyleBox[\"s\", \"TI\"]], \" \", RowBox[{\"(\", RowBox[{StyleBox[\"z\", \"TI\"], \"\[VerticalSeparator]\", StyleBox[\"m\", \"TI\"]}], \")\"}]}]\). "
NExpectation::usage = "\!\(\*RowBox[{\"NExpectation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) gives the numerical expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) under the assumption that \!\(\*StyleBox[\"x\", \"TI\"]\) follows the probability distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"NExpectation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) gives the numerical expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) under the assumption that \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) follows the multivariate distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). \n\!\(\*RowBox[{\"NExpectation\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}]}], \"]\"}]\) gives the numerical expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) under the assumption that \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) are independent and follow the distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\). \n\!\(\*RowBox[{\"NExpectation\", \"[\", RowBox[{RowBox[{StyleBox[\"expr\", \"TI\"], \"\[Conditioned]\", StyleBox[\"pred\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the numerical conditional expectation of \!\(\*StyleBox[\"expr\", \"TI\"]\) given \!\(\*StyleBox[\"pred\", \"TI\"]\)."
NextCell::usage = "\!\(\*RowBox[{\"NextCell\", \"[\", \"]\"}]\) returns the CellObject corresponding to the cell directly below the currently evaluating cell.\n\!\(\*RowBox[{\"NextCell\", \"[\", StyleBox[\"cellobj\", \"TI\"], \"]\"}]\) starts looking from the given cell."
NextPrime::usage = "\!\(\*RowBox[{\"NextPrime\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the next prime above \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"NextPrime\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) prime above \!\(\*StyleBox[\"n\", \"TI\"]\)."
NextScheduledTaskTime::usage = "\!\(\*RowBox[{\"NextScheduledTaskTime\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) gives the next execution time of the scheduled task represented by \!\(\*StyleBox[\"obj\", \"TI\"]\)."
NHoldAll::usage = "NHoldAll is an attribute which specifies that none of the arguments to a function should be affected by N. "
NHoldFirst::usage = "NHoldFirst is an attribute which specifies that the first argument to a function should not be affected by N. "
NHoldRest::usage = "NHoldRest is an attribute which specifies that all but the first argument to a function should not be affected by N. "
NicholsGridLines::usage = "NicholsGridLines is an option to NicholsPlot that specifies contours of constant magnitude and constant phase of the closed-loop system."
NicholsPlot::usage = "\!\(\*RowBox[{\"NicholsPlot\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) generates a Nichols plot of the transfer function for the system \!\(\*StyleBox[\"lsys\", \"TI\"]\).\n\!\(\*RowBox[{\"NicholsPlot\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots for the frequency range \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"NicholsPlot\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots \!\(\*StyleBox[\"expr\", \"TI\"]\) using the variable \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
NightHemisphere::usage = "\!\(\*RowBox[{\"NightHemisphere\", \"[\", \"]\"}]\) is a two-dimensional GeoGraphics primitive that represents the half of the Earth currently in darkness.\n\!\(\*RowBox[{\"NightHemisphere\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) represents the night half of the Earth for the specified date."
NIntegrate::usage = "\!\(\*RowBox[{\"NIntegrate\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives a numerical approximation to the integral \!\(\*RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], \" \", RowBox[{StyleBox[\"f\", \"TI\"], \" \", StyleBox[\"d\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"x\", \"TI\"]}]}]\). \n\!\(\*RowBox[{\"NIntegrate\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a numerical approximation to the multiple integral \!\(\*RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"d\", \"TI\"], StyleBox[\"x\", \"TI\"], RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"d\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"y\", \"TI\"], \" \", \"\[Ellipsis]\", \" \", StyleBox[\"f\", \"TI\"]}]}]}]}]\).\n\!\(\*RowBox[{\"NIntegrate\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) integrates over the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
NMaximize::usage = "\!\(\*RowBox[{\"NMaximize\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) maximizes \!\(\*StyleBox[\"f\", \"TI\"]\) numerically with respect to \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"NMaximize\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) maximizes \!\(\*StyleBox[\"f\", \"TI\"]\) numerically with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\). \n\!\(\*RowBox[{\"NMaximize\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) maximizes \!\(\*StyleBox[\"f\", \"TI\"]\) numerically subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"NMaximize\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
NMaxValue::usage = "\!\(\*RowBox[{\"NMaxValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the maximum value of \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"NMaxValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the maximum value of \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis]. \n\!\(\*RowBox[{\"NMaxValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the maximum value of \!\(\*StyleBox[\"f\", \"TI\"]\) subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"NMaxValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
NMinimize::usage = "\!\(\*RowBox[{\"NMinimize\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) minimizes \!\(\*StyleBox[\"f\", \"TI\"]\) numerically with respect to \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"NMinimize\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) minimizes \!\(\*StyleBox[\"f\", \"TI\"]\) numerically with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\). \n\!\(\*RowBox[{\"NMinimize\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) minimizes \!\(\*StyleBox[\"f\", \"TI\"]\) numerically subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\). \n\!\(\*RowBox[{\"NMinimize\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
NMinValue::usage = "\!\(\*RowBox[{\"NMinValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the minimum value of \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"NMinValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the minimum value of \!\(\*StyleBox[\"f\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis]. \n\!\(\*RowBox[{\"NMinValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the minimum value of \!\(\*StyleBox[\"f\", \"TI\"]\) subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\).\n\!\(\*RowBox[{\"NMinValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) constrains \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
NominalVariables::usage = "NominalVariables is an option for machine learning functions such as LinearModelFit or Classify that specifies which variables should be treated as having discrete values specified by names."
NonAssociative::usage = "NonAssociative is a symbol that represents a non-associative operator in formatting functions."
NoncentralBetaDistribution::usage = "\!\(\*RowBox[{\"NoncentralBetaDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"]}], \"]\"}]\) represents a noncentral beta distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\), \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) and noncentrality parameter \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\)."
NoncentralChiSquareDistribution::usage = "\!\(\*RowBox[{\"NoncentralChiSquareDistribution\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"]\"}]\) represents a noncentral \!\(\*SuperscriptBox[\"\[Chi]\", \"2\"]\) distribution with \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom and noncentrality parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\)."
NoncentralFRatioDistribution::usage = "\!\(\*RowBox[{\"NoncentralFRatioDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"]\"}]\) represents a noncentral F-ratio distribution with \!\(\*StyleBox[\"n\", \"TI\"]\) numerator degrees of freedom, \!\(\*StyleBox[\"m\", \"TI\"]\) denominator degrees of freedom, and numerator noncentrality parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\).\n\!\(\*RowBox[{\"NoncentralFRatioDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\" \", \"TR\"], StyleBox[\"\[Eta]\", \"TR\"]}], \"]\"}]\) represents a doubly noncentral F-ratio distribution with numerator noncentrality parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\) and denominator noncentrality parameter \!\(\*StyleBox[\"\[Eta]\", \"TR\"]\)."
NoncentralStudentTDistribution::usage = "\!\(\*RowBox[{\"NoncentralStudentTDistribution\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"]}], \"]\"}]\) represents a noncentral Student \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom and noncentrality parameter \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\)."
NonCommutativeMultiply::usage = "\!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"**\", StyleBox[\"b\", \"TI\"], \"**\", StyleBox[\"c\", \"TI\"]}]\) is a general associative, but non\[Hyphen]commutative, form of multiplication. "
NonConstants::usage = "NonConstants is an option for D which gives a list of objects to be taken to depend implicitly on the differentiation variables. "
NoneTrue::usage = "\!\(\*RowBox[{\"NoneTrue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) yields True if \!\(\*RowBox[{StyleBox[\"test\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is False for all of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"NoneTrue\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"level\", \"TI\"]}], \"]\"}]\) tests parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) at level \!\(\*StyleBox[\"level\", \"TI\"]\).\n\!\(\*RowBox[{\"NoneTrue\", \"[\", StyleBox[\"test\", \"TI\"], \"]\"}]\) represents an operator form of NoneTrue that can be applied to an expression."
None::usage = "None is a setting used for certain options. "
NonlinearModelFit::usage = "\!\(\*RowBox[{\"NonlinearModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"form\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) constructs a nonlinear model with structure \!\(\*StyleBox[\"form\", \"TI\"]\) that fits the \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for successive \!\(\*StyleBox[\"x\", \"TI\"]\) values 1, 2, \[Ellipsis] using the parameters \!\(\*StyleBox[SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \"TI\"]\), \[Ellipsis].\n\!\(\*RowBox[{\"NonlinearModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"form\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs a nonlinear model where \!\(\*StyleBox[\"form\", \"TI\"]\) depends on the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]]\). \n\!\(\*RowBox[{\"NonlinearModelFit\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs a nonlinear model subject to the parameter constraints \!\(\*StyleBox[\"cons\", \"TI\"]\)."
NonlinearRegression`NonlinearRegress::usage = "\!\(\*RowBox[{\"NonlinearRegress\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pars\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) finds numerical values of the parameters \!\(\*StyleBox[\"pars\", \"TI\"]\) that make the model \!\(\*StyleBox[\"expr\", \"TI\"]\) give a best fit to \!\(\*StyleBox[\"data\", \"TI\"]\) as a function of \!\(\*StyleBox[\"vars\", \"TI\"]\) and provides diagnostics for the fitting.\n\!\(\*RowBox[{\"NonlinearRegress\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"cons\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"pars\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) finds a best fit and provides diagnostics subject to the constraints \!\(\*StyleBox[\"cons\", \"TI\"]\)."
NonlinearStateSpaceModel::usage = "\!\(\*RowBox[{\"NonlinearStateSpaceModel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"]}], \"]\"}]\) represents the model \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"'\"}], RowBox[{\"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \"\[Equal]\", RowBox[{StyleBox[\"f\", \"TI\"], \"(\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}]}]\), \!\(\*RowBox[{RowBox[{StyleBox[\"y\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \"\[Equal]\", RowBox[{StyleBox[\"g\", \"TI\"], \"(\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}]}]\).\n\!\(\*RowBox[{\"NonlinearStateSpaceModel\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives a state-space representation corresponding to the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\). \n\!\(\*RowBox[{\"NonlinearStateSpaceModel\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"10\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"10\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the state-space model of the differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) with dependent variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), input variables \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), operating vaues \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[StyleBox[RowBox[{\"i\", StyleBox[\"0\", FontSlant -> \"Plain\"]}]], \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[StyleBox[RowBox[{\"i\", StyleBox[\"0\", FontSlant -> \"Plain\"]}]], \"TI\"]]\), outputs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and independent variable \!\(\*StyleBox[\"t\", \"TI\"]\)."
NonlocalMeansFilter::usage = "\!\(\*RowBox[{\"NonlocalMeansFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies a nonlocal means filter to \!\(\*StyleBox[\"image\", \"TI\"]\) by comparing a range \!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood to its nearby neighborhoods.\n\!\(\*RowBox[{\"NonlocalMeansFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"ns\", \"TI\"]}], \"]\"}]\) assumes an additive noise power value \!\(\*StyleBox[\"ns\", \"TI\"]\) for comparing neighborhoods.\n\!\(\*RowBox[{\"NonlocalMeansFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"ns\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) compares neighborhoods in a range \!\(\*StyleBox[\"w\", \"TI\"]\) window."
NonNegative::usage = "\!\(\*RowBox[{\"NonNegative\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"x\", \"TI\"]\) is a non\[Hyphen]negative number. "
NonPositive::usage = "\!\(\*RowBox[{\"NonPositive\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"x\", \"TI\"]\) is a non\[Hyphen]positive number. "
NorlundB::usage = "\!\(\*RowBox[{\"NorlundB\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives N\[OSlash]rlund polynomials \!\(\*SubsuperscriptBox[StyleBox[\"B\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", StyleBox[\"a\", \"TI\"], \")\"}]]\) of degree \!\(\*StyleBox[\"n\", \"TI\"]\) in \!\(\*StyleBox[\"a\", \"TI\"]\).\n\!\(\*RowBox[{\"NorlundB\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives generalized Bernoulli polynomials \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"B\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", StyleBox[\"a\", \"TI\"], \")\"}]], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\)."
NormalDistribution::usage = "\!\(\*RowBox[{\"NormalDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a normal (Gaussian) distribution with mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"NormalDistribution\", \"[\", \"]\"}]\) represents a normal distribution with zero mean and unit standard deviation."
NormalizedSquaredEuclideanDistance::usage = "\!\(\*RowBox[{\"NormalizedSquaredEuclideanDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the normalized squared Euclidean distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
Normalized::usage = "Normalized is an option that determines whether to test if matrix rows are normalized."
NormalizeImages::usage = "\!\(\*RowBox[{\"NormalizeImages\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) returns a scaled version of the \!\(\*SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) so that their sum is a white image.\n\!\(\*RowBox[{\"NormalizeImages\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"img\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) normalizes the images according to the \!\(\*StyleBox[\"p\", \"TI\"]\)-norm."
Normalize::usage = "\!\(\*RowBox[{\"Normalize\", \"[\", StyleBox[\"v\", \"TI\"], \"]\"}]\) gives the normalized form of a vector \!\(\*StyleBox[\"v\", \"TI\"]\). \n\!\(\*RowBox[{\"Normalize\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the normalized form of a complex number \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"Normalize\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) normalizes with respect to the norm function \!\(\*StyleBox[\"f\", \"TI\"]\)."
NormalMatrixQ::usage = "\!\(\*RowBox[{\"NormalMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is an explicitly normal matrix, and False otherwise."
NormalsFunction::usage = "NormalsFunction is an option for Plot3D and related functions that specifies a function to apply to determine the effective surface normals at every point."
Normal::usage = "\!\(\*RowBox[{\"Normal\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts \!\(\*StyleBox[\"expr\", \"TI\"]\) to a normal expression from a variety of special forms. \n\!\(\*RowBox[{\"Normal\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) converts objects with head \!\(\*StyleBox[\"h\", \"TI\"]\) in \!\(\*StyleBox[\"expr\", \"TI\"]\) to normal expressions.\n\!\(\*RowBox[{\"Normal\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"h\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"h\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) converts objects with head \!\(\*SubscriptBox[StyleBox[\"h\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to normal expressions."
NormFunction::usage = "NormFunction is an option for functions such as FindFit and NDSolve which gives a function to be minimized in generating results."
Norm::usage = "\!\(\*RowBox[{\"Norm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the norm of a number, vector, or matrix. \n\!\(\*RowBox[{\"Norm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"p\", \"TI\"]\)\[Hyphen]norm. "
Nor::usage = "\!\(\*RowBox[{\"Nor\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is the logical NOR function. It evaluates its arguments in order, giving False immediately if any of them are True, and True if they are all False. "
Notation`Action::usage = "Action is an option of Notation, Symbolize, and InfixNotation that defines what action will be performed with the given notation statement."
Notation`ActiveInputAliases::usage = "\!\(\*RowBox[{\"ActiveInputAliases\", \"[\", \"]\"}]\) returns a list of all active aliases in the current notebook. \n\!\(\*RowBox[{\"ActiveInputAliases\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) returns a list of all active aliases in the notebook \!\(\*StyleBox[\"notebook\", \"TI\"]\)."
Notation`AddInputAlias::usage = "\!\(\*RowBox[{\"AddInputAlias\", \"[\", RowBox[{StyleBox[\"alias\", \"TI\"], \"->\", StyleBox[\"boxes\", \"TI\"]}], \"]\"}]\) adds the alias \!\(\*StyleBox[\"Esc\", \"KeyEvent\"]\)\!\(\*StyleBox[\"\[ThinSpace]\", \"InlineCode\"]\)\!\(\*StyleBox[\"alias\", \"TI\"]\)\!\(\*StyleBox[\"\[ThinSpace]\", \"InlineCode\"]\)\!\(\*StyleBox[\"Esc\", \"KeyEvent\"]\) for \!\(\*StyleBox[\"boxes\", \"TI\"]\) to the aliases in the current notebook. \n\!\(\*RowBox[{\"AddInputAlias\", \"[\", RowBox[{StyleBox[RowBox[{\"alias\", StyleBox[\"->\", FontSlant -> \"Plain\"], \"boxes\"}], \"TI\"], \",\", StyleBox[\"notebook\", \"TI\"]}], \"]\"}]\) adds the alias to the notebook \!\(\*StyleBox[\"notebook\", \"TI\"]\)."
Notation`AutoLoadNotationPalette::usage = "AutoLoadNotationPalette specifies whether the \!\(\*StyleBox[\"Notation\", \"DialogElementName\"]\) palette is opened when the Notation Package is loaded."
Notation`ClearNotations::usage = "\!\(\*RowBox[{\"ClearNotations\", \"[\", \"]\"}]\) will remove all notations, symbolizations, and infix notations."
Notation`CreateNotationRules::usage = "CreateNotationRules is a possible value for the Action option to Notation, Symbolize, and InfixNotation."
Notation`InfixNotation::usage = "\!\(\*RowBox[{\"InfixNotation\", \"[\", RowBox[{StyleBox[\"op\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) forces the box structure \!\(\*StyleBox[\"op\", \"TI\"]\) to be treated as an infix operator representing the function \!\(\*StyleBox[\"func\", \"TI\"]\) in input and output."
Notation`NotationBoxTag::usage = "NotationBoxTag is provided for compatibility with previous versions of saved notation files."
Notation`NotationMadeBoxesTag::usage = "NotationMadeBoxesTag is provided for compatibility with previous versions of saved notation files."
Notation`NotationMakeBoxes::usage = "NotationMakeBoxes is a private version of MakeBoxes."
Notation`NotationMakeExpression::usage = "NotationMakeExpression is a private version of MakeExpression."
Notation`NotationPatternTag::usage = "NotationPatternTag is provided for compatibility with previous versions of saved notation files."
Notation`Notation::usage = "\!\(\*RowBox[{\"Notation\", \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \" \", \"\[DoubleLongLeftRightArrow]\", \" \", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) parses any input box structure \!\(\*StyleBox[\"boxes\", \"TI\"]\) internally as \!\(\*StyleBox[\"expr\", \"TI\"]\), and formats any expression matching \!\(\*StyleBox[\"expr\", \"TI\"]\) as \!\(\*StyleBox[\"boxes\", \"TI\"]\) in output.\n\!\(\*RowBox[{\"Notation\", \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \"\[DoubleLongRightArrow]\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) restricts Notation to only parsing.\n\!\(\*RowBox[{\"Notation\", \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \"\[DoubleLongLeftArrow]\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) restricts Notation to only formatting."
Notation`ParsedBoxWrapper::usage = "ParsedBoxWrapper is a wrapper that wraps parsed boxes which come from the TagBox expressions that are embedded in Notation, Symbolize, and InfixNotation statements."
Notation`PrintNotationRules::usage = "PrintNotationRules is a possible value for the Action option to Notation, Symbolize, and InfixNotation."
Notation`RemoveInfixNotation::usage = "\!\(\*RowBox[{\"RemoveInfixNotation\", \"[\", RowBox[{StyleBox[\"op\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) removes the infix operator \!\(\*StyleBox[\"op\", \"TI\"]\)."
Notation`RemoveNotationRules::usage = "RemoveNotationRules is a possible value for the Action option to Notation, Symbolize, and InfixNotation."
Notation`RemoveNotation::usage = "\!\(\*RowBox[{\"RemoveNotation\", \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \" \", \"\[DoubleLongLeftRightArrow]\", \" \", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) removes the notation \!\(\*RowBox[{StyleBox[\"boxes\", \"TI\"], \" \", \"\[DoubleLongLeftRightArrow]\", \" \", StyleBox[\"expr\", \"TI\"]}]\).\n\!\(\*RowBox[{\"RemoveNotation\", \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \"\[DoubleLongRightArrow]\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) removes only the parsing.\n\!\(\*RowBox[{\"RemoveNotation\", \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \"\[DoubleLongLeftArrow]\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) removes only the formatting."
Notation`RemoveSymbolize::usage = "\!\(\*RowBox[{\"RemoveSymbolize\", \"[\", StyleBox[\"boxes\", \"TI\"], \"]\"}]\) removes the symbolization of \!\(\*StyleBox[\"boxes\", \"TI\"]\)."
Notation`SymbolizeRootName::usage = "SymbolizeRootName is an option for Symbolize specifying the name to be used internally for the symbolized boxes."
Notation`Symbolize::usage = "\!\(\*RowBox[{\"Symbolize\", \"[\", StyleBox[\"boxes\", \"TI\"], \"]\"}]\) forces any box structure matching \!\(\*StyleBox[\"boxes\", \"TI\"]\) to be treated internally as a single symbol anywhere it appears in an input expression."
Notation`UpdateNotebookStyles::usage = "\!\(\*RowBox[{\"UpdateNotebookStyles\", \"[\", \"]\"}]\) is a function that will add the styles and input aliases the Notation Package defines to your current notebook.\n\!\(\*RowBox[{\"UpdateNotebookStyles\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) will update the stylesheet of the notebook \!\(\*StyleBox[\"notebook\", \"TI\"]\)."
Notation`WorkingForm::usage = "WorkingForm is an option of Notation, Symbolize, and InfixNotation that defines in which form the notation will be defined."
NotCongruent::usage = "\!\(\*RowBox[{\"NotCongruent\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotCongruent]\", StyleBox[\"y\", \"TI\"], \"\[NotCongruent]\", \"\[Ellipsis]\"}]\)."
NotCupCap::usage = "\!\(\*RowBox[{\"NotCupCap\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotCupCap]\", StyleBox[\"y\", \"TI\"], \"\[NotCupCap]\", \"\[Ellipsis]\"}]\)."
NotDoubleVerticalBar::usage = "\!\(\*RowBox[{\"NotDoubleVerticalBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotDoubleVerticalBar]\", StyleBox[\"y\", \"TI\"], \"\[NotDoubleVerticalBar]\", \"\[Ellipsis]\"}]\)."
NotebookApply::usage = "\!\(\*RowBox[{\"NotebookApply\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) writes data into a notebook at the current selection, replacing the first selection placeholder in \!\(\*StyleBox[\"data\", \"TI\"]\) by the current selection, and then setting the current selection to be just after the data written. \n\!\(\*RowBox[{\"NotebookApply\", \"[\", RowBox[{StyleBox[\"cell\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) writes data into a notebook in place of the specified cell.\n\!\(\*RowBox[{\"NotebookApply\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"sel\", \"TI\"]}], \"]\"}]\) writes data into a notebook and then sets the current selection to be as specified by \!\(\*StyleBox[\"sel\", \"TI\"]\). "
NotebookAutoSave::usage = "NotebookAutoSave is a notebook option which specifies whether the notebook should automatically be saved after each piece of output generated by evaluation in it. "
NotebookBrowseDirectory::usage = "NotebookBrowseDirectory is a global option that determines the current working directory."
NotebookClose::usage = "\!\(\*RowBox[{\"NotebookClose\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) closes the notebook corresponding to the specified notebook object. \n\!\(\*RowBox[{\"NotebookClose\", \"[\", \"]\"}]\) closes the current evaluation notebook."
NotebookConvertSettings::usage = "\!\(\*RowBox[{\"NotebookConvertSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is a global option that specifies settings for converting imported legacy notebooks."
NotebookCreate::usage = "\!\(\*RowBox[{\"NotebookCreate\", \"[\", \"]\"}]\) creates a new open notebook in the front end. \n\!\(\*RowBox[{\"NotebookCreate\", \"[\", StyleBox[\"options\", \"TI\"], \"]\"}]\) sets up the specified options for the new notebook. "
NotebookDelete::usage = "\!\(\*RowBox[{\"NotebookDelete\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) deletes the current selection in the notebook corresponding to the specified notebook object. \n\!\(\*RowBox[{\"NotebookDelete\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) deletes the given cell or box object.\n\!\(\*RowBox[{\"NotebookDelete\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) deletes all specified objects.\n\!\(\*RowBox[{\"NotebookDelete\", \"[\", \"]\"}]\) deletes the current selection in the current evaluation notebook."
NotebookDirectory::usage = "\!\(\*RowBox[{\"NotebookDirectory\", \"[\", \"]\"}]\) gives the directory of the current evaluation notebook. \n\!\(\*RowBox[{\"NotebookDirectory\", \"[\", StyleBox[\"nb\", \"TI\"], \"]\"}]\) gives the directory for the notebook specified by \!\(\*StyleBox[\"nb\", \"TI\"]\). "
NotebookDynamicExpression::usage = "NotebookDynamicExpression is an option for notebooks that specifies an expression to be dynamically updated whenever that notebook is open."
NotebookEvaluate::usage = "\!\(\*RowBox[{\"NotebookEvaluate\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) evaluates all the evaluatable cells in \!\(\*StyleBox[\"notebook\", \"TI\"]\)."
NotebookEventActions::usage = "NotebookEventActions is a notebook option that gives a list of actions to perform when specified events occur in connection with the notebook. "
NotebookFileName::usage = "\!\(\*RowBox[{\"NotebookFileName\", \"[\", \"]\"}]\) gives the file name of the current evaluation notebook. \n\!\(\*RowBox[{\"NotebookFileName\", \"[\", StyleBox[\"nb\", \"TI\"], \"]\"}]\) gives the file name for the notebook specified by \!\(\*StyleBox[\"nb\", \"TI\"]\). "
NotebookFind::usage = "\!\(\*RowBox[{\"NotebookFind\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) sets the current selection in the specified notebook object to be the next occurrence of \!\(\*StyleBox[\"data\", \"TI\"]\). \n\!\(\*RowBox[{\"NotebookFind\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", \"Previous\"}], \"]\"}]\) sets the current selection to be the previous occurrence. \n\!\(\*RowBox[{\"NotebookFind\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", \"All\"}], \"]\"}]\) sets the current selection to be all occurrences. \n\!\(\*RowBox[{\"NotebookFind\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dir\", \"TI\"], \",\", StyleBox[\"elems\", \"TI\"]}], \"]\"}]\) sets the current selection to be the occurrence in the direction \!\(\*StyleBox[\"dir\", \"TI\"]\) and searches the elements of cells specified by \!\(\*StyleBox[\"elems\", \"TI\"]\). "
NotebookGet::usage = "\!\(\*RowBox[{\"NotebookGet\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) gets the raw expression corresponding to the notebook represented by the notebook object \!\(\*StyleBox[\"obj\", \"TI\"]\). \n\!\(\*RowBox[{\"NotebookGet\", \"[\", \"]\"}]\) gets the raw expression corresponding to the currently selected notebook. "
NotebookImport::usage = "\!\(\*RowBox[{\"NotebookImport\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"style\", \"TI\"]}], \"]\"}]\) imports cells with the given cell style from the specified notebook.\n\!\(\*RowBox[{\"NotebookImport\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", RowBox[{StyleBox[\"style\", \"TI\"], \"\[Rule]\", StyleBox[\"form\", \"TI\"]}]}], \"]\"}]\) imports cells in the form specified by \!\(\*StyleBox[\"form\", \"TI\"]\)."
NotebookInformation::usage = "\!\(\*RowBox[{\"NotebookInformation\", \"[\", \"]\"}]\) gives a list of properties of the current evaluation notebook.\n\!\(\*RowBox[{\"NotebookInformation\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) gives a list of properties for the specified notebook."
NotebookLocate::usage = "\!\(\*RowBox[{\"NotebookLocate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"tag\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) locates all cells with the specified tag in your current input notebook, selecting the cells and scrolling to the position of the first one. \n\!\(\*RowBox[{\"NotebookLocate\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"tag\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}], \"]\"}]\) if necessary opens the notebook stored in \!\(\*StyleBox[\"file\", \"TI\"]\), then locates cells with the specified tag. "
NotebookObject::usage = "\!\(\*RowBox[{\"NotebookObject\", \"[\", RowBox[{StyleBox[\"fe\", \"TI\"], \",\", StyleBox[\"id\", \"TI\"]}], \"]\"}]\) is an object that represents an open notebook in the front end. "
NotebookOpen::usage = "\!\(\*RowBox[{\"NotebookOpen\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) opens an existing notebook with the specified name, returning the corresponding notebook object. \n\!\(\*RowBox[{\"NotebookOpen\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) opens a notebook using the options given. \n\!\(\*RowBox[{\"NotebookOpen\", \"[\", RowBox[{StyleBox[\"\\\"http://\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) opens a notebook from any accessible URL. "
NotebookPath::usage = "NotebookPath is a global option that determines which directories are searched when a specified notebook is needed."
NotebookPrint::usage = "\!\(\*RowBox[{\"NotebookPrint\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) sends a notebook containing \!\(\*StyleBox[\"expr\", \"TI\"]\) to your default printer.\n\!\(\*RowBox[{\"NotebookPrint\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) sends the specified notebook to your default printer. \n\!\(\*RowBox[{\"NotebookPrint\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).\\!\\(\\*StyleBox[\\\"ext\\\",\\\"TI\\\"]\\)\\\"\",ShowStringCharacters->True]}], \"]\"}]\) saves a print\[Hyphen]ready form of the notebook to a file in the format indicated by the file extension \!\(\*StyleBox[\"ext\", \"TI\"]\). \n\!\(\*RowBox[{\"NotebookPrint\", \"[\", \"]\"}]\) sends the current evaluation notebook to your default printer."
NotebookPut::usage = "\!\(\*RowBox[{\"NotebookPut\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) creates a notebook corresponding to \!\(\*StyleBox[\"expr\", \"TI\"]\) and makes it the currently selected notebook in the front end. \n\!\(\*RowBox[{\"NotebookPut\", \"[\", \"]\"}]\) creates a new empty notebook.\n\!\(\*RowBox[{\"NotebookPut\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) replaces the notebook represented by the notebook object \!\(\*StyleBox[\"obj\", \"TI\"]\) with one corresponding to \!\(\*StyleBox[\"expr\", \"TI\"]\). "
NotebookRead::usage = "\!\(\*RowBox[{\"NotebookRead\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) gives the expression corresponding to the current selection in the specified notebook object. \n\!\(\*RowBox[{\"NotebookRead\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) gives the expression corresponding to the given cell or box object.\n\!\(\*RowBox[{\"NotebookRead\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of expressions corresponding to the \!\(\*SubscriptBox[StyleBox[\"obj\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
NotebookSave::usage = "\!\(\*RowBox[{\"NotebookSave\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) saves the current version of the specified notebook. \n\!\(\*RowBox[{\"NotebookSave\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) saves the notebook in the specified file. \n\!\(\*RowBox[{\"NotebookSave\", \"[\", \"]\"}]\) saves the current version of the current evaluation notebook in a file."
NotebookSelection::usage = "\!\(\*RowBox[{\"NotebookSelection\", \"[\", \"]\"}]\) represents the current selection in the current evaluation notebook in the front end.\n\!\(\*RowBox[{\"NotebookSelection\", \"[\", StyleBox[\"nb\", \"TI\"], \"]\"}]\) represents the current selection associated with the open notebook \!\(\*StyleBox[\"nb\", \"TI\"]\). "
NotebooksMenu::usage = "NotebooksMenu is a global option that specifies which recently opened notebooks are listed under the \!\(\*StyleBox[\"File\", \"MenuName\"]\) menu."
Notebooks::usage = "\!\(\*RowBox[{\"Notebooks\", \"[\", \"]\"}]\) gives a list of notebooks currently open in the front end."
NotebookTemplate::usage = "\!\(\*RowBox[{\"NotebookTemplate\", \"[\", StyleBox[\"nb\", \"TI\"], \"]\"}]\) yields a TemplateObject that represents a notebook template to be applied using functions like GenerateDocument and FileTemplateApply."
Notebook::usage = "\!\(\*RowBox[{\"Notebook\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is the low\[Hyphen]level construct that represents a notebook manipulated by the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) front end. "
NotebookWrite::usage = "\!\(\*RowBox[{\"NotebookWrite\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) writes data into a notebook at the current selection, setting the current selection to be just after the data written. \n\!\(\*RowBox[{\"NotebookWrite\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) replaces the given cell or box object instead of the current selection.\n\!\(\*RowBox[{\"NotebookWrite\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"sel\", \"TI\"]}], \"]\"}]\) writes data into a notebook, setting the current selection to be as specified by \!\(\*StyleBox[\"sel\", \"TI\"]\). "
NotElement::usage = "\!\(\*RowBox[{\"NotElement\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotElement]\", StyleBox[\"dom\", \"TI\"]}]\) asserts that \!\(\*StyleBox[\"x\", \"TI\"]\) is not an element of the domain \!\(\*StyleBox[\"dom\", \"TI\"]\).\n\!\(\*RowBox[{\"NotElement\", \"[\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"|\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"|\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) asserts that none of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are elements of \!\(\*StyleBox[\"dom\", \"TI\"]\).\n\!\(\*RowBox[{\"NotElement\", \"[\", RowBox[{StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) asserts that any expression matching the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\) is not an element of the domain \!\(\*StyleBox[\"dom\", \"TI\"]\)."
NotEqualTilde::usage = "\!\(\*RowBox[{\"NotEqualTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotEqualTilde]\", StyleBox[\"y\", \"TI\"], \"\[NotEqualTilde]\", \"\[Ellipsis]\"}]\)."
NotExists::usage = "\!\(\*RowBox[{\"NotExists\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{SubscriptBox[\"\[NotExists]\", StyleBox[\"x\", \"TI\"]], StyleBox[\"y\", \"TI\"]}]\)."
NotGreaterEqual::usage = "\!\(\*RowBox[{\"NotGreaterEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotGreaterEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotGreaterEqual]\", \"\[Ellipsis]\"}]\)."
NotGreaterFullEqual::usage = "\!\(\*RowBox[{\"NotGreaterFullEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotGreaterFullEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotGreaterFullEqual]\", \"\[Ellipsis]\"}]\)."
NotGreaterGreater::usage = "\!\(\*RowBox[{\"NotGreaterGreater\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotGreaterGreater]\", StyleBox[\"y\", \"TI\"], \"\[NotGreaterGreater]\", \"\[Ellipsis]\"}]\)."
NotGreaterLess::usage = "\!\(\*RowBox[{\"NotGreaterLess\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotGreaterLess]\", StyleBox[\"y\", \"TI\"], \"\[NotGreaterLess]\", \"\[Ellipsis]\"}]\)."
NotGreaterSlantEqual::usage = "\!\(\*RowBox[{\"NotGreaterSlantEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotGreaterSlantEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotGreaterSlantEqual]\", \"\[Ellipsis]\"}]\)."
NotGreaterTilde::usage = "\!\(\*RowBox[{\"NotGreaterTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotGreaterTilde]\", StyleBox[\"y\", \"TI\"], \"\[NotGreaterTilde]\", \"\[Ellipsis]\"}]\)."
NotGreater::usage = "\!\(\*RowBox[{\"NotGreater\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotGreater]\", StyleBox[\"y\", \"TI\"], \"\[NotGreater]\", \"\[Ellipsis]\"}]\)."
Nothing::usage = "Nothing represents an element of a list or association that will automatically be removed. \n\!\(\*RowBox[{\"Nothing\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) gives Nothing."
NotHumpDownHump::usage = "\!\(\*RowBox[{\"NotHumpDownHump\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotHumpDownHump]\", StyleBox[\"y\", \"TI\"], \"\[NotHumpDownHump]\", \"\[Ellipsis]\"}]\)."
NotHumpEqual::usage = "\!\(\*RowBox[{\"NotHumpEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotHumpEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotHumpEqual]\", \"\[Ellipsis]\"}]\)."
NotificationFunction::usage = "NotificationFunction is an option that specifies how notifications should be sent from asynchronous tasks."
NotLeftTriangleBar::usage = "\!\(\*RowBox[{\"NotLeftTriangleBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLeftTriangleBar]\", StyleBox[\"y\", \"TI\"], \"\[NotLeftTriangleBar]\", \"\[Ellipsis]\"}]\)."
NotLeftTriangleEqual::usage = "\!\(\*RowBox[{\"NotLeftTriangleEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLeftTriangleEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotLeftTriangleEqual]\", \"\[Ellipsis]\"}]\)."
NotLeftTriangle::usage = "\!\(\*RowBox[{\"NotLeftTriangle\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLeftTriangle]\", StyleBox[\"y\", \"TI\"], \"\[NotLeftTriangle]\", \"\[Ellipsis]\"}]\)."
NotLessEqual::usage = "\!\(\*RowBox[{\"NotLessEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLessEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotLessEqual]\", \"\[Ellipsis]\"}]\)."
NotLessFullEqual::usage = "\!\(\*RowBox[{\"NotLessFullEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLessFullEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotLessFullEqual]\", \"\[Ellipsis]\"}]\)."
NotLessGreater::usage = "\!\(\*RowBox[{\"NotLessGreater\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLessGreater]\", StyleBox[\"y\", \"TI\"], \"\[NotLessGreater]\", \"\[Ellipsis]\"}]\)."
NotLessLess::usage = "\!\(\*RowBox[{\"NotLessLess\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLessLess]\", StyleBox[\"y\", \"TI\"], \"\[NotLessLess]\", \"\[Ellipsis]\"}]\)."
NotLessSlantEqual::usage = "\!\(\*RowBox[{\"NotLessSlantEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLessSlantEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotLessSlantEqual]\", \"\[Ellipsis]\"}]\)."
NotLessTilde::usage = "\!\(\*RowBox[{\"NotLessTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLessTilde]\", StyleBox[\"y\", \"TI\"], \"\[NotLessTilde]\", \"\[Ellipsis]\"}]\)."
NotLess::usage = "\!\(\*RowBox[{\"NotLess\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotLess]\", StyleBox[\"y\", \"TI\"], \"\[NotLess]\", \"\[Ellipsis]\"}]\)."
NotNestedGreaterGreater::usage = "\!\(\*RowBox[{\"NotNestedGreaterGreater\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotNestedGreaterGreater]\", StyleBox[\"y\", \"TI\"], \"\[NotNestedGreaterGreater]\", \"\[Ellipsis]\"}]\)."
NotNestedLessLess::usage = "\!\(\*RowBox[{\"NotNestedLessLess\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotNestedLessLess]\", StyleBox[\"y\", \"TI\"], \"\[NotNestedLessLess]\", \"\[Ellipsis]\"}]\)."
NotPrecedesEqual::usage = "\!\(\*RowBox[{\"NotPrecedesEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotPrecedesEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotPrecedesEqual]\", \"\[Ellipsis]\"}]\)."
NotPrecedesSlantEqual::usage = "\!\(\*RowBox[{\"NotPrecedesSlantEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotPrecedesSlantEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotPrecedesSlantEqual]\", \"\[Ellipsis]\"}]\)."
NotPrecedesTilde::usage = "\!\(\*RowBox[{\"NotPrecedesTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotPrecedesTilde]\", StyleBox[\"y\", \"TI\"], \"\[NotPrecedesTilde]\", \"\[Ellipsis]\"}]\)."
NotPrecedes::usage = "\!\(\*RowBox[{\"NotPrecedes\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotPrecedes]\", StyleBox[\"y\", \"TI\"], \"\[NotPrecedes]\", \"\[Ellipsis]\"}]\)."
NotReverseElement::usage = "\!\(\*RowBox[{\"NotReverseElement\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotReverseElement]\", StyleBox[\"y\", \"TI\"], \"\[NotReverseElement]\", \"\[Ellipsis]\"}]\)."
NotRightTriangleBar::usage = "\!\(\*RowBox[{\"NotRightTriangleBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotRightTriangleBar]\", StyleBox[\"y\", \"TI\"], \"\[NotRightTriangleBar]\", \"\[Ellipsis]\"}]\)."
NotRightTriangleEqual::usage = "\!\(\*RowBox[{\"NotRightTriangleEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotRightTriangleEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotRightTriangleEqual]\", \"\[Ellipsis]\"}]\)."
NotRightTriangle::usage = "\!\(\*RowBox[{\"NotRightTriangle\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotRightTriangle]\", StyleBox[\"y\", \"TI\"], \"\[NotRightTriangle]\", \"\[Ellipsis]\"}]\)."
NotSquareSubsetEqual::usage = "\!\(\*RowBox[{\"NotSquareSubsetEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSquareSubsetEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotSquareSubsetEqual]\", \"\[Ellipsis]\"}]\)."
NotSquareSubset::usage = "\!\(\*RowBox[{\"NotSquareSubset\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSquareSubset]\", StyleBox[\"y\", \"TI\"], \"\[NotSquareSubset]\", \"\[Ellipsis]\"}]\)."
NotSquareSupersetEqual::usage = "\!\(\*RowBox[{\"NotSquareSupersetEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSquareSupersetEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotSquareSupersetEqual]\", \"\[Ellipsis]\"}]\)."
NotSquareSuperset::usage = "\!\(\*RowBox[{\"NotSquareSuperset\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSquareSuperset]\", StyleBox[\"y\", \"TI\"], \"\[NotSquareSuperset]\", \"\[Ellipsis]\"}]\)."
NotSubsetEqual::usage = "\!\(\*RowBox[{\"NotSubsetEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSubsetEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotSubsetEqual]\", \"\[Ellipsis]\"}]\)."
NotSubset::usage = "\!\(\*RowBox[{\"NotSubset\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSubset]\", StyleBox[\"y\", \"TI\"], \"\[NotSubset]\", \"\[Ellipsis]\"}]\)."
NotSucceedsEqual::usage = "\!\(\*RowBox[{\"NotSucceedsEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSucceedsEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotSucceedsEqual]\", \"\[Ellipsis]\"}]\)."
NotSucceedsSlantEqual::usage = "\!\(\*RowBox[{\"NotSucceedsSlantEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSucceedsSlantEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotSucceedsSlantEqual]\", \"\[Ellipsis]\"}]\)."
NotSucceedsTilde::usage = "\!\(\*RowBox[{\"NotSucceedsTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSucceedsTilde]\", StyleBox[\"y\", \"TI\"], \"\[NotSucceedsTilde]\", \"\[Ellipsis]\"}]\)."
NotSucceeds::usage = "\!\(\*RowBox[{\"NotSucceeds\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSucceeds]\", StyleBox[\"y\", \"TI\"], \"\[NotSucceeds]\", \"\[Ellipsis]\"}]\)."
NotSupersetEqual::usage = "\!\(\*RowBox[{\"NotSupersetEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSupersetEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotSupersetEqual]\", \"\[Ellipsis]\"}]\)."
NotSuperset::usage = "\!\(\*RowBox[{\"NotSuperset\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotSuperset]\", StyleBox[\"y\", \"TI\"], \"\[NotSuperset]\", \"\[Ellipsis]\"}]\)."
NotTildeEqual::usage = "\!\(\*RowBox[{\"NotTildeEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotTildeEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotTildeEqual]\", \"\[Ellipsis]\"}]\)."
NotTildeFullEqual::usage = "\!\(\*RowBox[{\"NotTildeFullEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotTildeFullEqual]\", StyleBox[\"y\", \"TI\"], \"\[NotTildeFullEqual]\", \"\[Ellipsis]\"}]\)."
NotTildeTilde::usage = "\!\(\*RowBox[{\"NotTildeTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotTildeTilde]\", StyleBox[\"y\", \"TI\"], \"\[NotTildeTilde]\", \"\[Ellipsis]\"}]\)."
NotTilde::usage = "\!\(\*RowBox[{\"NotTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotTilde]\", StyleBox[\"y\", \"TI\"], \"\[NotTilde]\", \"\[Ellipsis]\"}]\)."
Not::usage = "\!\(\*RowBox[{\"!\", StyleBox[\"expr\", \"TI\"]}]\) is the logical NOT function. It gives False if \!\(\*StyleBox[\"expr\", \"TI\"]\) is True, and True if it is False. "
NotVerticalBar::usage = "\!\(\*RowBox[{\"NotVerticalBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[NotVerticalBar]\", StyleBox[\"y\", \"TI\"], \"\[NotVerticalBar]\", \"\[Ellipsis]\"}]\)."
NoWhitespace::usage = "NoWhitespace represents the absence of whitespace between elements in a grammar rules pattern."
Now::usage = "Now gives a DateObject representing the current moment in time."
NProbability::usage = "\!\(\*RowBox[{\"NProbability\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) gives the numerical probability for an event that satisfies the predicate \!\(\*StyleBox[\"pred\", \"TI\"]\) under the assumption that \!\(\*StyleBox[\"x\", \"TI\"]\) follows the probability distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). \n\!\(\*RowBox[{\"NProbability\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) gives the numerical probability that an event satisfies \!\(\*StyleBox[\"pred\", \"TI\"]\) under the assumption that \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) follows the multivariate distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). \n\!\(\*RowBox[{\"NProbability\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}]}], \"]\"}]\) gives the numerical probability that an event satisfies \!\(\*StyleBox[\"pred\", \"TI\"]\) under the assumption that \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\) are independent and follow the distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\). \n\!\(\*RowBox[{\"NProbability\", \"[\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"pred\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Conditioned]\", SubscriptBox[StyleBox[\"pred\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the numerical conditional probability of \!\(\*SubscriptBox[StyleBox[\"pred\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) given \!\(\*SubscriptBox[StyleBox[\"pred\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
NProductFactors::usage = "NProductFactors is an option for NProduct. \!\(\*RowBox[{\"NProductFactors\", \" \", \"->\", \" \", StyleBox[\"n\", \"TI\"]}]\) explicitly includes \!\(\*StyleBox[\"n\", \"TI\"]\) factors in the product before extrapolation."
NProduct::usage = "\!\(\*RowBox[{\"NProduct\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives a numerical approximation to the product \!\(\*RowBox[{UnderoverscriptBox[\"\[Product]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], \"min\"]}], SubscriptBox[StyleBox[\"i\", \"TI\"], \"max\"]], StyleBox[\"f\", \"TI\"]}]\).\n\!\(\*RowBox[{\"NProduct\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses a step \!\(\*StyleBox[\"di\", \"TI\"]\) in the product. "
NRoots::usage = "\!\(\*RowBox[{\"NRoots\", \"[\", RowBox[{RowBox[{StyleBox[\"lhs\", \"TI\"], \"==\", StyleBox[\"rhs\", \"TI\"]}], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) yields a disjunction of equations which represent numerical approximations to the roots of a polynomial equation. "
NSolve::usage = "\!\(\*RowBox[{\"NSolve\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) attempts to find numerical approximations to the solutions of the system \!\(\*StyleBox[\"expr\", \"TI\"]\) of equations or inequalities for the variables \!\(\*StyleBox[\"vars\", \"TI\"]\). \n\!\(\*RowBox[{\"NSolve\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"], \",\", \"Reals\"}], \"]\"}]\) finds solutions over the domain of real numbers."
NSumTerms::usage = "NSumTerms is an option for NSum. \!\(\*RowBox[{\"NSumTerms\", \" \", \"->\", \" \", StyleBox[\"n\", \"TI\"]}]\) explicitly includes \!\(\*StyleBox[\"n\", \"TI\"]\) terms in the sum before extrapolation."
NSum::usage = "\!\(\*RowBox[{\"NSum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives a numerical approximation to the sum \!\(\*RowBox[{UnderoverscriptBox[\"\[Sum]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], \"min\"]}], SubscriptBox[StyleBox[\"i\", \"TI\"], \"max\"]], StyleBox[\"f\", \"TI\"]}]\).\n\!\(\*RowBox[{\"NSum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses a step \!\(\*StyleBox[\"di\", \"TI\"]\) in the sum. "
NuclearExplosionData::usage = "\!\(\*RowBox[{\"NuclearExplosionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the nuclear explosion \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"NuclearExplosionData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified nuclear explosion entities.\n\!\(\*RowBox[{\"NuclearExplosionData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
NuclearReactorData::usage = "\!\(\*RowBox[{\"NuclearReactorData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the nuclear reactor \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"NuclearReactorData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified nuclear reactor entities.\n\!\(\*RowBox[{\"NuclearReactorData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
NullRecords::usage = "NullRecords is an option for Read and related functions which specifies whether null records should be taken to exist between repeated record separators. "
NullSpace::usage = "\!\(\*RowBox[{\"NullSpace\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a list of vectors that forms a basis for the null space of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\). "
Null::usage = "Null is a symbol used to indicate the absence of an expression or a result. It is not displayed in ordinary output.  When Null appears as a complete output expression, no output is printed. "
NullWords::usage = "NullWords is an option for Read and related functions which specifies whether null words should be taken to exist between repeated word separators. "
NumberCompose::usage = "\!\(\*RowBox[{\"NumberCompose\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) returns the quantity \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \" \", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"+\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]], \" \", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]}]\)."
NumberDecompose::usage = "\!\(\*RowBox[{\"NumberDecompose\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) returns a list of coefficients \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\) of a decomposition of the number \!\(\*StyleBox[\"x\", \"TI\"]\) in the basis \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\)."
NumberFieldClassNumber::usage = "\!\(\*RowBox[{\"NumberFieldClassNumber\", \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}]\) gives the class number for the algebraic number field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", \"\[Theta]\", \"]\"}]\) generated by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\)."
NumberFieldDiscriminant::usage = "\!\(\*RowBox[{\"NumberFieldDiscriminant\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives the discriminant of the field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) generated by the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
NumberFieldFundamentalUnits::usage = "\!\(\*RowBox[{\"NumberFieldFundamentalUnits\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives a list of fundamental units for the field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) generated by the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
NumberFieldIntegralBasis::usage = "\!\(\*RowBox[{\"NumberFieldIntegralBasis\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives an integral basis for the field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) generated by the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
NumberFieldNormRepresentatives::usage = "\!\(\*RowBox[{\"NumberFieldNormRepresentatives\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives a list of representatives of classes of algebraic integers of norm \!\(\*RowBox[{\"\[PlusMinus]\", StyleBox[\"m\", \"TI\"]}]\) in the field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) generated by the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
NumberFieldRegulator::usage = "\!\(\*RowBox[{\"NumberFieldRegulator\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives the regulator of the field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) generated by the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
NumberFieldRootsOfUnity::usage = "\!\(\*RowBox[{\"NumberFieldRootsOfUnity\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives the roots of unity for the field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) generated by the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
NumberFieldSignature::usage = "\!\(\*RowBox[{\"NumberFieldSignature\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) gives the signature of the field \!\(\*RowBox[{\"\[DoubleStruckCapitalQ]\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) generated by the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\)."
NumberFormat::usage = "NumberFormat is an option for NumberForm and related functions that specifies how the mantissa, base, and exponent should be assembled into a final print form. "
NumberForm::usage = "\!\(\*RowBox[{\"NumberForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) prints with approximate real numbers in \!\(\*StyleBox[\"expr\", \"TI\"]\) given to \!\(\*StyleBox[\"n\", \"TI\"]\)\[Hyphen]digit precision. \n\!\(\*RowBox[{\"NumberForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"}\"}]}], \"]\"}]\) prints with approximate real numbers having \!\(\*StyleBox[\"n\", \"TI\"]\) digits, with \!\(\*StyleBox[\"f\", \"TI\"]\) digits to the right of the decimal point."
NumberLinePlot::usage = "\!\(\*RowBox[{\"NumberLinePlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots the values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) on a number line.\n\!\(\*RowBox[{\"NumberLinePlot\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) plots a number line illustrating the region \!\(\*StyleBox[\"pred\", \"TI\"]\).\n\!\(\*RowBox[{\"NumberLinePlot\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots the number to extend over the interval from \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"NumberLinePlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots several number lines."
NumberMarks::usage = "NumberMarks is an option for InputForm and related functions that specifies whether ` marks should be included in the printed forms of approximate numbers. "
NumberMultiplier::usage = "NumberMultiplier is an option for NumberForm and related functions which gives the string to use as a multiplication sign in scientific notation. "
NumberPadding::usage = "NumberPadding is an option for NumberForm and related functions which gives strings to use as padding on the left\[Hyphen] and right\[Hyphen]hand sides of numbers. "
NumberPoint::usage = "NumberPoint is an option for NumberForm and related functions that gives the string to use as a decimal point. "
NumberQ::usage = "\!\(\*RowBox[{\"NumberQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a number, and False otherwise. "
NumberSeparator::usage = "NumberSeparator is an option for NumberForm and related functions that gives the string to insert at breaks between digits. "
NumberSigns::usage = "NumberSigns is an option for NumberForm and related functions which gives strings to use as signs for negative and positive numbers. "
NumberString::usage = "NumberString represents the characters of a number in StringExpression."
Number::usage = "Number represents an exact integer or an approximate real number in Read. "
Numerator::usage = "\!\(\*RowBox[{\"Numerator\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the numerator of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
NumericalCalculus`EulerRatio::usage = "EulerRatio is an option to EulerSum that specifies the parameter to use in the generalized Euler transformation."
NumericalCalculus`EulerSum::usage = "\!\(\*RowBox[{\"EulerSum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives a numerical approximation to the sum \!\(\*RowBox[{UnderoverscriptBox[StyleBox[\"\[Sum]\", \"TR\"], RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]], StyleBox[\"f\", \"TI\"]}]\) using Euler's transformation.\n\!\(\*RowBox[{\"EulerSum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses a step \!\(\*StyleBox[\"di\", \"TI\"]\) in the sum."
NumericalCalculus`ExtraTerms::usage = "ExtraTerms is an option to EulerSum that specifies the number of terms to be used in the extrapolation process."
NumericalCalculus`ND::usage = "\!\(\*RowBox[{\"ND\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) gives a numerical approximation to the derivative of \!\(\*StyleBox[\"expr\", \"TI\"]\) with respect to \!\(\*StyleBox[\"x\", \"TI\"]\) at the point \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"ND\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) gives a numerical approximation to the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
NumericalCalculus`NLimit::usage = "\!\(\*RowBox[{\"NLimit\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"z\", \"TI\"], \"->\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]}], \"]\"}]\) numerically finds the limiting value of \!\(\*StyleBox[\"expr\", \"TI\"]\) as \!\(\*StyleBox[\"z\", \"TI\"]\) approaches \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
NumericalCalculus`NResidue::usage = "\!\(\*RowBox[{\"NResidue\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) numerically finds the residue of \!\(\*StyleBox[\"expr\", \"TI\"]\) near the point \!\(\*RowBox[{StyleBox[\"z\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\)."
NumericalCalculus`NSeries::usage = "\!\(\*RowBox[{\"NSeries\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives a numerical approximation to the series expansion of \!\(\*StyleBox[\"f\", \"TI\"]\) about the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\) including the terms \!\(\*SuperscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"-\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \")\"}], RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]]\) through \!\(\*SuperscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"-\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \")\"}], StyleBox[\"n\", \"TI\"]]\)."
NumericalCalculus`Terms::usage = "Terms is an option to EulerSum, NLimit, and ND that specifies the total number of terms to be used."
NumericalDifferentialEquationAnalysis`ButcherAlpha::usage = "\!\(\*RowBox[{\"ButcherAlpha\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the number of ways of labeling the vertices of \!\(\*StyleBox[\"tree\", \"TI\"]\) with a totally ordered set of labels such that if \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \")\"}]\) is an edge, then \!\(\*RowBox[{StyleBox[\"m\", \"TI\"], \"<\", StyleBox[\"n\", \"TI\"]}]\)."
NumericalDifferentialEquationAnalysis`ButcherBetaBar::usage = "\!\(\*RowBox[{\"ButcherBetaBar\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the number of ways of labeling \!\(\*StyleBox[\"tree\", \"TI\"]\) with \!\(\*RowBox[{\"ButcherOrder\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) distinct labels such that every vertex is labeled.\n\!\(\*RowBox[{\"ButcherBetaBar\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"tree\", \"TI\"]}], \"]\"}]\) gives the number of ways of labeling \!\(\*StyleBox[\"n\", \"TI\"]\) of the vertices of \!\(\*StyleBox[\"tree\", \"TI\"]\) with \!\(\*StyleBox[\"n\", \"TI\"]\) distinct labels such that every leaf is labeled."
NumericalDifferentialEquationAnalysis`ButcherBeta::usage = "\!\(\*RowBox[{\"ButcherBeta\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the number of ways of labeling \!\(\*StyleBox[\"tree\", \"TI\"]\) with \!\(\*RowBox[{RowBox[{\"ButcherOrder\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}], \"-\", StyleBox[\"1\", \"TR\"]}]\) distinct labels such that the root is not labeled, but every other vertex is labeled.\n\!\(\*RowBox[{\"ButcherBeta\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"tree\", \"TI\"]}], \"]\"}]\) gives the number of ways of labeling \!\(\*StyleBox[\"n\", \"TI\"]\) of the vertices of \!\(\*StyleBox[\"tree\", \"TI\"]\) with \!\(\*StyleBox[\"n\", \"TI\"]\) distinct labels such that every leaf is labeled and the root is not labeled."
NumericalDifferentialEquationAnalysis`ButcherColumnConditions::usage = "\!\(\*RowBox[{\"ButcherColumnConditions\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the column-simplifying conditions up to and including order \!\(\*StyleBox[\"p\", \"TI\"]\) for \!\(\*StyleBox[\"s\", \"TI\"]\) stages.\n\!\(\*RowBox[{\"ButcherColumnConditions\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the column-simplifying conditions in stage-independent tensor notation."
NumericalDifferentialEquationAnalysis`ButcherGamma::usage = "\!\(\*RowBox[{\"ButcherGamma\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the density of \!\(\*StyleBox[\"tree\", \"TI\"]\)."
NumericalDifferentialEquationAnalysis`ButcherHeight::usage = "\!\(\*RowBox[{\"ButcherHeight\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the height of \!\(\*StyleBox[\"tree\", \"TI\"]\)."
NumericalDifferentialEquationAnalysis`ButcherOrder::usage = "\!\(\*RowBox[{\"ButcherOrder\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the number of vertices in \!\(\*StyleBox[\"tree\", \"TI\"]\)."
NumericalDifferentialEquationAnalysis`ButcherPhi::usage = "\!\(\*RowBox[{\"ButcherPhi\", \"[\", RowBox[{StyleBox[\"tree\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the weight of \!\(\*StyleBox[\"tree\", \"TI\"]\) in an \!\(\*StyleBox[\"s\", \"TI\"]\)-stage Runge\[Dash]Kutta method. \n\!\(\*RowBox[{\"ButcherPhi\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the weight of \!\(\*StyleBox[\"tree\", \"TI\"]\) in stage-independent tensor notation."
NumericalDifferentialEquationAnalysis`ButcherPlotColumns::usage = "ButcherPlotColumns is an option to ButcherPlot that specifies the number of columns in the array of Butcher tree plots."
NumericalDifferentialEquationAnalysis`ButcherPlotLabel::usage = "ButcherPlotLabel is an option to ButcherPlot that specifies a list of plot labels."
NumericalDifferentialEquationAnalysis`ButcherPlotNodeSize::usage = "ButcherPlotNodeSize is an option to ButcherPlot that specifies a scaling factor for the nodes of the trees in the plot."
NumericalDifferentialEquationAnalysis`ButcherPlotRootSize::usage = "ButcherPlotRootSize is an option to ButcherPlot that specifies a scaling factor for the circle highlighting the root."
NumericalDifferentialEquationAnalysis`ButcherPlot::usage = "\!\(\*RowBox[{\"ButcherPlot\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives a plot of \!\(\*StyleBox[\"tree\", \"TI\"]\).\n\!\(\*RowBox[{\"ButcherPlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"tree\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"tree\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives an array of plots of \!\(\*RowBox[{SubscriptBox[StyleBox[\"tree\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"tree\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
NumericalDifferentialEquationAnalysis`ButcherPrincipalError::usage = "\!\(\*RowBox[{\"ButcherPrincipalError\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the principal error for a method of order \!\(\*StyleBox[\"p\", \"TI\"]\) with \!\(\*StyleBox[\"s\", \"TI\"]\) stages.\n\!\(\*RowBox[{\"ButcherPrincipalError\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the principal error using stage-independent tensor notation."
NumericalDifferentialEquationAnalysis`ButcherQuadratureConditions::usage = "\!\(\*RowBox[{\"ButcherQuadratureConditions\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the quadrature conditions up to and including order \!\(\*StyleBox[\"p\", \"TI\"]\) for \!\(\*StyleBox[\"s\", \"TI\"]\) stages.\n\!\(\*RowBox[{\"ButcherQuadratureConditions\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the quadrature conditions in stage-independent tensor notation."
NumericalDifferentialEquationAnalysis`ButcherRowConditions::usage = "\!\(\*RowBox[{\"ButcherRowConditions\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the row-simplifying conditions up to and including order \!\(\*StyleBox[\"p\", \"TI\"]\) for \!\(\*StyleBox[\"s\", \"TI\"]\) stages.\n\!\(\*RowBox[{\"ButcherRowConditions\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the row-simplifying conditions in stage-independent tensor notation."
NumericalDifferentialEquationAnalysis`ButcherRowSum::usage = "ButcherRowSum is an option to RungeKuttaOrderConditions that specifies whether the row sum conditions for the \!\(\*SubscriptBox[\"\[FormalC]\", StyleBox[\"i\", \"TI\"]]\) should be added to the list of order conditions."
NumericalDifferentialEquationAnalysis`ButcherSigma::usage = "\!\(\*RowBox[{\"ButcherSigma\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the order of the symmetry group of isomorphisms of \!\(\*StyleBox[\"tree\", \"TI\"]\) with itself."
NumericalDifferentialEquationAnalysis`ButcherSimplify::usage = "ButcherSimplify is an option to RungeKuttaOrderConditions that specifies whether to apply Butcher's row- and column-simplifying conditions."
NumericalDifferentialEquationAnalysis`ButcherTreeCount::usage = "\!\(\*RowBox[{\"ButcherTreeCount\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives a list of the number of trees through order \!\(\*StyleBox[\"p\", \"TI\"]\)."
NumericalDifferentialEquationAnalysis`ButcherTreeQ::usage = "\!\(\*RowBox[{\"ButcherTreeQ\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"tree\", \"TI\"]\) is a valid Butcher tree, and False otherwise."
NumericalDifferentialEquationAnalysis`ButcherTreeSimplify::usage = "\!\(\*RowBox[{\"ButcherTreeSimplify\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"\[Eta]\", \"TR\"], \",\", StyleBox[\"\[Xi]\", \"TR\"]}], \"]\"}]\) gives the set of trees through order \!\(\*StyleBox[\"p\", \"TI\"]\) that are not reduced by Butcher's quadrature conditions through order \!\(\*StyleBox[\"p\", \"TI\"]\), row-simplifying conditions through order \!\(\*StyleBox[\"\[Eta]\", \"TR\"]\) and column-simplifying conditions through order \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\)."
NumericalDifferentialEquationAnalysis`ButcherTrees::usage = "\!\(\*RowBox[{\"ButcherTrees\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives a list, partitioned by order, of the trees for any Runge\[Dash]Kutta method of order \!\(\*StyleBox[\"p\", \"TI\"]\)."
NumericalDifferentialEquationAnalysis`ButcherWidth::usage = "\!\(\*RowBox[{\"ButcherWidth\", \"[\", StyleBox[\"tree\", \"TI\"], \"]\"}]\) gives the width of \!\(\*StyleBox[\"tree\", \"TI\"]\)."
NumericalDifferentialEquationAnalysis`ContinuousExtension::usage = "ContinuousExtension is an option to RungeKuttaOrderConditions and related functions that specifies whether to generate order conditions for continuous extensions of Runge\[Dash]Kutta methods."
NumericalDifferentialEquationAnalysis`DiagonallyImplicit::usage = "DiagonallyImplicit is a setting for the option RungeKuttaMethod specifying the type of Runge\[Dash]Kutta method to be generated."
NumericalDifferentialEquationAnalysis`Explicit::usage = "Explicit is a setting for the option RungeKuttaMethod specifying the type of Runge\[Dash]Kutta method to be generated."
NumericalDifferentialEquationAnalysis`GaussianQuadratureError::usage = "\!\(\*RowBox[{\"GaussianQuadratureError\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the leading term in the error of the elementary \!\(\*StyleBox[\"n\", \"TI\"]\)-point Gaussian quadrature formula for the function \!\(\*StyleBox[\"f\", \"TI\"]\) on an interval from \!\(\*StyleBox[\"a\", \"TI\"]\) to \!\(\*StyleBox[\"b\", \"TI\"]\).\n\!\(\*RowBox[{\"GaussianQuadratureError\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"prec\", \"TI\"]}], \"]\"}]\) attempts to give a result with \!\(\*StyleBox[\"prec\", \"TI\"]\) digits of precision."
NumericalDifferentialEquationAnalysis`GaussianQuadratureWeights::usage = "\!\(\*RowBox[{\"GaussianQuadratureWeights\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives a list of the \!\(\*StyleBox[\"n\", \"TI\"]\) pairs \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) of the elementary \!\(\*StyleBox[\"n\", \"TI\"]\)-point Gaussian formula for quadrature on the interval \!\(\*StyleBox[\"a\", \"TI\"]\) to \!\(\*StyleBox[\"b\", \"TI\"]\), where \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is the weight of the abscissa \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"GaussianQuadratureWeights\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"prec\", \"TI\"]}], \"]\"}]\) attempts to give a result with \!\(\*StyleBox[\"prec\", \"TI\"]\) digits of precision."
NumericalDifferentialEquationAnalysis`Implicit::usage = "Implicit is a setting for the option RungeKuttaMethod specifying the type of Runge\[Dash]Kutta method to be generated."
NumericalDifferentialEquationAnalysis`NewtonCotesError::usage = "\!\(\*RowBox[{\"NewtonCotesError\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the error in the elementary \!\(\*StyleBox[\"n\", \"TI\"]\)-point Newton\[Dash]Cotes quadrature formula for the function \!\(\*StyleBox[\"f\", \"TI\"]\) on an interval from \!\(\*StyleBox[\"a\", \"TI\"]\) to \!\(\*StyleBox[\"b\", \"TI\"]\)."
NumericalDifferentialEquationAnalysis`NewtonCotesWeights::usage = "\!\(\*RowBox[{\"NewtonCotesWeights\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives a list of the \!\(\*StyleBox[\"n\", \"TI\"]\) pairs \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\) of the elementary \!\(\*StyleBox[\"n\", \"TI\"]\)-point Newton\[Dash]Cotes formula for quadrature on the interval \!\(\*StyleBox[\"a\", \"TI\"]\) to \!\(\*StyleBox[\"b\", \"TI\"]\), where \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is the weight of the abscissa \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
NumericalDifferentialEquationAnalysis`QuadratureType::usage = "QuadratureType is an option to NewtonCotesWeights and NewtonCotesError that specifies whether the endpoints are to be included as abscissas."
NumericalDifferentialEquationAnalysis`RungeKuttaMethod::usage = "RungeKuttaMethod is an option to ButcherPhi and related functions that specifies the type of method to be generated."
NumericalDifferentialEquationAnalysis`RungeKuttaOrderConditions::usage = "\!\(\*RowBox[{\"RungeKuttaOrderConditions\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives a list of the order conditions that any \!\(\*StyleBox[\"s\", \"TI\"]\)-stage Runge\[Dash]Kutta method of order \!\(\*StyleBox[\"p\", \"TI\"]\) must satisfy. \n\!\(\*RowBox[{\"RungeKuttaOrderConditions\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) gives the order conditions using stage-independent tensor notation."
NumericalDifferentialEquationAnalysis`$ContinuousExtension::usage = "$ContinuousExtension is a global environment setting, specifying whether to generate conditions for continuous extensions of Runge\[Dash]Kutta methods."
NumericalDifferentialEquationAnalysis`$RungeKuttaMethod::usage = "$RungeKuttaMethod is a global environment setting, specifying the type of method to be generated by \!\(\*RowBox[{\"ButcherPhi\", \" \"}]\)and related functions."
NumericFunction::usage = "NumericFunction is an attribute that can be assigned to a symbol \!\(\*StyleBox[\"f\", \"TI\"]\) to indicate that \!\(\*RowBox[{\"f\", \"[\", RowBox[{SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) should be considered a numeric quantity whenever all the \!\(\*SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are numeric quantities. "
NumericQ::usage = "\!\(\*RowBox[{\"NumericQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a numeric quantity, and False otherwise. "
N::usage = "\!\(\*RowBox[{\"N\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the numerical value of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"N\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) attempts to give a result with \!\(\*StyleBox[\"n\", \"TI\"]\)\[Hyphen]digit precision. "
NuttallWindow::usage = "\!\(\*RowBox[{\"NuttallWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Nuttall window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
NValues::usage = "\!\(\*RowBox[{\"NValues\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives a list of transformation rules corresponding to all numerical values (values for \!\(\*RowBox[{\"N\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\), etc.) defined for the symbol \!\(\*StyleBox[\"f\", \"TI\"]\)."
NyquistGridLines::usage = "NyquistGridLines is an option to NyquistPlot that specifies contours of constant magnitude and phase of a closed-loop system."
NyquistPlot::usage = "\!\(\*RowBox[{\"NyquistPlot\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) generates a Nyquist plot of the transfer function for the system \!\(\*StyleBox[\"lsys\", \"TI\"]\).\n\!\(\*RowBox[{\"NyquistPlot\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots for the frequency range \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"NyquistPlot\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots \!\(\*StyleBox[\"expr\", \"TI\"]\) using the variable \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
ObservabilityGramian::usage = "\!\(\*RowBox[{\"ObservabilityGramian\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) gives the observability Gramian of the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
ObservabilityMatrix::usage = "\!\(\*RowBox[{\"ObservabilityMatrix\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) gives the observability matrix of the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
ObservableDecomposition::usage = "\!\(\*RowBox[{\"ObservableDecomposition\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) yields the observable subsystem of the system \!\(\*StyleBox[\"sys\", \"TI\"]\).\n\!\(\*RowBox[{\"ObservableDecomposition\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) specifies the new coordinates \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ObservableModelQ::usage = "\!\(\*RowBox[{\"ObservableModelQ\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives True if the system \!\(\*StyleBox[\"sys\", \"TI\"]\) is observable, and False otherwise.\n\!\(\*RowBox[{\"ObservableModelQ\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"sub\", \"TI\"]}], \"}\"}], \"]\"}]\) gives True if the subsystem \!\(\*StyleBox[\"sub\", \"TI\"]\) is observable."
OceanData::usage = "\!\(\*RowBox[{\"OceanData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the ocean \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"OceanData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified ocean entities.\n\!\(\*RowBox[{\"OceanData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
OddQ::usage = "\!\(\*RowBox[{\"OddQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is an odd integer, and False otherwise. "
Offset::usage = "\!\(\*RowBox[{\"Offset\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"position\", \"TI\"]}], \"]\"}]\) gives the position of a graphical object obtained by starting at the specified position and then moving by absolute offset \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]\). "
Off::usage = "\!\(\*RowBox[{\"Off\", \"[\", RowBox[{StyleBox[\"symbol\", \"TI\"], \"::\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) switches off a message, so that it is no longer printed. \n\!\(\*RowBox[{\"Off\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) switches off a named group of messages.\n\!\(\*RowBox[{\"Off\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) switches off tracing messages associated with the symbol \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"Off\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) switches off several messages or message groups. "
ONanGroupON::usage = "\!\(\*RowBox[{\"ONanGroupON\", \"[\", \"]\"}]\) represents the sporadic simple O'Nan group \!\(\*RowBox[{RowBox[{StyleBox[\"O\", FontSlant -> \"Plain\"], \"'\"}], StyleBox[\"N\", FontSlant -> \"Plain\"]}]\)."
OneIdentity::usage = "OneIdentity is an attribute that can be assigned to a symbol \!\(\*StyleBox[\"f\", \"TI\"]\) to indicate that \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\), \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\), etc. are all equivalent to \!\(\*StyleBox[\"x\", \"TI\"]\) for the purpose of pattern matching. "
On::usage = "\!\(\*RowBox[{\"On\", \"[\", RowBox[{StyleBox[\"symbol\", \"TI\"], \"::\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) switches on a message, so that it can be printed. \n\!\(\*RowBox[{\"On\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) switches on a named group of messages.\n\!\(\*RowBox[{\"On\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) switches on tracing for the symbol \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"On\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) switches on several messages or message groups. "
OpacityFunctionScaling::usage = "OpacityFunctionScaling is an option to visualization functions such as DensityPlot3D that specifies whether arguments supplied to OpacityFunction should be scaled to lie between 0 and 1."
OpacityFunction::usage = "OpacityFunction is an option for graphics functions that specifies a function to apply to determine opacity of elements."
Opacity::usage = "\!\(\*RowBox[{\"Opacity\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that graphical objects which follow are to be displayed, if possible, with opacity \!\(\*StyleBox[\"a\", \"TI\"]\). \n\!\(\*RowBox[{\"Opacity\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"color\", \"TI\"]}], \"]\"}]\) uses the specified color with opacity \!\(\*StyleBox[\"a\", \"TI\"]\)."
OpenAppend::usage = "\!\(\*RowBox[{\"OpenAppend\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) opens a file to append output to it, and returns an OutputStream object. "
OpenCLLink`OpenCLFractalRender3D::usage = "\!\(\*RowBox[{\"OpenCLFractalRender3D\", \"[\", RowBox[{StyleBox[\"width\", \"TI\"], \",\", StyleBox[\"height\", \"TI\"]}], \"]\"}]\) renders a three-dimensional fractal with image size being the specified \!\(\*StyleBox[\"width\", \"TI\"]\) and \!\(\*StyleBox[\"height\", \"TI\"]\)."
OpenCLLink`OpenCLFunctionInformation::usage = "\!\(\*RowBox[{\"OpenCLFunctionInformation\", \"[\", StyleBox[\"oclfun\", \"TI\"], \"]\"}]\) returns information on OpenCLFunction \!\(\*StyleBox[\"oclfun\", \"TI\"]\) such as build log, build options, source code, etc."
OpenCLLink`OpenCLFunctionLoad::usage = "\!\(\*RowBox[{\"OpenCLFunctionLoad\", \"[\", RowBox[{StyleBox[\"prog\", \"TI\"], \",\", StyleBox[\"fun\", \"TI\"], \",\", StyleBox[\"argtypes\", \"TI\"], \",\", StyleBox[\"blockdims\", \"TI\"]}], \"]\"}]\) loads \!\(\*StyleBox[\"fun\", \"TI\"]\) from source code \!\(\*StyleBox[\"prog\", \"TI\"]\), returning an OpenCLFunction object.\n\!\(\*RowBox[{\"OpenCLFunctionLoad\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"progfile\", \"TI\"], \"}\"}], \",\", StyleBox[\"fun\", \"TI\"], \",\", StyleBox[\"argtypes\", \"TI\"], \",\", StyleBox[\"blockdims\", \"TI\"]}], \"]\"}]\) loads \!\(\*StyleBox[\"fun\", \"TI\"]\) from source file \!\(\*StyleBox[\"progfile\", \"TI\"]\), returning an OpenCLFunction object."
OpenCLLink`OpenCLFunction::usage = "\!\(\*RowBox[{\"OpenCLFunction\", \"[\", StyleBox[\"args\", \"TI\"], \"]\"}]\) represents a function loaded using OpenCLFunctionLoad."
OpenCLLink`OpenCLImplicitRender3D::usage = "\!\(\*RowBox[{\"OpenCLImplicitRender3D\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) ray traces the implicit surface \!\(\*RowBox[{StyleBox[\"poly\", \"TI\"], \"=\", \"0\"}]\) as a function of \!\(\*StyleBox[\"vars\", \"TI\"]\) with bound sphere of radius \!\(\*StyleBox[\"r\", \"TI\"]\)."
OpenCLLink`OpenCLInformation::usage = "\!\(\*RowBox[{\"OpenCLInformation\", \"[\", \"]\"}]\) gives all information about OpenCL platforms and devices on the system.\n\!\(\*RowBox[{\"OpenCLInformation\", \"[\", StyleBox[\"platform\", \"TI\"], \"]\"}]\) gives information on OpenCL \!\(\*StyleBox[\"platform\", \"TI\"]\) and about its devices.\n\!\(\*RowBox[{\"OpenCLInformation\", \"[\", RowBox[{StyleBox[\"platform\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives information on OpenCL \!\(\*StyleBox[\"platform\", \"TI\"]\) property.\n\!\(\*RowBox[{\"OpenCLInformation\", \"[\", RowBox[{StyleBox[\"platform\", \"TI\"], \",\", StyleBox[\"device\", \"TI\"]}], \"]\"}]\) gives information on OpenCL \!\(\*StyleBox[\"device\", \"TI\"]\) with specified \!\(\*StyleBox[\"platform\", \"TI\"]\).\n\!\(\*RowBox[{\"OpenCLInformation\", \"[\", RowBox[{StyleBox[\"platform\", \"TI\"], \",\", StyleBox[\"device\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives information on OpenCL \!\(\*StyleBox[\"device\", \"TI\"]\) property."
OpenCLLink`OpenCLMemoryAllocate::usage = "\!\(\*RowBox[{\"OpenCLMemoryAllocate\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"len\", \"TI\"]}], \"]\"}]\) allocates a new one-dimensional list of type \!\(\*StyleBox[\"t\", \"TI\"]\) returning OpenCLMemory.\n\!\(\*RowBox[{\"OpenCLMemoryAllocate\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) allocates a new list of dimensions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) type \!\(\*StyleBox[\"t\", \"TI\"]\) returning OpenCLMemory."
OpenCLLink`OpenCLMemoryCopyToDevice::usage = "\!\(\*RowBox[{\"OpenCLMemoryCopyToDevice\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) force copies OpenCLMemory from the CPU to the GPU."
OpenCLLink`OpenCLMemoryCopyToHost::usage = "\!\(\*RowBox[{\"OpenCLMemoryCopyToHost\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) force copies OpenCLMemory from the GPU to the CPU."
OpenCLLink`OpenCLMemoryGet::usage = "\!\(\*RowBox[{\"OpenCLMemoryGet\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) gets OpenCLMemory into the CPU and \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\)."
OpenCLLink`OpenCLMemoryInformation::usage = "\!\(\*RowBox[{\"OpenCLMemoryInformation\", \"[\", StyleBox[\"mem\", \"TI\"], \"]\"}]\) gives information on OpenCLMemory."
OpenCLLink`OpenCLMemoryLoad::usage = "\!\(\*RowBox[{\"OpenCLMemoryLoad\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) loads \!\(\*StyleBox[\"list\", \"TI\"]\) into OpenCLMemory manager, returning an OpenCLMemory.\n\!\(\*RowBox[{\"OpenCLMemoryLoad\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) loads \!\(\*StyleBox[\"list\", \"TI\"]\) with specified \!\(\*StyleBox[\"type\", \"TI\"]\) into OpenCLMemory manager, returning an OpenCLMemory."
OpenCLLink`OpenCLMemoryUnload::usage = "\!\(\*RowBox[{\"OpenCLMemoryUnload\", \"[\", RowBox[{SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"mem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) unloads OpenCLMemory from the \!\(\*StyleBox[\"OpenCLLink\", FontSlant -> \"Italic\"]\) memory manager."
OpenCLLink`OpenCLMemory::usage = "\!\(\*RowBox[{\"OpenCLMemory\", \"[\", RowBox[{StyleBox[\"args\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is a handle to memory registered with the \!\(\*StyleBox[\"OpenCLLink\", FontSlant -> \"Italic\"]\) memory manager."
OpenCLLink`OpenCLMersenneTwister::usage = "\!\(\*RowBox[{\"OpenCLMersenneTwister\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) generates \!\(\*StyleBox[\"n\", \"TI\"]\) random reals using the Mersenne Twister algorithm."
OpenCLLink`OpenCLQ::usage = "\!\(\*RowBox[{\"OpenCLQ\", \"[\", \"]\"}]\) returns True if the system has OpenCL support."
OpenCLLink`SymbolicOpenCLBlockDimension::usage = "\!\(\*RowBox[{\"SymbolicOpenCLBlockDimension\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of an OpenCL kernel block dimension call."
OpenCLLink`SymbolicOpenCLBlockIndex::usage = "\!\(\*RowBox[{\"SymbolicOpenCLBlockIndex\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of an OpenCL kernel block index call."
OpenCLLink`SymbolicOpenCLCalculateKernelIndex::usage = "\!\(\*RowBox[{\"SymbolicOpenCLCalculateKernelIndex\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of an OpenCL kernel index calculation."
OpenCLLink`SymbolicOpenCLDeclareIndexBlock::usage = "\!\(\*RowBox[{\"SymbolicOpenCLDeclareIndexBlock\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of an OpenCL kernel index declaration."
OpenCLLink`SymbolicOpenCLFunction::usage = "\!\(\*RowBox[{\"SymbolicOpenCLFunction\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) is a symbolic representation of an OpenCL function declaration.\n\!\(\*RowBox[{\"SymbolicOpenCLFunction\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) is a symbolic representation of an OpenCL function definition."
OpenCLLink`SymbolicOpenCLKernelIndex::usage = "\!\(\*RowBox[{\"SymbolicOpenCLKernelIndex\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of an OpenCL kernel index call."
OpenCLLink`SymbolicOpenCLThreadIndex::usage = "\!\(\*RowBox[{\"SymbolicOpenCLThreadIndex\", \"[\", StyleBox[\"dim\", \"TI\"], \"]\"}]\) is a symbolic representation of an OpenCL kernel thread index call."
OpenCLLink`$OpenCLDevice::usage = "$OpenCLDevice is a device used throughout \!\(\*StyleBox[\"OpenCLLink\", FontSlant -> \"Italic\"]\)'s computation."
OpenCLLink`$OpenCLLinkLibraryPath::usage = "$OpenCLLinkLibraryPath gives the path to the \!\(\*StyleBox[\"OpenCLLink\", FontSlant -> \"Italic\"]\) library files."
OpenCLLink`$OpenCLLinkPath::usage = "$OpenCLLinkPath gives the path to the \!\(\*StyleBox[\"OpenCLLink\", FontSlant -> \"Italic\"]\) application."
OpenCLLink`$OpenCLPlatform::usage = "$OpenCLPlatform is a platform used throughout \!\(\*StyleBox[\"OpenCLLink\", FontSlant -> \"Italic\"]\)'s computation."
OpenerBoxOptions::usage = "\!\(\*RowBox[{OpenerBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for OpenerBox objects."
Opener::usage = "\!\(\*RowBox[{\"Opener\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents an opener with setting \!\(\*StyleBox[\"x\", \"TI\"]\), displayed as \!\(\*OpenerBox[True]\) when \!\(\*StyleBox[\"x\", \"TI\"]\) is True and \!\(\*OpenerBox[False]\) when \!\(\*StyleBox[\"x\", \"TI\"]\) is False. \n\!\(\*RowBox[{\"Opener\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being toggled if the opener is clicked. "
OpenerView::usage = "\!\(\*RowBox[{\"OpenerView\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents an object which displays as an opener, together with \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) if the opener is closed, and both \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) if it is open.\n\!\(\*RowBox[{\"OpenerView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"state\", \"TI\"]}], \"]\"}]\) specifies the state of the opener, with False being closed, and True being open."
Opening::usage = "\!\(\*RowBox[{\"Opening\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the morphological opening of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to the structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"Opening\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the opening with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"Opening\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies opening to an array of data."
OpenRead::usage = "\!\(\*RowBox[{\"OpenRead\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) opens a file to read data from, and returns an InputStream object."
OpenTemporary::usage = "\!\(\*RowBox[{\"OpenTemporary\", \"[\", \"]\"}]\) opens a temporary file to which output can be written, and returns an OutputStream object. "
OpenWrite::usage = "\!\(\*RowBox[{\"OpenWrite\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) opens a file to write output to it, and returns an OutputStream object. \n\!\(\*RowBox[{\"OpenWrite\", \"[\", \"]\"}]\) opens a new file in the default area for temporary files on your computer system."
Operate::usage = "\!\(\*RowBox[{\"Operate\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]}], \"]\"}]\) gives \!\(\*RowBox[{RowBox[{StyleBox[\"p\", \"TI\"], \"[\", StyleBox[\"f\", \"TI\"], \"]\"}], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\). \n\!\(\*RowBox[{\"Operate\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"p\", \"TI\"]\) at level \!\(\*StyleBox[\"n\", \"TI\"]\) in the head of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
OperatingSystem::usage = "OperatingSystem is an option for file and related operations that specifies the type of operating system to use to determine file name and other conventions."
OptimumFlowData::usage = "\!\(\*RowBox[{\"OptimumFlowData\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents flow data such as generated by FindMaximumFlow, FindMinimumCostFlow, etc."
OptionalElement::usage = "\!\(\*RowBox[{\"OptionalElement\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) is a grammar rules pattern object that represents 0 or 1 instances of \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"OptionalElement\", \"[\", RowBox[{StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"default\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"default\", \"TI\"]\) if the element is not present. "
Optional::usage = "\!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \":\", StyleBox[\"v\", \"TI\"]}]\) is a pattern object that represents an expression of the form \!\(\*StyleBox[\"p\", \"TI\"]\), which, if omitted, should be replaced by \!\(\*StyleBox[\"v\", \"TI\"]\). "
OptionInspectorSettings::usage = "\!\(\*RowBox[{\"OptionInspectorSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is a global option that specifies the display of options in the \!\(\*StyleBox[\"Option Inspector\", \"DialogElementName\"]\)."
OptionQ::usage = "\!\(\*RowBox[{\"OptionQ\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"e\", \"TI\"]\) can be considered an option or list of options, and False otherwise."
OptionsPattern::usage = "\!\(\*RowBox[{\"OptionsPattern\", \"[\", \"]\"}]\) is a pattern object that represents a collection of options given as rules, where the values of the options can be accessed using OptionValue. \n\!\(\*RowBox[{\"OptionsPattern\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) takes default option values from \!\(\*RowBox[{\"Options\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\).\n\!\(\*RowBox[{\"OptionsPattern\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) uses an explicit list of default option values."
Options::usage = "\!\(\*RowBox[{\"Options\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) gives the list of default options assigned to a symbol. \n\!\(\*RowBox[{\"Options\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the options explicitly specified in a particular expression such as a graphics object. \n\!\(\*RowBox[{\"Options\", \"[\", StyleBox[\"stream\", \"TI\"], \"]\"}]\) or \!\(\*RowBox[{\"Options\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"sname\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives options associated with a particular stream. \n\!\(\*RowBox[{\"Options\", \"[\", StyleBox[\"object\", \"TI\"], \"]\"}]\) gives options associated with an external object such as a NotebookObject. \n\!\(\*RowBox[{\"Options\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) gives the setting for the option \!\(\*StyleBox[\"name\", \"TI\"]\). \n\!\(\*RowBox[{\"Options\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of the settings for the options \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
OptionValueBoxOptions::usage = "\!\(\*RowBox[{OptionValueBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for OptionValueBox objects."
OptionValue::usage = "\!\(\*RowBox[{\"OptionValue\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) gives the value of \!\(\*StyleBox[\"name\", \"TI\"]\) in options matched by OptionsPattern. \n\!\(\*RowBox[{\"OptionValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) gives the value of \!\(\*StyleBox[\"name\", \"TI\"]\) for options associated with the head \!\(\*StyleBox[\"f\", \"TI\"]\). \n\!\(\*RowBox[{\"OptionValue\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) extracts option values from the explicit list of rules \!\(\*StyleBox[\"opts\", \"TI\"]\)."
Orange::usage = "Orange represents the color orange in graphics or style specifications. "
OrderDistribution::usage = "\!\(\*RowBox[{\"OrderDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\)-order statistics distribution for \!\(\*StyleBox[\"n\", \"TI\"]\) observations from the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"OrderDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the joint \!\(\*RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], \"2\"], \",\", \"\[Ellipsis]\"}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\)-order statistics distribution from \!\(\*StyleBox[\"n\", \"TI\"]\) observations from the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\). \n\!\(\*RowBox[{\"OrderDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the order statistics distribution for independent distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"OrderDistribution\", \"[\", RowBox[{StyleBox[\"mdist\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the order statistics distribution for multivariate distribution \!\(\*StyleBox[\"mdist\", \"TI\"]\)."
OrderedQ::usage = "\!\(\*RowBox[{\"OrderedQ\", \"[\", RowBox[{StyleBox[\"h\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \"]\"}]\) gives True if the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are in canonical order, and False otherwise. "
Ordering::usage = "\!\(\*RowBox[{\"Ordering\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the positions in \!\(\*StyleBox[\"list\", \"TI\"]\) at which each successive element of \!\(\*RowBox[{\"Sort\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) appears. \n\!\(\*RowBox[{\"Ordering\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the positions in \!\(\*StyleBox[\"list\", \"TI\"]\) at which the first \!\(\*StyleBox[\"n\", \"TI\"]\) elements of \!\(\*RowBox[{\"Sort\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) appear. \n\!\(\*RowBox[{\"Ordering\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) gives the positions of the last \!\(\*StyleBox[\"n\", \"TI\"]\) elements of \!\(\*RowBox[{\"Sort\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\). \n\!\(\*RowBox[{\"Ordering\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) uses \!\(\*RowBox[{\"Sort\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\). "
OrderlessPatternSequence::usage = "\!\(\*RowBox[{\"OrderlessPatternSequence\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is a pattern object that represents a sequence of arguments matching \!\(\*RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) in any order."
Orderless::usage = "Orderless is an attribute that can be assigned to a symbol \!\(\*StyleBox[\"f\", \"TI\"]\) to indicate that the elements \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in expressions of the form \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) should automatically be sorted into canonical order. This property is accounted for in pattern matching. "
Order::usage = "\!\(\*RowBox[{\"Order\", \"[\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives 1 if \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) is before \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in canonical order, and \!\(\*RowBox[{\"-\", \"1\"}]\) if \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) is after \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in canonical order. It gives 0 if \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) is identical to \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
OrnsteinUhlenbeckProcess::usage = "\!\(\*RowBox[{\"OrnsteinUhlenbeckProcess\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) represents a stationary Ornstein\[Dash]Uhlenbeck process with long-term mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), volatility \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\), and mean reversion speed \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\). \n\!\(\*RowBox[{\"OrnsteinUhlenbeckProcess\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents an Ornstein\[Dash]Uhlenbeck process with initial condition \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
Orthogonalize::usage = "\!\(\*RowBox[{\"Orthogonalize\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives an orthonormal basis found by orthogonalizing the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Orthogonalize\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gives a basis for the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) orthonormal with respect to the inner product function \!\(\*StyleBox[\"f\", \"TI\"]\)."
OrthogonalMatrixQ::usage = "\!\(\*RowBox[{\"OrthogonalMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is an explicitly orthogonal matrix, and False otherwise."
Or::usage = "\!\(\*RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"||\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"||\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) is the logical OR function. It evaluates its arguments in order, giving True immediately if any of them are True, and False if they are all False. "
O::usage = "\!\(\*RowBox[{RowBox[{\"O\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"^\", StyleBox[\"n\", \"TI\"]}]\) represents a term of order \!\(\*SuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{RowBox[{\"O\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"^\", StyleBox[\"n\", \"TI\"]}]\) is generated to represent omitted higher\[Hyphen]order terms in power series. \n\!\(\*RowBox[{RowBox[{\"O\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}], \"^\", StyleBox[\"n\", \"TI\"]}]\) represents a term of order \!\(\*SuperscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"-\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \")\"}], StyleBox[\"n\", \"TI\"]]\). "
Outer::usage = "\!\(\*RowBox[{\"Outer\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the generalized outer product of the \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), forming all possible combinations of the lowest\[Hyphen]level elements in each of them, and feeding them as arguments to \!\(\*StyleBox[\"f\", \"TI\"]\). \n\!\(\*RowBox[{\"Outer\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) treats as separate elements only sublists at level \!\(\*StyleBox[\"n\", \"TI\"]\) in the \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Outer\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) treats as separate elements only sublists at level \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the corresponding \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
OutputAutoOverwrite::usage = "OutputAutoOverwrite is an option for notebooks that specifies whether the output of a command should replace any existing output from a previous evaluation."
OutputControllabilityMatrix::usage = "\!\(\*RowBox[{\"OutputControllabilityMatrix\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) gives the output controllability matrix of the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
OutputControllableModelQ::usage = "\!\(\*RowBox[{\"OutputControllableModelQ\", \"[\", StyleBox[\"ssm\", \"TI\"], \"]\"}]\) gives True if the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\) is output controllable, and False otherwise."
OutputForm::usage = "\!\(\*RowBox[{\"OutputForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as a two-dimensional representation of \!\(\*StyleBox[\"expr\", \"TI\"]\) using only keyboard characters. "
OutputMathEditExpression::usage = "OutputMathEditExpression is an internal symbol used for formatting."
OutputNamePacket::usage = "\!\(\*RowBox[{\"OutputNamePacket\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that contains in \!\(\*StyleBox[\"string\", \"TI\"]\) the name assigned to the next output."
OutputResponse::usage = "\!\(\*RowBox[{\"OutputResponse\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the numeric output response of systems model \!\(\*StyleBox[\"sys\", \"TI\"]\) to the input \!\(\*StyleBox[\"u\", \"TI\"]\) for \!\(\*RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"\[LessEqual]\", StyleBox[\"t\", \"TI\"], \"\[LessEqual]\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}]\).\n\!\(\*RowBox[{\"OutputResponse\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", \"0\", \"]\"}], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the output response of the discrete-time system \!\(\*StyleBox[\"sys\", \"TI\"]\) to the input sequence \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[\"i\", \"TI\"], \"]\"}]\).\n\!\(\*RowBox[{\"OutputResponse\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the symbolic output response of system \!\(\*StyleBox[\"sys\", \"TI\"]\) to the input \!\(\*StyleBox[\"u\", \"TI\"]\) as a function of time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"OutputResponse\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the output response for multiple inputs \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
OutputSizeLimit::usage = "OutputSizeLimit is an option for notebooks which specifies the maximum size in bytes of expressions that will automatically be output in their entirety."
OutputStream::usage = "\!\(\*RowBox[{\"OutputStream\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) is an object that represents an output stream for functions such as Write. "
Out::usage = "\!\(\*RowBox[{\"%\", StyleBox[\"n\", \"TI\"]}]\) or \!\(\*RowBox[{\"Out\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) is a global object that is assigned to be the value produced on the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) output line. \n% gives the last result generated. \n%% gives the result before last. \!\(\*RowBox[{\"%%\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"%\"}]\) (\!\(\*StyleBox[\"k\", \"TI\"]\) times) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) previous result. "
OverBar::usage = "\!\(\*RowBox[{\"OverBar\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays with a bar over \!\(\*StyleBox[\"expr\", \"TI\"]\)."
OverDot::usage = "\!\(\*RowBox[{\"OverDot\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays with a dot over \!\(\*StyleBox[\"expr\", \"TI\"]\)."
Overflow::usage = "\!\(\*RowBox[{\"Overflow\", \"[\", \"]\"}]\) represents a number too large to represent explicitly on your computer system."
OverHat::usage = "\!\(\*RowBox[{\"OverHat\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays with a hat over \!\(\*StyleBox[\"expr\", \"TI\"]\)."
Overlaps::usage = "Overlaps is an option to string and sequence functions that specifies how to treat overlapping substrings. "
OverlayBoxOptions::usage = "\!\(\*RowBox[{OverlayBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for OverlayBox objects."
Overlay::usage = "\!\(\*RowBox[{\"Overlay\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) displays as an overlay of all the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Overlay\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) displays as an overlay of \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"j\", \"TI\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"Overlay\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) allows selections to be made and controls to be clicked in \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"s\", \"TI\"]]\)."
OverscriptBoxOptions::usage = "\!\(\*RowBox[{OverscriptBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies the style and display of OverscriptBox constructs."
OverscriptBox::usage = "\!\(\*RowBox[{OverscriptBox, \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is the low\[Hyphen]level box representation for \!\(\*OverscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\) in notebook expressions. "
Overscript::usage = "\!\(\*RowBox[{\"Overscript\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is an object that formats as \!\(\*OverscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\). "
OverTilde::usage = "\!\(\*RowBox[{\"OverTilde\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays with a tilde over \!\(\*StyleBox[\"expr\", \"TI\"]\)."
OverVector::usage = "\!\(\*RowBox[{\"OverVector\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays with a right vector over \!\(\*StyleBox[\"expr\", \"TI\"]\)."
OwenT::usage = "\!\(\*RowBox[{\"OwenT\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives Owen's T function \!\(\*RowBox[{StyleBox[\"T\", \"TI\"], \"(\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \")\"}]\)."
OwnValues::usage = "\!\(\*RowBox[{\"OwnValues\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the rule corresponding to any ownvalue defined for the symbol \!\(\*StyleBox[\"x\", \"TI\"]\)."
PackingMethod::usage = "PackingMethod is an option for GraphPlot and related functions that specifies how disconnected components should be packed together in the layout produced."
PaddedForm::usage = "\!\(\*RowBox[{\"PaddedForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) prints with all numbers in \!\(\*StyleBox[\"expr\", \"TI\"]\) padded to leave room for a total of \!\(\*StyleBox[\"n\", \"TI\"]\) digits. \n\!\(\*RowBox[{\"PaddedForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"}\"}]}], \"]\"}]\) prints with approximate real numbers having exactly \!\(\*StyleBox[\"f\", \"TI\"]\) digits to the right of the decimal point. "
Padding::usage = "Padding is an option to various array and image operations that specifies what padding to use when extending beyond the original data specified."
PadeApproximant::usage = "\!\(\*RowBox[{\"PadeApproximant\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) gives the Pad\[EAcute] approximant to \!\(\*StyleBox[\"expr\", \"TI\"]\) about the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\), with numerator order \!\(\*StyleBox[\"m\", \"TI\"]\) and denominator order \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"PadeApproximant\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the diagonal Pad\[EAcute] approximant to \!\(\*StyleBox[\"expr\", \"TI\"]\) about the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\) of order \!\(\*StyleBox[\"n\", \"TI\"]\)."
PadLeft::usage = "\!\(\*RowBox[{\"PadLeft\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) makes a list of length \!\(\*StyleBox[\"n\", \"TI\"]\) by padding \!\(\*StyleBox[\"list\", \"TI\"]\) with zeros on the left. \n\!\(\*RowBox[{\"PadLeft\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) pads by repeating the element \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"PadLeft\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) pads by cyclically repeating the elements \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"PadLeft\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) leaves a margin of \!\(\*StyleBox[\"m\", \"TI\"]\) elements of padding on the right. \n\!\(\*RowBox[{\"PadLeft\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) makes a nested list with length \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at level \!\(\*StyleBox[\"i\", \"TI\"]\). \n\!\(\*RowBox[{\"PadLeft\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) pads a ragged array \!\(\*StyleBox[\"list\", \"TI\"]\) with zeros to make it full. "
PadRight::usage = "\!\(\*RowBox[{\"PadRight\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) makes a list of length \!\(\*StyleBox[\"n\", \"TI\"]\) by padding \!\(\*StyleBox[\"list\", \"TI\"]\) with zeros on the right. \n\!\(\*RowBox[{\"PadRight\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) pads by repeating the element \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"PadRight\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) pads by cyclically repeating the elements \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"PadRight\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"padding\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) leaves a margin of \!\(\*StyleBox[\"m\", \"TI\"]\) elements of padding on the left. \n\!\(\*RowBox[{\"PadRight\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) makes a nested list with length \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at level \!\(\*StyleBox[\"i\", \"TI\"]\). \n\!\(\*RowBox[{\"PadRight\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) pads a ragged array \!\(\*StyleBox[\"list\", \"TI\"]\) with zeros to make it full. "
PageBreakAbove::usage = "PageBreakAbove is an option for Cell which specifies whether a page break should be made immediately above the cell if the notebook that contains the cell is printed. "
PageBreakBelow::usage = "PageBreakBelow is an option for Cell which specifies whether a page break should be made immediately below the cell if the notebook that contains the cell is printed. "
PageBreakWithin::usage = "PageBreakWithin is an option for Cell which specifies whether a page break should be allowed within the cell if the notebook that contains the cell is printed. "
PageFooterLines::usage = "PageFooterLines is an option for notebooks that specifies whether a horizontal line is inserted at the bottom of each page when the notebook is printed."
PageFooters::usage = "PageFooters is an option for notebooks that specifies what should be inserted as the footer of each page of a notebook when it is printed."
PageHeaderLines::usage = "PageHeaderLines is an option for notebooks that specifies whether a horizontal line is inserted at the top of each page when the notebook is printed."
PageHeaders::usage = "PageHeaders is an option for notebooks that specifies what should be inserted as the header of each page of a notebook when it is printed."
PageRankCentrality::usage = "\!\(\*RowBox[{\"PageRankCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) gives a list of page-rank centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) and weight \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\).\n\!\(\*RowBox[{\"PageRankCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) gives a list of page-rank centralities, using weight \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and initial centralities \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"PageRankCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
PageWidth::usage = "PageWidth is an option for output streams and for cells that specifies how wide each line of text is allowed to be."
PairedBarChart::usage = "\!\(\*RowBox[{\"PairedBarChart\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) makes a paired bar chart with bar lengths \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*RowBox[{StyleBox[\" \", \"TI\"], SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]\), \[Ellipsis] and \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis], respectively.\n\!\(\*RowBox[{\"PairedBarChart\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) makes a paired bar chart with bar features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"PairedBarChart\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) makes a paired bar chart from multiple datasets \!\(\*SubscriptBox[StyleBox[SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"], StyleBox[\"j\", \"TI\"]]\)."
PairedHistogram::usage = "\!\(\*RowBox[{\"PairedHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) plots a paired histogram of the values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"PairedHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \" \", StyleBox[\"bspec\", \"TI\"]}], \"]\"}]\) plots a paired histogram with bin width specification \!\(\*StyleBox[\"bspec\", \"TI\"]\).\n\!\(\*RowBox[{\"PairedHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"bspec\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) plots a paired histogram with bin heights computed according to the specification \!\(\*StyleBox[\"hspec\", \"TI\"]\).\n\!\(\*RowBox[{\"PairedHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots paired histograms for multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], RowBox[{StyleBox[\"1\", \"TR\"], StyleBox[\"i\", \"TI\"]}]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], RowBox[{StyleBox[\"2\", \"TR\"], StyleBox[\"j\", \"TI\"]}]]\)."
PairedSmoothHistogram::usage = "\!\(\*RowBox[{\"PairedSmoothHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) plots a paired smooth histogram of the values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"PairedSmoothHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"espec\", \"TI\"]}], \"]\"}]\) plots a paired smooth histogram with estimator specification \!\(\*StyleBox[\"espec\", \"TI\"]\).\n\!\(\*RowBox[{\"PairedSmoothHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"espec\", \"TI\"], \",\", StyleBox[\"dfun\", \"TI\"]}], \"]\"}]\) plots a paired smooth histogram with distribution function \!\(\*StyleBox[\"dfun\", \"TI\"]\).\n\!\(\*RowBox[{\"PairedSmoothHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots paired smooth histograms for multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], RowBox[{StyleBox[\"1\", \"TR\"], StyleBox[\"i\", \"TI\"]}]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], RowBox[{StyleBox[\"2\", \"TR\"], StyleBox[\"j\", \"TI\"]}]]\)."
PairedTTest::usage = "\!\(\*RowBox[{\"PairedTTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the mean of \!\(\*StyleBox[\"data\", \"TI\"]\) is zero. \n\!\(\*RowBox[{\"PairedTTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the mean of \!\(\*RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Dash]\", \" \", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]\) is zero.\n\!\(\*RowBox[{\"PairedTTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) tests a location measure against \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"PairedTTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
PairedZTest::usage = "\!\(\*RowBox[{\"PairedZTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the mean of the \!\(\*StyleBox[\"data\", \"TI\"]\) is zero. \n\!\(\*RowBox[{\"PairedZTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the means of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"PairedZTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) tests for zero or equal means assuming a population variance \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"PairedZTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) tests the mean against \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"PairedZTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
PaletteNotebook::usage = "\!\(\*RowBox[{\"PaletteNotebook\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cell\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a palette notebook that can be manipulated by the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) front end. "
PalettePath::usage = "PalettePath is a global option that specifies which directories \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) searches for palettes on startup."
PalindromeQ::usage = "\!\(\*RowBox[{\"PalindromeQ\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) returns True if the given list is identical to \!\(\*RowBox[{\"Reverse\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\), and False otherwise.\n\!\(\*RowBox[{\"PalindromeQ\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) returns True if the integer \!\(\*StyleBox[\"n\", \"TI\"]\) is identical to \!\(\*RowBox[{\"IntegerReverse\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\), and False otherwise.\n\!\(\*RowBox[{\"PalindromeQ\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) returns True if the given string is identical to \!\(\*RowBox[{\"StringReverse\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\), and False otherwise. "
PaneBoxOptions::usage = "\!\(\*RowBox[{PaneBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for PaneBox objects."
PanelBoxOptions::usage = "\!\(\*RowBox[{PanelBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for PanelBox objects."
Paneled::usage = "Paneled is an option for Manipulate and related functions that specifies whether to give the output inside a panel."
Panel::usage = "\!\(\*RowBox[{\"Panel\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as a panel containing \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Panel\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"title\", \"TI\"]}], \"]\"}]\) gives the panel the specified title. \n\!\(\*RowBox[{\"Panel\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"title\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) places \!\(\*StyleBox[\"title\", \"TI\"]\) at a position specified by \!\(\*StyleBox[\"pos\", \"TI\"]\). \n\!\(\*RowBox[{\"Panel\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"title\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"title\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) places \!\(\*SubscriptBox[StyleBox[\"title\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at position \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Panel\", \"[\", \"]\"}]\) displays an empty panel. "
PaneSelectorBoxOptions::usage = "\!\(\*RowBox[{PaneSelectorBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for PaneSelectorBox objects."
PaneSelector::usage = "\!\(\*RowBox[{\"PaneSelector\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", \"\[Ellipsis]\"}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents an object that displays as a pane containing the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for which \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is equal to \!\(\*StyleBox[\"v\", \"TI\"]\). "
Pane::usage = "\!\(\*RowBox[{\"Pane\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as a pane containing \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Pane\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) makes the pane be \!\(\*StyleBox[\"w\", \"TI\"]\) printer's points wide, linewrapping the contents if necessary.\n\!\(\*RowBox[{\"Pane\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]}], \"]\"}]\) makes the pane be \!\(\*StyleBox[\"w\", \"TI\"]\) points wide and \!\(\*StyleBox[\"h\", \"TI\"]\) points high, shrinking the contents if necessary."
ParabolicCylinderD::usage = "\!\(\*RowBox[{\"ParabolicCylinderD\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the parabolic cylinder function \!\(\*RowBox[{SubscriptBox[StyleBox[\"D\", \"TI\"], \"\[Nu]\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
ParagraphIndent::usage = "ParagraphIndent is an option for Cell which specifies how far in printer's points to indent the first line of each paragraph of text. "
ParagraphSpacing::usage = "ParagraphSpacing is an option for Cell, StyleBox, and Style that specifies how much extra space to leave between successive paragraphs of text. "
ParallelArray::usage = "\!\(\*RowBox[{\"ParallelArray\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates in parallel a list of length \!\(\*StyleBox[\"n\", \"TI\"]\), with elements \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"i\", \"TI\"], \"]\"}]\), evaluated.\n\!\(\*RowBox[{\"ParallelArray\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates in parallel an \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Cross]\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Cross]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) array of nested lists, with elements \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\). \n\!\(\*RowBox[{\"ParallelArray\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates in parallel a list using the index origins \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) (default 1). \n\!\(\*RowBox[{\"ParallelArray\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"dims\", \"TI\"], \",\", StyleBox[\"origin\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) uses head \!\(\*StyleBox[\"h\", \"TI\"]\), rather than List, for each level of the array. "
ParallelCombine::usage = "\!\(\*RowBox[{\"ParallelCombine\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"h\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"comb\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"h\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \"]\"}]\) in parallel by distributing parts of the computation to all parallel kernels and combining the partial results with \!\(\*StyleBox[\"comb\", \"TI\"]\).\n\!\(\*RowBox[{\"ParallelCombine\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"h\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]}], \"]\"}]\) is equivalent to \!\(\*RowBox[{\"ParallelCombine\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"h\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) if \!\(\*StyleBox[\"h\", \"TI\"]\) has attribute Flat, and \!\(\*RowBox[{\"ParallelCombine\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"h\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", \"Join\"}], \"]\"}]\) otherwise."
ParallelDo::usage = "\!\(\*RowBox[{\"ParallelDo\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"}\"}]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) in parallel \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) times. \n\!\(\*RowBox[{\"ParallelDo\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) in parallel with the variable \!\(\*StyleBox[\"i\", \"TI\"]\) successively taking on the values 1 through \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) (in steps of 1). \n\!\(\*RowBox[{\"ParallelDo\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) starts with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"ParallelDo\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"di\", \"TI\"]\). \n\!\(\*RowBox[{\"ParallelDo\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses the successive values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"ParallelDo\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) looping in parallel over different values of \!\(\*StyleBox[\"j\", \"TI\"]\), etc. for each \!\(\*StyleBox[\"i\", \"TI\"]\). "
Parallelepiped::usage = "\!\(\*RowBox[{\"Parallelepiped\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a parallelepiped with origin \!\(\*StyleBox[\"p\", \"TI\"]\) and directions \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ParallelEvaluate::usage = "\!\(\*RowBox[{\"ParallelEvaluate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates the expression \!\(\*StyleBox[\"expr\", \"TI\"]\) on all available parallel kernels and returns the list of results obtained.\n\!\(\*RowBox[{\"ParallelEvaluate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"kernel\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) on the parallel kernel specified. \n\!\(\*RowBox[{\"ParallelEvaluate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) on the parallel kernels \!\(\*SubscriptBox[StyleBox[\"ker\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Parallelization::usage = "Parallelization is an option for Compile that specifies whether it should create a compiled function that could run in parallel. "
Parallelize::usage = "\!\(\*RowBox[{\"Parallelize\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) using automatic parallelization."
ParallelMap::usage = "\!\(\*RowBox[{\"ParallelMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) in parallel to each element on the first level in \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"ParallelMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) in parallel to parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\)."
ParallelNeeds::usage = "\!\(\*RowBox[{\"ParallelNeeds\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context`\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) evaluates \!\(\*RowBox[{\"Needs\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context`\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) on all available parallel kernels."
Parallelogram::usage = "\!\(\*RowBox[{\"Parallelogram\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents a parallelogram with origin \!\(\*StyleBox[\"p\", \"TI\"]\) and directions \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ParallelProduct::usage = "\!\(\*RowBox[{\"ParallelProduct\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) evaluates the product \!\(\*RowBox[{UnderoverscriptBox[\"\[Product]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", \"1\"}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], StyleBox[\"expr\", FontSlant -> \"Italic\"]}]\) in parallel.\n\!\(\*RowBox[{\"ParallelProduct\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) starts with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\).\n\!\(\*RowBox[{\"ParallelProduct\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*RowBox[{StyleBox[\"d\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"i\", \"TI\"]}]\).\n\!\(\*RowBox[{\"ParallelProduct\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses successive values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"ParallelProduct\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) evaluates the multiple product \!\(\*RowBox[{UnderoverscriptBox[\"\[Product]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]]}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], RowBox[{UnderoverscriptBox[\"\[Product]\", RowBox[{StyleBox[\"j\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]]}], SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], RowBox[{\"\[Ellipsis]\", \" \", StyleBox[\"expr\", FontSlant -> \"Italic\"]}]}]}]\) in parallel."
ParallelSubmit::usage = "\!\(\*RowBox[{\"ParallelSubmit\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) submits \!\(\*StyleBox[\"expr\", \"TI\"]\) for evaluation on the next available parallel kernel and returns an EvaluationObject expression representing the submitted evaluation.\n\!\(\*RowBox[{\"ParallelSubmit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) builds a closure for the variables given before submitting \!\(\*StyleBox[\"expr\", \"TI\"]\)."
ParallelSum::usage = "\!\(\*RowBox[{\"ParallelSum\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) evaluates in parallel the sum \!\(\*RowBox[{UnderoverscriptBox[\"\[Sum]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", \"1\"}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], StyleBox[\"expr\", FontSlant -> \"Italic\"]}]\).\n\!\(\*RowBox[{\"ParallelSum\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) starts with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[StyleBox[\"min\", \"TI\"], FontSlant -> \"Italic\"]]}]\).\n\!\(\*RowBox[{\"ParallelSum\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*RowBox[{StyleBox[\"d\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"i\", \"TI\"]}]\).\n\!\(\*RowBox[{\"ParallelSum\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses successive values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]..\n\!\(\*RowBox[{\"ParallelSum\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) evaluates in parallel the multiple sum \!\(\*RowBox[{UnderoverscriptBox[\"\[Sum]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]]}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], RowBox[{UnderoverscriptBox[\"\[Sum]\", RowBox[{StyleBox[\"j\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]]}], SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], RowBox[{\"\[Ellipsis]\", \" \", StyleBox[\"expr\", FontSlant -> \"Italic\"]}]}]}]\)."
ParallelTable::usage = "\!\(\*RowBox[{\"ParallelTable\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"}\"}]}], \"]\"}]\) generates in parallel a list of \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) copies of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"ParallelTable\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates in parallel a list of the values of \!\(\*StyleBox[\"expr\", \"TI\"]\) when \!\(\*StyleBox[\"i\", \"TI\"]\) runs from \!\(\*StyleBox[\"1\", \"TR\"]\) to \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"ParallelTable\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) starts with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"ParallelTable\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"di\", \"TI\"]\). \n\!\(\*RowBox[{\"ParallelTable\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses the successive values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"ParallelTable\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a nested list. The list associated with \!\(\*StyleBox[\"i\", \"TI\"]\) is outermost."
ParallelTry::usage = "\!\(\*RowBox[{\"ParallelTry\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) evaluates \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) in parallel, returning the first result received.\n\!\(\*RowBox[{\"ParallelTry\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) returns a list of the first \!\(\*StyleBox[\"k\", \"TI\"]\) results."
ParameterEstimator::usage = "ParameterEstimator is an option to EstimatedDistribution and FindDistributionParameters that specifies what parameter estimator to use. "
ParameterMixtureDistribution::usage = "\!\(\*RowBox[{\"ParameterMixtureDistribution\", \"[\", RowBox[{RowBox[{StyleBox[\"dist\", \"TI\"], \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}], \",\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \"\[Distributed]\", StyleBox[\"wdist\", \"TI\"]}]}], \"]\"}]\) represents a parameter mixture distribution where the parameter \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) is distributed according to the weight distribution \!\(\*StyleBox[\"wdist\", \"TI\"]\). \n\!\(\*RowBox[{\"ParameterMixtureDistribution\", \"[\", RowBox[{RowBox[{StyleBox[\"dist\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"wdist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"wdist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a parameter mixture distribution where the parameter \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) has weight distribution \!\(\*SubscriptBox[StyleBox[\"wdist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\) has weight distribution \!\(\*SubscriptBox[StyleBox[\"wdist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc. "
ParameterVariables::usage = "ParameterVariables is an option for GroebnerBasis and PolynomialReduce. These variables will always be last in the ordering. By default, all variables that are not otherwise classified will become parameter variables. By specifying them explicitly one fixes their relative positions in the overall variable ordering."
ParametricFunction::usage = "\!\(\*RowBox[{\"ParametricFunction\", \"[\", RowBox[{StyleBox[\"pars\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a function that computes a solution when evaluated with numerical values for the parameters \!\(\*StyleBox[\"pars\", \"TI\"]\). "
ParametricNDSolve::usage = "\!\(\*RowBox[{\"ParametricNDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"pars\", \"TI\"]}], \"]\"}]\) finds a numerical solution to the ordinary differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) for the function \!\(\*StyleBox[\"u\", \"TI\"]\) with the independent variable \!\(\*StyleBox[\"x\", \"TI\"]\) in the range \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) with parameters \!\(\*StyleBox[\"pars\", \"TI\"]\).\n\!\(\*RowBox[{\"ParametricNDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"pars\", \"TI\"]}], \"]\"}]\) solves the partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over a rectangular region.\n\!\(\*RowBox[{\"ParametricNDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], StyleBox[\"\[Element]\", \"TR\"], StyleBox[\"\[CapitalOmega]\", \"TR\"]}], StyleBox[\",\", \"MR\"], StyleBox[\" \", \"TR\"], StyleBox[\"pars\", \"TI\"]}], \"]\"}]\) solves the partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"ParametricNDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], StyleBox[\"\[Element]\", \"TR\"], StyleBox[\"\[CapitalOmega]\", \"TR\"]}], StyleBox[\",\", \"MR\"], StyleBox[\" \", \"TR\"], StyleBox[\"pars\", \"TI\"]}], \"]\"}]\) solves the time-dependent partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"ParametricNDSolve\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) solves for the functions\[NonBreakingSpace]\!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
ParametricNDSolveValue::usage = "\!\(\*RowBox[{\"ParametricNDSolveValue\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"pars\", \"TI\"]}], \"]\"}]\) gives the value of \!\(\*StyleBox[\"expr\", \"TI\"]\) with functions determined by a numerical solution to the ordinary differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) with the independent variable \!\(\*StyleBox[\"x\", \"TI\"]\) in the range \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) with parameters \!\(\*StyleBox[\"pars\", \"TI\"]\).\n\!\(\*RowBox[{\"ParametricNDSolveValue\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) solves the partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over a rectangular region.\n\!\(\*RowBox[{\"ParametricNDSolveValue\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"pars\", \"TI\"]}], \"]\"}]\) solves the partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\).\n\!\(\*RowBox[{\"ParametricNDSolveValue\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"\[CapitalOmega]\", \"TR\"]}], \",\", StyleBox[\"pars\", \"TI\"]}], \"]\"}]\) solves the time-dependent partial differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) over the region \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\)."
ParametricPlot3D::usage = "\!\(\*RowBox[{\"ParametricPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) produces a three-dimensional space curve parametrized by a variable \!\(\*StyleBox[\"u\", \"TI\"]\) which runs from \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"ParametricPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) produces a three-dimensional surface parametrized by \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\). \n\!\(\*RowBox[{\"ParametricPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots several objects together. \n\!\(\*RowBox[{\"ParametricPlot3D\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes parameters \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
ParametricPlot::usage = "\!\(\*RowBox[{\"ParametricPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a parametric plot of a curve with \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) coordinates \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]\) as a function of \!\(\*StyleBox[\"u\", \"TI\"]\). \n\!\(\*RowBox[{\"ParametricPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots several parametric curves. \n\!\(\*RowBox[{\"ParametricPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots a parametric region. \n\!\(\*RowBox[{\"ParametricPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots several parametric regions. \n\!\(\*RowBox[{\"ParametricPlot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes parameters \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
ParametricRegion::usage = "\!\(\*RowBox[{\"ParametricRegion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a region in \!\(\*SuperscriptBox[\"\[DoubleStruckCapitalR]\", StyleBox[\"n\", \"TI\"]]\) given by the points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\) for parameters \!\(\*RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[Element]\", \"\[DoubleStruckCapitalR]\"}]\).\n\!\(\*RowBox[{\"ParametricRegion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constrains parameters to an interval \!\(\*RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[LessEqual]\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[LessEqual]\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]}]\) etc. \n\!\(\*RowBox[{\"ParametricRegion\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"cond\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) constrains parameters to satisfy the condition \!\(\*StyleBox[\"cond\", \"TI\"]\)."
ParentBox::usage = "\!\(\*RowBox[{ParentBox, \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) returns the BoxObject that contains \!\(\*StyleBox[\"obj\", \"TI\"]\)."
ParentCell::usage = "\!\(\*RowBox[{\"ParentCell\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) returns the CellObject that contains \!\(\*StyleBox[\"obj\", \"TI\"]\)."
ParentDirectory::usage = "\!\(\*RowBox[{\"ParentDirectory\", \"[\", \"]\"}]\) gives the parent of the current working directory. \n\!\(\*RowBox[{\"ParentDirectory\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dir\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the parent of the directory \!\(\*StyleBox[\"dir\", \"TI\"]\). "
ParentForm::usage = "ParentForm sets the parent form for a boxes format."
Parenthesize::usage = "\!\(\*RowBox[{\"Parenthesize\", \"[\", \" \", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \" \", StyleBox[\"fmt\", \"TI\"], \",\", \" \", StyleBox[\"prec\", \"TI\"], \",\", \" \", StyleBox[\"group\", \"TI\"]}], \"]\"}]\) will represent \!\(\*StyleBox[\"expr\", \"TI\"]\) in format \!\(\*StyleBox[\"fmt\", \"TI\"]\) and parenthesize it if necessary."
ParentNotebook::usage = "\!\(\*RowBox[{\"ParentNotebook\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) returns the NotebookObject that contains \!\(\*StyleBox[\"obj\", \"TI\"]\)."
ParetoDistribution::usage = "\!\(\*RowBox[{\"ParetoDistribution\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) represents a Pareto distribution with minimum value parameter \!\(\*StyleBox[\"k\", \"TI\"]\) and shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\).\n\!\(\*RowBox[{\"ParetoDistribution\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a Pareto type II distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\).\n\!\(\*RowBox[{\"ParetoDistribution\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a Pareto type IV distribution with shape parameter \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\)."
ParkData::usage = "\!\(\*RowBox[{\"ParkData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the park \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"ParkData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified park entities.\n\!\(\*RowBox[{\"ParkData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
PartBehavior::usage = "PartBehavior is an option to Query and related functions that specifies how nonexistent parts should be resolved."
PartialCorrelationFunction::usage = "\!\(\*RowBox[{\"PartialCorrelationFunction\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) estimates the partial correlation function at lags \!\(\*StyleBox[\"hspec\", \"TI\"]\) from \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"PartialCorrelationFunction\", \"[\", RowBox[{StyleBox[\"tproc\", \"TI\"], \",\", StyleBox[\"hspec\", \"TI\"]}], \"]\"}]\) represents the partial correlation function at lags \!\(\*StyleBox[\"hspec\", \"TI\"]\) for the time series process \!\(\*StyleBox[\"tproc\", \"TI\"]\). "
ParticleAcceleratorData::usage = "\!\(\*RowBox[{\"ParticleAcceleratorData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the particle accelerator \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"ParticleAcceleratorData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified particle accelerator entities.\n\!\(\*RowBox[{\"ParticleAcceleratorData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
ParticleData::usage = "\!\(\*RowBox[{\"ParticleData\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property for a subatomic particle or family of particles with the specified name. \n\!\(\*RowBox[{\"ParticleData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property for a version of the particle with charge \!\(\*StyleBox[\"q\", \"TI\"]\)."
PartitionsP::usage = "\!\(\*RowBox[{\"PartitionsP\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], RowBox[{\"(\", StyleBox[\"n\", \"TI\"], \")\"}]}]\) of unrestricted partitions of the integer \!\(\*StyleBox[\"n\", \"TI\"]\). "
PartitionsQ::usage = "\!\(\*RowBox[{\"PartitionsQ\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number \!\(\*RowBox[{StyleBox[\"q\", \"TI\"], RowBox[{\"(\", StyleBox[\"n\", \"TI\"], \")\"}]}]\) of partitions of the integer \!\(\*StyleBox[\"n\", \"TI\"]\) into distinct parts. "
Partition::usage = "\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) partitions \!\(\*StyleBox[\"list\", \"TI\"]\) into nonoverlapping sublists of length \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) generates sublists with offset \!\(\*StyleBox[\"d\", \"TI\"]\). \n\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) partitions a nested list into blocks of size \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis].\n\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses offset \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at level \!\(\*StyleBox[\"i\", \"TI\"]\) in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) specifies that the first element of \!\(\*StyleBox[\"list\", \"TI\"]\) should appear at position \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]]\) in the first sublist, and the last element of \!\(\*StyleBox[\"list\", \"TI\"]\) should appear at or after position \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]\) in the last sublist. If additional elements are needed, Partition fills them in by treating \!\(\*StyleBox[\"list\", \"TI\"]\) as cyclic. \n\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) pads if necessary by repeating the element \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) pads if necessary by cyclically repeating the elements \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", \"}\"}]}], \"]\"}]\) uses no padding, and so can yield sublists of different lengths. \n\!\(\*RowBox[{\"Partition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"nlist\", \"TI\"], \",\", StyleBox[\"dlist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"klist\", \"TI\"], StyleBox[\"L\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"klist\", \"TI\"], StyleBox[\"R\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"padlist\", \"TI\"]}], \"]\"}]\) specifies alignments and padding in a nested list. "
PartOfSpeech::usage = "\!\(\*RowBox[{\"PartOfSpeech\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"word\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) returns the possible parts of speech for the specified word."
Part::usage = "\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", StyleBox[\"i\", \"TI\"], \"]\"}], \"]\"}]\) or \!\(\*RowBox[{\"Part\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) part of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", RowBox[{\"-\", StyleBox[\"i\", \"TI\"]}], \"]\"}], \"]\"}]\) counts from the end. \n\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \"]\"}]\) or \!\(\*RowBox[{\"Part\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is equivalent to \!\(\*RowBox[{RowBox[{RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", StyleBox[\"i\", \"TI\"], \"]\"}], \"]\"}], \"[\", RowBox[{\"[\", StyleBox[\"j\", \"TI\"], \"]\"}], \"]\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]\). \n\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}], \"]\"}]\) gives a list of the parts \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", RowBox[{StyleBox[\"m\", \"TI\"], \";;\", StyleBox[\"n\", \"TI\"]}], \"]\"}], \"]\"}]\) gives parts \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", RowBox[{StyleBox[\"m\", \"TI\"], \";;\", StyleBox[\"n\", \"TI\"], \";;\", StyleBox[\"s\", \"TI\"]}], \"]\"}], \"]\"}]\) gives parts \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) in steps of \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"key\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}], \"]\"}]\) gives the value associated with the key \"\!\(\*\nStyleBox[\"key\", \"TI\"]\)\" in an association \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"[\", RowBox[{\"[\", RowBox[{\"Key\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}], \"]\"}], \"]\"}]\) gives the value associated with an arbitrary key \!\(\*StyleBox[\"k\", \"TI\"]\) in the association \!\(\*StyleBox[\"expr\", \"TI\"]\)."
ParzenWindow::usage = "\!\(\*RowBox[{\"ParzenWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Parzen window function of \!\(\*StyleBox[\"x\", \"TI\"]\)."
PascalDistribution::usage = "\!\(\*RowBox[{\"PascalDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents a Pascal distribution with parameters \!\(\*StyleBox[\"n\", \"TI\"]\) and \!\(\*StyleBox[\"p\", \"TI\"]\)."
PassEventsDown::usage = "PassEventsDown is an option to EventHandler which specifies whether events handled by a particular event handler should be passed down to event handlers nested inside."
PassEventsUp::usage = "PassEventsUp is an option to EventHandler that specifies whether events handled by a particular event handler should be passed up to event handlers in outer expressions."
PasteBoxFormInlineCells::usage = "PasteBoxFormInlineCells is an option for cells that specifies whether a new inline cell is created when a typeset expression is pasted into a non-box-type cell."
PasteButton::usage = "\!\(\*RowBox[{\"PasteButton\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents a button that pastes \!\(\*StyleBox[\"expr\", \"TI\"]\) whenever it is pressed. \n\!\(\*RowBox[{\"PasteButton\", \"[\", RowBox[{StyleBox[\"label\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) displays with \!\(\*StyleBox[\"label\", \"TI\"]\) on the button. "
Paste::usage = "\!\(\*RowBox[{\"Paste\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) pastes \!\(\*StyleBox[\"expr\", \"TI\"]\) at the current insertion point in the input notebook. \n\!\(\*RowBox[{\"Paste\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) pastes \!\(\*StyleBox[\"expr\", \"TI\"]\) to the specified notebook.\n\!\(\*RowBox[{\"Paste\", \"[\", \"]\"}]\) pastes the contents of the system clipboard in the input notebook. "
PathGraphQ::usage = "\!\(\*RowBox[{\"PathGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a path and False otherwise."
Path::usage = "Path is an option for Get and related functions which gives a list of directories to search in attempting to find an external file. "
PatternSequence::usage = "\!\(\*RowBox[{\"PatternSequence\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is a pattern object which represents a sequence of arguments matching \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
PatternTest::usage = "\!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"?\", StyleBox[\"test\", \"TI\"]}]\) is a pattern object that stands for any expression that matches \!\(\*StyleBox[\"p\", \"TI\"]\), and on which the application of \!\(\*StyleBox[\"test\", \"TI\"]\) gives True. "
Pattern::usage = "\!\(\*RowBox[{StyleBox[\"s\", \"TI\"], \":\", StyleBox[\"obj\", \"TI\"]}]\) represents the pattern object \!\(\*StyleBox[\"obj\", \"TI\"]\), assigned the name \!\(\*StyleBox[\"s\", \"TI\"]\). "
PauliMatrix::usage = "\!\(\*RowBox[{\"PauliMatrix\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) Pauli spin matrix \!\(\*SubscriptBox[\"\[Sigma]\", StyleBox[\"k\", \"TI\"]]\)."
PaulWavelet::usage = "\!\(\*RowBox[{\"PaulWavelet\", \"[\", \"]\"}]\) represents a Paul wavelet of order 4.\n\!\(\*RowBox[{\"PaulWavelet\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a Paul wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\)."
Pause::usage = "\!\(\*RowBox[{\"Pause\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) pauses for at least \!\(\*StyleBox[\"n\", \"TI\"]\) seconds. "
PDF::usage = "\!\(\*RowBox[{\"PDF\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the probability density function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) evaluated at \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"PDF\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multivariate probability density function for a symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) evaluated at \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"PDF\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the PDF as a pure function."
PeakDetect::usage = "\!\(\*RowBox[{\"PeakDetect\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) gives a binary list in which 1s correspond to peak positions in \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"PeakDetect\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) detects peaks that survive Gaussian blurring up to scale \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"PeakDetect\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) detects peaks with minimum sharpness \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{\"PeakDetect\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) detects only peaks with values greater than \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"PeakDetect\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"s\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"t\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) uses different scales for thresholding sharpness and value."
PearsonChiSquareTest::usage = "\!\(\*RowBox[{\"PearsonChiSquareTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed using the Pearson \!\(\*SuperscriptBox[\"\[Chi]\", \"2\"]\) test.\n\!\(\*RowBox[{\"PearsonChiSquareTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is distributed according to \!\(\*StyleBox[\"dist\", \"TI\"]\) using the Pearson \!\(\*SuperscriptBox[\"\[Chi]\", \"2\"]\) test.\n\!\(\*RowBox[{\"PearsonChiSquareTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
PearsonCorrelationTest::usage = "\!\(\*RowBox[{\"PearsonCorrelationTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are linearly independent.\n\!\(\*RowBox[{\"PearsonCorrelationTest\", \"[\", RowBox[{\"\[Ellipsis]\", \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
PearsonDistribution::usage = "\!\(\*RowBox[{\"PearsonDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents a distribution of the Pearson family with parameters \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), and \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"PearsonDistribution\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents a Pearson distribution of given \!\(\*StyleBox[\"type\", \"TI\"]\). "
PerformanceGoal::usage = "PerformanceGoal is an option for various algorithmic and presentational functions that specifies what aspect of performance to try to optimize with Automatic settings for options."
PeriodogramArray::usage = "\!\(\*RowBox[{\"PeriodogramArray\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) returns the squared magnitude of the discrete Fourier transform (power spectrum) of \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"PeriodogramArray\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) averages the power spectra of non-overlapping partitions of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"PeriodogramArray\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses partitions with offset \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"PeriodogramArray\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to each partition.\n\!\(\*RowBox[{\"PeriodogramArray\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) pads partitions with zeros to length \!\(\*StyleBox[\"m\", \"TI\"]\) prior to the computation of the transform.\n\!\(\*RowBox[{\"PeriodogramArray\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) returns the squared power spectrum of \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"PeriodogramArray\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) returns the squared power spectrum of sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
Periodogram::usage = "\!\(\*RowBox[{\"Periodogram\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) plots the squared magnitude of the discrete Fourier transform (power spectrum) of \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Periodogram\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) plots the mean of power spectra of non-overlapping partitions of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"Periodogram\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses partitions with offset \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"Periodogram\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to each partition.\n\!\(\*RowBox[{\"Periodogram\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) pads partitions with zeros to length \!\(\*StyleBox[\"m\", \"TI\"]\) prior to the computation of the transform.\n\!\(\*RowBox[{\"Periodogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) plots power spectra of several lists.\n\!\(\*RowBox[{\"Periodogram\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots the power spectrum of sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
Permanent::usage = "\!\(\*RowBox[{\"Permanent\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the permanent of the square matrix \!\(\*StyleBox[\"m\", \"TI\"]\). "
PermissionsGroups::usage = "\!\(\*RowBox[{\"PermissionsGroups\", \"[\", \"]\"}]\) gives a list of permissions groups that the current user can use."
PermissionsGroup::usage = "\!\(\*RowBox[{\"PermissionsGroup\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents a permissions group with the specified name, owned by the current user.\n\!\(\*RowBox[{\"PermissionsGroup\", \"[\", RowBox[{StyleBox[\"user\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents a permissions group owned by the specified user."
Permissions::usage = "Permissions is an option for CloudObject and related constructs that specifies permissions for classes of users to access or perform operations."
PermutationCyclesQ::usage = "\!\(\*RowBox[{\"PermutationCyclesQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a permutation in disjoint cyclic form, and False otherwise."
PermutationCycles::usage = "\!\(\*RowBox[{\"PermutationCycles\", \"[\", StyleBox[\"perm\", \"TI\"], \"]\"}]\) gives a disjoint cycle representation of permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
PermutationGroup::usage = "\!\(\*RowBox[{\"PermutationGroup\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"perm\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"perm\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents the group generated by multiplication of the permutations \!\(\*RowBox[{SubscriptBox[StyleBox[\"perm\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"perm\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\)."
PermutationLength::usage = "\!\(\*RowBox[{\"PermutationLength\", \"[\", StyleBox[\"perm\", \"TI\"], \"]\"}]\) returns the number of integers moved by the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
PermutationListQ::usage = "\!\(\*RowBox[{\"PermutationListQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a valid permutation list and False otherwise."
PermutationList::usage = "\!\(\*RowBox[{\"PermutationList\", \"[\", StyleBox[\"perm\", \"TI\"], \"]\"}]\) returns a permutation list representation of permutation \!\(\*StyleBox[\"perm\", \"TI\"]\).\n\!\(\*RowBox[{\"PermutationList\", \"[\", RowBox[{StyleBox[\"perm\", \"TI\"], \",\", StyleBox[\"len\", \"TI\"]}], \"]\"}]\) returns a permutation list of length \!\(\*StyleBox[\"len\", \"TI\"]\)."
PermutationMax::usage = "\!\(\*RowBox[{\"PermutationMax\", \"[\", StyleBox[\"perm\", \"TI\"], \"]\"}]\) returns the largest integer moved by the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
PermutationMin::usage = "\!\(\*RowBox[{\"PermutationMin\", \"[\", StyleBox[\"perm\", \"TI\"], \"]\"}]\) returns the smallest integer moved by the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
PermutationOrder::usage = "\!\(\*RowBox[{\"PermutationOrder\", \"[\", StyleBox[\"perm\", \"TI\"], \"]\"}]\) gives the order of permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
PermutationPower::usage = "\!\(\*RowBox[{\"PermutationPower\", \"[\", RowBox[{StyleBox[\"perm\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) permutation power of the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
PermutationProduct::usage = "\!\(\*RowBox[{\"PermutationProduct\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) gives the product of permutations \!\(\*StyleBox[\"a\", \"TI\"]\), \!\(\*StyleBox[\"b\", \"TI\"]\), \!\(\*StyleBox[\"c\", \"TI\"]\)."
PermutationReplace::usage = "\!\(\*RowBox[{\"PermutationReplace\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"perm\", \"TI\"]}], \"]\"}]\) replaces each part in \!\(\*StyleBox[\"expr\", \"TI\"]\) by its image under the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\).\n\!\(\*RowBox[{\"PermutationReplace\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"gr\", \"TI\"]}], \"]\"}]\) returns the list of images of \!\(\*StyleBox[\"expr\", \"TI\"]\) under all elements of the permutation group \!\(\*StyleBox[\"gr\", \"TI\"]\)."
PermutationSupport::usage = "\!\(\*RowBox[{\"PermutationSupport\", \"[\", StyleBox[\"perm\", \"TI\"], \"]\"}]\) returns the support of the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
Permutations::usage = "\!\(\*RowBox[{\"Permutations\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) generates a list of all possible permutations of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Permutations\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives all permutations containing at most \!\(\*StyleBox[\"n\", \"TI\"]\) elements.\n\!\(\*RowBox[{\"Permutations\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) gives all permutations containing exactly \!\(\*StyleBox[\"n\", \"TI\"]\) elements."
Permute::usage = "\!\(\*RowBox[{\"Permute\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"perm\", \"TI\"]}], \"]\"}]\) permutes the positions of the elements of \!\(\*StyleBox[\"expr\", \"TI\"]\) according to the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\).\n\!\(\*RowBox[{\"Permute\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"gr\", \"TI\"]}], \"]\"}]\) returns the list of permuted forms of \!\(\*StyleBox[\"expr\", \"TI\"]\) under the elements of the permutation group \!\(\*StyleBox[\"gr\", \"TI\"]\)."
PeronaMalikFilter::usage = "\!\(\*RowBox[{\"PeronaMalikFilter\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) applies a Perona\[Dash]Malik diffusion filter to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"PeronaMalikFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) specifies the amount of diffusion time \!\(\*StyleBox[\"t\", \"TI\"]\) to be applied. \n\!\(\*RowBox[{\"PeronaMalikFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) uses a conductance parameter \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"PeronaMalikFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) applies a Gaussian regularization of width \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\) to the image gradient in the conductance function."
PersonData::usage = "\!\(\*RowBox[{\"PersonData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the person \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"PersonData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified person entities.\n\!\(\*RowBox[{\"PersonData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
PERTDistribution::usage = "\!\(\*RowBox[{\"PERTDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents a PERT distribution with range \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\) and mode at \!\(\*StyleBox[\"c\", \"TI\"]\).\n\!\(\*RowBox[{\"PERTDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"]\"}]\) represents a modified PERT distribution with shape parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\)."
PetersenGraph::usage = "\!\(\*RowBox[{\"PetersenGraph\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the generalized Petersen graph \!\(\*SubscriptBox[StyleBox[\"P\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", \" \", StyleBox[\"k\", \"TI\"]}]]\)."
PhaseMargins::usage = "\!\(\*RowBox[{\"PhaseMargins\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) gives the phase margins of the linear time-invariant system \!\(\*StyleBox[\"lsys\", \"TI\"]\)."
PhaseRange::usage = "PhaseRange is an option to BodePlot and NicholsPlot that specifies the phase range."
PhysicalConstants`AccelerationDueToGravity::usage = "AccelerationDueToGravity is the acceleration of a body freely falling in a vacuum on Earth at sea level."
PhysicalConstants`AgeOfUniverse::usage = "AgeOfUniverse is the age of the universe, a physical constant."
PhysicalConstants`AvogadroConstant::usage = "AvogadroConstant is the number of molecules in one mole or gram molecular weight of a substance."
PhysicalConstants`BohrRadius::usage = "BohrRadius is the Bohr radius, an atomic constant."
PhysicalConstants`BoltzmannConstant::usage = "BoltzmannConstant is the ratio of the universal gas constant (MolarGasConstant) to Avogadro's number (AvogadroConstant)."
PhysicalConstants`ClassicalElectronRadius::usage = "ClassicalElectronRadius is the classical electron radius, an atomic constant."
PhysicalConstants`CosmicBackgroundTemperature::usage = "CosmicBackgroundTemperature is the temperature of the cosmic background radiation."
PhysicalConstants`DeuteronMagneticMoment::usage = "DeuteronMagneticMoment is the deuteron magnetic moment."
PhysicalConstants`DeuteronMass::usage = "DeuteronMass is the mass of a deuteron."
PhysicalConstants`EarthMass::usage = "EarthMass is the mass of Earth, a physical constant."
PhysicalConstants`EarthRadius::usage = "EarthRadius is the radius of Earth, a physical constant."
PhysicalConstants`ElectronCharge::usage = "ElectronCharge is the elementary charge on the electron, an electromagnetic constant."
PhysicalConstants`ElectronComptonWavelength::usage = "ElectronComptonWavelength is the electron Compton wavelength."
PhysicalConstants`ElectronGFactor::usage = "ElectronGFactor is the electron g-factor."
PhysicalConstants`ElectronMagneticMoment::usage = "ElectronMagneticMoment is the electron magnetic moment."
PhysicalConstants`ElectronMass::usage = "ElectronMass is the mass of an electron."
PhysicalConstants`FaradayConstant::usage = "FaradayConstant is the product of the Avogadro constant (AvogadroConstant) and the elementary charge (ElectronCharge)."
PhysicalConstants`FineStructureConstant::usage = "FineStructureConstant is the fine structure constant, an atomic constant."
PhysicalConstants`GalacticUnit::usage = "GalacticUnit is the approximate distance of the Sun from the center of the Milky Way Galaxy."
PhysicalConstants`GravitationalConstant::usage = "GravitationalConstant is the coefficient of proportionality in Newton's law of gravitation."
PhysicalConstants`HubbleConstant::usage = "HubbleConstant is a measure of the rate at which the expansion of the universe varies with distance."
PhysicalConstants`IcePoint::usage = "IcePoint is the temperature at which a mixture of air-saturated pure water and pure ice may exist in equilibrium at a pressure of one standard atmosphere."
PhysicalConstants`MagneticFluxQuantum::usage = "MagneticFluxQuantum is magnetic flux quantum, an electromagnetic constant."
PhysicalConstants`MolarGasConstant::usage = "MolarGasConstant is a physico-chemical constant."
PhysicalConstants`MolarVolume::usage = "MolarVolume is the volume occupied by a mole or a gram molecular weight of any gas measured at standard conditions."
PhysicalConstants`MuonGFactor::usage = "MuonGFactor is the muon g-factor."
PhysicalConstants`MuonMagneticMoment::usage = "MuonMagneticMoment is the muon magnetic moment."
PhysicalConstants`MuonMass::usage = "MuonMass is the mass of a muon."
PhysicalConstants`NeutronComptonWavelength::usage = "NeutronComptonWavelength is the neutron Compton wavelength."
PhysicalConstants`NeutronMagneticMoment::usage = "NeutronMagneticMoment is the neutron magnetic moment."
PhysicalConstants`NeutronMass::usage = "NeutronMass is the mass of a neutron."
PhysicalConstants`PlanckConstantReduced::usage = "PlanckConstantReduced is a universal constant, equal to \!\(\*RowBox[{\"PlanckConstant\", \"/\", RowBox[{\"(\", RowBox[{StyleBox[\"2\", \"MR\"], \" \", \"Pi\"}], \")\"}]}]\)."
PhysicalConstants`PlanckConstant::usage = "PlanckConstant is a universal constant of nature that relates the energy of a quantum of radiation to the frequency of the oscillator that emitted it."
PhysicalConstants`PlanckMass::usage = "PlanckMass is a universal constant."
PhysicalConstants`ProtonComptonWavelength::usage = "ProtonComptonWavelength is the proton Compton wavelength."
PhysicalConstants`ProtonMagneticMoment::usage = "ProtonMagneticMoment is the proton magnetic moment."
PhysicalConstants`ProtonMass::usage = "ProtonMass is the mass of a proton."
PhysicalConstants`QuantizedHallConductance::usage = "QuantizedHallConductance is the quantized Hall conductance, an electromagnetic constant."
PhysicalConstants`RydbergConstant::usage = "RydbergConstant is an atomic constant appearing in the Rydberg formula expressing the wavenumbers of the lines in a spectral series."
PhysicalConstants`SackurTetrodeConstant::usage = "SackurTetrodeConstant is the absolute entropy constant, a physico-chemical constant."
PhysicalConstants`SolarConstant::usage = "SolarConstant is the rate at which solar radiation is received outside Earth's atmosphere on a surface normal to the incident radiation and at Earth's mean distance from the Sun."
PhysicalConstants`SolarLuminosity::usage = "SolarLuminosity is a physical constant."
PhysicalConstants`SolarRadius::usage = "SolarRadius is a physical constant."
PhysicalConstants`SolarSchwarzschildRadius::usage = "SolarSchwarzschildRadius is a physical constant."
PhysicalConstants`SpeedOfLight::usage = "SpeedOfLight is the speed of light in a vacuum, a universal constant."
PhysicalConstants`SpeedOfSound::usage = "SpeedOfSound is the speed of sound at sea level in the standard atmosphere."
PhysicalConstants`StefanConstant::usage = "StefanConstant is the Stefan\[Dash]Boltzmann constant, a universal constant of proportionality between the radiant emittance of a black body and the fourth power of the body's absolute temperature."
PhysicalConstants`ThomsonCrossSection::usage = "ThomsonCrossSection is the Thomson cross section, an atomic constant."
PhysicalConstants`VacuumPermeability::usage = "VacuumPermeability is the permeability of vacuum, a universal constant."
PhysicalConstants`VacuumPermittivity::usage = "VacuumPermittivity is the permittivity of vacuum, a universal constant."
PhysicalConstants`WeakMixingAngle::usage = "WeakMixingAngle is a physical constant."
PhysicalSystemData::usage = "\!\(\*RowBox[{\"PhysicalSystemData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the physical system \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"PhysicalSystemData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified physical system entities.\n\!\(\*RowBox[{\"PhysicalSystemData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
Pick::usage = "\!\(\*RowBox[{\"Pick\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"sel\", \"TI\"]}], \"]\"}]\) picks out those elements of \!\(\*StyleBox[\"list\", \"TI\"]\) for which the corresponding element of \!\(\*StyleBox[\"sel\", \"TI\"]\) is True. \n\!\(\*RowBox[{\"Pick\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"sel\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) picks out those elements of \!\(\*StyleBox[\"list\", \"TI\"]\) for which the corresponding element of \!\(\*StyleBox[\"sel\", \"TI\"]\) matches \!\(\*StyleBox[\"patt\", \"TI\"]\). "
PIDData::usage = "\!\(\*RowBox[{\"PIDData\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents PID data generated by PIDTune function."
PIDDerivativeFilter::usage = "PIDDerivativeFilter is an option to PIDTune that controls the filtering used for derivative terms."
PIDFeedforward::usage = "PIDFeedforward is an option to PIDTune that controls the reference weights used for the feedforward filter. "
PIDTune::usage = "\!\(\*RowBox[{\"PIDTune\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) gives a feedback PID controller for the linear time-invariant system \!\(\*StyleBox[\"lsys\", \"TI\"]\). \n\!\(\*RowBox[{\"PIDTune\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"carch\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a controller of architecture \"\!\(\*\nStyleBox[\"carch\", \"TI\"]\)\" (\"P\", \"PI\", \"PID\", etc). \n\!\(\*RowBox[{\"PIDTune\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"carch\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"trule\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}]}], \"]\"}]\) gives a controller using the tuning rule \"\!\(\*\nStyleBox[\"trule\", \"TI\"]\)\". \n\!\(\*RowBox[{\"PIDTune\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value for the property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\". "
PiecewiseExpand::usage = "\!\(\*RowBox[{\"PiecewiseExpand\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands nested piecewise functions in \!\(\*StyleBox[\"expr\", \"TI\"]\) to give a single piecewise function. \n\!\(\*RowBox[{\"PiecewiseExpand\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"assum\", \"TI\"]}], \"]\"}]\) expands piecewise functions using assumptions. \n\!\(\*RowBox[{\"PiecewiseExpand\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"assum\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) does the expansion over the domain \!\(\*StyleBox[\"dom\", \"TI\"]\). "
Piecewise::usage = "\!\(\*RowBox[{\"Piecewise\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cond\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cond\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a piecewise function with values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the regions defined by the conditions \!\(\*SubscriptBox[StyleBox[\"cond\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Piecewise\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cond\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) uses default value \!\(\*StyleBox[\"val\", \"TI\"]\) if none of the \!\(\*SubscriptBox[StyleBox[\"cond\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) apply. The default for \!\(\*StyleBox[\"val\", \"TI\"]\) is 0. "
PieChart3D::usage = "\!\(\*RowBox[{\"PieChart3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D pie chart with sector angle proportional to \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"PieChart3D\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D pie chart with sector features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"PieChart3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D pie chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
PieCharts`PieEdgeStyle::usage = "PieEdgeStyle is an option for PieChart that specifies the styles for lines in the pie chart."
PieCharts`PieExploded::usage = "PieExploded is an option for PieChart that specifies the distance to move wedges outward radially in the pie chart."
PieCharts`PieLabels::usage = "PieLabels is an option for PieChart that specifies the labels on the pie wedges."
PieCharts`PieOrientation::usage = "PieOrientation \:f3b5is an option for PieChart that determines the placement of the first piece of data."
PieCharts`PieStyle::usage = "PieStyle is an option for PieChart that specifies a style for each wedge of the pie chart."
PieChart::usage = "\!\(\*RowBox[{\"PieChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a pie chart with sector angle proportional to \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"PieChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a pie chart with sector features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"PieChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a pie chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
PillaiTraceTest::usage = "\!\(\*RowBox[{\"PillaiTraceTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"PillaiTraceTest\", \"[\", RowBox[{\"\[Ellipsis]\", \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
PillaiTrace::usage = "\!\(\*RowBox[{\"PillaiTrace\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Pillai's trace for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
Pink::usage = "Pink represents the color pink in graphics or style specifications. "
Pi::usage = "Pi is \[Pi], with numerical value \!\(\*RowBox[{\"\[TildeEqual]\", \"3.14159\"}]\). "
Pivoting::usage = "Pivoting is an option to certain matrix decomposition functions. With \!\(\*RowBox[{\"Pivoting\", \" \", \"->\", \" \", \"False\"}]\), no pivoting is done. With \!\(\*RowBox[{\"Pivoting\", \" \", \"->\", \" \", \"True\"}]\), column pivoting is carried out and the list of matrices returned is augmented by the appropriate permutation matrix."
PixelConstrained::usage = "PixelConstrained is an option for ArrayPlot that specifies how to constrain cells to align with displayed pixels."
PixelValuePositions::usage = "\!\(\*RowBox[{\"PixelValuePositions\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) returns a list of pixel positions in \!\(\*StyleBox[\"image\", \"TI\"]\) that match the value \!\(\*StyleBox[\"val\", \"TI\"]\).\n\!\(\*RowBox[{\"PixelValuePositions\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) returns all pixel positions that have values within a distance \!\(\*StyleBox[\"d\", \"TI\"]\) from \!\(\*StyleBox[\"val\", \"TI\"]\)."
PixelValue::usage = "\!\(\*RowBox[{\"PixelValue\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ppos\", \"TI\"]}], \"]\"}]\) gives the pixel value of \!\(\*StyleBox[\"image\", \"TI\"]\) at position \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"PixelValue\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ppos\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the pixel value converted to the specified type."
Placed::usage = "\!\(\*RowBox[{\"Placed\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) represents an expression \!\(\*StyleBox[\"expr\", \"TI\"]\) placed at relative position \!\(\*StyleBox[\"pos\", \"TI\"]\) in a chart or other display. \n\!\(\*RowBox[{\"Placed\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) places each of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at a relative position specified by \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"Placed\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"pos\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to each of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) before displaying it."
PlaceholderReplace::usage = "PlaceholderReplace is an option to Paste that determines whether to replace a selection placeholder with the selected contents."
Placeholder::usage = "\!\(\*RowBox[{\"Placeholder\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) represents a placeholder labeled with \!\(\*StyleBox[\"name\", \"TI\"]\) that indicates a place to type.\n\!\(\*RowBox[{\"Placeholder\", \"[\", \"]\"}]\) gives the empty placeholder \[Placeholder]."
Plain::usage = "Plain represents a font that is not bold, italic, or underlined."
PlanarGraphQ::usage = "\!\(\*RowBox[{\"PlanarGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"g\", \"TI\"]\) is a planar graph and False otherwise."
PlanckRadiationLaw::usage = "\!\(\*RowBox[{\"PlanckRadiationLaw\", \"[\", RowBox[{StyleBox[\"temperature\", \"TI\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"]\"}]\) returns the spectral radiance for the specified temperature and wavelength \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\).\n\!\(\*RowBox[{\"PlanckRadiationLaw\", \"[\", RowBox[{StyleBox[\"temperature\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) returns the spectral radiance for the specified temperature and frequency \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"PlanckRadiationLaw\", \"[\", RowBox[{StyleBox[\"temperature\", \"TI\"], \",\", StyleBox[\"\\\"SpectralPlot\\\"\",ShowStringCharacters->True]}], \"]\"}]\) returns the plot of spectral radiance versus wavelength.\n\!\(\*RowBox[{\"PlanckRadiationLaw\", \"[\", RowBox[{StyleBox[\"temperature\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) returns the integrated result of the spectral radiance over the wavelength range \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"PlanckRadiationLaw\", \"[\", RowBox[{StyleBox[\"temperature\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) returns the integrated result of the spectral radiance over the frequency range \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
PlaneCurveData::usage = "\!\(\*RowBox[{\"PlaneCurveData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the plane curve \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"PlaneCurveData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified plane curve entities.\n\!\(\*RowBox[{\"PlaneCurveData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
PlanetaryMoonData::usage = "\!\(\*RowBox[{\"PlanetaryMoonData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the planetary moon \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"PlanetaryMoonData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified moon entities.\n\!\(\*RowBox[{\"PlanetaryMoonData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the property."
PlanetData::usage = "\!\(\*RowBox[{\"PlanetData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the planet \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"PlanetData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified planet entities.\n\!\(\*RowBox[{\"PlanetData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the property."
PlantData::usage = "\!\(\*RowBox[{\"PlantData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the plant \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"PlantData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified plant entities.\n\!\(\*RowBox[{\"PlantData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the property."
PlayRange::usage = "PlayRange is an option for Play and related functions which specifies what range of sound amplitude levels should be included. "
Play::usage = "\!\(\*RowBox[{\"Play\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) creates an object that plays as a sound whose amplitude is given by \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of time \!\(\*StyleBox[\"t\", \"TI\"]\) in seconds between \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). "
Plot3D::usage = "\!\(\*RowBox[{\"Plot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a three-dimensional plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{\"Plot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots several functions. \n\!\(\*RowBox[{\"Plot3D\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes variables \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\). "
PlotDivision::usage = "PlotDivision is an option for Plot that specifies the maximum amount of subdivision to be used."
PlotJoined::usage = "PlotJoined is an option for ListPlot that specifies whether the points plotted should be joined by a line. "
PlotLabel::usage = "PlotLabel is an option for graphics functions that specifies an overall label for a plot. "
PlotLayout::usage = "PlotLayout is an option used by WaveletListPlot and similar functions to specify the layout of multiple plots."
PlotLegends`LegendBackground::usage = "LegendBackground is an option for Legend that specifies the style of background to use with a legend. "
PlotLegends`LegendBorderSpace::usage = "LegendBorderSpace is an option for Legend that sets the space around the entire set of key boxes and text in the legend."
PlotLegends`LegendBorder::usage = "LegendBorder is an option for Legend that specifies the style of the line surrounding key boxes and text in a legend."
PlotLegends`LegendLabelSpace::usage = "LegendLabelSpace is an option for Legend that specifies the space for LegendLabel. "
PlotLegends`LegendOrientation::usage = "LegendOrientation is an option for Legend that specifies the direction in which key boxes are laid out. "
PlotLegends`LegendPosition::usage = "LegendPosition is an option for Legend that specifies the location of the lower-left corner of a legend box. "
PlotLegends`LegendShadow::usage = "LegendShadow is an option for Legend that specifies the shadowing drawn around the legend."
PlotLegends`LegendSize::usage = "LegendSize is an option for Legend that specifies the size of a legend box."
PlotLegends`LegendSpacing::usage = "LegendSpacing is an option for Legend that specifies the amount of space around each key box on a scale where the box is 1."
PlotLegends`LegendTextDirection::usage = "LegendTextDirection is an option for Legend that specifies the direction of text next to the key box. "
PlotLegends`LegendTextOffset::usage = "LegendTextOffset is an option for Legend that specifies the offset of text next to the key box."
PlotLegends`LegendTextSpace::usage = "LegendTextSpace is an option for Legend that specifies the space in the legend box for text."
PlotLegends`Legend::usage = "\!\(\*RowBox[{\"Legend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"text\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) generates a legend with the specified boxes and text.\n\!\(\*RowBox[{\"Legend\", \"[\", RowBox[{StyleBox[\"func\", \"TI\"], \",\", StyleBox[\"num\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) generates a legend by applying \!\(\*StyleBox[\"func\", \"TI\"]\) to numbers between 0 and 1, incremented by the number of boxes \!\(\*RowBox[{StyleBox[\"num\", \"TI\"], \"-\", StyleBox[\"1\", \"TR\"]}]\).\n\!\(\*RowBox[{\"Legend\", \"[\", RowBox[{StyleBox[\"func\", \"TI\"], \",\", StyleBox[\"num\", \"TI\"], \",\", StyleBox[\"mintext\", \"TI\"], \",\", StyleBox[\"maxtext\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) labels the first and last boxes with \!\(\*StyleBox[\"mintext\", \"TI\"]\) and \!\(\*StyleBox[\"maxtext\", \"TI\"]\), respectively."
PlotLegends`PlotLegend::usage = "PlotLegend is an option for Plot, ListPlot, and related functions that assigns text to lines in a 2D plot to create a legend for that plot. "
PlotLegends`ShadowBackground::usage = "ShadowBackground is an option for ShadowBox or Legend that specifies the style for a drop shadow. "
PlotLegends`ShadowBorder::usage = "ShadowBorder is an option for ShadowBox that specifies the style of the border around the rectangle above a shadow. "
PlotLegends`ShadowBox::usage = "\!\(\*RowBox[{ShadowBox, \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"xlength\", \"TI\"], \",\", StyleBox[\"ylength\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) generates a box with a drop shadow."
PlotLegends`ShadowForeground::usage = "ShadowForeground is an option for ShadowBox that specifies a style for the foreground of a shadow box. "
PlotLegends`ShadowOffset::usage = "ShadowOffset is an option for ShadowBox that sets the offset of a shadow from the rest of the box. "
PlotLegends`ShowLegend::usage = "\!\(\*RowBox[{\"ShowLegend\", \"[\", RowBox[{StyleBox[\"graphics\", \"TI\"], \",\", SubscriptBox[StyleBox[\"legend\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"legend\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) places the \!\(\*SubscriptBox[StyleBox[\"legend\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"legend\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] in the given graphic \!\(\*StyleBox[\"graphics\", \"TI\"]\)."
PlotLegends::usage = "PlotLegends is an option for plot functions that specifies what legends to use. "
PlotMarkers::usage = "PlotMarkers is an option for graphics functions like ListPlot and ListLinePlot that specifies what markers to draw at the points plotted. "
PlotPoints::usage = "PlotPoints is an option for plotting functions that specifies how many initial sample points to use. "
PlotRangeClipping::usage = "PlotRangeClipping is an option for graphics functions that specifies whether graphics objects should be clipped at the edge of the region defined by PlotRange, or should be allowed to extend to the actual edge of the image. "
PlotRangePadding::usage = "PlotRangePadding is an option for graphics functions that specifies how much further axes etc. should extend beyond the range of coordinates specified by PlotRange. "
PlotRange::usage = "PlotRange is an option for graphics functions that specifies what range of coordinates to include in a plot. "
PlotRegion::usage = "PlotRegion is an option for graphics functions that specifies what region of the final display area a plot should fill. "
PlotStyle::usage = "PlotStyle is an option for plotting and related functions that specifies styles in which objects are to be drawn. "
PlotTheme::usage = "PlotTheme is an option for plotting and related functions that specifies an overall theme for visualization elements and styles. "
Plot::usage = "\!\(\*RowBox[{\"Plot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"Plot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots several functions \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Plot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", StyleBox[\"x\", \"TI\"], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes the variable \!\(\*StyleBox[\"x\", \"TI\"]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
Pluralize::usage = "\!\(\*RowBox[{\"Pluralize\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"noun\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the plural form of the English word \"noun\".\n\!\(\*RowBox[{\"Pluralize\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"noun\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the inflected form of \"\!\(\*\nStyleBox[\"noun\", \"TI\"]\)\" for \!\(\*StyleBox[\"n\", \"TI\"]\) instances. \n\!\(\*RowBox[{\"Pluralize\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"singular\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"plural\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) inflects using the specified forms.\n\!\(\*RowBox[{\"Pluralize\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) uses the length of \!\(\*StyleBox[\"list\", \"TI\"]\) to determine the inflection to use. "
PlusMinus::usage = "\!\(\*RowBox[{\"PlusMinus\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) displays as \!\(\*RowBox[{\"\[PlusMinus]\", StyleBox[\"x\", \"TI\"]}]\).\n\!\(\*RowBox[{\"PlusMinus\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"\[PlusMinus]\", StyleBox[\"y\", \"TI\"]}], \"\[PlusMinus]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Plus::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"+\", StyleBox[\"y\", \"TI\"], \"+\", StyleBox[\"z\", \"TI\"]}]\) represents a sum of terms. "
Pochhammer::usage = "\!\(\*RowBox[{\"Pochhammer\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the Pochhammer symbol \!\(\*SubscriptBox[RowBox[{\"(\", StyleBox[\"a\", \"TI\"], \")\"}], StyleBox[\"n\", \"TI\"]]\). "
PodStates::usage = "PodStates is an option for WolframAlpha that determines information about the states of the pods."
PodWidth::usage = "PodWidth is an option for WolframAlpha that determines the width parameters of the content returned by the Wolfram|Alpha API."
Point3DBoxOptions::usage = "\!\(\*RowBox[{Point3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for Point3DBox objects."
PointBoxOptions::usage = "\!\(\*RowBox[{PointBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for PointBox objects."
PointFigureChart::usage = "\!\(\*RowBox[{\"PointFigureChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a point and figure chart with prices \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at date \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"PointFigureChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"daterange\", \"TI\"]}], \"}\"}], \"]\"}]\) makes a point and figure chart of closing prices for the financial entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" over the date range \!\(\*StyleBox[\"daterange\", \"TI\"]\).\n\!\(\*RowBox[{\"PointFigureChart\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) makes a point and figure chart with point and figure height \!\(\*StyleBox[\"s\", \"TI\"]\) and \!\(\*StyleBox[\"n\", \"TI\"]\) reversals."
PointForm::usage = "\!\(\*RowBox[{\"PointForm\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) is a three-dimensional graphics directive that specifies that points are to be drawn with the graphics directive \!\(\*StyleBox[\"g\", \"TI\"]\) or the list of graphics directives \!\(\*StyleBox[\"g\", \"TI\"]\)."
PointLegend::usage = "\!\(\*RowBox[{\"PointLegend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates a legend that associates points of colors \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"PointLegend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"Automatic\"}], \"]\"}]\) generates a legend with placeholder labels for the colors \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"PointLegend\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a legend with inherited colors within visualization functions."
PointSize::usage = "\!\(\*RowBox[{\"PointSize\", \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that points which follow are to be shown if possible as circular regions with diameter \!\(\*StyleBox[\"d\", \"TI\"]\). The diameter \!\(\*StyleBox[\"d\", \"TI\"]\) is given as a fraction of the total width of the plot. "
Point::usage = "\!\(\*RowBox[{\"Point\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) is a graphics and geometry primitive that represents a point at \!\(\*StyleBox[\"p\", \"TI\"]\). \n\!\(\*RowBox[{\"Point\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a collection of points. "
PoissonConsulDistribution::usage = "\!\(\*RowBox[{\"PoissonConsulDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Lambda]\", \"TR\"]}], \"]\"}]\) represents a Poisson\[Dash]Consul distribution with parameters \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\)."
PoissonDistribution::usage = "\!\(\*RowBox[{\"PoissonDistribution\", \"[\", StyleBox[\"\[Mu]\", \"TR\"], \"]\"}]\) represents a Poisson distribution with mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
PoissonProcess::usage = "\!\(\*RowBox[{\"PoissonProcess\", \"[\", StyleBox[\"\[Mu]\", \"TR\"], \"]\"}]\) represents a Poisson process with rate \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
PoissonWindow::usage = "\!\(\*RowBox[{\"PoissonWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Poisson window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"PoissonWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
PolarAxesOrigin::usage = "PolarAxesOrigin is an option for sector charts and polar plots that specifies where polar axes should be drawn."
PolarAxes::usage = "PolarAxes is an option for sector charts and polar plots that specifies whether polar axes should be drawn."
PolarGridLines::usage = "PolarGridLines is an option for sector charts and polar plots that specifies polar grid lines."
PolarPlot::usage = "\!\(\*RowBox[{\"PolarPlot\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a polar plot of a curve with radius \!\(\*StyleBox[\"r\", \"TI\"]\) as a function of angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\).\n\!\(\*RowBox[{\"PolarPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) makes a polar plot of curves with radius functions \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
PolarTicks::usage = "PolarTicks is an option for sector charts and polar plots that specifies tick marks for polar axes."
PoleZeroMarkers::usage = "PoleZeroMarkers is an option for RootLocusPlot that specifies the markers to be drawn on the complex plane at the open-loop poles, closed-loop poles, and open-loop zeros."
PolyaAeppliDistribution::usage = "\!\(\*RowBox[{\"PolyaAeppliDistribution\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents a Polya\[Dash]Aeppli distribution with shape parameters \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) and \!\(\*StyleBox[\"p\", \"TI\"]\). "
PolyGamma::usage = "\!\(\*RowBox[{\"PolyGamma\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the digamma function \!\(\*RowBox[{\"\[Psi]\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"PolyGamma\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative of the digamma function \!\(\*RowBox[{SuperscriptBox[\"\[Psi]\", RowBox[{\"(\", StyleBox[\"n\", \"TI\"], \")\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
Polygon3DBoxOptions::usage = "\!\(\*RowBox[{Polygon3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for Polygon3DBox objects."
PolygonBoxOptions::usage = "\!\(\*RowBox[{PolygonBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for PolygonBox objects."
PolygonIntersections::usage = "PolygonIntersections is an option for Graphics3D which specifies whether intersecting polygons should be left unchanged. "
Polygon::usage = "\!\(\*RowBox[{\"Polygon\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents a filled polygon with points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Polygon\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a collection of polygons. "
PolyhedronData::usage = "\!\(\*RowBox[{\"PolyhedronData\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the polyhedron named \!\(\*StyleBox[\"poly\", \"TI\"]\).\n\!\(\*RowBox[{\"PolyhedronData\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) gives an image of the polyhedron named \!\(\*StyleBox[\"poly\", \"TI\"]\).\n\!\(\*RowBox[{\"PolyhedronData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"class\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the polyhedra in the specified class."
PolyhedronOperations`Geodesate::usage = "\!\(\*RowBox[{\"Geodesate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) replaces each polygon in graphics expression \!\(\*StyleBox[\"expr\", \"TI\"]\) by the projection onto the circumscribed sphere of the order-\!\(\*StyleBox[\"n\", \"TI\"]\) regular tessellation of that polygon.\n\!\(\*RowBox[{\"Geodesate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"radius\", \"TI\"]}], \"]\"}]\) does the projection onto the sphere of radius \!\(\*StyleBox[\"radius\", \"TI\"]\) centered at \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}]\)."
PolyhedronOperations`OpenTruncate::usage = "\!\(\*RowBox[{\"OpenTruncate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) truncates each edge of each polygon in graphics expression \!\(\*StyleBox[\"expr\", \"TI\"]\) without filling in with a polygon.\n\!\(\*RowBox[{\"OpenTruncate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"ratio\", \"TI\"]}], \"]\"}]\) truncates to the specified \!\(\*StyleBox[\"ratio\", \"TI\"]\) of the edge length."
PolyhedronOperations`Stellate::usage = "\!\(\*RowBox[{\"Stellate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) replaces each polygon in graphics expression \!\(\*StyleBox[\"expr\", \"TI\"]\) by a pyramid, with the polygon as its base.\n\!\(\*RowBox[{\"Stellate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"ratio\", \"TI\"]}], \"]\"}]\) uses a stellation ratio \!\(\*StyleBox[\"ratio\", \"TI\"]\)."
PolyhedronOperations`Truncate::usage = "\!\(\*RowBox[{\"Truncate\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) truncates each edge of each polygon in graphics expression \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"Truncate\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"ratio\", \"TI\"]}], \"]\"}]\) truncates to the specified \!\(\*StyleBox[\"ratio\", \"TI\"]\) of the edge length."
PolyLog::usage = "\!\(\*RowBox[{\"PolyLog\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the polylogarithm function \!\(\*RowBox[{SubscriptBox[\"Li\", StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"PolyLog\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Nielsen generalized polylogarithm function \!\(\*RowBox[{SubscriptBox[StyleBox[\"S\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
PolynomialExtendedGCD::usage = "\!\(\*RowBox[{\"PolynomialExtendedGCD\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the extended GCD of \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) treated as univariate polynomials in \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"PolynomialExtendedGCD\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) gives the extended GCD over the integers mod prime \!\(\*StyleBox[\"p\", \"TI\"]\)."
PolynomialGCD::usage = "\!\(\*RowBox[{\"PolynomialGCD\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the greatest common divisor of the polynomials \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"PolynomialGCD\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) evaluates the GCD modulo the prime \!\(\*StyleBox[\"p\", \"TI\"]\). "
PolynomialLCM::usage = "\!\(\*RowBox[{\"PolynomialLCM\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the least common multiple of the polynomials \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"PolynomialLCM\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) evaluates the LCM modulo the prime \!\(\*StyleBox[\"p\", \"TI\"]\). "
PolynomialMod::usage = "\!\(\*RowBox[{\"PolynomialMod\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the polynomial \!\(\*StyleBox[\"poly\", \"TI\"]\) reduced modulo \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"PolynomialMod\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reduces modulo all of the \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
PolynomialQuotientRemainder::usage = "\!\(\*RowBox[{\"PolynomialQuotientRemainder\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a list of the quotient and remainder of \!\(\*StyleBox[\"p\", \"TI\"]\) and \!\(\*StyleBox[\"q\", \"TI\"]\), treated as polynomials in \!\(\*StyleBox[\"x\", \"TI\"]\). "
PolynomialQuotient::usage = "\!\(\*RowBox[{\"PolynomialQuotient\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the quotient of \!\(\*StyleBox[\"p\", \"TI\"]\) and \!\(\*StyleBox[\"q\", \"TI\"]\), treated as polynomials in \!\(\*StyleBox[\"x\", \"TI\"]\), with any remainder dropped. "
PolynomialQ::usage = "\!\(\*RowBox[{\"PolynomialQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) yields True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a polynomial in \!\(\*StyleBox[\"var\", \"TI\"]\), and yields False otherwise. \n\!\(\*RowBox[{\"PolynomialQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"expr\", \"TI\"]\) is a polynomial in the \!\(\*SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
PolynomialReduce::usage = "\!\(\*RowBox[{\"PolynomialReduce\", \"[\", RowBox[{StyleBox[\"poly\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields a list representing a reduction of \!\(\*StyleBox[\"poly\", \"TI\"]\) in terms of the \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). The list has the form \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}]\), where \!\(\*StyleBox[\"b\", \"TI\"]\) is minimal and \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \" \", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"+\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \" \", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"+\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"+\", StyleBox[\"b\", \"TI\"]}]\) is exactly \!\(\*StyleBox[\"poly\", \"TI\"]\). "
PolynomialRemainder::usage = "\!\(\*RowBox[{\"PolynomialRemainder\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the remainder from dividing \!\(\*StyleBox[\"p\", \"TI\"]\) by \!\(\*StyleBox[\"q\", \"TI\"]\), treated as polynomials in \!\(\*StyleBox[\"x\", \"TI\"]\). "
Polynomials::usage = "\!\(\*RowBox[{\"Polynomials\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the domain of polynomials in \!\(\*StyleBox[\"x\", \"TI\"]\)."
Polytopes`CircumscribedRadius::usage = "\!\(\*RowBox[{\"CircumscribedRadius\", \"[\", StyleBox[\"polygon\", \"TI\"], \"]\"}]\) gives the radius of a circumscribed circle of polygon \!\(\*StyleBox[\"polygon\", \"TI\"]\), when the edges of \!\(\*StyleBox[\"polygon\", \"TI\"]\) have unit length."
Polytopes`Decagon::usage = "Decagon is a regular polygon with 10 edges, for use with polytope functions."
Polytopes`Digon::usage = "Digon is a regular polygon with two edges, for use with polytope functions."
Polytopes`Dodecagon::usage = "Dodecagon is a regular polygon with 12 edges, for use with polytope functions."
Polytopes`Faces::usage = "\!\(\*RowBox[{\"Faces\", \"[\", StyleBox[\"polytope\", \"TI\"], \"]\"}]\) gives a list of the faces of \!\(\*StyleBox[\"polytope\", \"TI\"]\). "
Polytopes`Heptagon::usage = "Heptagon is a regular polygon with seven edges, for use with polytope functions."
Polytopes`Hexagon::usage = "Hexagon is a regular polygon with six edges, for use with polytope functions."
Polytopes`InscribedRadius::usage = "\!\(\*RowBox[{\"InscribedRadius\", \"[\", StyleBox[\"polygon\", \"TI\"], \"]\"}]\) gives the radius of an inscribed circle of polygon \!\(\*StyleBox[\"polygon\", \"TI\"]\), when the edges of \!\(\*StyleBox[\"polygon\", \"TI\"]\) have unit length."
Polytopes`Nonagon::usage = "Nonagon is a regular polygon with nine edges, for use with polytope functions."
Polytopes`NumberOfEdges::usage = "\!\(\*RowBox[{\"NumberOfEdges\", \"[\", StyleBox[\"polytope\", \"TI\"], \"]\"}]\) gives the number of edges of \!\(\*StyleBox[\"polytope\", \"TI\"]\)."
Polytopes`NumberOfFaces::usage = "\!\(\*RowBox[{\"NumberOfFaces\", \"[\", StyleBox[\"polytope\", \"TI\"], \"]\"}]\) gives the number of faces of \!\(\*StyleBox[\"polytope\", \"TI\"]\)."
Polytopes`NumberOfVertices::usage = "\!\(\*RowBox[{\"NumberOfVertices\", \"[\", StyleBox[\"polytope\", \"TI\"], \"]\"}]\) gives the number of vertices of \!\(\*StyleBox[\"polytope\", \"TI\"]\)."
Polytopes`Octagon::usage = "Octagon is a regular polygon with eight edges, for use with polytope functions."
Polytopes`Pentagon::usage = "Pentagon is a regular polygon with five edges, for use with polytope functions."
Polytopes`Undecagon::usage = "Undecagon is a regular polygon with 11 edges, for use with polytope functions."
PopupMenuBoxOptions::usage = "\!\(\*RowBox[{PopupMenuBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for PopupMenuBox objects."
PopupMenu::usage = "\!\(\*RowBox[{\"PopupMenu\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a popup menu with setting \!\(\*StyleBox[\"x\", \"TI\"]\) and possible values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"PopupMenu\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being reset every time an item is selected from the menu. \n\!\(\*RowBox[{\"PopupMenu\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a popup menu in which possible value \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is indicated by \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"PopupMenu\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dlbl\", \"TI\"]}], \"]\"}]\) displays the menu item as \!\(\*StyleBox[\"dlbl\", \"TI\"]\) if \!\(\*StyleBox[\"x\", \"TI\"]\) is none of the \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"PopupMenu\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", StyleBox[\"dlbl\", \"TI\"], \",\", StyleBox[\"base\", \"TI\"]}], \"]\"}]\) displays as \!\(\*StyleBox[\"base\", \"TI\"]\) when it is not being clicked. "
PopupView::usage = "\!\(\*RowBox[{\"PopupView\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an object which displays as a popup menu whose items are the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"PopupView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) makes the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) entry be the one currently chosen.\n\!\(\*RowBox[{\"PopupView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"base\", \"TI\"]}], \"]\"}]\) displays as \!\(\*StyleBox[\"base\", \"TI\"]\) if it is not being clicked."
PopupWindow::usage = "\!\(\*RowBox[{\"PopupWindow\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"contents\", \"TI\"]}], \"]\"}]\) displays as \!\(\*StyleBox[\"expr\", \"TI\"]\), but pops up a window containing \!\(\*StyleBox[\"contents\", \"TI\"]\) when clicked."
PositionIndex::usage = "\!\(\*RowBox[{\"PositionIndex\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives an association between unique elements in \!\(\*StyleBox[\"list\", \"TI\"]\) and the positions at which they occur.\n\!\(\*RowBox[{\"PositionIndex\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) gives an association whose keys are the distinct values in \!\(\*StyleBox[\"assoc\", \"TI\"]\), and whose values are lists of the keys with which they are associated."
Position::usage = "\!\(\*RowBox[{\"Position\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) gives a list of the positions at which objects matching \!\(\*StyleBox[\"pattern\", \"TI\"]\) appear in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Position\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) finds only objects that appear on levels specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"Position\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the positions of the first \!\(\*StyleBox[\"n\", \"TI\"]\) objects found. \n\!\(\*RowBox[{\"Position\", \"[\", StyleBox[\"pattern\", \"TI\"], \"]\"}]\) represents an operator form of Position that can be applied to an expression."
PositiveDefiniteMatrixQ::usage = "\!\(\*RowBox[{\"PositiveDefiniteMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly positive definite, and False otherwise. "
PositiveSemidefiniteMatrixQ::usage = "\!\(\*RowBox[{\"PositiveSemidefiniteMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly positive semidefinite, and False otherwise. "
Positive::usage = "\!\(\*RowBox[{\"Positive\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"x\", \"TI\"]\) is a positive number. "
PossibleZeroQ::usage = "\!\(\*RowBox[{\"PossibleZeroQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if basic symbolic and numerical methods suggest that \!\(\*StyleBox[\"expr\", \"TI\"]\) has value zero, and gives False otherwise. "
Postfix::usage = "\!\(\*RowBox[{\"Postfix\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}], \"]\"}]\) prints with \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) given in default postfix form: \!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"//\", StyleBox[\"f\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Postfix\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) prints as \!\(\*StyleBox[\"exprh\", \"TI\"]\). "
PowerDistribution::usage = "\!\(\*RowBox[{\"PowerDistribution\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) represents a power distribution with domain parameter \!\(\*StyleBox[\"k\", \"TI\"]\) and shape parameter \!\(\*StyleBox[\"a\", \"TI\"]\)."
PowerExpand::usage = "\!\(\*RowBox[{\"PowerExpand\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands all powers of products and powers. \n\!\(\*RowBox[{\"PowerExpand\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) expands only with respect to the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
PowerModList::usage = "\!\(\*RowBox[{\"PowerModList\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", RowBox[{StyleBox[\"s\", \"TI\"], \"/\", StyleBox[\"r\", \"TI\"]}], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives a list of all \!\(\*StyleBox[\"x\", \"TI\"]\) modulo \!\(\*StyleBox[\"m\", \"TI\"]\) for which \!\(\*RowBox[{SuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"r\", \"TI\"]], \"\[Congruent]\", SuperscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"s\", \"TI\"]]}]\) mod \!\(\*StyleBox[\"m\", \"TI\"]\)."
PowerMod::usage = "\!\(\*RowBox[{\"PowerMod\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives \!\(\*RowBox[{SuperscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"b\", \"TI\"]], \" \", \"mod\", \" \", StyleBox[\"m\", \"TI\"]}]\). \n\!\(\*RowBox[{\"PowerMod\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", RowBox[{\"-\", \"1\"}], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) finds the modular inverse of \!\(\*StyleBox[\"a\", \"TI\"]\) modulo \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"PowerMod\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", RowBox[{\"1\", \"/\", StyleBox[\"r\", \"TI\"]}], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) finds a modular \!\(\*StyleBox[\"r\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) root of \!\(\*StyleBox[\"a\", \"TI\"]\)."
PowerRange::usage = "\!\(\*RowBox[{\"PowerRange\", \"[\", StyleBox[\"b\", \"TI\"], \"]\"}]\) generates the list \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"10\", \",\", \"100\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]\), where \!\(\*StyleBox[\"max\", \"TI\"]\) is the largest power of 10 that does not exceed \!\(\*StyleBox[\"b\", \"TI\"]\).\n\!\(\*RowBox[{\"PowerRange\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) generates the list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", RowBox[{\"10\", StyleBox[\"a\", \"TI\"]}], \",\", RowBox[{\"100\", StyleBox[\"a\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]\), with successive elements increasing by factors of 10. \n\!\(\*RowBox[{\"PowerRange\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) uses factors of \!\(\*StyleBox[\"r\", \"TI\"]\) instead of 10."
PowerSpectralDensity::usage = "\!\(\*RowBox[{\"PowerSpectralDensity\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) estimates the power spectral density for \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"PowerSpectralDensity\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"], \",\", StyleBox[\"sspec\", \"TI\"]}], \"]\"}]\) estimates the power spectral density for \!\(\*StyleBox[\"data\", \"TI\"]\) with smoothing specification \!\(\*StyleBox[\"sspec\", \"TI\"]\).\n\!\(\*RowBox[{\"PowerSpectralDensity\", \"[\", RowBox[{StyleBox[\"tproc\", \"TI\"], \",\", StyleBox[\"\[Omega]\", \"TR\"]}], \"]\"}]\) represents the power spectral density of a time series process \!\(\*StyleBox[\"tproc\", \"TI\"]\)."
PowersRepresentations::usage = "\!\(\*RowBox[{\"PowersRepresentations\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the distinct representations of the integer \!\(\*StyleBox[\"n\", \"TI\"]\) as a sum of \!\(\*StyleBox[\"k\", \"TI\"]\) non-negative \!\(\*StyleBox[\"p\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) integer powers."
PowerSymmetricPolynomial::usage = "\!\(\*RowBox[{\"PowerSymmetricPolynomial\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) represents a formal power symmetric polynomial with exponent \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"PowerSymmetricPolynomial\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a multivariate formal power symmetric polynomial with exponents \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\).\n\!\(\*RowBox[{\"PowerSymmetricPolynomial\", \"[\", StyleBox[RowBox[{\"rspec\", \",\", \"data\"}], \"TI\"], \"]\"}]\) gives the power symmetric polynomial in \!\(\*StyleBox[\"data\", \"TI\"]\). "
Power::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"^\", StyleBox[\"y\", \"TI\"]}]\) gives \!\(\*StyleBox[\"x\", \"TI\"]\) to the power \!\(\*StyleBox[\"y\", \"TI\"]\)."
PrecedenceForm::usage = "\!\(\*RowBox[{\"PrecedenceForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"prec\", \"TI\"]}], \"]\"}]\) prints with \!\(\*StyleBox[\"expr\", \"TI\"]\) parenthesized as it would be if it contained an operator with precedence \!\(\*StyleBox[\"prec\", \"TI\"]\). "
PrecedesEqual::usage = "\!\(\*RowBox[{\"PrecedesEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[PrecedesEqual]\", StyleBox[\"y\", \"TI\"], \"\[PrecedesEqual]\", \"\[Ellipsis]\"}]\)."
PrecedesSlantEqual::usage = "\!\(\*RowBox[{\"PrecedesSlantEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[PrecedesSlantEqual]\", StyleBox[\"y\", \"TI\"], \"\[PrecedesSlantEqual]\", \"\[Ellipsis]\"}]\)."
PrecedesTilde::usage = "\!\(\*RowBox[{\"PrecedesTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[PrecedesTilde]\", StyleBox[\"y\", \"TI\"], \"\[PrecedesTilde]\", \"\[Ellipsis]\"}]\)."
Precedes::usage = "\!\(\*RowBox[{\"Precedes\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Precedes]\", StyleBox[\"y\", \"TI\"], \"\[Precedes]\", \"\[Ellipsis]\"}]\)."
PrecisionGoal::usage = "PrecisionGoal is an option for various numerical operations which specifies how many effective digits of precision should be sought in the final result. "
Precision::usage = "\!\(\*RowBox[{\"Precision\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the effective number of digits of precision in the number \!\(\*StyleBox[\"x\", \"TI\"]\). "
PreDecrement::usage = "\!\(\*RowBox[{\"--\", StyleBox[\"x\", \"TI\"]}]\) decreases the value of \!\(\*StyleBox[\"x\", \"TI\"]\) by 1, returning the new value of \!\(\*StyleBox[\"x\", \"TI\"]\). "
PredictorFunction::usage = "\!\(\*RowBox[{\"PredictorFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents a function generated by Predict that classifies data into classes."
PredictorInformation::usage = "\!\(\*RowBox[{\"PredictorInformation\", \"[\", StyleBox[\"predictor\", \"TI\"], \"]\"}]\) generates a report giving information on the predictor function \!\(\*StyleBox[\"predictor\", \"TI\"]\).\n\!\(\*RowBox[{\"PredictorInformation\", \"[\", RowBox[{StyleBox[\"predictor\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives information for \!\(\*StyleBox[\"predictor\", \"TI\"]\) associated with property \!\(\*StyleBox[\"prop\", \"TI\"]\)."
PredictorMeasurementsObject::usage = "\!\(\*RowBox[{\"PredictorMeasurementsObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents an object generated by PredictorMeasurements that can be applied to properties."
PredictorMeasurements::usage = "\!\(\*RowBox[{\"PredictorMeasurements\", \"[\", RowBox[{StyleBox[\"predictor\", \"TI\"], \",\", StyleBox[\"testset\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives measurements associated with the property \!\(\*StyleBox[\"prop\", \"TI\"]\) when \!\(\*StyleBox[\"predictor\", \"TI\"]\) is evaluated on \!\(\*StyleBox[\"testset\", \"TI\"]\).\n\!\(\*RowBox[{\"PredictorMeasurements\", \"[\", RowBox[{StyleBox[\"predictor\", \"TI\"], \",\", StyleBox[\"testset\", \"TI\"]}], \"]\"}]\) yields a \!\(\*RowBox[{\"PredictorMeasurementsObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied to any property."
Predict::usage = "\!\(\*RowBox[{\"Predict\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a \!\(\*RowBox[{\"PredictorFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) based on the example input-output pairs given.\n\!\(\*RowBox[{\"Predict\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates the same result.\n\!\(\*RowBox[{\"Predict\", \"[\", RowBox[{StyleBox[\"training\", \"TI\"], \",\", StyleBox[\"input\", \"TI\"]}], \"]\"}]\) attempts to predict the output associated with \!\(\*StyleBox[\"input\", \"TI\"]\) from the training examples given.\n\!\(\*RowBox[{\"Predict\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"input\", \"TI\"]}], \"]\"}]\) uses the built-in predictor function represented by \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"Predict\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"input\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"]}], \"]\"}]\) gives the specified property of the prediction associated with \!\(\*StyleBox[\"input\", \"TI\"]\)."
PreemptProtect::usage = "\!\(\*RowBox[{\"PreemptProtect\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), without any interruption from preemptive evaluations."
PreferencesPath::usage = "PreferencesPath is a global option that specifies which directories are searched for user-specific settings when \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) is started."
Prefix::usage = "\!\(\*RowBox[{\"Prefix\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}], \"]\"}]\) prints with \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) given in default prefix form: \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"@\", StyleBox[\"expr\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Prefix\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) prints as \!\(\*StyleBox[\"hexpr\", \"TI\"]\). "
PreIncrement::usage = "\!\(\*RowBox[{\"++\", StyleBox[\"x\", \"TI\"]}]\) increases the value of \!\(\*StyleBox[\"x\", \"TI\"]\) by 1, returning the new value of \!\(\*StyleBox[\"x\", \"TI\"]\). "
PrependTo::usage = "\!\(\*RowBox[{\"PrependTo\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"]}], \"]\"}]\) prepends \!\(\*StyleBox[\"elem\", \"TI\"]\) to the value of \!\(\*StyleBox[\"s\", \"TI\"]\), and resets \!\(\*StyleBox[\"s\", \"TI\"]\) to the result. "
Prepend::usage = "\!\(\*RowBox[{\"Prepend\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"expr\", \"TI\"]\) with \!\(\*StyleBox[\"elem\", \"TI\"]\) prepended. \n\!\(\*RowBox[{\"Prepend\", \"[\", StyleBox[\"elem\", \"TI\"], \"]\"}]\) represents an operator form of Prepend that can be applied to an expression."
PreserveImageOptions::usage = "PreserveImageOptions is an option to graphics and related functions that specifies whether image size and certain other options should be preserved from the previous version of a graphic if the graphic is replaced by a new one in output."
PreviousCell::usage = "\!\(\*RowBox[{\"PreviousCell\", \"[\", \"]\"}]\) returns the CellObject corresponding to the cell directly above the currently evaluating cell.\n\!\(\*RowBox[{\"PreviousCell\", \"[\", StyleBox[\"cellobj\", \"TI\"], \"]\"}]\) starts looking from the given cell."
PriceGraphDistribution::usage = "\!\(\*RowBox[{\"PriceGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) represents a de Solla Price graph distribution for \!\(\*StyleBox[\"n\", \"TI\"]\)-vertex graphs where a new vertex with \!\(\*StyleBox[\"k\", \"TI\"]\) edges is added at each step, using attractiveness parameter \!\(\*StyleBox[\"a\", \"TI\"]\)."
PrimalityProving`PrimeQCertificateCheck::usage = "\!\(\*RowBox[{\"PrimeQCertificateCheck\", \"[\", RowBox[{StyleBox[\"cert\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives True if \!\(\*StyleBox[\"cert\", \"TI\"]\) is a valid certificate for the primality or compositeness of \!\(\*StyleBox[\"n\", \"TI\"]\), and False otherwise."
PrimalityProving`PrimeQCertificate::usage = "\!\(\*RowBox[{\"PrimeQCertificate\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a certificate that \!\(\*StyleBox[\"n\", \"TI\"]\) is prime or that \!\(\*StyleBox[\"n\", \"TI\"]\) is composite."
PrimalityProving`ProvablePrimeQ::usage = "\!\(\*RowBox[{\"ProvablePrimeQ\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"n\", \"TI\"]\) is provably prime, and False otherwise."
PrimeNu::usage = "\!\(\*RowBox[{\"PrimeNu\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number of distinct primes \!\(\*RowBox[{\"\[Nu]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\) in \!\(\*StyleBox[\"n\", \"TI\"]\)."
PrimeOmega::usage = "\!\(\*RowBox[{\"PrimeOmega\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number of prime factors counting multiplicities \!\(\*RowBox[{\"\[CapitalOmega]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\) in \!\(\*StyleBox[\"n\", \"TI\"]\)."
PrimePi::usage = "\!\(\*RowBox[{\"PrimePi\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the number of primes \!\(\*RowBox[{StyleBox[\"\[Pi]\", \"TR\"], RowBox[{\"(\", StyleBox[\"x\", \"TI\"], \")\"}]}]\) less than or equal to \!\(\*StyleBox[\"x\", \"TI\"]\). "
PrimePowerQ::usage = "\!\(\*RowBox[{\"PrimePowerQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a power of a prime number, and yields False otherwise. "
PrimeQ::usage = "\!\(\*RowBox[{\"PrimeQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a prime number, and yields False otherwise. "
Primes::usage = "Primes represents the domain of prime numbers, as in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Element]\", \"Primes\"}]\). "
Prime::usage = "\!\(\*RowBox[{\"Prime\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*RowBox[{SuperscriptBox[\"\[Null]\", \"th\"], \" \"}]\)prime number. "
PrimeZetaP::usage = "\!\(\*RowBox[{\"PrimeZetaP\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives prime zeta function \!\(\*RowBox[{StyleBox[\"P\", \"TI\"], \"(\", StyleBox[\"s\", \"TI\"], \")\"}]\)."
PrimitiveRootList::usage = "\!\(\*RowBox[{\"PrimitiveRootList\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a list of primitive roots of \!\(\*StyleBox[\"n\", \"TI\"]\)."
PrimitiveRoot::usage = "\!\(\*RowBox[{\"PrimitiveRoot\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a primitive root of \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"PrimitiveRoot\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the smallest primitive root of \!\(\*StyleBox[\"n\", \"TI\"]\) greater than or equal to \!\(\*StyleBox[\"k\", \"TI\"]\)."
PrincipalComponents::usage = "\!\(\*RowBox[{\"PrincipalComponents\", \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) transforms elements of \!\(\*StyleBox[\"matrix\", \"TI\"]\) into unscaled principal components."
PrincipalValue::usage = "PrincipalValue is an option for Integrate that specifies whether the Cauchy principal value should be found for a definite integral. "
PrintableASCIIQ::usage = "\!\(\*RowBox[{\"PrintableASCIIQ\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) yields True if the string contains only printable ASCII characters, and yields False otherwise. "
PrintAction::usage = "PrintAction is an option for notebooks that specifies the action taken when a \!\(\*RowBox[{\"Print\", \"[\", \"]\"}]\) command is evaluated by the kernel."
PrintingCopies::usage = "PrintingCopies is an option for notebooks that specifies the number of copies of a notebook printed when a print command is given."
PrintingOptions::usage = "\!\(\*RowBox[{\"PrintingOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for printing."
PrintingPageRange::usage = "PrintingPageRange is an option for notebooks that specifies the range of pages of a notebook to be printed."
PrintingStartingPageNumber::usage = "PrintingStartingPageNumber is an option for notebooks that specifies what number to assign to the first page of a notebook when printed."
PrintingStyleEnvironment::usage = "PrintingStyleEnvironment is an option for notebooks which specifies the style environment to be used in printing the notebook on paper. "
PrintPrecision::usage = "PrintPrecision is an option for selections that specifies the maximum number of digits used for displaying a machine-precision number."
PrintTemporary::usage = "\!\(\*RowBox[{\"PrintTemporary\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints \!\(\*StyleBox[\"expr\", \"TI\"]\) as a temporary cell in a notebook, removing it when the evaluation of the current input line is complete."
Print::usage = "\!\(\*RowBox[{\"Print\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints \!\(\*StyleBox[\"expr\", \"TI\"]\) as output. "
Prism::usage = "\!\(\*RowBox[{\"Prism\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"6\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents a filled prism connecting the triangles \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]\) and \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"4\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"5\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"6\", \"TR\"]]}], \"}\"}]\)."
PrivateCellOptions::usage = "\!\(\*RowBox[{\"PrivateCellOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}]}]\) is an option for cells that specifies various low-level cell settings."
PrivateEvaluationOptions::usage = "\!\(\*RowBox[{\"PrivateEvaluationOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}]}]\) is an option for selections that specifies settings for evaluation-related suboptions."
PrivateFontOptions::usage = "\!\(\*RowBox[{\"PrivateFontOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for selections that specifies settings for various font suboptions."
PrivateKey::usage = "\!\(\*RowBox[{\"PrivateKey\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) represents the private part of a key pair for a public-key cryptographic system."
PrivateNotebookOptions::usage = "\!\(\*RowBox[{\"PrivateNotebookOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for notebooks that specifies various low-level notebook settings."
PrivatePaths::usage = "\!\(\*RowBox[{\"PrivatePaths\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is a global option that specifies settings for paths private to the notebook front end."
ProbabilityDistribution::usage = "\!\(\*RowBox[{\"ProbabilityDistribution\", \"[\", RowBox[{StyleBox[\"pdf\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the continuous distribution with PDF \!\(\*StyleBox[\"pdf\", \"TI\"]\) in the variable \!\(\*StyleBox[\"x\", \"TI\"]\) where the \!\(\*StyleBox[\"pdf\", \"TI\"]\) is taken to be zero for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\) and \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \">\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}]\).\n\!\(\*RowBox[{\"ProbabilityDistribution\", \"[\", RowBox[{StyleBox[\"pdf\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents the discrete distribution with PDF \!\(\*StyleBox[\"pdf\", \"TI\"]\) in the variable \!\(\*StyleBox[\"x\", \"TI\"]\) where the \!\(\*StyleBox[\"pdf\", \"TI\"]\) is taken to be zero for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\) and \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \">\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}]\).\n\!\(\*RowBox[{\"ProbabilityDistribution\", \"[\", RowBox[{StyleBox[\"pdf\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a multivariate distribution with PDF \!\(\*StyleBox[\"pdf\", \"TI\"]\) in the variables \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis], etc. \n\!\(\*RowBox[{\"ProbabilityDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"CDF\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"cdf\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a probability distribution with CDF given by \!\(\*StyleBox[\"cdf\", \"TI\"]\). \n\!\(\*RowBox[{\"ProbabilityDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"SF\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"sf\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a probability distribution with survival function given by \!\(\*StyleBox[\"sf\", \"TI\"]\). \n\!\(\*RowBox[{\"ProbabilityDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"HF\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"hf\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a probability distribution with hazard function given by \!\(\*StyleBox[\"hf\", \"TI\"]\). "
ProbabilityPlot::usage = "\!\(\*RowBox[{\"ProbabilityPlot\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) generates a plot of the CDF of \!\(\*StyleBox[\"list\", \"TI\"]\) against the CDF of a normal distribution.\n\!\(\*RowBox[{\"ProbabilityPlot\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) generates a plot of the CDF of the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) against the CDF of a normal distribution.\n\!\(\*RowBox[{\"ProbabilityPlot\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"rdata\", \"TI\"]}], \"]\"}]\) generates a plot of the CDF of \!\(\*StyleBox[\"data\", \"TI\"]\) against the CDF of \!\(\*StyleBox[\"rdata\", \"TI\"]\).\n\!\(\*RowBox[{\"ProbabilityPlot\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"rdist\", \"TI\"]}], \"]\"}]\) generates a plot of the CDF of \!\(\*StyleBox[\"data\", \"TI\"]\) against the CDF of symbolic distribution \!\(\*StyleBox[\"rdist\", \"TI\"]\).\n\!\(\*RowBox[{\"ProbabilityPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"ref\", \"TI\"]}], \"]\"}]\) generates a plot of the CDF of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) against the CDF of a reference distribution \!\(\*StyleBox[\"ref\", \"TI\"]\)."
ProbabilityScalePlot::usage = "\!\(\*RowBox[{\"ProbabilityScalePlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a normal probability plot of the samples \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"ProbabilityScalePlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dist\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) generates a probability plot scaled for the distribution \"\!\(\*\nStyleBox[\"dist\", \"TI\"]\)\".\n\!\(\*RowBox[{\"ProbabilityScalePlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dist\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) generates several scaled probability plots for \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
Probability::usage = "\!\(\*RowBox[{\"Probability\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) gives the probability for an event that satisfies the predicate \!\(\*StyleBox[\"pred\", \"TI\"]\) under the assumption that \!\(\*StyleBox[\"x\", \"TI\"]\) follows the probability distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"Probability\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"data\", \"TI\"]}]}], \"]\"}]\) gives the probability for an event that satisfies the predicate \!\(\*StyleBox[\"pred\", \"TI\"]\) under the assumption that \!\(\*StyleBox[\"x\", \"TI\"]\) follows the probability distribution given by \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"Probability\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) gives the probability that an event satisfies \!\(\*StyleBox[\"pred\", \"TI\"]\) under the assumption that \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) follows the multivariate distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"Probability\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the probability that an event satisfies \!\(\*StyleBox[\"pred\", \"TI\"]\) under the assumption that \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] are independent and follow the distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"Probability\", \"[\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"pred\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Conditioned]\", SubscriptBox[StyleBox[\"pred\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the conditional probability of \!\(\*SubscriptBox[StyleBox[\"pred\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) given \!\(\*SubscriptBox[StyleBox[\"pred\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ProbitModelFit::usage = "\!\(\*RowBox[{\"ProbitModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) constructs a binomial probit regression model of the form \!\(\*RowBox[{FractionBox[\"1\", \"2\"], \" \", RowBox[{\"(\", RowBox[{\"1\", \"+\", RowBox[{\"erf\", \"(\", RowBox[{RowBox[{\"(\", RowBox[{SubscriptBox[\"\[Beta]\", \"0\"], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \" \", \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"2\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \" \", \"+\", \"\[CenterEllipsis]\"}], \")\"}], \"/\", SqrtBox[\"2\"]}], \")\"}]}], \")\"}]}]\) that fits the \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for successive \!\(\*StyleBox[\"x\", \"TI\"]\) values 1, 2, \[Ellipsis].\n\!\(\*RowBox[{\"ProbitModelFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) constructs a binomial probit regression model of the form \!\(\*RowBox[{FractionBox[\"1\", \"2\"], \" \", RowBox[{\"(\", RowBox[{\"1\", \"+\", RowBox[{\"erf\", \"(\", RowBox[{RowBox[{\"(\", RowBox[{SubscriptBox[\"\[Beta]\", \"0\"], \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"1\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"1\"]}], \" \", \"+\", RowBox[{SubscriptBox[\"\[Beta]\", \"2\"], SubscriptBox[StyleBox[\"f\", \"TI\"], \"2\"]}], \" \", \"+\", \"\[CenterEllipsis]\"}], \")\"}], \"/\", SqrtBox[\"2\"]}], \")\"}]}], \")\"}]}]\) where the \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) depend on the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"ProbitModelFit\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"]\"}]\) constructs a binomial probit regression model from the design matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and response vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
ProcessConnection::usage = "\!\(\*RowBox[{\"ProcessConnection\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"stream\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the stream object for a given stream."
ProcessDirectory::usage = "ProcessDirectory is an option specifying the initial working directory to use when executing a process in functions like StartProcess and RunProcess."
ProcessEnvironment::usage = "ProcessEnvironment is an option specifying the initial settings of environment variables to use when executing a process in functions like StartProcess and RunProcess."
ProcessEstimator::usage = "ProcessEstimator is an option to EstimatedProcess and FindProcessParameters that specifies what process parameter estimator to use. "
Processes::usage = "\!\(\*RowBox[{\"Processes\", \"[\", \"]\"}]\) returns a list of currently running external processes started in this Wolfram Language session."
ProcessInformation::usage = "\!\(\*RowBox[{\"ProcessInformation\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) gives information about an external process \!\(\*StyleBox[\"proc\", \"TI\"]\).\n\!\(\*RowBox[{\"ProcessInformation\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives information about the property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\". "
ProcessObject::usage = "\!\(\*RowBox[{\"ProcessObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) is an object that represents a runnable external process. "
ProcessParameterAssumptions::usage = "\!\(\*RowBox[{\"ProcessParameterAssumptions\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) gives a logical expression for assumptions on parameters in the random process \!\(\*StyleBox[\"proc\", \"TI\"]\)."
ProcessParameterQ::usage = "\!\(\*RowBox[{\"ProcessParameterQ\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"proc\", \"TI\"]\) is a valid random process, and yields False otherwise."
ProcessStatus::usage = "\!\(\*RowBox[{\"ProcessStatus\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) gives the current status of the external process represented by the ProcessObject \!\(\*StyleBox[\"proc\", \"TI\"]\).\n\!\(\*RowBox[{\"ProcessStatus\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"status\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns True if the process has the status given and returns False otherwise."
ProductDistribution::usage = "\!\(\*RowBox[{\"ProductDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the joint distribution with independent component distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
ProductLog::usage = "\!\(\*RowBox[{\"ProductLog\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the principal solution for \!\(\*StyleBox[\"w\", \"TI\"]\) in \!\(\*RowBox[{StyleBox[\"z\", \"TI\"], \"\[LongEqual]\", RowBox[{StyleBox[\"w\", \"TI\"], \"\[InvisibleSpace]\", SuperscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"w\", \"TI\"]]}]}]\). \n\!\(\*RowBox[{\"ProductLog\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) solution. "
Product::usage = "\!\(\*RowBox[{\"Product\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) evaluates the product \!\(\*RowBox[{UnderoverscriptBox[\"\[Product]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", \"1\"}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]], StyleBox[\"f\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Product\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) starts with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"Product\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"di\", \"TI\"]\). \n\!\(\*RowBox[{\"Product\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses successive values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"Product\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) evaluates the multiple product \!\(\*RowBox[{UnderoverscriptBox[\"\[Product]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]], RowBox[{UnderoverscriptBox[\"\[Product]\", RowBox[{StyleBox[\"j\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]], RowBox[{\"\[Ellipsis]\", \" \", StyleBox[\"f\", \"TI\"]}]}]}]\). \n\!\(\*RowBox[{\"Product\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives the indefinite product \!\(\*RowBox[{UnderscriptBox[\"\[Product]\", StyleBox[\"i\", \"TI\"]], StyleBox[\"f\", \"TI\"]}]\)."
ProgressIndicatorBoxOptions::usage = "\!\(\*RowBox[{ProgressIndicatorBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for ProgressIndicatorBox objects."
ProgressIndicator::usage = "\!\(\*RowBox[{\"ProgressIndicator\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a progress indicator with setting \!\(\*StyleBox[\"x\", \"TI\"]\) in the range 0 to 1. \n\!\(\*RowBox[{\"ProgressIndicator\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"ProgressIndicator\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a progress indicator with range \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"ProgressIndicator\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", \"Indeterminate\"}], \"]\"}]\) represents a progress indicator with indeterminate range. "
Projection::usage = "\!\(\*RowBox[{\"Projection\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) finds the projection of the vector \!\(\*StyleBox[\"u\", \"TI\"]\) onto the vector \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"Projection\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) finds projections with respect to the inner product function \!\(\*StyleBox[\"f\", \"TI\"]\)."
Prolog::usage = "Prolog is an option for graphics functions which gives a list of graphics primitives to be rendered before the main part of the graphics is rendered. "
PromptForm::usage = "\!\(\*RowBox[{\"PromptForm\", \"[\", RowBox[{StyleBox[\"prompt\", \"TI\"], \",\", \" \", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) prints as an output prompt and expression."
Properties::usage = "Properties is an option that allows specification of properties to objects and items of objects."
PropertyList::usage = "\!\(\*RowBox[{\"PropertyList\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"itemspec\", \"TI\"]}], \"}\"}], \"]\"}]\) lists the properties available for \!\(\*StyleBox[\"itemspec\", \"TI\"]\) in \!\(\*StyleBox[\"obj\", \"TI\"]\)."
Property::usage = "\!\(\*RowBox[{\"Property\", \"[\", RowBox[{StyleBox[\"item\", \"TI\"], \",\", RowBox[{StyleBox[\"name\", \"TI\"], \"\[Rule]\", StyleBox[\"value\", \"TI\"]}]}], \"]\"}]\) associates the property \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \"\[Rule]\", StyleBox[\"value\", \"TI\"]}]\) with \!\(\*StyleBox[\"item\", \"TI\"]\)."
PropertyValue::usage = "\!\(\*RowBox[{\"PropertyValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"item\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) gives the property value associated with \!\(\*StyleBox[\"name\", \"TI\"]\) for \!\(\*StyleBox[\"item\", \"TI\"]\) in \!\(\*StyleBox[\"obj\", \"TI\"]\).\n\!\(\*RowBox[{\"PropertyValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"itemspec\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) gives the property values associated with \!\(\*StyleBox[\"name\", \"TI\"]\) for items indicated by \!\(\*StyleBox[\"itemspec\", \"TI\"]\) in \!\(\*StyleBox[\"obj\", \"TI\"]\).\n\!\(\*RowBox[{\"PropertyValue\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of property values associated with \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), etc."
Proportional::usage = "\!\(\*RowBox[{\"Proportional\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Proportional]\", StyleBox[\"y\", \"TI\"], \"\[Proportional]\", \"\[Ellipsis]\"}]\)."
Proportion::usage = "\!\(\*RowBox[{\"Proportion\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Proportion]\", StyleBox[\"y\", \"TI\"], \"\[Proportion]\", \"\[Ellipsis]\"}]\)."
Protected::usage = "Protected is an attribute which prevents any values associated with a symbol from being modified. "
Protect::usage = "\!\(\*RowBox[{\"Protect\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) sets the attribute Protected for the symbols \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Protect\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) protects all symbols whose names match any of the string patterns \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
ProteinData::usage = "\!\(\*RowBox[{\"ProteinData\", \"[\", StyleBox[\"entity\", \"TI\"], \"]\"}]\) gives the reference amino acid sequence for the protein \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"ProteinData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the protein \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"ProteinData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
Pruning::usage = "\!\(\*RowBox[{\"Pruning\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) removes the outermost branches of thin objects in \!\(\*StyleBox[\"image\", \"TI\"]\) by setting their values to black.\n\!\(\*RowBox[{\"Pruning\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) removes branches that are at most \!\(\*StyleBox[\"n\", \"TI\"]\) pixels long.\n\!\(\*RowBox[{\"Pruning\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], StyleBox[\",\", \"TI\"], RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) removes \!\(\*StyleBox[\"n\", \"TI\"]\) pixels from each branch.\n\!\(\*RowBox[{\"Pruning\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) treats values above \!\(\*StyleBox[\"t\", \"TI\"]\) as foreground."
PseudoInverse::usage = "\!\(\*RowBox[{\"PseudoInverse\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) finds the pseudoinverse of a rectangular matrix. "
PublicKey::usage = "\!\(\*RowBox[{\"PublicKey\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) represents the public part of a key pair for a public-key cryptographic system."
PulsarData::usage = "\!\(\*RowBox[{\"PulsarData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the pulsar \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"PulsarData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified pulsar entities.\n\!\(\*RowBox[{\"PulsarData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
PunctuationCharacter::usage = "PunctuationCharacter represents a punctuation character in StringExpression."
Purple::usage = "Purple represents the color purple in graphics or style specifications. "
PutAppend::usage = "\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \">>>\", StyleBox[\"filename\", \"TI\"]}]\) appends \!\(\*StyleBox[\"expr\", \"TI\"]\) to a file. \n\!\(\*RowBox[{\"PutAppend\", \"[\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) appends a sequence of expressions \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to a file. "
Put::usage = "\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \">>\", StyleBox[\"filename\", \"TI\"]}]\) writes \!\(\*StyleBox[\"expr\", \"TI\"]\) to a file. \n\!\(\*RowBox[{\"Put\", \"[\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes a sequence of expressions \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to a file. \n\!\(\*RowBox[{\"Put\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) creates an empty file with the specified name."
Pyramid::usage = "\!\(\*RowBox[{\"Pyramid\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"5\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents a filled pyramid with base \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"4\", \"TR\"]]}], \"}\"}]\) and top \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"5\", \"TR\"]]\)."
QBinomial::usage = "\!\(\*RowBox[{\"QBinomial\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"q\", \"TI\"]\)-binomial coefficient \!\(\*SubscriptBox[RowBox[{\"(\", GridBox[{{TagBox[StyleBox[\"n\", \"TI\"], Identity, Editable -> True, Selectable -> True]}, {TagBox[StyleBox[\"m\", \"TI\"], Identity, Editable -> True, Selectable -> True]}}], \")\"}], StyleBox[\"q\", \"TI\"]]\)."
QFactorial::usage = "\!\(\*RowBox[{\"QFactorial\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"q\", \"TI\"]\)-factorial \!\(\*RowBox[{SubscriptBox[RowBox[{\"[\", StyleBox[\"n\", \"TI\"], \"]\"}], StyleBox[\"q\", \"TI\"]], \"!\"}]\)."
QGamma::usage = "\!\(\*RowBox[{\"QGamma\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"q\", \"TI\"]\)-gamma function \!\(\*RowBox[{SubscriptBox[\"\[CapitalGamma]\", StyleBox[\"q\", \"TI\"]], \" \", RowBox[{\"(\", StyleBox[\"z\", \"TI\"], \")\"}]}]\)."
QHypergeometricPFQ::usage = "\!\(\*RowBox[{\"QHypergeometricPFQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"s\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the basic hypergeometric series \!\(\*RowBox[{SubscriptBox[\"\[Null]\", StyleBox[\"r\", \"TI\"]], \"\[InvisibleSpace]\", SubscriptBox[\"\[Phi]\", StyleBox[\"s\", \"TI\"]], \"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"b\", \"TI\"], \";\", StyleBox[\"q\", \"TI\"], \";\", StyleBox[\"z\", \"TI\"]}], \")\"}]\)."
QPochhammer::usage = "\!\(\*RowBox[{\"QPochhammer\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"q\", \"TI\"]\)-Pochhammer symbol \!\(\*SubscriptBox[RowBox[{RowBox[{\"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"q\", \"TI\"]}], \")\"}], \" \"}], StyleBox[\"n\", \"TI\"]]\).\n\!\(\*RowBox[{\"QPochhammer\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"q\", \"TI\"]\)-Pochhammer symbol \!\(\*SubscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"a\", \"TI\"], \";\", StyleBox[\"q\", \"TI\"]}], \")\"}], \"\[Infinity]\"]\).\n\!\(\*RowBox[{\"QPochhammer\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"q\", \"TI\"]\)-Pochhammer symbol \!\(\*SubscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"q\", \"TI\"], \";\", StyleBox[\"q\", \"TI\"]}], \")\"}], \"\[Infinity]\"]\)."
QPolyGamma::usage = "\!\(\*RowBox[{\"QPolyGamma\", \"[\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"q\", \"TI\"]\)-digamma function \!\(\*RowBox[{SubscriptBox[\"\[Psi]\", StyleBox[\"q\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"QPolyGamma\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative of the \!\(\*StyleBox[\"q\", \"TI\"]\)-digamma function \!\(\*RowBox[{SubsuperscriptBox[\"\[Psi]\", StyleBox[\"q\", \"TI\"], RowBox[{\"(\", StyleBox[\"n\", \"TI\"], \")\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
QRDecomposition::usage = "\!\(\*RowBox[{\"QRDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) yields the QR decomposition for a numerical matrix \!\(\*StyleBox[\"m\", \"TI\"]\). The result is a list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]\), where \!\(\*StyleBox[\"q\", \"TI\"]\) is an orthogonal matrix and \!\(\*StyleBox[\"r\", \"TI\"]\) is an upper\[Hyphen]triangular matrix. "
QuadraticIrrationalQ::usage = "\!\(\*RowBox[{\"QuadraticIrrationalQ\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"x\", \"TI\"]\) is a quadratic irrational and False otherwise."
QuantilePlot::usage = "\!\(\*RowBox[{\"QuantilePlot\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) generates a plot of quantiles of \!\(\*StyleBox[\"list\", \"TI\"]\) against the quantiles of a normal distribution.\n\!\(\*RowBox[{\"QuantilePlot\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) generates a plot of quantiles of the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) against the quantiles of a normal distribution.\n\!\(\*RowBox[{\"QuantilePlot\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"rdata\", \"TI\"]}], \"]\"}]\) generates a plot of the quantiles of \!\(\*StyleBox[\"data\", \"TI\"]\) against the quantiles of \!\(\*StyleBox[\"rdata\", \"TI\"]\).\n\!\(\*RowBox[{\"QuantilePlot\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"rdist\", \"TI\"]}], \"]\"}]\) generates a plot of the quantiles of \!\(\*StyleBox[\"data\", \"TI\"]\) against the quantiles of a symbolic distribution \!\(\*StyleBox[\"rdist\", \"TI\"]\).\n\!\(\*RowBox[{\"QuantilePlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"ref\", \"TI\"]}], \"]\"}]\) generates a plot of quantiles of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) against the quantiles of a reference distribution \!\(\*StyleBox[\"ref\", \"TI\"]\)."
Quantile::usage = "\!\(\*RowBox[{\"Quantile\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[RowBox[{StyleBox[\"q\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) quantile of \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Quantile\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of quantiles \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. \n\!\(\*RowBox[{\"Quantile\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses the quantile definition specified by parameters \!\(\*StyleBox[\"a\", \"TI\"]\), \!\(\*StyleBox[\"b\", \"TI\"]\), \!\(\*StyleBox[\"c\", \"TI\"]\), \!\(\*StyleBox[\"d\", \"TI\"]\). \n\!\(\*RowBox[{\"Quantile\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) gives a quantile of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
QuantityArray::usage = "\!\(\*RowBox[{\"QuantityArray\", \"[\", RowBox[{StyleBox[\"mags\", \"TI\"], \",\", StyleBox[\"unit\", \"TI\"]}], \"]\"}]\) represents an array of quantities with magnitudes \!\(\*StyleBox[\"mags\", \"TI\"]\) and common \!\(\*StyleBox[\"unit\", \"TI\"]\).\n\!\(\*RowBox[{\"QuantityArray\", \"[\", RowBox[{StyleBox[\"mags\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"unit\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"unit\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents an array of lists of quantities with units \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"unit\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"unit\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"QuantityArray\", \"[\", StyleBox[\"quants\", \"TI\"], \"]\"}]\) converts an array of Quantity objects into a single QuantityArray object."
QuantityForm::usage = "\!\(\*RowBox[{\"QuantityForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) prints with all Quantity expressions in \!\(\*StyleBox[\"expr\", \"TI\"]\) using the specified unit display form \!\(\*StyleBox[\"form\", \"TI\"]\).\n\!\(\*RowBox[{\"QuantityForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"forms\", \"TI\"], \"}\"}]}], \"]\"}]\) prints \!\(\*StyleBox[\"expr\", \"TI\"]\) using the appropriate combination of the specified unit display forms \!\(\*StyleBox[\"forms\", \"TI\"]\)."
QuantityMagnitude::usage = "\!\(\*RowBox[{\"QuantityMagnitude\", \"[\", StyleBox[\"quantity\", \"TI\"], \"]\"}]\) gives the amount of the specified \!\(\*StyleBox[\"quantity\", \"TI\"]\).\n\!\(\*RowBox[{\"QuantityMagnitude\", \"[\", RowBox[{StyleBox[\"quantity\", \"TI\"], \",\", StyleBox[\"unit\", \"TI\"]}], \"]\"}]\) gives the value corresponding to \!\(\*StyleBox[\"quantity\", \"TI\"]\) when converted to \!\(\*StyleBox[\"unit\", \"TI\"]\)."
QuantityQ::usage = "\!\(\*RowBox[{\"QuantityQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a Quantity with valid arguments, and False otherwise."
QuantityThread::usage = "\!\(\*RowBox[{\"QuantityThread\", \"[\", StyleBox[\"quantity\", \"TI\"], \"]\"}]\) threads the unit of \!\(\*StyleBox[\"quantity\", \"TI\"]\) through all levels of its magnitude.\n\!\(\*RowBox[{\"QuantityThread\", \"[\", RowBox[{StyleBox[\"quantity\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) threads the unit to depth \!\(\*StyleBox[\"n\", \"TI\"]\)."
QuantityUnit::usage = "\!\(\*RowBox[{\"QuantityUnit\", \"[\", StyleBox[\"quantity\", \"TI\"], \"]\"}]\) returns the unit associated with the specified \!\(\*StyleBox[\"quantity\", \"TI\"]\)."
Quantity::usage = "\!\(\*RowBox[{\"Quantity\", \"[\", RowBox[{StyleBox[\"magnitude\", \"TI\"], \",\", StyleBox[\"unit\", \"TI\"]}], \"]\"}]\) represents a quantity with size \!\(\*StyleBox[\"magnitude\", \"TI\"]\) and the unit specified by \!\(\*StyleBox[\"unit\", \"TI\"]\).\n\!\(\*RowBox[{\"Quantity\", \"[\", StyleBox[\"unit\", \"TI\"], \"]\"}]\) assumes the \!\(\*StyleBox[\"magnitude\", \"TI\"]\) of the specified \!\(\*StyleBox[\"unit\", \"TI\"]\) to be 1."
QuantityVariableCanonicalUnit::usage = "\!\(\*RowBox[{\"QuantityVariableCanonicalUnit\", \"[\", StyleBox[\"quantityvariable\", \"TI\"], \"]\"}]\) returns the canonical unit associated with the specified \!\(\*StyleBox[\"quantityvariable\", \"TI\"]\)."
QuantityVariableDimensions::usage = "\!\(\*RowBox[{\"QuantityVariableDimensions\", \"[\", StyleBox[\"quantityvariable\", \"TI\"], \"]\"}]\) returns a list of base dimensions associated with the specified \!\(\*StyleBox[\"quantityvariable\", \"TI\"]\)."
QuantityVariableIdentifier::usage = "\!\(\*RowBox[{\"QuantityVariableIdentifier\", \"[\", StyleBox[\"quantityvariable\", \"TI\"], \"]\"}]\) returns the identifier associated with the specified \!\(\*StyleBox[\"quantityvariable\", \"TI\"]\)."
QuantityVariablePhysicalQuantity::usage = "\!\(\*RowBox[{\"QuantityVariablePhysicalQuantity\", \"[\", StyleBox[\"var\", \"TI\"], \"]\"}]\) returns the physical quantity associated with the quantity variable \!\(\*StyleBox[\"var\", \"TI\"]\)."
QuantityVariable::usage = "\!\(\*RowBox[{\"QuantityVariable\", \"[\", RowBox[{StyleBox[\"var\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"pq\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents a variable with the label \!\(\*StyleBox[\"var\", \"TI\"]\) and the corresponding physical quantity \"\!\(\*\nStyleBox[\"pq\", \"TI\"]\)\".\n\!\(\*RowBox[{\"QuantityVariable\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"pq\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents the unlabeled physical quantity \"\!\(\*\nStyleBox[\"pq\", \"TI\"]\)\"."
Quartics::usage = "Quartics is an option for functions that involve solving algebraic equations that specifies whether explicit forms for solutions to quartic equations should be given."
QuartileDeviation::usage = "\!\(\*RowBox[{\"QuartileDeviation\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the quartile deviation or semi-interquartile range of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"QuartileDeviation\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the quartile deviation or semi-interquartile range of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
QuartileSkewness::usage = "\!\(\*RowBox[{\"QuartileSkewness\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the coefficient of quartile skewness for the elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"QuartileSkewness\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the coefficient of quartile skewness for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
Quartiles::usage = "\!\(\*RowBox[{\"Quartiles\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a list of the 1/4, 1/2, and 3/4 quantiles of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Quartiles\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives a list of the 1/4, 1/2, and 3/4 quantiles of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
Quaternions`AbsIJK::usage = "\!\(\*RowBox[{\"AbsIJK\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives the absolute value of the pure quaternion part of \!\(\*StyleBox[\"q\", \"TI\"]\)."
Quaternions`AdjustedSignIJK::usage = "\!\(\*RowBox[{\"AdjustedSignIJK\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives the sign of the pure quaternion part of \!\(\*StyleBox[\"q\", \"TI\"]\), adjusted so its first nonzero component is positive."
Quaternions`FromQuaternion::usage = "\!\(\*RowBox[{\"FromQuaternion\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) transforms the Quaternion object \!\(\*StyleBox[\"q\", \"TI\"]\) to the symbolic form \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"+\", RowBox[{\"I\", \" \", StyleBox[\"b\", \"TI\"]}], \"+\", RowBox[{\"J\", \" \", StyleBox[\"c\", \"TI\"]}], \"+\", RowBox[{\"K\", \" \", StyleBox[\"d\", \"TI\"]}]}]\)."
Quaternions`IntegerQuaternionQ::usage = "\!\(\*RowBox[{\"IntegerQuaternionQ\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"q\", \"TI\"]\) is an integer quaternion and False otherwise."
Quaternions`J::usage = "J represents a quaternion unit with \!\(\*RowBox[{SuperscriptBox[\"J\", \"2\"], \"==\", RowBox[{\"-\", \"1\"}]}]\)."
Quaternions`LeftAssociates::usage = "\!\(\*RowBox[{\"LeftAssociates\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives a list of the 24 left associates of the quaternion \!\(\*StyleBox[\"q\", \"TI\"]\)."
Quaternions`LeftGCD::usage = "\!\(\*RowBox[{\"LeftGCD\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the greatest common left divisor of the quaternions \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\)."
Quaternions`PrimaryLeftAssociate::usage = "\!\(\*RowBox[{\"PrimaryLeftAssociate\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives the left associate of the quaternion \!\(\*StyleBox[\"q\", \"TI\"]\) with the largest scalar component."
Quaternions`PrimaryRightAssociate::usage = "\!\(\*RowBox[{\"PrimaryRightAssociate\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives the right associate of the quaternion \!\(\*StyleBox[\"q\", \"TI\"]\) with the largest scalar component."
Quaternions`QuaternionQ::usage = "\!\(\*RowBox[{\"QuaternionQ\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"q\", \"TI\"]\) is a quaternion and False otherwise."
Quaternions`Quaternions::usage = "Quaternions is an option for PrimeQ that specifies whether factorization should be done over the quaternions."
Quaternions`Quaternion::usage = "\!\(\*RowBox[{\"Quaternion\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) represents the quaternion \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"+\", RowBox[{\"I\", \" \", StyleBox[\"b\", \"TI\"]}], \"+\", RowBox[{\"J\", \" \", StyleBox[\"c\", \"TI\"]}], \"+\", RowBox[{\"K\", \" \", StyleBox[\"d\", \"TI\"]}]}]\)."
Quaternions`RightAssociates::usage = "\!\(\*RowBox[{\"RightAssociates\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives a list of the 24 right associates of the quaternion \!\(\*StyleBox[\"q\", \"TI\"]\)."
Quaternions`RightGCD::usage = "\!\(\*RowBox[{\"RightGCD\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives the greatest common right divisor of the quaternions \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\)."
Quaternions`ScalarQ::usage = "\!\(\*RowBox[{\"ScalarQ\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"q\", \"TI\"]\) is a real numeric quantity and False otherwise."
Quaternions`ToQuaternion::usage = "\!\(\*RowBox[{\"ToQuaternion\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) transforms \!\(\*StyleBox[\"q\", \"TI\"]\) into a Quaternion object if possible."
Quaternions`UnitQuaternionQ::usage = "\!\(\*RowBox[{\"UnitQuaternionQ\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"q\", \"TI\"]\) is a unit quaternion and False otherwise."
Quaternions`UnitQuaternions::usage = "UnitQuaternions gives a list of the 24 units in the ring of integer quaternions."
Query::usage = "\!\(\*RowBox[{\"Query\", \"[\", RowBox[{SubscriptBox[StyleBox[\"operator\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"operator\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a query that can be applied to a Dataset object, in which the successive \!\(\*SubscriptBox[StyleBox[\"operator\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are applied at successively deeper levels. "
QueueingNetworkProcess::usage = "\!\(\*RowBox[{\"QueueingNetworkProcess\", \"[\", RowBox[{StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents an open (Jackson) queueing network process with arrival vector \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\), routing probability matrix \!\(\*StyleBox[\"r\", \"TI\"]\), service vector \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and service channel vector \!\(\*StyleBox[\"c\", \"TI\"]\). \n\!\(\*RowBox[{\"QueueingNetworkProcess\", \"[\", RowBox[{StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents a closed (Gordon\[Dash]Newell) queueing network process with \!\(\*StyleBox[\"k\", \"TI\"]\) jobs in the system."
QueueingProcess::usage = "\!\(\*RowBox[{\"QueueingProcess\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents an M/M/1 queue with arrival rate \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\) and service rate \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\).\n\!\(\*RowBox[{\"QueueingProcess\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"sdist\", \"TI\"]}], \"]\"}]\) represents an M/G/1 queue with arrival rate \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\) and service distribution \!\(\*StyleBox[\"sdist\", \"TI\"]\).\n\!\(\*RowBox[{\"QueueingProcess\", \"[\", RowBox[{StyleBox[\"adist\", \"TI\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a G/M/1 queue with arrival distribution \!\(\*StyleBox[\"adist\", \"TI\"]\) and service rate \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\).\n\!\(\*RowBox[{\"QueueingProcess\", \"[\", RowBox[{StyleBox[\"adist\", \"TI\"], \",\", StyleBox[\"sdist\", \"TI\"]}], \"]\"}]\) represents a G/G/1 queue with arrival distribution \!\(\*StyleBox[\"adist\", \"TI\"]\) and service distribution \!\(\*StyleBox[\"sdist\", \"TI\"]\).\n\!\(\*RowBox[{\"QueueingProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents a queueing process with \!\(\*StyleBox[\"c\", \"TI\"]\) service channels.\n\!\(\*RowBox[{\"QueueingProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents a queueing process with system capacity \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"QueueingProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) represents a queueing process with initial state \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\)."
QueueProperties::usage = "\!\(\*RowBox[{\"QueueProperties\", \"[\", StyleBox[\"qproc\", \"TI\"], \"]\"}]\) gives a summary of properties for the queueing process \!\(\*StyleBox[\"qproc\", \"TI\"]\).\n\!\(\*RowBox[{\"QueueProperties\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"qproc\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], StyleBox[\"}\", \"TI\"]}], \"]\"}]\) gives a summary of properties for the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) node in the queueing network process \!\(\*StyleBox[\"qproc\", \"TI\"]\).\n\!\(\*RowBox[{\"QueueProperties\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) gives a summary of properties for queueing simulation data. \n\!\(\*RowBox[{\"QueueProperties\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
Quiet::usage = "\!\(\*RowBox[{\"Quiet\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) \"quietly\", without actually outputting any messages generated.\n\!\(\*RowBox[{\"Quiet\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"::\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"::\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) quietens only the specified messages during the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"Quiet\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) quietens only the named group of messages."
Quit::usage = "\!\(\*RowBox[{\"Quit\", \"[\", \"]\"}]\) terminates a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) kernel session. "
QuotientRemainder::usage = "\!\(\*RowBox[{\"QuotientRemainder\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of the quotient and remainder from division of \!\(\*StyleBox[\"m\", \"TI\"]\) by \!\(\*StyleBox[\"n\", \"TI\"]\)."
Quotient::usage = "\!\(\*RowBox[{\"Quotient\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the integer quotient of \!\(\*StyleBox[\"m\", \"TI\"]\) and \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"Quotient\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses an offset \!\(\*StyleBox[\"d\", \"TI\"]\). "
RadialGradientImage::usage = "\!\(\*RowBox[{\"RadialGradientImage\", \"[\", StyleBox[\"gcol\", \"TI\"], \"]\"}]\) returns an image with values radially changing from center to corners based on gradient color \!\(\*StyleBox[\"gcol\", \"TI\"]\).\n\!\(\*RowBox[{\"RadialGradientImage\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"\[Rule]\", StyleBox[\"gcol\", \"TI\"]}], \"]\"}]\) returns an image where the gradient starts at \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and ends at \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"RadialGradientImage\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) returns a radial gradient image of the specified \!\(\*StyleBox[\"size\", \"TI\"]\)."
RadialityCentrality::usage = "\!\(\*RowBox[{\"RadialityCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of radiality centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"RadialityCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"In\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of in-centralities for a directed graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"RadialityCentrality\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\\\"Out\\\"\",ShowStringCharacters->True]}], \"]\"}]\) gives a list of out-centralities for a directed graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"RadialityCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
RadicalBoxOptions::usage = "\!\(\*RowBox[{RadicalBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for selections that specifies settings for RadicalBox objects."
RadicalBox::usage = "\!\(\*RowBox[{RadicalBox, \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) is a low-level box construct that represents the displayed object \!\(\*RadicalBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]\) in notebook expressions. "
RadioButtonBar::usage = "\!\(\*RowBox[{\"RadioButtonBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a radio button bar with setting \!\(\*StyleBox[\"x\", \"TI\"]\) and with labeled radio buttons for values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"RadioButtonBar\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being reset every time a radio button is pressed.\n\!\(\*RowBox[{\"RadioButtonBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a radio button bar in which the radio button giving value \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is given label \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
RadioButtonBoxOptions::usage = "\!\(\*RowBox[{RadioButtonBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for RadioButtonBox objects."
RadioButton::usage = "\!\(\*RowBox[{\"RadioButton\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) represents a radio button whose setting \!\(\*StyleBox[\"x\", \"TI\"]\) is set to \!\(\*StyleBox[\"val\", \"TI\"]\) when the button is clicked. \n\!\(\*RowBox[{\"RadioButton\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) is displayed as \!\(\*RadioButtonBox[0, {0}]\) when \!\(\*StyleBox[\"x\", \"TI\"]\) is \!\(\*StyleBox[\"val\", \"TI\"]\), and as \!\(\*RadioButtonBox[1, {0}]\) otherwise. \n\!\(\*RowBox[{\"RadioButton\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being reset if the button is clicked. "
Radon::usage = "\!\(\*RowBox[{\"Radon\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives an image representing the discrete Radon transform of \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"Radon\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}]}], \"]\"}]\) specifies the width \!\(\*StyleBox[\"w\", \"TI\"]\) and the height \!\(\*StyleBox[\"h\", \"TI\"]\) of the resulting image.\n\!\(\*RowBox[{\"Radon\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) computes the Radon transform only for angles from \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
RamanujanTauL::usage = "\!\(\*RowBox[{\"RamanujanTauL\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives the Ramanujan tau Dirichlet L-function \!\(\*RowBox[{StyleBox[\"L\", \"TI\"], \"(\", StyleBox[\"s\", \"TI\"], \")\"}]\)."
RamanujanTauTheta::usage = "\!\(\*RowBox[{\"RamanujanTauTheta\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) gives the Ramanujan tau theta function \!\(\*RowBox[{\"\[Theta]\", \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\)."
RamanujanTau::usage = "\!\(\*RowBox[{\"RamanujanTau\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Ramanujan \[Tau] function \!\(\*RowBox[{\"\[Tau]\", \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\)."
RamanujanTauZ::usage = "\!\(\*RowBox[{\"RamanujanTauZ\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) gives the Ramanujan tau Z-function \!\(\*RowBox[{StyleBox[\"Z\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\)."
RandomChoice::usage = "\!\(\*RowBox[{\"RandomChoice\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a pseudorandom choice of one of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"RandomChoice\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom choices. \n\!\(\*RowBox[{\"RandomChoice\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis] array of pseudorandom choices. \n\!\(\*RowBox[{\"RandomChoice\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a pseudorandom choice weighted by the \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"RandomChoice\", \"[\", RowBox[{RowBox[{StyleBox[\"wlist\", \"TI\"], \"\[Rule]\", StyleBox[\"elist\", \"TI\"]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) weighted choices.\n\!\(\*RowBox[{\"RandomChoice\", \"[\", RowBox[{RowBox[{StyleBox[\"wlist\", \"TI\"], \"\[Rule]\", StyleBox[\"elist\", \"TI\"]}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis] array of weighted choices."
RandomColor::usage = "\!\(\*RowBox[{\"RandomColor\", \"[\", \"]\"}]\) gives a pseudorandom color directive in the RGBColor space.\n\!\(\*RowBox[{\"RandomColor\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom colors.\n\!\(\*RowBox[{\"RandomColor\", \"[\", StyleBox[\"model\", \"TI\"], \"]\"}]\) gives a color from the specified \!\(\*StyleBox[\"model\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomColor\", \"[\", RowBox[{StyleBox[\"model\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"n\", \"TI\"]\) colors.\n\!\(\*RowBox[{\"RandomColor\", \"[\", RowBox[{StyleBox[\"model\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an array of colors."
RandomComplex::usage = "\!\(\*RowBox[{\"RandomComplex\", \"[\", \"]\"}]\) gives a pseudorandom complex number with real and imaginary parts in the range 0 to 1.\n\!\(\*RowBox[{\"RandomComplex\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives a pseudorandom complex number in the rectangle with corners given by the complex numbers \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"RandomComplex\", \"[\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"]\"}]\) gives a pseudorandom complex number in the rectangle whose corners are the origin and \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"RandomComplex\", \"[\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom complex numbers.\n\!\(\*RowBox[{\"RandomComplex\", \"[\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis] array of pseudorandom complex numbers."
RandomEntity::usage = "\!\(\*RowBox[{\"RandomEntity\", \"[\", StyleBox[\"spec\", \"TI\"], \"]\"}]\) gives a pseudorandom entity with a type determined by the specification \!\(\*StyleBox[\"spec\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomEntity\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom entities."
RandomFunction::usage = "\!\(\*RowBox[{\"RandomFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a pseudorandom function from the process \!\(\*StyleBox[\"proc\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"RandomFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dt\", \"TI\"]}], \"}\"}]}], \"]\"}]\) generates a pseudorandom function from \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) in steps of \!\(\*StyleBox[\"dt\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomFunction\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", \" \", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates an ensemble of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom functions. "
RandomGraph::usage = "\!\(\*RowBox[{\"RandomGraph\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"}\"}], \"]\"}]\) gives a pseudorandom graph with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices and \!\(\*StyleBox[\"m\", \"TI\"]\) edges.\n\!\(\*RowBox[{\"RandomGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"k\", \"TI\"]\) pseudorandom graphs.\n\!\(\*RowBox[{\"RandomGraph\", \"[\", RowBox[{StyleBox[\"gdist\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) samples from the random graph distribution \!\(\*StyleBox[\"gdist\", \"TI\"]\)."
RandomImage::usage = "\!\(\*RowBox[{\"RandomImage\", \"[\", StyleBox[\"max\", \"TI\"], \"]\"}]\) gives an image with pseudorandom pixel values in the range 0 to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomImage\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \"]\"}]\) generates pseudorandom pixel values in the range \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomImage\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) generates pixel values using a symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomImage\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) generates a random image of the specified \!\(\*StyleBox[\"size\", \"TI\"]\)."
RandomInteger::usage = "\!\(\*RowBox[{\"RandomInteger\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives a pseudorandom integer in the range \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"RandomInteger\", \"[\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"]\"}]\) gives a pseudorandom integer in the range \!\(\*RowBox[{\"{\", RowBox[{\"0\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"RandomInteger\", \"[\", \"]\"}]\) pseudorandomly gives 0 or 1. \n\!\(\*RowBox[{\"RandomInteger\", \"[\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom integers. \n\!\(\*RowBox[{\"RandomInteger\", \"[\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis] array of pseudorandom integers. "
RandomPermutation::usage = "\!\(\*RowBox[{\"RandomPermutation\", \"[\", StyleBox[\"gr\", \"TI\"], \"]\"}]\) gives a pseudorandom permutation in the permutation group \!\(\*StyleBox[\"gr\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomPermutation\", \"[\", RowBox[{StyleBox[\"gr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom permutations in the permutation group \!\(\*StyleBox[\"gr\", \"TI\"]\)."
RandomPoint::usage = "\!\(\*RowBox[{\"RandomPoint\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives a pseudorandom point uniformly distributed in the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomPoint\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom points uniformly distributed in the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomPoint\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an \!\(\*RowBox[{StyleBox[SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \"\[Times]\", StyleBox[\" \", \"TI\"], StyleBox[SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"], \"\[Times]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) array of pseudorandom points.\n\!\(\*RowBox[{\"RandomPoint\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) restricts to the bounds \!\(\*RowBox[{RowBox[{\"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"min\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"max\"]}], \"]\"}], \"\[Times]\", \"\[CenterEllipsis]\"}]\)."
RandomPrime::usage = "\!\(\*RowBox[{\"RandomPrime\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives a pseudorandom prime number in the range \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"RandomPrime\", \"[\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"]\"}]\) gives a pseudorandom prime number in the range 2 to \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"RandomPrime\", \"[\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom primes."
RandomReal::usage = "\!\(\*RowBox[{\"RandomReal\", \"[\", \"]\"}]\) gives a pseudorandom real number in the range 0 to 1. \n\!\(\*RowBox[{\"RandomReal\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives a pseudorandom real number in the range \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"RandomReal\", \"[\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"]\"}]\) gives a pseudorandom real number in the range 0 to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"RandomReal\", \"[\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom reals. \n\!\(\*RowBox[{\"RandomReal\", \"[\", RowBox[{StyleBox[\"range\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis] array of pseudorandom reals. "
RandomSample::usage = "\!\(\*RowBox[{\"RandomSample\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a pseudorandom sample of \!\(\*StyleBox[\"n\", \"TI\"]\) of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"RandomSample\", \"[\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a pseudorandom sample of \!\(\*StyleBox[\"n\", \"TI\"]\) of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) chosen using weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"RandomSample\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a pseudorandom permutation of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Random::usage = "\!\(\*RowBox[{\"Random\", \"[\", \"]\"}]\) gives a uniformly distributed pseudorandom Real in the range 0 to 1. \n\!\(\*RowBox[{\"Random\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"range\", \"TI\"]}], \"]\"}]\) gives a pseudorandom number of the specified type, lying in the specified range. Possible types are: Integer, Real and Complex. The default range is 0 to 1. You can give the range \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]\) explicitly; a range specification of \!\(\*StyleBox[\"max\", \"TI\"]\) is equivalent to \!\(\*RowBox[{\"{\", RowBox[{\"0\", \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]\). "
RandomVariate::usage = "\!\(\*RowBox[{\"RandomVariate\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives a pseudorandom variate from the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomVariate\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom variates from the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomVariate\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives an \!\(\*RowBox[{StyleBox[SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"TI\"], \"\[Times]\", StyleBox[\" \", \"TI\"], StyleBox[SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"TI\"], \"\[Times]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) array of pseudorandom variates from the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
RandomWalkProcess::usage = "\!\(\*RowBox[{\"RandomWalkProcess\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) represents a random walk on a line with the probability of a positive unit step \!\(\*StyleBox[\"p\", \"TI\"]\) and the probability of a negative unit step \!\(\*RowBox[{\"1\", \"-\", StyleBox[\"p\", \"TI\"]}]\).\n\!\(\*RowBox[{\"RandomWalkProcess\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents a random walk with the probability of a positive unit step \!\(\*StyleBox[\"p\", \"TI\"]\), the probability of a negative unit step \!\(\*StyleBox[\"q\", \"TI\"]\), and the probability of a zero step \!\(\*RowBox[{\"1\", \"-\", StyleBox[\"p\", \"TI\"], \"-\", StyleBox[\"q\", \"TI\"]}]\)."
RandomWord::usage = "\!\(\*RowBox[{\"RandomWord\", \"[\", \"]\"}]\) gives a pseudorandom commonly used word.\n\!\(\*RowBox[{\"RandomWord\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) gives a pseudorandom word of the specified \!\(\*StyleBox[\"type\", \"TI\"]\).\n\!\(\*RowBox[{\"RandomWord\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"n\", \"TI\"]\) pseudorandom words of the specified \!\(\*StyleBox[\"type\", \"TI\"]\)."
RangeFilter::usage = "\!\(\*RowBox[{\"RangeFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every pixel by the difference of the maximum and minimum in its range-\!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"RangeFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies a range filter to an array of \!\(\*StyleBox[\"data\", \"TI\"]\)."
Range::usage = "\!\(\*RowBox[{\"Range\", \"[\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"]\"}]\) generates the list \!\(\*RowBox[{\"{\", RowBox[{\"1\", \",\", \"2\", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"Range\", \"[\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"]\"}]\) generates the list \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]\). \n\!\(\*RowBox[{\"Range\", \"[\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"]\"}]\) uses step \!\(\*StyleBox[\"di\", \"TI\"]\)."
RankedMax::usage = "\!\(\*RowBox[{\"RankedMax\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) largest element in \!\(\*StyleBox[\"list\", \"TI\"]\)."
RankedMin::usage = "\!\(\*RowBox[{\"RankedMin\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) smallest element in \!\(\*StyleBox[\"list\", \"TI\"]\)."
Raster3DBoxOptions::usage = "\!\(\*RowBox[{Raster3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for Raster3DBox objects."
Raster3D::usage = "\!\(\*RowBox[{\"Raster3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a three-dimensional graphics primitive that represents a cubical array of gray cells. \n\!\(\*RowBox[{\"Raster3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"11\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an array of RGB color cells. \n\!\(\*RowBox[{\"Raster3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"11\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an array of color cells with opacity \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"ij\", \"TI\"]]\).\n\!\(\*RowBox[{\"Raster3D\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) represents a three-dimensional graphics primitive by giving the coordinates of opposite corners.\n\!\(\*RowBox[{\"Raster3D\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"coordinates\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a three-dimensional graphics primitive whose voxel values should be scaled so that \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) corresponds to 0 and \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) corresponds to 1."
RasterArray::usage = "\!\(\*RowBox[{\"RasterArray\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a two-dimensional graphics primitive that represents a rectangular array of cells colored according to the graphics directives \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"ij\", \"TI\"]]\). "
RasterBoxOptions::usage = "\!\(\*RowBox[{RasterBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for RasterBox objects."
Rasterize::usage = "\!\(\*RowBox[{\"Rasterize\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) returns a rasterized graphic of \!\(\*StyleBox[\"g\", \"TI\"]\). \n\!\(\*RowBox[{\"Rasterize\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"elem\", \"TI\"]}], \"]\"}]\) gives the element \!\(\*StyleBox[\"elem\", \"TI\"]\) associated with the rasterized form of \!\(\*StyleBox[\"g\", \"TI\"]\). "
RasterSize::usage = "RasterSize is an option for Rasterize and related functions that determines the absolute pixel size of the raster generated."
Raster::usage = "\!\(\*RowBox[{\"Raster\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a two-dimensional graphics primitive which represents a rectangular array of gray cells. \n\!\(\*RowBox[{\"Raster\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"11\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an array of RGB color cells. \n\!\(\*RowBox[{\"Raster\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"11\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an array of color cells with opacity \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"ij\", \"TI\"]]\). \n\!\(\*RowBox[{\"Raster\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"11\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an array of gray cells with the specified opacities. "
RationalFunctions::usage = "RationalFunctions represents the domain of rational functions."
Rationalize::usage = "\!\(\*RowBox[{\"Rationalize\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) converts an approximate number \!\(\*StyleBox[\"x\", \"TI\"]\) to a nearby rational with small denominator. \n\!\(\*RowBox[{\"Rationalize\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"dx\", \"TI\"]}], \"]\"}]\) yields the rational number with smallest denominator that lies within \!\(\*StyleBox[\"dx\", \"TI\"]\) of \!\(\*StyleBox[\"x\", \"TI\"]\)."
Rationals::usage = "Rationals represents the domain of rational numbers, as in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], StyleBox[\"\[Element]\", \"TR\"], \"Rationals\"}]\). "
Rational::usage = "Rational is the head used for rational numbers. "
Ratios::usage = "\!\(\*RowBox[{\"Ratios\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the successive ratios of elements in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Ratios\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) iterated ratios of \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Ratios\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the successive \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) ratios at level \!\(\*StyleBox[\"k\", \"TI\"]\) in a nested list. "
RawBoxes::usage = "\!\(\*RowBox[{RawBoxes, \"[\", StyleBox[\"boxes\", \"TI\"], \"]\"}]\) is a low-level construct which is formatted as \!\(\*StyleBox[\"boxes\", \"TI\"]\) without further interpretation. "
RawData::usage = "\!\(\*RowBox[{\"RawData\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) is a low-level representation of the contents of a cell in which \!\(\*StyleBox[\"Show Cell Expression\", \"MenuName\"]\) has been toggled."
RawMedium::usage = "RawMedium is an internal symbol."
RayleighDistribution::usage = "\!\(\*RowBox[{\"RayleighDistribution\", \"[\", StyleBox[\"\[Sigma]\", \"TR\"], \"]\"}]\) represents the Rayleigh distribution with scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
ReadLine::usage = "\!\(\*RowBox[{\"ReadLine\", \"[\", StyleBox[\"stream\", \"TI\"], \"]\"}]\) reads a line of text from a stream and returns it as a string.\n\!\(\*RowBox[{\"ReadLine\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) reads a line of text generated by an external process and returns it as a string."
ReadList::usage = "\!\(\*RowBox[{\"ReadList\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) reads all the remaining expressions in a file and returns a list of them. \n\!\(\*RowBox[{\"ReadList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) reads objects of the specified type from a file, until the end of the file is reached. The list of objects read is returned. \n\!\(\*RowBox[{\"ReadList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reads objects with a sequence of types, until the end of the file is reached. \n\!\(\*RowBox[{\"ReadList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"types\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) reads only the first \!\(\*StyleBox[\"n\", \"TI\"]\) objects of the specified types. "
ReadProtected::usage = "ReadProtected is an attribute that prevents values associated with a symbol from being seen. "
ReadString::usage = "\!\(\*RowBox[{\"ReadString\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) reads the complete contents of a file and returns it as a string.\n\!\(\*RowBox[{\"ReadString\", \"[\", StyleBox[\"stream\", \"TI\"], \"]\"}]\) reads everything from a stream and returns it as a string.\n\!\(\*RowBox[{\"ReadString\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) reads everything generated by an external process and returns it as a string.\n\!\(\*RowBox[{\"ReadString\", \"[\", RowBox[{StyleBox[\"src\", \"TI\"], \",\", StyleBox[\"term\", \"TI\"]}], \"]\"}]\) reads until the terminator \!\(\*StyleBox[\"term\", \"TI\"]\) is encountered."
Read::usage = "\!\(\*RowBox[{\"Read\", \"[\", StyleBox[\"stream\", \"TI\"], \"]\"}]\) reads one expression from an input stream and returns the expression. \n\!\(\*RowBox[{\"Read\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) reads one object of the specified type. \n\!\(\*RowBox[{\"Read\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reads a sequence of objects of the specified types. "
RealBlockDiagonalForm::usage = "RealBlockDiagonalForm is an option for SchurDecomposition and related functions which specifies whether 2\[Times]2 blocks of real values should be used on matrix diagonals in place of complex values."
RealBlockForm::usage = "RealBlockForm is an option of SchurDecomposition which specifies whether complex eigenvalues of a real input matrix should be returned as 2x2 real blocks or as complex values."
RealDigits::usage = "\!\(\*RowBox[{\"RealDigits\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives a list of the digits in the approximate real number \!\(\*StyleBox[\"x\", \"TI\"]\), together with the number of digits that are to the left of the decimal point. \n\!\(\*RowBox[{\"RealDigits\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives a list of base\[Hyphen]\!\(\*StyleBox[\"b\", \"TI\"]\) digits in \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"RealDigits\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"len\", \"TI\"]}], \"]\"}]\) gives a list of \!\(\*StyleBox[\"len\", \"TI\"]\) digits. \n\!\(\*RowBox[{\"RealDigits\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"len\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"len\", \"TI\"]\) digits starting with the coefficient of \!\(\*SuperscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). "
RealExponent::usage = "\!\(\*RowBox[{\"RealExponent\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives \!\(\*RowBox[{SubscriptBox[\"log\", \"10\"], \"(\", RowBox[{\"\[LeftBracketingBar]\", StyleBox[\"x\", \"TI\"], \"\[RightBracketingBar]\"}], \")\"}]\).\n\!\(\*RowBox[{\"RealExponent\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) gives \!\(\*RowBox[{SubscriptBox[\"log\", StyleBox[\"b\", \"TI\"]], \"(\", RowBox[{\"\[LeftBracketingBar]\", StyleBox[\"x\", \"TI\"], \"\[RightBracketingBar]\"}], \")\"}]\)."
Reals::usage = "Reals represents the domain of real numbers, as in \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], StyleBox[\"\[Element]\", \"TR\"], \"Reals\"}]\). "
Real::usage = "Real is the head used for real (floating\[Hyphen]point) numbers. "
Reap::usage = "\!\(\*RowBox[{\"Reap\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives the value of \!\(\*StyleBox[\"expr\", \"TI\"]\) together with all expressions to which Sow has been applied during its evaluation. Expressions sown using \!\(\*RowBox[{\"Sow\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) or \!\(\*RowBox[{\"Sow\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", SubscriptBox[StyleBox[\"tag\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"]\"}]\) with different tags are given in different lists. \n\!\(\*RowBox[{\"Reap\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) reaps only expressions sown with tags that match \!\(\*StyleBox[\"patt\", \"TI\"]\). \n\!\(\*RowBox[{\"Reap\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) puts expressions associated with each of the \!\(\*SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in a separate list. \n\!\(\*RowBox[{\"Reap\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) returns \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"tag\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]\). "
RecognitionPrior::usage = "RecognitionPrior is an option for ImageInstanceQ and related functions that specifies the prior probability to assume for the function to give True."
RecognitionThreshold::usage = "RecognitionThreshold is an option for ImageInstanceQ and related functions that specifies the minimum estimated probability at which recognition is considered acceptable. "
RecordLists::usage = "RecordLists is an option for ReadList that specifies whether objects from separate records should be returned in separate sublists. "
RecordSeparators::usage = "RecordSeparators is an option for Read, Find, and related functions that specifies the list of strings to be taken as delimiters for records. "
Record::usage = "Record represents a record in Read, Find, and related functions. "
RectangleBoxOptions::usage = "\!\(\*RowBox[{RectangleBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for RectangleBox objects."
RectangleChart3D::usage = "\!\(\*RowBox[{\"RectangleChart3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D rectangle chart with bars of width \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), depth \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and height \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"RectangleChart3D\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"j\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D rectangle chart with bar features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"RectangleChart3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D rectangle chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
RectangleChart::usage = "\!\(\*RowBox[{\"RectangleChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a rectangle chart with bars of width \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and height \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"RectangleChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a rectangle chart with bar features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"RectangleChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a rectangle chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
Rectangle::usage = "\!\(\*RowBox[{\"Rectangle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents an axis-aligned filled rectangle from \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}]\) to \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"Rectangle\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}], \"]\"}]\) corresponds to a unit square with its bottom-left corner at \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}]\)."
RecurrenceFilter::usage = "\!\(\*RowBox[{\"RecurrenceFilter\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"x\", \"TI\"]\) using a linear recurrence equation with coefficients \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"RecurrenceFilter\", \"[\", RowBox[{StyleBox[\"tf\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) uses a discrete-time filter defined by the TransferFunctionModel \!\(\*StyleBox[\"tf\", \"TI\"]\).\n\!\(\*RowBox[{\"RecurrenceFilter\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses a specified list \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) as the initial condition.\n\!\(\*RowBox[{\"RecurrenceFilter\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"image\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"RecurrenceFilter\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"sound\", \"TI\"]}], \"]\"}]\) filters sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
RecurrenceTable::usage = "\!\(\*RowBox[{\"RecurrenceTable\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a list of values of \!\(\*StyleBox[\"expr\", \"TI\"]\) for successive \!\(\*StyleBox[\"n\", \"TI\"]\) based on solving the recurrence equations \!\(\*StyleBox[\"eqns\", \"TI\"]\).\n\!\(\*RowBox[{\"RecurrenceTable\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"nspec\", \"TI\"]}], \"]\"}]\) generates a list of values of \!\(\*StyleBox[\"expr\", \"TI\"]\) over the range of \!\(\*StyleBox[\"n\", \"TI\"]\) values specified by \!\(\*StyleBox[\"nspec\", \"TI\"]\).\n\!\(\*RowBox[{\"RecurrenceTable\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) generates an array of values of \!\(\*StyleBox[\"expr\", \"TI\"]\) for successive \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] ."
Reduce::usage = "\!\(\*RowBox[{\"Reduce\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) reduces the statement \!\(\*StyleBox[\"expr\", \"TI\"]\) by solving equations or inequalities for \!\(\*StyleBox[\"vars\", \"TI\"]\) and eliminating quantifiers. \n\!\(\*RowBox[{\"Reduce\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) does the reduction over the domain \!\(\*StyleBox[\"dom\", \"TI\"]\). Common choices of \!\(\*StyleBox[\"dom\", \"TI\"]\) are Reals, Integers, and Complexes. "
Red::usage = "Red represents the color red in graphics or style specifications. "
ReferenceLineStyle::usage = "ReferenceLineStyle is an option for QuantilePlot and similar functions that specifies the style used for the reference line. "
Refine::usage = "\!\(\*RowBox[{\"Refine\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"assum\", \"TI\"]}], \"]\"}]\) gives the form of \!\(\*StyleBox[\"expr\", \"TI\"]\) that would be obtained if symbols in it were replaced by explicit numerical expressions satisfying the assumptions \!\(\*StyleBox[\"assum\", \"TI\"]\). \n\!\(\*RowBox[{\"Refine\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) uses default assumptions specified by any enclosing Assuming constructs. "
ReflectionMatrix::usage = "\!\(\*RowBox[{\"ReflectionMatrix\", \"[\", StyleBox[\"v\", \"TI\"], \"]\"}]\) gives the matrix that represents reflection of points in a mirror normal to the vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
ReflectionTransform::usage = "\!\(\*RowBox[{\"ReflectionTransform\", \"[\", StyleBox[\"v\", \"TI\"], \"]\"}]\) gives a TransformationFunction that represents a reflection in a mirror through the origin, normal to the vector \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"ReflectionTransform\", \"[\", RowBox[{StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives a reflection in a mirror through the point \!\(\*StyleBox[\"p\", \"TI\"]\), normal to the vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
RefreshRate::usage = "RefreshRate is an option to Animate and related functions which specifies the refresh rate for frames in animations."
Refresh::usage = "\!\(\*RowBox[{\"Refresh\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) represents an object whose value in a Dynamic should be refreshed at times specified by the options \!\(\*StyleBox[\"opts\", \"TI\"]\). \n\!\(\*RowBox[{\"Refresh\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"None\"}], \"]\"}]\) specifies that the value of \!\(\*StyleBox[\"expr\", \"TI\"]\) should never automatically be refreshed. "
RegionBinarize::usage = "\!\(\*RowBox[{\"RegionBinarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives a binary version of \!\(\*StyleBox[\"image\", \"TI\"]\) that includes the foreground pixels of \!\(\*StyleBox[\"marker\", \"TI\"]\) and also connected regions whose pixel values are within a distance \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"RegionBinarize\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) grows regions in \!\(\*StyleBox[\"marker\", \"TI\"]\) by adding pixels whose average intensity is also constrained within an interval \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\)."
RegionBoundary::usage = "\!\(\*RowBox[{\"RegionBoundary\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) represents the boundary of the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
RegionBounds::usage = "\!\(\*RowBox[{\"RegionBounds\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives the bounds for the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"RegionBounds\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives region bounds of the specified \"\!\(\*\nStyleBox[\"type\", \"TI\"]\)\". "
RegionCentroid::usage = "\!\(\*RowBox[{\"RegionCentroid\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives the centroid of the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
RegionDifference::usage = "\!\(\*RowBox[{\"RegionDifference\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) represents the region difference of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
RegionDimension::usage = "\!\(\*RowBox[{\"RegionDimension\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives the geometric dimension of the region \!\(\*StyleBox[\"reg\", \"TI\"]\). "
RegionDistanceFunction::usage = "\!\(\*RowBox[{RowBox[{\"RegionDistanceFunction\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \" \"}]\) represents a function whose values give the distance from a point to the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
RegionDistance::usage = "\!\(\*RowBox[{\"RegionDistance\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the minimum distance from the point \!\(\*StyleBox[\"p\", \"TI\"]\) to the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"RegionDistance\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives a \!\(\*RowBox[{\"RegionDistanceFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied repeatedly to different points."
RegionEmbeddingDimension::usage = "\!\(\*RowBox[{\"RegionEmbeddingDimension\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives the dimension of the space in which the region \!\(\*StyleBox[\"reg\", \"TI\"]\) is embedded. "
RegionFunction::usage = "RegionFunction is an option for plotting functions that specifies the region to include in the plot drawn. "
RegionIntersection::usage = "\!\(\*RowBox[{\"RegionIntersection\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) represents the intersection of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"RegionIntersection\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the intersection of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
RegionMeasure::usage = "\!\(\*RowBox[{\"RegionMeasure\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives the measure of the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"RegionMeasure\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"d\", \"TI\"]\)-dimensional measure of the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
RegionMemberFunction::usage = "\!\(\*RowBox[{RowBox[{\"RegionMemberFunction\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \" \"}]\) represents a function whose values give whether a point is in a region \!\(\*StyleBox[\"reg\", \"TI\"]\) or not."
RegionMember::usage = "\!\(\*RowBox[{\"RegionMember\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], StyleBox[\",\", \"TI\"], RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives True if the numeric point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) is a member of the constant region \!\(\*StyleBox[\"reg\", \"TI\"]\) and False otherwise.\n\!\(\*RowBox[{\"RegionMember\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives conditions for the point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) to be a member of \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"RegionMember\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) returns a \!\(\*RowBox[{\"RegionMemberFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied repeatedly to different points. "
RegionNearestFunction::usage = "\!\(\*RowBox[{RowBox[{\"RegionNearestFunction\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \" \"}]\) represents a function whose values give the nearest point in the region \!\(\*StyleBox[\"reg\", \"TI\"]\)."
RegionNearest::usage = "\!\(\*RowBox[{\"RegionNearest\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives a point in the region \!\(\*StyleBox[\"reg\", \"TI\"]\) that is nearest the point \!\(\*StyleBox[\"p\", \"TI\"]\). \n\!\(\*RowBox[{\"RegionNearest\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives a \!\(\*RowBox[{\"RegionNearestFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be repeatedly applied to points. "
RegionPlot3D::usage = "\!\(\*RowBox[{\"RegionPlot3D\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) makes a plot showing the three-dimensional region in which \!\(\*StyleBox[\"pred\", \"TI\"]\) is True. "
RegionPlot::usage = "\!\(\*RowBox[{\"RegionPlot\", \"[\", RowBox[{StyleBox[\"pred\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) makes a plot showing the region in which \!\(\*StyleBox[\"pred\", \"TI\"]\) is True. "
RegionProduct::usage = "\!\(\*RowBox[{\"RegionProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) represents the Cartesian product of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"RegionProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the Cartesian product of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
RegionQ::usage = "\!\(\*RowBox[{\"RegionQ\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"reg\", \"TI\"]\) is a valid region and False otherwise. "
RegionSymmetricDifference::usage = "\!\(\*RowBox[{\"RegionSymmetricDifference\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) represents the symmetric difference of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"RegionSymmetricDifference\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the symmetric difference of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
RegionUnion::usage = "\!\(\*RowBox[{\"RegionUnion\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) represents the union of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"RegionUnion\", \"[\", RowBox[{SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the union of the regions \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"reg\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
RegressionCommon`AdjustedRSquared::usage = "AdjustedRSquared is a possible value for the RegressionReport option to Regress and DesignedRegress which represents the adjusted coefficient of determination."
RegressionCommon`ANOVATable::usage = "ANOVATable is a possible value for the RegressionReport option for regression functions which represents the analysis of variance table."
RegressionCommon`AsymptoticCorrelationMatrix::usage = "AsymptoticCorrelationMatrix is a possible value for the RegressionReport option for NonlinearRegress which represents the estimated correlation matrix of the fit parameters."
RegressionCommon`AsymptoticCovarianceMatrix::usage = "AsymptoticCovarianceMatrix is a possible value for the RegressionReport option for NonlinearRegress which represents the estimated covariance matrix of the fit parameters."
RegressionCommon`BestFitParametersDelta::usage = "BestFitParametersDelta is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the effect on parameter values if data points are omitted."
RegressionCommon`BestFitParameters::usage = "BestFitParameters is a possible value for the RegressionReport option which represents the fitted parameter vector."
RegressionCommon`BestFit::usage = "BestFit is a possible value for the RegressionReport option which represents the fitted function."
RegressionCommon`CatcherMatrix::usage = "CatcherMatrix is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the catcher matrix."
RegressionCommon`CoefficientOfVariation::usage = "CoefficientOfVariation is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the coefficient of variation."
RegressionCommon`CookD::usage = "CookD is a possible value for the RegressionReport option for Regress and DesignedRegress which represents a list of Cook's distances."
RegressionCommon`CorrelationMatrix::usage = "CorrelationMatrix is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the estimated correlation matrix of the fit parameters."
RegressionCommon`CovarianceMatrixDetRatio::usage = "CovarianceMatrixDetRatio is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the covariance determinant ratio diagnostic."
RegressionCommon`CovarianceMatrix::usage = "CovarianceMatrix is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the estimated covariance matrix of the fit parameters."
RegressionCommon`DurbinWatsonD::usage = "DurbinWatsonD is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the Durbin-Watson \!\(\*StyleBox[\"d\", \"TI\"]\) statistic for autocorrelation."
RegressionCommon`EigenstructureTable::usage = "EigenstructureTable is a possible value for the RegressionReport option for Regress and DesignedRegress which represents tabular information about the eigenstructure of the parameter correlation matrix."
RegressionCommon`Ellipsoid::usage = "\!\(\*RowBox[{\"Ellipsoid\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a \!\(\*StyleBox[\"p\", \"TI\"]\)-dimensional ellipsoid centered at the point \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]\) with semi-axis radii \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) aligned with the coordinate axes.\n\!\(\*RowBox[{\"Ellipsoid\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a \!\(\*StyleBox[\"p\", \"TI\"]\)-dimensional ellipsoid with semi-axis radii \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) aligned with the direction \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
RegressionCommon`EstimatedVariance::usage = "EstimatedVariance is a possible value for the RegressionReport option which represents the estimated error variance."
RegressionCommon`FitCurvatureTable::usage = "FitCurvatureTable is a possible value for the RegressionReport option for NonlinearRegress which represents a table of curvature diagnostics."
RegressionCommon`FitResiduals::usage = "FitResiduals is a possible value for the RegressionReport option which represents the residual errors for the fitted values."
RegressionCommon`HatDiagonal::usage = "HatDiagonal is a possible value for the RegressionReport option which represents the diagonal of the hat matrix."
RegressionCommon`JackknifedVariance::usage = "JackknifedVariance is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the list of jackknifed variance estimates."
RegressionCommon`MeanPredictionCITable::usage = "MeanPredictionCITable is a possible value for the RegressionReport option which represents a table of confidence intervals for the mean predicted responses."
RegressionCommon`ParameterBias::usage = "ParameterBias is a possible value for the RegressionReport option for NonlinearRegress which represents the estimated bias in the parameter estimates."
RegressionCommon`ParameterCITable::usage = "ParameterCITable is a possible value for the RegressionReport option which represents a table of confidence interval information for the fitted parameters."
RegressionCommon`ParameterConfidenceRegion::usage = "ParameterConfidenceRegion is a possible value for the RegressionReport option which represents the elliptically shaped joint confidence region for parameter estimates."
RegressionCommon`ParameterTable::usage = "ParameterTable is a possible value for the RegressionReport option which represents a table of fitted parameter information."
RegressionCommon`PartialSumOfSquares::usage = "PartialSumOfSquares is a possible value for the RegressionReport option to Regress and DesignedRegress which represents the change in the model sum of squares as nonconstant basis functions are removed."
RegressionCommon`PredictedResponseDelta::usage = "PredictedResponseDelta is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the effect on predicted values if data points are omitted."
RegressionCommon`PredictedResponse::usage = "PredictedResponse is a possible value for the RegressionReport option which represents the fitted values for the data."
RegressionCommon`RegressionReport::usage = "RegressionReport is an option for Regress, DesignedRegress and NonlinearRegress which specifies the report values to return."
RegressionCommon`RegressionReportValues::usage = "\!\(\*RowBox[{\"RegressionReportValues\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives a list of the possible report values for the regression function \!\(\*StyleBox[\"f\", \"TI\"]\)."
RegressionCommon`RSquared::usage = "RSquared is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the coefficient of determination \!\(\*SuperscriptBox[\"R\", StyleBox[\"2\", \"TR\"]]\)."
RegressionCommon`SequentialSumOfSquares::usage = "SequentialSumOfSquares is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the model sum of squares partitioned componentwise."
RegressionCommon`SinglePredictionCITable::usage = "SinglePredictionCITable is a possible value for the RegressionReport option which represents a table of confidence intervals for the predicted response of single observations."
RegressionCommon`StandardizedResiduals::usage = "StandardizedResiduals is a possible value for the RegressionReport option which represents the list of standardized residuals."
RegressionCommon`StartingParameters::usage = "StartingParameters is a possible value for the RegressionReport option for NonlinearRegress which represents the starting point in the optimization."
RegressionCommon`StudentizedResiduals::usage = "StudentizedResiduals is a possible value for the RegressionReport option for Regress and DesignedRegress which represents the list of studentized residuals."
RegressionCommon`SummaryReport::usage = "SummaryReport is a possible value for the RegressionReport option for regression functions."
RegressionCommon`VarianceInflation::usage = "VarianceInflation is a possible value for the RegressionReport option for Regress and DesignedRegress that represents variance inflation factors."
RegularExpression::usage = "\!\(\*RowBox[{\"RegularExpression\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"regex\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents the generalized regular expression specified by the string \"\!\(\*\nStyleBox[\"regex\", \"TI\"]\)\". "
Regularization::usage = "Regularization is an option for Sum and Product that specifies what type of regularization to use."
RegularlySampledQ::usage = "\!\(\*RowBox[{\"RegularlySampledQ\", \"[\", StyleBox[\"tseries\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"tseries\", \"TI\"]\) is a regular time series, and False otherwise."
RegularPolygon::usage = "\!\(\*RowBox[{\"RegularPolygon\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the regular polygon with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices equally spaced around the unit circle.\n\!\(\*RowBox[{\"RegularPolygon\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the regular polygon of radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"RegularPolygon\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) starts at angle \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) with respect to the \!\(\*StyleBox[\"x\", \"TI\"]\) axis.\n\!\(\*RowBox[{\"RegularPolygon\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"rspec\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) centers the polygon at \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\)."
ReIm::usage = "\!\(\*RowBox[{\"ReIm\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the list \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"Re\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}], \",\", RowBox[{\"Im\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]}], \"}\"}]\) of the number \!\(\*StyleBox[\"z\", \"TI\"]\)."
Reinstall::usage = "\!\(\*RowBox[{\"Reinstall\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) un-installs the specified external package and installs it again."
RelationGraph::usage = "\!\(\*RowBox[{\"RelationGraph\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the graph with vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and edges from \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) whenever \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"j\", \"TI\"]]}], \"]\"}]\) is True.\n\!\(\*RowBox[{\"RelationGraph\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the graph with vertices \!\(\*RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]]}]\) and edges from \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) whenever \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]]}], \"]\"}]\) is True."
ReleaseHold::usage = "\!\(\*RowBox[{\"ReleaseHold\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) removes Hold, HoldForm, HoldPattern, and HoldComplete in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
ReliabilityDistribution::usage = "\!\(\*RowBox[{\"ReliabilityDistribution\", \"[\", RowBox[{StyleBox[\"bexpr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the reliability distribution for a system with components \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) having reliability distribution \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), where the whole system is working when the Boolean expression \!\(\*StyleBox[\"bexpr\", \"TI\"]\) is True, and component \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is working when \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is True."
ReliefImage::usage = "\!\(\*RowBox[{\"ReliefImage\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a relief image of an array of height values. "
ReliefPlot::usage = "\!\(\*RowBox[{\"ReliefPlot\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) generates a relief plot of an array of height values. "
RemoveAlphaChannel::usage = "\!\(\*RowBox[{\"RemoveAlphaChannel\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) removes all opacity information from \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"RemoveAlphaChannel\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) removes opacity by blending all pixels with the background color \!\(\*StyleBox[\"c\", \"TI\"]\)."
RemoveAsynchronousTask::usage = "\!\(\*RowBox[{\"RemoveAsynchronousTask\", \"[\", StyleBox[\"asyncTask\", \"TI\"], \"]\"}]\) stops asynchronous evaluations and removes \!\(\*StyleBox[\"asyncTask\", \"TI\"]\) from the system."
RemoveBackground::usage = "\!\(\*RowBox[{\"RemoveBackground\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) returns an image with an alpha channel where the background is transparent. \n\!\(\*RowBox[{\"RemoveBackground\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"model\", \"TI\"]}], \"]\"}]\) uses foreground or background \!\(\*StyleBox[\"model\", \"TI\"]\) specification."
RemoveDiacritics::usage = "\!\(\*RowBox[{\"RemoveDiacritics\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) replaces characters in \!\(\*StyleBox[\"string\", \"TI\"]\) that have diacritics by their base ASCII characters, when possible."
Removed::usage = "\!\(\*RowBox[{\"Removed\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) is printed to indicate a symbol that has been removed."
RemoveInputStreamMethod::usage = "\!\(\*RowBox[{\"RemoveInputStreamMethod\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) removes a custom input stream method."
RemoveOutputStreamMethod::usage = "\!\(\*RowBox[{\"RemoveOutputStreamMethod\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) removes a custom output stream method."
RemoveProperty::usage = "\!\(\*RowBox[{\"RemoveProperty\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"itemspec\", \"TI\"]}], \"}\"}], \"]\"}]\) removes all properties associated with \!\(\*StyleBox[\"itemspec\", \"TI\"]\) in \!\(\*StyleBox[\"obj\", \"TI\"]\).\n\!\(\*RowBox[{\"RemoveProperty\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"itemspec\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) removes the property \!\(\*StyleBox[\"name\", \"TI\"]\) associated with \!\(\*StyleBox[\"itemspec\", \"TI\"]\) in \!\(\*StyleBox[\"obj\", \"TI\"]\)."
RemoveScheduledTask::usage = "\!\(\*RowBox[{\"RemoveScheduledTask\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) removes \!\(\*StyleBox[\"obj\", \"TI\"]\) from the list of currently scheduled local or cloud tasks."
Remove::usage = "\!\(\*RowBox[{\"Remove\", \"[\", RowBox[{SubscriptBox[StyleBox[\"symbol\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) removes symbols completely, so that their names are no longer recognized by \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\"]\). \n\!\(\*RowBox[{\"Remove\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) removes all symbols whose names match any of the string patterns \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
RemoveUsers::usage = "\!\(\*RowBox[{\"RemoveUsers\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) removes the users \!\(\*SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) from the permissions group \!\(\*StyleBox[\"group\", \"TI\"]\)."
RenameDirectory::usage = "\!\(\*RowBox[{\"RenameDirectory\", \"[\", RowBox[{SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) renames the directory \!\(\*SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
RenameFile::usage = "\!\(\*RowBox[{\"RenameFile\", \"[\", RowBox[{SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) renames \!\(\*SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"file\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
RenderAll::usage = "RenderAll is an option for Graphics3D that specifies whether or not PostScript should be generated for \!\(\*StyleBox[\"all\", \"TI\"]\) polygons. "
RenewalProcess::usage = "\!\(\*RowBox[{\"RenewalProcess\", \"[\", StyleBox[\"rdist\", \"TI\"], \"]\"}]\) represents a renewal process with interarrival times distributed according to \!\(\*StyleBox[\"rdist\", \"TI\"]\)."
RenkoChart::usage = "\!\(\*RowBox[{\"RenkoChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a Renko chart with prices \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at date \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"RenkoChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"daterange\", \"TI\"]}], \"}\"}], \"]\"}]\) makes a Renko chart of closing prices for the financial entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" over the date range \!\(\*StyleBox[\"daterange\", \"TI\"]\).\n\!\(\*RowBox[{\"RenkoChart\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) makes a Renko chart with brick height of fraction \!\(\*StyleBox[\"s\", \"TI\"]\) of the average price."
RepeatedNull::usage = "\!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"...\"}]\) or \!\(\*RowBox[{\"RepeatedNull\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) is a pattern object that represents a sequence of zero or more expressions, each matching \!\(\*StyleBox[\"p\", \"TI\"]\). "
RepeatedString::usage = "RepeatedString is an internal symbol used for formatting and printing."
RepeatedTiming::usage = "\!\(\*RowBox[{\"RepeatedTiming\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) repeatedly and returns a list of the average time in seconds used, together with the result obtained.\n\!\(\*RowBox[{\"RepeatedTiming\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) does repeated evaluation for at least \!\(\*StyleBox[\"t\", \"TI\"]\) seconds. "
Repeated::usage = "\!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"..\"}]\) or \!\(\*RowBox[{\"Repeated\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) is a pattern object that represents a sequence of one or more expressions, each matching\[NonBreakingSpace]\!\(\*StyleBox[\"p\", \"TI\"]\). \n\!\(\*RowBox[{\"Repeated\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"]\"}]\) represents up to \!\(\*StyleBox[\"max\", \"TI\"]\) expressions matching \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"Repeated\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents between \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*StyleBox[\"max\", \"TI\"]\) expressions matching \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"Repeated\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) represents exactly \!\(\*StyleBox[\"n\", \"TI\"]\) expressions matching \!\(\*StyleBox[\"p\", \"TI\"]\)."
RepeatingElement::usage = "\!\(\*RowBox[{\"RepeatingElement\", \"[\", StyleBox[\"spec\", \"TI\"], \"]\"}]\) represents an element that can be arbitrarily repeated in an interpreter or form specification.\n\!\(\*RowBox[{\"RepeatingElement\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"]\"}]\) represents an element that can appear at most \!\(\*StyleBox[\"max\", \"TI\"]\) times in a form.\n\!\(\*RowBox[{\"RepeatingElement\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents an element that can appear between \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*StyleBox[\"max\", \"TI\"]\) times.\n\!\(\*RowBox[{\"RepeatingElement\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) represents an element that initially appears \!\(\*StyleBox[\"n\", \"TI\"]\) times in a form.\n\!\(\*RowBox[{\"RepeatingElement\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) represents an element where \!\(\*StyleBox[\"i\", \"TI\"]\) takes successive values."
ReplaceAll::usage = "\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"/.\", StyleBox[\"rules\", \"TI\"]}]\) applies a rule or list of rules in an attempt to transform each subpart of an expression \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"ReplaceAll\", \"[\", StyleBox[\"rules\", \"TI\"], \"]\"}]\) represents an operator form of ReplaceAll that can be applied to an expression."
ReplaceImageValue::usage = "\!\(\*RowBox[{\"ReplaceImageValue\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"pos\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}]}], \"]\"}]\) changes the pixel values at position \!\(\*StyleBox[\"pos\", \"TI\"]\) in \!\(\*StyleBox[\"image\", \"TI\"]\) to \!\(\*StyleBox[\"val\", \"TI\"]\).\n\!\(\*RowBox[{\"ReplaceImageValue\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"pos\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) assumes \!\(\*StyleBox[\"val\", \"TI\"]\) to be of the specified type."
ReplaceList::usage = "\!\(\*RowBox[{\"ReplaceList\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"rules\", \"TI\"]}], \"]\"}]\) attempts to transform the entire expression \!\(\*StyleBox[\"expr\", \"TI\"]\) by applying a rule or list of rules in all possible ways, and returns a list of the results obtained. \n\!\(\*RowBox[{\"ReplaceList\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"rules\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of at most \!\(\*StyleBox[\"n\", \"TI\"]\) results. "
ReplacePart::usage = "\!\(\*RowBox[{\"ReplacePart\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"i\", \"TI\"], \"\[Rule]\", StyleBox[\"new\", \"TI\"]}]}], \"]\"}]\) yields an expression in which the \!\(\*StyleBox[RowBox[{StyleBox[\"i\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) part of \!\(\*StyleBox[\"expr\", \"TI\"]\) is replaced by \!\(\*StyleBox[\"new\", \"TI\"]\). \n\!\(\*RowBox[{\"ReplacePart\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"new\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"new\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) replaces parts at positions \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"n\", \"TI\"]]\) by \!\(\*SubscriptBox[StyleBox[\"new\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"ReplacePart\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", StyleBox[\"new\", \"TI\"]}]}], \"]\"}]\) replaces the part at position \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"ReplacePart\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", SubscriptBox[StyleBox[\"new\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) replaces parts at positions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) by \!\(\*SubscriptBox[StyleBox[\"new\", \"TI\"], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"ReplacePart\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", StyleBox[\"new\", \"TI\"]}]}], \"]\"}]\) replaces all parts at positions \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) by \!\(\*StyleBox[\"new\", \"TI\"]\). \n\!\(\*RowBox[{\"ReplacePart\", \"[\", StyleBox[RowBox[{\"i\", StyleBox[\"\[Rule]\", FontSlant -> \"Plain\"], \"new\"}], \"TI\"], \"]\"}]\) represents an operator form of ReplacePart that can be applied to an expression."
ReplacePixelValue::usage = "\!\(\*RowBox[{\"ReplacePixelValue\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"ppos\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}]}], \"]\"}]\) changes the pixel values at pixel position \!\(\*StyleBox[\"ppos\", \"TI\"]\) in \!\(\*StyleBox[\"image\", \"TI\"]\) to \!\(\*StyleBox[\"val\", \"TI\"]\).\n\!\(\*RowBox[{\"ReplacePixelValue\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", RowBox[{StyleBox[\"ppos\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) assumes \!\(\*StyleBox[\"val\", \"TI\"]\) to be of the specified type."
ReplaceRepeated::usage = "\!\(\*RowBox[{StyleBox[\"expr\", \"TI\"], \"//.\", StyleBox[\"rules\", \"TI\"]}]\) repeatedly performs replacements until \!\(\*StyleBox[\"expr\", \"TI\"]\) no longer changes. "
Replace::usage = "\!\(\*RowBox[{\"Replace\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"rules\", \"TI\"]}], \"]\"}]\) applies a rule or list of rules in an attempt to transform the entire expression \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Replace\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"rules\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) applies rules to parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"Replace\", \"[\", StyleBox[\"rules\", \"TI\"], \"]\"}]\) represents an operator form of Replace that can be applied to an expression."
RequiredPhysicalQuantities::usage = "RequiredPhysicalQuantities is an option for FormulaLookup that specifies physical quantities that must be used by the formulas returned."
ResamplingAlgorithmData::usage = "\!\(\*RowBox[{\"ResamplingAlgorithmData\", \"[\", RowBox[{StyleBox[\"rs\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\" for the resampling \!\(\*StyleBox[\"rs\", \"TI\"]\)."
ResamplingMethod::usage = "ResamplingMethod is an option for functions such as TemporalData and MovingMap that specifies how values in between given times should be computed."
Resampling::usage = "Resampling is an option that specifies the method to be used for resampling images or arrays."
Rescale::usage = "\!\(\*RowBox[{\"Rescale\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*StyleBox[\"x\", \"TI\"]\) rescaled to run from 0 to 1 over the range \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\). \n\!\(\*RowBox[{\"Rescale\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives \!\(\*StyleBox[\"x\", \"TI\"]\) rescaled to run from \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) over the range \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\). \n\!\(\*RowBox[{\"Rescale\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) rescales each element of \!\(\*StyleBox[\"list\", \"TI\"]\) to run from 0 to 1 over the range \!\(\*RowBox[{\"Min\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) to \!\(\*RowBox[{\"Max\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\). "
RescalingTransform::usage = "\!\(\*RowBox[{\"RescalingTransform\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"xp\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"xp\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a TransformationFunction that rescales the region with coordinate ranges \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\), etc. to the region with coordinate ranges \!\(\*SubscriptBox[StyleBox[\"xp\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"xp\", \"TI\"], StyleBox[\"max\", \"TI\"]]\), etc.\n\!\(\*RowBox[{\"RescalingTransform\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a TransformationFunction that rescales to the unit square, cube, etc."
ResetDirectory::usage = "\!\(\*RowBox[{\"ResetDirectory\", \"[\", \"]\"}]\) resets the current working directory to its previous value. "
ResetScheduledTask::usage = "\!\(\*RowBox[{RowBox[{\"ResetScheduledTask\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"]}], \"]\"}], \" \"}]\) resets the timing for a scheduled task to \!\(\*StyleBox[\"timespec\", \"TI\"]\).\n\!\(\*RowBox[{\"ResetScheduledTask\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"], \",\", StyleBox[\"offset\", \"TI\"]}], \"]\"}]\) resets the time offset for a scheduled task to \!\(\*StyleBox[\"offset\", \"TI\"]\)."
Residue::usage = "\!\(\*RowBox[{\"Residue\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) finds the residue of \!\(\*StyleBox[\"expr\", \"TI\"]\) at the point \!\(\*RowBox[{StyleBox[\"z\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\). "
Resolve::usage = "\!\(\*RowBox[{\"Resolve\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) attempts to resolve \!\(\*StyleBox[\"expr\", \"TI\"]\) into a form that eliminates ForAll and Exists quantifiers. \n\!\(\*RowBox[{\"Resolve\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) works over the domain \!\(\*StyleBox[\"dom\", \"TI\"]\). Common choices of \!\(\*StyleBox[\"dom\", \"TI\"]\) are Complexes, Reals, and Booleans. "
ResonanceAbsorptionLines`AirWavelength::usage = "\!\(\*RowBox[{\"AirWavelength\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"a\", \"TI\"]]}], \"}\"}]\) pairs, where \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]]\) is the wavelength in vacuum and \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"a\", \"TI\"]]\) is the wavelength in air, for the resonance absorption lines produced by element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"AirWavelength\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives wavelengths for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`AtomicData::usage = "\!\(\*RowBox[{\"AtomicData\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives the spectral data of the resonance absorption lines produced by element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"AtomicData\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives the data for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\). "
ResonanceAbsorptionLines`DampingConstant::usage = "\!\(\*RowBox[{\"DampingConstant\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]], \",\", StyleBox[\"damping\", \"TI\"]}], \"}\"}]\) pairs, where \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]]\) is the wavelength in vacuum and \!\(\*StyleBox[\"damping\", \"TI\"]\) is the natural damping constant of the resonance absorption lines produced by element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"DampingConstant\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives a list of pairs for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`Deuterium::usage = "Deuterium is an isotope of hydrogen."
ResonanceAbsorptionLines`ElementAbsorptionMap::usage = "\!\(\*RowBox[{\"ElementAbsorptionMap\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) generates a plot of the absorption map of the element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"ElementAbsorptionMap\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) generates a plot for the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`FindIons::usage = "\!\(\*RowBox[{\"FindIons\", \"[\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the resonance absorption lines in the wavelength range between \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ResonanceAbsorptionLines`IonStage::usage = "IonStage is the ionization level of the element producing resonance absorption lines."
ResonanceAbsorptionLines`LowerStatisticalWeight::usage = "\!\(\*RowBox[{\"LowerStatisticalWeight\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]], \",\", StyleBox[\"weight\", \"TI\"]}], \"}\"}]\) pairs, where \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]]\) is the wavelength in vacuum and \!\(\*StyleBox[\"weight\", \"TI\"]\) is the statistical weight of the lower level of the resonance absorption lines produced by element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"LowerStatisticalWeight\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives a list of pairs for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`LowerTermFineStructureEnergy::usage = "\!\(\*RowBox[{\"LowerTermFineStructureEnergy\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]], \",\", StyleBox[\"energy\", \"TI\"]}], \"}\"}]\) pairs, where \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]]\) is the wavelength in vacuum and \!\(\*StyleBox[\"energy\", \"TI\"]\) is the energy of the fine-structure level in the lower term of the resonance absorption lines produced by element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"LowerTermFineStructureEnergy\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives a list of pairs for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`OscillatorStrength::usage = "\!\(\*RowBox[{\"OscillatorStrength\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]], \",\", StyleBox[\"strength\", \"TI\"]}], \"}\"}]\) pairs, where \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]]\) is the wavelength in vacuum and \!\(\*StyleBox[\"strength\", \"TI\"]\) is the oscillator strength of the resonance absorption lines produced by element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"OscillatorStrength\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives a list of pairs for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`RelativeStrength::usage = "\!\(\*RowBox[{\"RelativeStrength\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]], \",\", StyleBox[\"strength\", \"TI\"]}], \"}\"}]\) pairs, where \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]]\) is the wavelength in vacuum and \!\(\*StyleBox[\"strength\", \"TI\"]\) is the relative strength of the resonance absorption lines in the multiplets produced by element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"RelativeStrength\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of pairs for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`TransitionProbability::usage = "\!\(\*RowBox[{\"TransitionProbability\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]], \",\", StyleBox[\"prob\", \"TI\"]}], \"}\"}]\) pairs, where \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]]\) is the wavelength in vacuum and \!\(\*StyleBox[\"prob\", \"TI\"]\) is the spontaneous transition probability of the resonance absorption lines produced by the element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"TransitionProbability\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives a list of pairs for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`UpperStatisticalWeight::usage = "\!\(\*RowBox[{\"UpperStatisticalWeight\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]], \",\", StyleBox[\"weight\", \"TI\"]}], \"}\"}]\) pairs, where \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"v\", \"TI\"]]\) is the wavelength in vacuum and \!\(\*StyleBox[\"weight\", \"TI\"]\) is the statistical weight of the upper level of the resonance absorption lines produced by element \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"UpperStatisticalWeight\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives a list of pairs for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`VacuumWavelength::usage = "\!\(\*RowBox[{\"VacuumWavelength\", \"[\", StyleBox[\"element\", \"TI\"], \"]\"}]\) gives a list of the wavelengths in vacuum of the resonance absorption lines produced by the specified \!\(\*StyleBox[\"element\", \"TI\"]\).\n\!\(\*RowBox[{\"VacuumWavelength\", \"[\", RowBox[{StyleBox[\"element\", \"TI\"], \",\", StyleBox[\"ionstage\", \"TI\"]}], \"]\"}]\) gives the wavelength in vacuum for the lines of the ionization level \!\(\*StyleBox[\"ionstage\", \"TI\"]\)."
ResonanceAbsorptionLines`WavelengthAbsorptionMap::usage = "\!\(\*RowBox[{\"WavelengthAbsorptionMap\", \"[\", RowBox[{SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) generates a plot of the absorption map in the wavelength range between \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"wavelength\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
ResponseForm::usage = "\!\(\*RowBox[{\"ResponseForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"fmt\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents a response record to be given in a specified format when requested during the execution of a function specified by APIFunction, FormFunction, etc.\n\!\(\*RowBox[{\"ResponseForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"fmt\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) includes only the response record elements \!\(\*SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
RestartInterval::usage = "RestartInterval is an option controlling the restart behavior of functions such as ContinuousTask."
Restricted::usage = "\!\(\*RowBox[{\"Restricted\", \"[\", RowBox[{StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"cond\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a form for Interpreter and related functions restricted according to the conditions \!\(\*StyleBox[\"cond\", \"TI\"]\)."
Rest::usage = "\!\(\*RowBox[{\"Rest\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives \!\(\*StyleBox[\"expr\", \"TI\"]\) with the first element removed. "
Resultant::usage = "\!\(\*RowBox[{\"Resultant\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) computes the resultant of the polynomials \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with respect to the variable \!\(\*StyleBox[\"var\", \"TI\"]\). \n\!\(\*RowBox[{\"Resultant\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"var\", \"TI\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) computes the resultant modulo the prime \!\(\*StyleBox[\"p\", \"TI\"]\). "
ResumePacket::usage = "\!\(\*RowBox[{\"ResumePacket\", \"[\", \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet used for synchronization with the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) kernel."
ReturnExpressionPacket::usage = "\!\(\*RowBox[{\"ReturnExpressionPacket\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that contains the expression \!\(\*StyleBox[\"expr\", \"TI\"]\), the result of an EnterExpressionPacket evaluation."
ReturnInputFormPacket::usage = "ReturnInputFormPacket is an internal symbol used for formatting."
ReturnPacket::usage = "\!\(\*RowBox[{\"ReturnPacket\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet that contains the expression \!\(\*StyleBox[\"expr\", \"TI\"]\), the result of an EvaluatePacket evaluation."
ReturnReceiptFunction::usage = "ReturnReceiptFunction is an option for MailReceiverFunction that specifies what function to apply if a return receipt is requested for mail received by a MailReceiverFunction."
ReturnTextPacket::usage = "\!\(\*RowBox[{\"ReturnTextPacket\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet containing \!\(\*StyleBox[\"string\", \"TI\"]\), the result of an EnterTextPacket evaluation."
Return::usage = "\!\(\*RowBox[{\"Return\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the value \!\(\*StyleBox[\"expr\", \"TI\"]\) from a function. \n\!\(\*RowBox[{\"Return\", \"[\", \"]\"}]\) returns the value Null. "
Re::usage = "\!\(\*RowBox[{\"Re\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the real part of the complex number \!\(\*StyleBox[\"z\", \"TI\"]\). "
ReverseBiorthogonalSplineWavelet::usage = "\!\(\*RowBox[{\"ReverseBiorthogonalSplineWavelet\", \"[\", \"]\"}]\) represents a reverse biorthogonal spline wavelet of order 4 and dual order 2.\n\!\(\*RowBox[{\"ReverseBiorthogonalSplineWavelet\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) represents a reverse biorthogonal spline wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\) and dual order \!\(\*StyleBox[\"m\", \"TI\"]\)."
ReverseElement::usage = "\!\(\*RowBox[{\"ReverseElement\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[ReverseElement]\", StyleBox[\"y\", \"TI\"], \"\[ReverseElement]\", \"\[Ellipsis]\"}]\)."
ReverseEquilibrium::usage = "\!\(\*RowBox[{\"ReverseEquilibrium\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[ReverseEquilibrium]\", StyleBox[\"y\", \"TI\"], \"\[ReverseEquilibrium]\", \"\[Ellipsis]\"}]\)."
ReverseGraph::usage = "\!\(\*RowBox[{\"ReverseGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the reverse graph of the directed graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"ReverseGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
ReverseUpEquilibrium::usage = "\!\(\*RowBox[{\"ReverseUpEquilibrium\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[ReverseUpEquilibrium]\", StyleBox[\"y\", \"TI\"], \"\[ReverseUpEquilibrium]\", \"\[Ellipsis]\"}]\)."
Reverse::usage = "\!\(\*RowBox[{\"Reverse\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) reverses the order of the elements in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Reverse\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) reverses elements at level \!\(\*StyleBox[\"n\", \"TI\"]\) in \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{\"Reverse\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) reverses elements at levels \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] in \!\(\*StyleBox[\"expr\", \"TI\"]\)."
RevolutionAxis::usage = "RevolutionAxis is an option for RevolutionPlot3D which specifies the revolution axis around which the curve should be rotated. "
RevolutionPlot3D::usage = "\!\(\*RowBox[{\"RevolutionPlot3D\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the surface of revolution with height \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]\) at radius \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"RevolutionPlot3D\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) takes the azimuthal angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) to vary between \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"RevolutionPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the surface obtained by rotating the parametric curve with \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"z\", \"TI\"]\) coordinates \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}]\) around the \!\(\*StyleBox[\"z\", \"TI\"]\) axis.\n\!\(\*RowBox[{\"RevolutionPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) takes the azimuthal angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) to vary from \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"RevolutionPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{StyleBox[\"{\", \"TR\"], RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots the surface obtained by rotating the parametric curve with \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \!\(\*StyleBox[\"z\", \"TI\"]\) coordinates \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}]\)."
RGBColor::usage = "\!\(\*RowBox[{\"RGBColor\", \"[\", RowBox[{StyleBox[\"red\", \"TI\"], \",\", StyleBox[\"green\", \"TI\"], \",\", StyleBox[\"blue\", \"TI\"]}], \"]\"}]\) is a graphics directive specifying that objects that follow are to be displayed in the color given. \n\!\(\*RowBox[{\"RGBColor\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) specifies opacity \!\(\*StyleBox[\"a\", \"TI\"]\). \n\!\(\*RowBox[{\"RGBColor\", \"[\", StyleBox[\"\\\"string\\\"\",\"TI\",ShowStringCharacters->True], \"]\"}]\) evaluates to a normal RGBColor object."
RiccatiSolve::usage = "\!\(\*RowBox[{\"RiccatiSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the matrix \!\(\*StyleBox[\"x\", \"TI\"]\) that is the stabilizing solution of the continuous algebraic Riccati equation \!\(\*RowBox[{RowBox[{RowBox[{SuperscriptBox[\"a\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"]}], \"+\", RowBox[{StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"a\", \"TI\"]}], \"-\", RowBox[{StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"], \".\", SuperscriptBox[\"r\", RowBox[{\"-\", \"1\"}]], \".\", SuperscriptBox[\"b\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"]}], \"+\", StyleBox[\"q\", \"TI\"]}], \"\[LongEqual]\", \"0\"}]\).\n\!\(\*RowBox[{\"RiccatiSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"}\"}]}], \"]\"}]\) solves the equation \!\(\*RowBox[{RowBox[{RowBox[{SuperscriptBox[\"a\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"]}], \"+\", RowBox[{StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"a\", \"TI\"]}], \"-\", RowBox[{RowBox[{\"(\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \".\", StyleBox[\"b\", \"TI\"]}], \"+\", StyleBox[\"p\", \"TI\"]}], \")\"}], \".\", SuperscriptBox[\"r\", RowBox[{\"-\", \"1\"}]], \".\", RowBox[{\"(\", RowBox[{RowBox[{SuperscriptBox[\"b\", \"\[ConjugateTranspose]\"], \".\", StyleBox[\"x\", \"TI\"]}], \"+\", SuperscriptBox[\"p\", \"\[ConjugateTranspose]\"]}], \")\"}]}], \"+\", StyleBox[\"q\", \"TI\"]}], \"\[LongEqual]\", \"0\"}]\). "
RiceDistribution::usage = "\!\(\*RowBox[{\"RiceDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a Rice distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"RiceDistribution\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a Norton\[Dash]Rice distribution with parameters \!\(\*StyleBox[\"m\", \"TI\"]\), \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\)."
RidgeFilter::usage = "\!\(\*RowBox[{\"RidgeFilter\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) computes a measure for the presence of a ridge for each pixel in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"RidgeFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) uses the specified ridge scale \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"RidgeFilter\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) computes the ridge filter of two- or three-dimensional \!\(\*StyleBox[\"array\", \"TI\"]\)."
RiemannR::usage = "\!\(\*RowBox[{\"RiemannR\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the Riemann prime counting function \!\(\*RowBox[{StyleBox[\"R\", \"TI\"], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\)."
RiemannSiegelTheta::usage = "\!\(\*RowBox[{\"RiemannSiegelTheta\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) gives the Riemann\[Dash]Siegel function \!\(\*RowBox[{\"\[CurlyTheta]\", \"(\", \"t\", \")\"}]\). "
RiemannSiegelZ::usage = "\!\(\*RowBox[{\"RiemannSiegelZ\", \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) gives the Riemann\[Dash]Siegel function \!\(\*RowBox[{StyleBox[\"Z\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\). "
RiemannXi::usage = "\!\(\*RowBox[{\"RiemannXi\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives the Riemann xi function \!\(\*RowBox[{\"\[Xi]\", \"(\", StyleBox[\"s\", \"TI\"], \")\"}]\)."
Riffle::usage = "\!\(\*RowBox[{\"Riffle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"Riffle\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"Riffle\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) yields a list in which every \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) element is \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Riffle\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) yields a list in which \!\(\*StyleBox[\"x\", \"TI\"]\) appears if possible at positions \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]\), \!\(\*RowBox[{Cell[BoxData[SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]], \"InlineFormula\"], \"+\", StyleBox[\"n\", \"TI\"]}]\), \!\(\*RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"+\", RowBox[{\"2\", StyleBox[\"n\", \"TI\"]}]}]\), \[Ellipsis] , \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). "
RightArrowBar::usage = "\!\(\*RowBox[{\"RightArrowBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightArrowBar]\", StyleBox[\"y\", \"TI\"], \"\[RightArrowBar]\", \"\[Ellipsis]\"}]\)."
RightArrowLeftArrow::usage = "\!\(\*RowBox[{\"RightArrowLeftArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightArrowLeftArrow]\", StyleBox[\"y\", \"TI\"], \"\[RightArrowLeftArrow]\", \"\[Ellipsis]\"}]\)."
RightArrow::usage = "\!\(\*RowBox[{\"RightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightArrow]\", StyleBox[\"y\", \"TI\"], \"\[RightArrow]\", \"\[Ellipsis]\"}]\)."
RightComposition::usage = "\!\(\*RowBox[{\"RightComposition\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a composition on the right of the functions \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"3\", \"TR\"]]\), \[Ellipsis]. "
RightCosetRepresentative::usage = "\!\(\*RowBox[{\"RightCosetRepresentative\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"]\"}]\) returns the smallest element in the right coset of products of the elements of \!\(\*StyleBox[\"group\", \"TI\"]\) by \!\(\*StyleBox[\"g\", \"TI\"]\)."
RightDownTeeVector::usage = "\!\(\*RowBox[{\"RightDownTeeVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightDownTeeVector]\", StyleBox[\"y\", \"TI\"], \"\[RightDownTeeVector]\", \"\[Ellipsis]\"}]\)."
RightDownVectorBar::usage = "\!\(\*RowBox[{\"RightDownVectorBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightDownVectorBar]\", StyleBox[\"y\", \"TI\"], \"\[RightDownVectorBar]\", \"\[Ellipsis]\"}]\)."
RightDownVector::usage = "\!\(\*RowBox[{\"RightDownVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightDownVector]\", StyleBox[\"y\", \"TI\"], \"\[RightDownVector]\", \"\[Ellipsis]\"}]\)."
RightTeeArrow::usage = "\!\(\*RowBox[{\"RightTeeArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightTeeArrow]\", StyleBox[\"y\", \"TI\"], \"\[RightTeeArrow]\", \"\[Ellipsis]\"}]\)."
RightTee::usage = "\!\(\*RowBox[{\"RightTee\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightTee]\", StyleBox[\"y\", \"TI\"]}]\)."
RightTeeVector::usage = "\!\(\*RowBox[{\"RightTeeVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightTeeVector]\", StyleBox[\"y\", \"TI\"], \"\[RightTeeVector]\", \"\[Ellipsis]\"}]\)."
RightTriangleBar::usage = "\!\(\*RowBox[{\"RightTriangleBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightTriangleBar]\", StyleBox[\"y\", \"TI\"], \"\[RightTriangleBar]\", \"\[Ellipsis]\"}]\)."
RightTriangleEqual::usage = "\!\(\*RowBox[{\"RightTriangleEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightTriangleEqual]\", StyleBox[\"y\", \"TI\"], \"\[RightTriangleEqual]\", \"\[Ellipsis]\"}]\)."
RightTriangle::usage = "\!\(\*RowBox[{\"RightTriangle\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightTriangle]\", StyleBox[\"y\", \"TI\"], \"\[RightTriangle]\", \"\[Ellipsis]\"}]\)."
RightUpDownVector::usage = "\!\(\*RowBox[{\"RightUpDownVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightUpDownVector]\", StyleBox[\"y\", \"TI\"], \"\[RightUpDownVector]\", \"\[Ellipsis]\"}]\)."
RightUpTeeVector::usage = "\!\(\*RowBox[{\"RightUpTeeVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightUpTeeVector]\", StyleBox[\"y\", \"TI\"], \"\[RightUpTeeVector]\", \"\[Ellipsis]\"}]\)."
RightUpVectorBar::usage = "\!\(\*RowBox[{\"RightUpVectorBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightUpVectorBar]\", StyleBox[\"y\", \"TI\"], \"\[RightUpVectorBar]\", \"\[Ellipsis]\"}]\)."
RightUpVector::usage = "\!\(\*RowBox[{\"RightUpVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightUpVector]\", StyleBox[\"y\", \"TI\"], \"\[RightUpVector]\", \"\[Ellipsis]\"}]\)."
Right::usage = "Right is a symbol that represents the right-hand side for purposes of alignment and positioning. "
RightVectorBar::usage = "\!\(\*RowBox[{\"RightVectorBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightVectorBar]\", StyleBox[\"y\", \"TI\"], \"\[RightVectorBar]\", \"\[Ellipsis]\"}]\)."
RightVector::usage = "\!\(\*RowBox[{\"RightVector\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[RightVector]\", StyleBox[\"y\", \"TI\"], \"\[RightVector]\", \"\[Ellipsis]\"}]\)."
RiskAchievementImportance::usage = "\!\(\*RowBox[{\"RiskAchievementImportance\", \"[\", RowBox[{StyleBox[\"rdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the risk achievement importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"RiskAchievementImportance\", \"[\", RowBox[{StyleBox[\"fdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the risk achievement importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\)."
RiskReductionImportance::usage = "\!\(\*RowBox[{\"RiskReductionImportance\", \"[\", RowBox[{StyleBox[\"rdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the risk reduction importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"RiskReductionImportance\", \"[\", RowBox[{StyleBox[\"fdist\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the risk reduction importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\)."
RLink`FromRForm::usage = "\!\(\*RowBox[{\"FromRForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts a full form of an expression \!\(\*StyleBox[\"expr\", \"TI\"]\), representing some valid R object, to the short form. Returns $Failed on illegal expressions, which do not form a valid \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) representation of an R object."
RLink`InstallR::usage = "\!\(\*RowBox[{\"InstallR\", \"[\", StyleBox[\"opts\", \"TI\"], \"]\"}]\) installs \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\)."
RLink`RAttributes::usage = "\!\(\*RowBox[{\"RAttributes\", \"[\", StyleBox[\"atts\", \"TI\"], \"]\"}]\) an \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) container for attributes of R objects."
RLink`RCode::usage = "\!\(\*RowBox[{\"RCode\", \"[\", StyleBox[\"code\", \"TI\"], \"]\"}]\) a container used by \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) to represent pieces of R code corresponding to R objects not directly supported by \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\)."
RLink`RDataTypeDefinitionsReload::usage = "\!\(\*RowBox[{\"RDataTypeDefinitionsReload\", \"[\", StyleBox[\"opts\", \"TI\"], \"]\"}]\) searches for files with definitions of extra data types, defined by the user to extend the core data type system of \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\), and loads those definitions. "
RLink`RDataTypeRegisteredQ::usage = "\!\(\*RowBox[{\"RDataTypeRegisteredQ\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) returns True if a data type with a given name has been registered in a current \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) session, and False otherwise."
RLink`RDataTypeRegister::usage = "\!\(\*RowBox[{\"RDataTypeRegister\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"fwpatt\", \"TI\"], \",\", StyleBox[\"fwrule\", \"TI\"], \",\", StyleBox[\"bckpatt\", \"TI\"], \",\", StyleBox[\"bckrule\", \"TI\"]}], \"]\"}]\) registers a new \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) representation for a data type with name \!\(\*StyleBox[\"type\", \"TI\"]\). "
RLink`RDataTypeUnregister::usage = "\!\(\*RowBox[{\"RDataTypeUnregister\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) unregisters a data type with the name \!\(\*StyleBox[\"type\", \"TI\"]\) from the \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) type system."
RLink`REnvironment::usage = "\!\(\*RowBox[{\"REnvironment\", \"[\", \"]\"}]\) a container used by \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) to represent any R environment."
RLink`REvaluate::usage = "\!\(\*RowBox[{\"REvaluate\", \"[\", StyleBox[\"code\", \"TI\"], \"]\"}]\) evaluates a string of R code, and returns the result as a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) expression."
RLink`RFunction::usage = "\!\(\*RowBox[{\"RFunction\", \"[\", StyleBox[\"code\", \"TI\"], \"]\"}]\) uses \!\(\*StyleBox[\"code\", \"TI\"]\) to define a function in the R workspace and returns a reference (handle) to an R function defined in the R workspace, which also has the head RFunction.\n\!\(\*RowBox[{RowBox[{\"RFunction\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", RowBox[{\"RCode\", \"[\", StyleBox[\"code\", \"TI\"], \"]\"}], \",\", StyleBox[\"refIndex\", \"TI\"], \",\", StyleBox[\"attributes\", \"TI\"]}], \" \", \"]\"}], \" \"}]\)\n\trepresents a reference to an R function defined in the R workspace.\n\!\(\*RowBox[{RowBox[{\"RFunction\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", RowBox[{\"RCode\", \"[\", StyleBox[\"code\", \"TI\"], \"]\"}], \",\", StyleBox[\"refIndex\", \"TI\"], \",\", StyleBox[\"attributes\", \"TI\"]}], \" \", \"]\"}], \"[\", StyleBox[\"args\", \"TI\"], \"]\"}]\)\n\tcalls an R function represented by the RFunction object on arguments \!\(\*StyleBox[\"args\", \"TI\"]\)."
RLink`RLinkResourcesInstall::usage = "\!\(\*RowBox[{\"RLinkResourcesInstall\", \"[\", StyleBox[\"opts\", \"TI\"], \"]\"}]\) installs the \!\(\*StyleBox[\"RLinkRuntime\", FontSlant -> \"Italic\"]\) paclet from the Wolfram Data Paclet server.\n\!\(\*RowBox[{\"RLinkResourcesInstall\", \"[\", StyleBox[RowBox[{\"path\", \",\", \" \", \"opts\"}], \"TI\"], \"]\"}]\) installs the \!\(\*StyleBox[\"RLinkRuntime\", FontSlant -> \"Italic\"]\) paclet from the paclet file."
RLink`RLinkResourcesUninstall::usage = "\!\(\*RowBox[{\"RLinkResourcesUninstall\", \"[\", \"]\"}]\) uninstalls the \!\(\*StyleBox[\"RLinkRuntime\", FontSlant -> \"Italic\"]\) paclet."
RLink`RList::usage = "\!\(\*RowBox[{\"RList\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"elems\", \"TI\"], \"}\"}], \",\", StyleBox[\"attributes\", \"TI\"]}], \"]\"}]\) represents an internal form of an R list in \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\)."
RLink`RNull::usage = "\!\(\*RowBox[{\"RNull\", \"[\", \"]\"}]\) \n\tis \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\)'s representation of an R \!\(\*StyleBox[\"NULL\", \"InlineCode\"]\) object."
RLink`RObject::usage = "\!\(\*RowBox[{\"RObject\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"attributes\", \"TI\"]}], \"]\"}]\) represents a general R object, usually having a non-trivial set of attributes."
RLink`RSet::usage = "\!\(\*RowBox[{\"RSet\", \"[\", RowBox[{StyleBox[\"var\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) assigns the value of the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) expression \!\(\*StyleBox[\"expr\", \"TI\"]\) to a variable \!\(\*StyleBox[\"var\", \"TI\"]\) in the R workspace, returning back the value of \!\(\*StyleBox[\"expr\", \"TI\"]\) upon success and $Failed upon failure."
RLink`RTypeOfHighLevelExpression::usage = "\!\(\*RowBox[{\"RTypeOfHighLevelExpression\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns a (usually string) name of the \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) data type to which \!\(\*StyleBox[\"expr\", \"TI\"]\) belongs."
RLink`RTypeOfLowLevelExpression::usage = "\!\(\*RowBox[{\"RTypeOfLowLevelExpression\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns a (usually string) name of the \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) data type to which \!\(\*StyleBox[\"expr\", \"TI\"]\) belongs."
RLink`RVector::usage = "\!\(\*RowBox[{\"RVector\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"attributes\", \"TI\"]}], \"]\"}]\) represents an internal form of an R vector in \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\)."
RLink`ToRForm::usage = "\!\(\*RowBox[{\"ToRForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns a full form of \!\(\*StyleBox[\"expr\", \"TI\"]\) used by \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) internally to communicate with R. For expressions which do not correspond to any supported R type and cannot be converted, ToRForm returns $Failed."
RLink`UninstallR::usage = "\!\(\*RowBox[{\"UninstallR\", \"[\", \"]\"}]\) uninstalls the R runtime/\!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\)."
RLink`$RDataTypePath::usage = "$RDataTypePath is an internal \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) variable that stores a value of the search path (a list of directory names) where \!\(\*StyleBox[\"RLink\", FontSlant -> \"Italic\"]\) will look for definitions of user-defined data types."
RogersTanimotoDissimilarity::usage = "\!\(\*RowBox[{\"RogersTanimotoDissimilarity\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Rogers\[Dash]Tanimoto dissimilarity between Boolean vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
RollPitchYawAngles::usage = "\!\(\*RowBox[{\"RollPitchYawAngles\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives the roll-pitch-yaw angles \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}]\) corresponding to the rotation matrix \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"RollPitchYawAngles\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the roll-pitch-yaw angles \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}]\) corresponding to rotation order \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}]\)."
RollPitchYawMatrix::usage = "\!\(\*RowBox[{\"RollPitchYawMatrix\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the 3D rotation matrix formed by rotating \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) around the initial \!\(\*StyleBox[\"z\", \"TI\"]\) axis, then \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) around the initial \!\(\*StyleBox[\"y\", \"TI\"]\) axis, and then \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\) around the initial \!\(\*StyleBox[\"x\", \"TI\"]\) axis. \n\!\(\*RowBox[{\"RollPitchYawMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the 3D rotation matrix formed by rotating \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) around the fixed \!\(\*StyleBox[\"a\", \"TI\"]\) axis, then \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) around the fixed \!\(\*StyleBox[\"b\", \"TI\"]\) axis, and then \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\) around the fixed \!\(\*StyleBox[\"c\", \"TI\"]\) axis. "
RomanNumeral::usage = "\!\(\*RowBox[{\"RomanNumeral\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives a string corresponding to the Roman numeral form of the integer \!\(\*StyleBox[\"n\", \"TI\"]\)."
RootApproximant::usage = "\!\(\*RowBox[{\"RootApproximant\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) converts the number \!\(\*StyleBox[\"x\", \"TI\"]\) to one of the \"simplest\" algebraic numbers that approximates it well.\n\!\(\*RowBox[{\"RootApproximant\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds an algebraic number of degree at most \!\(\*StyleBox[\"n\", \"TI\"]\) that approximates \!\(\*StyleBox[\"x\", \"TI\"]\)."
RootIntervals::usage = "\!\(\*RowBox[{\"RootIntervals\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of isolating intervals for the real roots of any of the \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), together with a list of which polynomials actually have each successive root.\n\!\(\*RowBox[{\"RootIntervals\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) gives isolating intervals for real roots of a single polynomial. \n\!\(\*RowBox[{\"RootIntervals\", \"[\", RowBox[{StyleBox[\"polys\", \"TI\"], \",\", \"Complexes\"}], \"]\"}]\) gives bounding rectangles for complex roots."
RootLocusPlot::usage = "\!\(\*RowBox[{\"RootLocusPlot\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a root locus plot of a linear time-invariant system \!\(\*StyleBox[\"lsys\", \"TI\"]\) as the parameter \!\(\*StyleBox[\"k\", \"TI\"]\) ranges from \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"max\", \"TI\"]]\)."
RootMeanSquare::usage = "\!\(\*RowBox[{\"RootMeanSquare\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the root mean square of values in \!\(\*StyleBox[\"list\", \"TI\"]\)."
RootOfUnityQ::usage = "\!\(\*RowBox[{\"RootOfUnityQ\", \"[\", StyleBox[\"a\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"a\", \"TI\"]\) is a root of unity, and yields False otherwise."
RootReduce::usage = "\!\(\*RowBox[{\"RootReduce\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) attempts to reduce \!\(\*StyleBox[\"expr\", \"TI\"]\) to a single Root object. "
RootSum::usage = "\!\(\*RowBox[{\"RootSum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) represents the sum of \!\(\*RowBox[{StyleBox[\"form\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) for all \!\(\*StyleBox[\"x\", \"TI\"]\) that satisfy the polynomial equation \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], StyleBox[\"==\", \"TR\"], StyleBox[\"0\", \"TR\"]}]\). "
Roots::usage = "\!\(\*RowBox[{\"Roots\", \"[\", RowBox[{RowBox[{StyleBox[\"lhs\", \"TI\"], \"==\", StyleBox[\"rhs\", \"TI\"]}], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) yields a disjunction of equations which represent the roots of a polynomial equation. "
Root::usage = "\!\(\*RowBox[{\"Root\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents the exact \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) root of the polynomial equation \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"\[Equal]\", StyleBox[\"0\", \"TR\"]}]\). \n\!\(\*RowBox[{\"Root\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents the last coordinate of the exact vector \!\(\*RowBox[{StyleBox[\"{\", \"TR\"], RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}]\) such that \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) is the \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) root of the polynomial equation \!\(\*RowBox[{RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[RowBox[{\"i\", \"-\", StyleBox[\"1\", FontSlant -> \"Plain\"]}], \"TI\"]], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}], \"\[Equal]\", StyleBox[\"0\", \"TR\"]}]\).\n\!\(\*RowBox[{\"Root\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents the exact root of the general equation \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"\[Equal]\", StyleBox[\"0\", \"TR\"]}]\) near \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\).\n\!\(\*RowBox[{\"Root\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}], \"]\"}]\) represents \!\(\*StyleBox[\"n\", \"TI\"]\) roots of the equation \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"\[Equal]\", StyleBox[\"0\", \"TR\"]}]\) near \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\)."
RotateLabel::usage = "RotateLabel is an option for graphics and related functions that specifies whether labels on vertical frame axes should be rotated to be vertical. "
RotateLeft::usage = "\!\(\*RowBox[{\"RotateLeft\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) cycles the elements in \!\(\*StyleBox[\"expr\", \"TI\"]\) \!\(\*StyleBox[\"n\", \"TI\"]\) positions to the left. \n\!\(\*RowBox[{\"RotateLeft\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) cycles one position to the left. \n\!\(\*RowBox[{\"RotateLeft\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) cycles elements at successive levels \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) positions to the left. "
RotateRight::usage = "\!\(\*RowBox[{\"RotateRight\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) cycles the elements in \!\(\*StyleBox[\"expr\", \"TI\"]\) \!\(\*StyleBox[\"n\", \"TI\"]\) positions to the right. \n\!\(\*RowBox[{\"RotateRight\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) cycles one position to the right. \n\!\(\*RowBox[{\"RotateRight\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) cycles elements at successive levels \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) positions to the right. "
Rotate::usage = "\!\(\*RowBox[{\"Rotate\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) represents 2D graphics primitives or any other objects \!\(\*StyleBox[\"g\", \"TI\"]\) rotated counterclockwise by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians about the center of their bounding box. \n\!\(\*RowBox[{\"Rotate\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]}], \"]\"}]\) rotates about the point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"Rotate\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) rotates around the origin, transforming the 2D or 3D vector \!\(\*StyleBox[\"u\", \"TI\"]\) to \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"Rotate\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) rotates 3D graphics primitives by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians around the 3D vector \!\(\*StyleBox[\"w\", \"TI\"]\) anchored at the origin.\n\!\(\*RowBox[{\"Rotate\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) rotates around the 3D vector \!\(\*StyleBox[\"w\", \"TI\"]\) anchored at \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"Rotate\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) rotates by angle \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) in the plane spanned by 3D vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
RotationAction::usage = "RotationAction is an option for three-dimensional graphics functions that specifies how to render 3D objects when they are interactively rotated."
RotationBoxOptions::usage = "\!\(\*RowBox[{RotationBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for RotationBox objects."
RotationMatrix::usage = "\!\(\*RowBox[{\"RotationMatrix\", \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}]\) gives the 2D rotation matrix that rotates 2D vectors counterclockwise by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians.\n\!\(\*RowBox[{\"RotationMatrix\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) gives the 3D rotation matrix for a counterclockwise rotation around the 3D vector \!\(\*StyleBox[\"w\", \"TI\"]\).\n\!\(\*RowBox[{\"RotationMatrix\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the matrix that rotates the vector \!\(\*StyleBox[\"u\", \"TI\"]\) to the direction of the vector \!\(\*StyleBox[\"v\", \"TI\"]\) in any dimension.\n\!\(\*RowBox[{\"RotationMatrix\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the matrix that rotates by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians in the hyperplane spanned by \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
RotationTransform::usage = "\!\(\*RowBox[{\"RotationTransform\", \"[\", StyleBox[\"\[Theta]\", \"TR\"], \"]\"}]\) gives a TransformationFunction that represents a rotation in 2D by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians about the origin.\n\!\(\*RowBox[{\"RotationTransform\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives a 2D rotation about the 2D point \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"RotationTransform\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) gives a 3D rotation around the direction of the 3D vector \!\(\*StyleBox[\"w\", \"TI\"]\).\n\!\(\*RowBox[{\"RotationTransform\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives a 3D rotation around the axis \!\(\*StyleBox[\"w\", \"TI\"]\) anchored at the point \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"RotationTransform\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \"]\"}]\) gives a rotation about the origin that transforms the vector \!\(\*StyleBox[\"u\", \"TI\"]\) to the direction of the vector \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"RotationTransform\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives a rotation about the point \!\(\*StyleBox[\"p\", \"TI\"]\) that transforms \!\(\*StyleBox[\"u\", \"TI\"]\) to the direction of \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"RotationTransform\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a rotation by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians in the hyperplane spanned by \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
RoundingRadius::usage = "RoundingRadius is an option for Rectangle, Framed, and related functions that specifies the radius of the circle to use in rendering rounded corners."
Round::usage = "\!\(\*RowBox[{\"Round\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives the integer closest to \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Round\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) rounds to the nearest multiple of \!\(\*StyleBox[\"a\", \"TI\"]\). "
RowAlignments::usage = "RowAlignments is an option for the low-level function GridBox that specifies how entries in each row should be aligned. "
RowBox::usage = "\!\(\*RowBox[{RowBox, \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is a low-level box construct that represents a row of boxes or strings in a notebook expression. "
RowLines::usage = "RowLines is an option for the low-level function GridBox that specifies whether lines should be drawn between adjacent rows. "
RowMinHeight::usage = "RowMinHeight is an option for the low-level function GridBox that specifies the minimum total height in units of font size that should be allowed for each row. "
RowReduce::usage = "\!\(\*RowBox[{\"RowReduce\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the row\[Hyphen]reduced form of the matrix \!\(\*StyleBox[\"m\", \"TI\"]\). "
RowsEqual::usage = "RowsEqual is an option for the low-level function GridBox that specifies whether all rows in the grid should be assigned equal total height. "
RowSpacings::usage = "RowSpacings is an option for the low-level function GridBox that specifies the spaces in x heights that should be inserted between successive rows. "
Row::usage = "\!\(\*RowBox[{\"Row\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is an object that formats with the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) arranged in a row, potentially extending over several lines. \n\!\(\*RowBox[{\"Row\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) inserts \!\(\*StyleBox[\"s\", \"TI\"]\) as a separator between successive elements. "
RSolve::usage = "\!\(\*RowBox[{\"RSolve\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", RowBox[{StyleBox[\"a\", \"TI\"], \"[\", StyleBox[\"n\", \"TI\"], \"]\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) solves a recurrence equation for \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\). \n\!\(\*RowBox[{\"RSolve\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"n\", \"TI\"], \"]\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"[\", StyleBox[\"n\", \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) solves a system of recurrence equations. \n\!\(\*RowBox[{\"RSolve\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", RowBox[{StyleBox[\"a\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) solves a partial recurrence equation. "
RSolveValue::usage = "\!\(\*RowBox[{\"RSolveValue\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the value of \!\(\*StyleBox[\"expr\", \"TI\"]\) determined by a symbolic solution to the ordinary difference equation \!\(\*StyleBox[\"eqn\", \"TI\"]\) with independent variable \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"RSolveValue\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"eqn\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) uses a symbolic solution for a list of difference equations. \n\!\(\*RowBox[{\"RSolveValue\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) uses a solution for the partial recurrence equation \!\(\*StyleBox[\"eqn\", \"TI\"]\). "
RudinShapiro::usage = "\!\(\*RowBox[{\"RudinShapiro\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) term in the Rudin\[Dash]Shapiro sequence."
RudvalisGroupRu::usage = "\!\(\*RowBox[{\"RudvalisGroupRu\", \"[\", \"]\"}]\) represents the sporadic simple Rudvalis group Ru."
RuleCondition::usage = "RuleCondition is an internal symbol."
RuleDelayed::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \":>\", StyleBox[\"rhs\", \"TI\"]}]\) or \!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"\[RuleDelayed]\", StyleBox[\"rhs\", \"TI\"]}]\) represents a rule that transforms \!\(\*StyleBox[\"lhs\", \"TI\"]\) to \!\(\*StyleBox[\"rhs\", \"TI\"]\), evaluating \!\(\*StyleBox[\"rhs\", \"TI\"]\) only after the rule is used. "
RuleForm::usage = "RuleForm is an internal symbol used for formatting and printing."
RulerUnits::usage = "RulerUnits is an option for notebooks that specifies the units in the ruler toolbar."
Rule::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"->\", StyleBox[\"rhs\", \"TI\"]}]\) or \!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"\[Rule]\", StyleBox[\"rhs\", \"TI\"]}]\) represents a rule that transforms \!\(\*StyleBox[\"lhs\", \"TI\"]\) to \!\(\*StyleBox[\"rhs\", \"TI\"]\). "
RunProcess::usage = "\!\(\*RowBox[{\"RunProcess\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"command\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) runs the specified external command, returning information on the outcome.\n\!\(\*RowBox[{\"RunProcess\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"command\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) runs the specified command, with command-line arguments \!\(\*SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"RunProcess\", \"[\", RowBox[{StyleBox[\"command\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns only the specified property.\n\!\(\*RowBox[{\"RunProcess\", \"[\", RowBox[{StyleBox[\"command\", \"TI\"], \",\", StyleBox[\"prop\", \"TI\"], \",\", StyleBox[\"input\", \"TI\"]}], \"]\"}]\) feeds the specified initial input to the command."
RunScheduledTask::usage = "\!\(\*RowBox[{\"RunScheduledTask\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) schedules and starts a local scheduled task that will repeatedly evaluate \!\(\*StyleBox[\"expr\", \"TI\"]\) once per second.\n\!\(\*RowBox[{\"RunScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"time\", \"TI\"]}], \"]\"}]\) schedules and starts a task that will repeatedly evaluate \!\(\*StyleBox[\"expr\", \"TI\"]\) every \!\(\*StyleBox[\"time\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"RunScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"time\", \"TI\"], \"}\"}]}], \"]\"}]\) schedules and starts a task that will evaluate \!\(\*StyleBox[\"expr\", \"TI\"]\) once after \!\(\*StyleBox[\"time\", \"TI\"]\) seconds.\n\!\(\*RowBox[{\"RunScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"time\", \"TI\"], \",\", StyleBox[\"count\", \"TI\"]}], \"}\"}]}], \"]\"}]\) schedules and starts a task that will try evaluating \!\(\*StyleBox[\"expr\", \"TI\"]\) once every \!\(\*StyleBox[\"time\", \"TI\"]\) seconds up to \!\(\*StyleBox[\"count\", \"TI\"]\) times.\n\!\(\*RowBox[{\"RunScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"], \",\", StyleBox[\"start\", \"TI\"]}], \"]\"}]\) schedules a task that will automatically start at \!\(\*StyleBox[\"start\", \"TI\"]\) time.\n\!\(\*RowBox[{\"RunScheduledTask\", \"[\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"...\", \"TI\"], \"]\"}], \"]\"}]\) asynchronously executes an existing cloud task or document generator."
RunThrough::usage = "\!\(\*RowBox[{\"RunThrough\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"command\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) executes an external command, giving the printed form of \!\(\*StyleBox[\"expr\", \"TI\"]\) as input and taking the output, reading it as \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) input, and returning the result. "
RuntimeAttributes::usage = "RuntimeAttributes is an option for Compile that specifies attributes for the compiled function it creates."
RuntimeOptions::usage = "RuntimeOptions is an option for Compile that specifies runtime settings for the compiled function it creates."
Run::usage = "\!\(\*RowBox[{\"Run\", \"[\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) generates the printed form of the expressions \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), separated by spaces, and runs it as an external operating system command. "
RussellRaoDissimilarity::usage = "\!\(\*RowBox[{\"RussellRaoDissimilarity\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Russell\[Dash]Rao dissimilarity between Boolean vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
SameQ::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"===\", StyleBox[\"rhs\", \"TI\"]}]\) yields True if the expression \!\(\*StyleBox[\"lhs\", \"TI\"]\) is identical to \!\(\*StyleBox[\"rhs\", \"TI\"]\), and yields False otherwise. "
SameTest::usage = "SameTest is an option whose setting gives a pairwise comparison function to determine whether expressions should be considered the same."
SampleDepth::usage = "SampleDepth is an option for sound primitives that specifies how many bits should be used to encode sound amplitude levels. "
SampledSoundFunction::usage = "\!\(\*RowBox[{\"SampledSoundFunction\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) is a sound primitive that represents a sound whose amplitude sampled \!\(\*StyleBox[\"r\", \"TI\"]\) times a second is generated by applying the function \!\(\*StyleBox[\"f\", \"TI\"]\) to successive integers from 1 to \!\(\*StyleBox[\"n\", \"TI\"]\). "
SampledSoundList::usage = "\!\(\*RowBox[{\"SampledSoundList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) is a sound primitive that represents a sound whose amplitude has levels \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) sampled \!\(\*StyleBox[\"r\", \"TI\"]\) times a second. "
SampleRate::usage = "SampleRate is an option for sound primitives that specifies the number of samples per second to generate for sounds. "
SamplingPeriod::usage = "SamplingPeriod is an option to StateSpaceModel etc. that specifies the sampling period."
SARIMAProcess::usage = "\!\(\*RowBox[{\"SARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents a seasonal integrated autoregressive moving-average process with ARIMA coefficients \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*StyleBox[\"d\", \"TI\"]\), and \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"j\", \"TI\"]]\); seasonal order \!\(\*StyleBox[\"s\", \"TI\"]\); seasonal ARIMA coefficients \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\), and \!\(\*SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"j\", \"TI\"]]\); seasonal integration order \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\); and normal white noise with variance \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"SARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a vector SARIMA process with coefficient matrices \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"j\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\), and \!\(\*SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"j\", \"TI\"]]\) and covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\). \n\!\(\*RowBox[{\"SARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Delta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a vector SARIMA process with multiple integration orders \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), seasonal orders \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"j\", \"TI\"]]\), and seasonal integration orders \!\(\*SubscriptBox[StyleBox[\"\[Delta]\", \"TR\"], StyleBox[\"k\", \"TI\"]]\). \n\!\(\*RowBox[{\"SARIMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"d\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) represents a SARIMA process with initial data \!\(\*StyleBox[\"init\", \"TI\"]\). \n\!\(\*RowBox[{\"SARIMAProcess\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a SARIMA process with constant \!\(\*StyleBox[\"c\", \"TI\"]\)."
SARMAProcess::usage = "\!\(\*RowBox[{\"SARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) represents a weakly stationary seasonal autoregressive moving-average process with ARMA coefficients \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"j\", \"TI\"]]\), seasonal order \!\(\*StyleBox[\"s\", \"TI\"]\), seasonal ARMA coefficients \!\(\*SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"j\", \"TI\"]]\), and normal white noise with variance \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{RowBox[{\"SARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}], \" \"}]\) represents a weakly stationary vector SARMA process driven by normal white noise, with covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"SARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a weakly stationary vector SARMA process with multiple seasonal orders \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{RowBox[{\"SARMAProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"p\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"q\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Alpha]\", \"TR\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Beta]\", \"TR\"], StyleBox[\"r\", \"TI\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}], \" \"}]\) represents a SARMA process with initial data \!\(\*StyleBox[\"init\", \"TI\"]\). \n\!\(\*RowBox[{\"SARMAProcess\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a SARMA process with a constant \!\(\*StyleBox[\"c\", \"TI\"]\)."
SASTriangle::usage = "\!\(\*RowBox[{\"SASTriangle\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) returns a filled triangle with sides of length \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\) and angle \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\) between them. "
SatelliteData::usage = "\!\(\*RowBox[{\"SatelliteData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the satellite \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"SatelliteData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified satellite entities.\n\!\(\*RowBox[{\"SatelliteData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
SatisfiabilityCount::usage = "\!\(\*RowBox[{\"SatisfiabilityCount\", \"[\", StyleBox[\"bf\", \"TI\"], \"]\"}]\) counts the number of possible combinations of variable values that yield True when supplied as arguments to the Boolean function \!\(\*StyleBox[\"bf\", \"TI\"]\).\n\!\(\*RowBox[{\"SatisfiabilityCount\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) counts the number of possible combinations of the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that make the Boolean expression \!\(\*StyleBox[\"expr\", \"TI\"]\) be true."
SatisfiabilityInstances::usage = "\!\(\*RowBox[{\"SatisfiabilityInstances\", \"[\", StyleBox[\"bf\", \"TI\"], \"]\"}]\) attempts to find a choice of variables that makes the Boolean function \!\(\*StyleBox[\"bf\", \"TI\"]\) yield True.\n\!\(\*RowBox[{\"SatisfiabilityInstances\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) attempts to find a choice of the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) that makes the Boolean expression \!\(\*StyleBox[\"expr\", \"TI\"]\) be True.\n\!\(\*RowBox[{\"SatisfiabilityInstances\", \"[\", RowBox[{StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) attempts to find \!\(\*StyleBox[\"m\", \"TI\"]\) choices of variables that yield True."
SatisfiableQ::usage = "\!\(\*RowBox[{\"SatisfiableQ\", \"[\", StyleBox[\"bf\", \"TI\"], \"]\"}]\) gives True if a combination of values of variables exists that makes the Boolean function \!\(\*StyleBox[\"bf\", \"TI\"]\) yield True.\n\!\(\*RowBox[{\"SatisfiableQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives True if a combination of values of the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) exists that makes the Boolean expression \!\(\*StyleBox[\"expr\", \"TI\"]\) yield True."
Saturday::usage = "Saturday is a day of the week."
Saveable::usage = "Saveable is an option for notebooks that specifies whether a notebook can be saved."
SaveDefinitions::usage = "SaveDefinitions is an option to Manipulate and related functions that specifies whether current definitions relevant for the evaluation of the expression being manipulated should automatically be saved."
Save::usage = "\!\(\*RowBox[{\"Save\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"symbol\", \"TI\"]}], \"]\"}]\) appends definitions associated with the specified symbol to a file. \n\!\(\*RowBox[{\"Save\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) appends definitions associated with all symbols whose names match the string pattern \"\!\(\*\nStyleBox[\"form\", \"TI\"]\)\". \n\!\(\*RowBox[{\"Save\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"context\\\",\\\"TI\\\"]\\)`\\\"\", ShowStringCharacters->True]}], \"]\"}]\) appends definitions associated with all symbols in the specified context. \n\!\(\*RowBox[{\"Save\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"filename\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"object\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) appends definitions associated with several objects. "
SavitzkyGolayMatrix::usage = "\!\(\*RowBox[{\"SavitzkyGolayMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives a matrix corresponding to a smoothing kernel of radius \!\(\*StyleBox[\"r\", \"TI\"]\) for performing polynomial regression of degree \!\(\*StyleBox[\"k\", \"TI\"]\). \n\!\(\*RowBox[{\"SavitzkyGolayMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives a matrix for performing polynomial regression of degree \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) over a window of radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) along rows, and degree \!\(\*SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) over a window of radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) along columns.\n\!\(\*RowBox[{\"SavitzkyGolayMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a matrix for performing the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative of a polynomial regression of degree \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"SavitzkyGolayMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}], \" \", \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"k\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives an array using the specified parameters for each direction \!\(\*StyleBox[\"i\", \"TI\"]\)."
SawtoothWave::usage = "\!\(\*RowBox[{\"SawtoothWave\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives a sawtooth wave that varies from 0 to 1 with unit period.\n\!\(\*RowBox[{\"SawtoothWave\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a sawtooth wave that varies from \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\) with unit period."
ScaleDivisions::usage = "ScaleDivisions is an option for gauge functions that specifies how many tick marks should be drawn on the scale."
Scaled::usage = "\!\(\*RowBox[{\"Scaled\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the position of a graphical object in terms of coordinates scaled to run from 0 to 1 across the whole plot range in each direction. \n\!\(\*RowBox[{\"Scaled\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a position obtained by starting at ordinary coordinates \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\), then moving by a scaled offset \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). "
ScaleOrigin::usage = "ScaleOrigin is an option for gauge functions that describes how to position the scale on the gauge."
ScalePadding::usage = "ScalePadding is an option for gauge functions that specifies how much space to leave around the scale."
ScaleRangeStyle::usage = "ScaleRangeStyle is an option for gauge functions to describe how to style different sections of the scale."
ScaleRanges::usage = "ScaleRanges is an option for gauge functions that describes how to draw sections of the scale."
Scale::usage = "\!\(\*RowBox[{\"Scale\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) represents graphics primitives \!\(\*StyleBox[\"g\", \"TI\"]\) scaled by a factor \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"Scale\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) scales with the point \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) kept fixed. \n\!\(\*RowBox[{\"Scale\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) scales by different factors along different axes. "
ScalingFunctions::usage = "ScalingFunctions is an option for BarChart, Histogram, and other charting functions that specifies what scaling functions should be used. "
ScalingMatrix::usage = "\!\(\*RowBox[{\"ScalingMatrix\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the matrix corresponding to scaling by a factor \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) along each coordinate axis.\n\!\(\*RowBox[{\"ScalingMatrix\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the matrix corresponding to scaling by a factor \!\(\*StyleBox[\"s\", \"TI\"]\) along the direction of the vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
ScalingTransform::usage = "\!\(\*RowBox[{\"ScalingTransform\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a TransformationFunction that represents scaling by a factor \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) along each coordinate axis from the origin.\n\!\(\*RowBox[{\"ScalingTransform\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives scaling centered at the point \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"ScalingTransform\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives scaling by a factor \!\(\*StyleBox[\"s\", \"TI\"]\) along the direction of the vector \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"ScalingTransform\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives scaling along the direction of \!\(\*StyleBox[\"v\", \"TI\"]\), centered at the point \!\(\*StyleBox[\"p\", \"TI\"]\)."
Scan::usage = "\!\(\*RowBox[{\"Scan\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"f\", \"TI\"]\) applied to each element of \!\(\*StyleBox[\"expr\", \"TI\"]\) in turn. \n\!\(\*RowBox[{\"Scan\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"levelspec\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) specified by \!\(\*StyleBox[\"levelspec\", \"TI\"]\). \n\!\(\*RowBox[{\"Scan\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of Scan that can be applied to an expression."
ScheduledTaskActiveQ::usage = "\!\(\*RowBox[{\"ScheduledTaskActiveQ\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"obj\", \"TI\"]\) represents an active task, and False otherwise."
ScheduledTaskInformation::usage = "\!\(\*RowBox[{\"ScheduledTaskInformation\", \"[\", StyleBox[\"cloudobj\", \"TI\"], \"]\"}]\) returns the properties of the ScheduledTask \!\(\*StyleBox[\"cloudobj\", \"TI\"]\).\n\!\(\*RowBox[{\"ScheduledTaskInformation\", \"[\", RowBox[{StyleBox[\"cloudobj\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) returns the value of the property \!\(\*StyleBox[\"property\", \"TI\"]\)."
ScheduledTaskObject::usage = "\!\(\*RowBox[{\"ScheduledTaskObject\", \"[\", RowBox[{StyleBox[\"id\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is a task object specifying future evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\) according to \!\(\*StyleBox[\"spec\", \"TI\"]\)."
ScheduledTasks::usage = "\!\(\*RowBox[{\"ScheduledTasks\", \"[\", \"]\"}]\) returns a list of ScheduledTaskObject and CloudObject expressions that represent current tasks."
ScheduledTask::usage = "\!\(\*RowBox[{\"ScheduledTask\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"timespec\", \"TI\"]}], \"]\"}]\) represents a scheduled task to be evaluated on the schedule defined by \!\(\*StyleBox[\"timespec\", \"TI\"]\)."
SchurDecomposition::usage = "\!\(\*RowBox[{\"SchurDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) yields the Schur decomposition for a numerical matrix \!\(\*StyleBox[\"m\", \"TI\"]\), given as a list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"}\"}]\) where \!\(\*StyleBox[\"q\", \"TI\"]\) is an orthonormal matrix and \!\(\*StyleBox[\"t\", \"TI\"]\) is a block upper\[Hyphen]triangular matrix. \n\!\(\*RowBox[{\"SchurDecomposition\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the generalized Schur decomposition of \!\(\*StyleBox[\"m\", \"TI\"]\) with respect to \!\(\*StyleBox[\"a\", \"TI\"]\). "
ScientificForm::usage = "\!\(\*RowBox[{\"ScientificForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints with all real numbers in \!\(\*StyleBox[\"expr\", \"TI\"]\) given in scientific notation. \n\!\(\*RowBox[{\"ScientificForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) prints with numbers given to \!\(\*StyleBox[\"n\", \"TI\"]\)\[Hyphen]digit precision. "
ScorerGiPrime::usage = "\!\(\*RowBox[{\"ScorerGiPrime\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the derivative of the Scorer function \!\(\*RowBox[{SuperscriptBox[\"Gi\", \"\[Prime]\", MultilineFunction -> None], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
ScorerGi::usage = "\!\(\*RowBox[{\"ScorerGi\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Scorer function \!\(\*RowBox[{\"Gi\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
ScorerHiPrime::usage = "\!\(\*RowBox[{\"ScorerHiPrime\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the derivative of the Scorer function \!\(\*RowBox[{SuperscriptBox[\"Hi\", \"\[Prime]\", MultilineFunction -> None], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
ScorerHi::usage = "\!\(\*RowBox[{\"ScorerHi\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the Scorer function \!\(\*RowBox[{\"Hi\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
ScreenRectangle::usage = "ScreenRectangle is a global option that specifies the position of the screen by giving the coordinates of two diagonally opposite corners."
ScreenStyleEnvironment::usage = "ScreenStyleEnvironment is an option for notebooks that specifies the style environment to be used in displaying a notebook on the screen. "
ScriptBaselineShifts::usage = "ScriptBaselineShifts is an option for Style that specifies the minimum distance in \!\(\*StyleBox[\"x\", \"TI\"]\)\[Hyphen]heights to shift subscripts and superscripts. "
ScriptLevel::usage = "ScriptLevel is an option for selections that is used in determining the font size of modifiers such as subscripts and superscripts in a nested expression."
ScriptMinSize::usage = "ScriptMinSize is an option for Style which specifies the minimum font size to use in rendering subscripts, etc. "
ScriptSizeMultipliers::usage = "ScriptSizeMultipliers is an option for Style that specifies how much smaller to render each successive level of subscripts, etc. "
Scrollbars::usage = "Scrollbars is an option for Pane that specifies whether scrollbars should be displayed."
ScrollingOptions::usage = "\!\(\*RowBox[{\"ScrollingOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for notebooks that specifies settings for scrolling."
ScrollPosition::usage = "ScrollPosition is an option for Pane that specifies the scroll position of the contents of the pane."
SearchIndexObject::usage = "\!\(\*RowBox[{\"SearchIndexObject\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) represents a search index object, as created by CreateSearchIndex."
SearchIndices::usage = "\!\(\*RowBox[{\"SearchIndices\", \"[\", \"]\"}]\) returns a list with all the locally stored instances of SearchIndexObject."
SechDistribution::usage = "\!\(\*RowBox[{\"SechDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents the hyperbolic secant distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"SechDistribution\", \"[\", \"]\"}]\) represents the hyperbolic secant distribution with location parameter 0 and scale parameter 1."
Sech::usage = "\!\(\*RowBox[{\"Sech\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the hyperbolic secant of \!\(\*StyleBox[\"z\", \"TI\"]\). "
SectorChart3D::usage = "\!\(\*RowBox[{\"SectorChart3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D sector chart with sector angle proportional to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), radius \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and height \!\(\*SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SectorChart3D\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"j\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"j\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D sector chart with sector features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"SectorChart3D\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a 3D sector chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
SectorChart::usage = "\!\(\*RowBox[{\"SectorChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a sector chart with sector angles proportional to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and radii \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SectorChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"j\", \"TI\"]], \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"j\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"j\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a sector chart with sector features defined by the symbolic wrappers \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"k\", \"TI\"]]\).\n\!\(\*RowBox[{\"SectorChart\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a sector chart from multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
SectorOrigin::usage = "SectorOrigin is an option to PieChart and related functions that specifies where sectors should start."
SectorSpacing::usage = "SectorSpacing is an option to PieChart and related functions that specifies radial spacing of sectors. "
Sec::usage = "\!\(\*RowBox[{\"Sec\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the secant of \!\(\*StyleBox[\"z\", \"TI\"]\). "
SeedRandom::usage = "\!\(\*RowBox[{\"SeedRandom\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) resets the pseudorandom generator, using \!\(\*StyleBox[\"n\", \"TI\"]\) as a seed. \n\!\(\*RowBox[{\"SeedRandom\", \"[\", \"]\"}]\) resets the generator, using as a seed the time of day and certain attributes of the current \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) session. "
Selectable::usage = "Selectable is an option for displayed objects, cells, and notebooks that specifies whether their contents can be selected interactively using the front end. "
SelectComponents::usage = "\!\(\*RowBox[{\"SelectComponents\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) computes a property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\" for all components in a label matrix \!\(\*StyleBox[\"m\", \"TI\"]\) and returns a version of \!\(\*StyleBox[\"m\", \"TI\"]\) in which components that do not satisfy \!\(\*StyleBox[\"crit\", \"TI\"]\) are replaced with zeros.\n\!\(\*RowBox[{\"SelectComponents\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a label matrix for the first \!\(\*StyleBox[\"n\", \"TI\"]\) components, ranked by property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\".\n\!\(\*RowBox[{\"SelectComponents\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) uses an ordering function \!\(\*StyleBox[\"p\", \"TI\"]\)."
SelectedCells::usage = "\!\(\*RowBox[{\"SelectedCells\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) returns a list of CellObject expressions corresponding to the currently selected cells in \!\(\*StyleBox[\"notebook\", \"TI\"]\).\n\!\(\*RowBox[{\"SelectedCells\", \"[\", \"]\"}]\) returns the currently selected cells in the notebook in which this function is being evaluated."
SelectedNotebook::usage = "\!\(\*RowBox[{\"SelectedNotebook\", \"[\", \"]\"}]\) gives the currently selected notebook in the front end. "
SelectFirst::usage = "\!\(\*RowBox[{\"SelectFirst\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for which \!\(\*RowBox[{StyleBox[\"crit\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True, or \!\(\*RowBox[{\"Missing\", \"[\", StyleBox[\"\\\"NotFound\\\"\",ShowStringCharacters->True], \"]\"}]\) if none is found.\n\!\(\*RowBox[{\"SelectFirst\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"crit\", \"TI\"], \",\", StyleBox[\"default\", \"TI\"]}], \"]\"}]\) gives \!\(\*StyleBox[\"default\", \"TI\"]\) if there is no \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) such that \!\(\*RowBox[{StyleBox[\"crit\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True.\n\!\(\*RowBox[{\"SelectFirst\", \"[\", StyleBox[\"crit\", \"TI\"], \"]\"}]\) represents an operator form of SelectFirst that can be applied to an expression."
SelectionAnimate::usage = "\!\(\*RowBox[{\"SelectionAnimate\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) animates graphics in the current selection in a notebook. \n\!\(\*RowBox[{\"SelectionAnimate\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) animates graphics for \!\(\*StyleBox[\"t\", \"TI\"]\) seconds. "
SelectionCreateCell::usage = "\!\(\*RowBox[{\"SelectionCreateCell\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) copies the contents of the current selection in a notebook into a new cell. \n\!\(\*RowBox[{\"SelectionCreateCell\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"sel\", \"TI\"]}], \"]\"}]\) sets the current selection after the copy to be as specified by \!\(\*StyleBox[\"sel\", \"TI\"]\). "
SelectionEvaluateCreateCell::usage = "\!\(\*RowBox[{\"SelectionEvaluateCreateCell\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) takes the current selection in a notebook and creates a new cell containing the result obtained by evaluating the contents of the selection using the kernel. \n\!\(\*RowBox[{\"SelectionEvaluateCreateCell\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"sel\", \"TI\"]}], \"]\"}]\) sets the current selection after the evaluation to be as specified by \!\(\*StyleBox[\"sel\", \"TI\"]\). "
SelectionEvaluate::usage = "\!\(\*RowBox[{\"SelectionEvaluate\", \"[\", StyleBox[\"notebook\", \"TI\"], \"]\"}]\) replaces the current selection in a notebook with the result obtained by evaluating the contents of the selection in the kernel. \n\!\(\*RowBox[{\"SelectionEvaluate\", \"[\", RowBox[{StyleBox[\"notebook\", \"TI\"], \",\", StyleBox[\"sel\", \"TI\"]}], \"]\"}]\) sets the current selection after the evaluation to be as specified by \!\(\*StyleBox[\"sel\", \"TI\"]\). "
SelectionMove::usage = "\!\(\*RowBox[{\"SelectionMove\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"dir\", \"TI\"], \",\", StyleBox[\"unit\", \"TI\"]}], \"]\"}]\) moves the current selection in an open notebook in the front end in the direction \!\(\*StyleBox[\"dir\", \"TI\"]\) by the specified unit. \n\!\(\*RowBox[{\"SelectionMove\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"dir\", \"TI\"], \",\", StyleBox[\"unit\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) repeats the move \!\(\*StyleBox[\"n\", \"TI\"]\) times. "
Select::usage = "\!\(\*RowBox[{\"Select\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) picks out all elements \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) of \!\(\*StyleBox[\"list\", \"TI\"]\) for which \!\(\*RowBox[{StyleBox[\"crit\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True. \n\!\(\*RowBox[{\"Select\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) picks out the first \!\(\*StyleBox[\"n\", \"TI\"]\) elements for which \!\(\*RowBox[{StyleBox[\"crit\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True. \n\!\(\*RowBox[{\"Select\", \"[\", StyleBox[\"crit\", \"TI\"], \"]\"}]\) represents an operator form of Select that can be applied to an expression. "
SelfLoopStyle::usage = "SelfLoopStyle is an option for GraphPlot and related functions that specifies how to draw self-loops that connect a vertex to itself."
SemanticImportString::usage = "\!\(\*RowBox[{\"SemanticImportString\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) attempts to import a string semantically to give a Dataset object.\n\!\(\*RowBox[{\"SemanticImportString\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) attempts to interpret all elements in the string as being of the specified type.\n\!\(\*RowBox[{\"SemanticImportString\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) attempts to interpret elements in successive columns as being of the specified types. \n\!\(\*RowBox[{RowBox[{RowBox[{\"SemanticImportString\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"->\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"->\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]}]}], \"\[RightAssociation]\"}], \"]\"}]\) attempts to interpret elements in the named columns as being of the specified types.\n\!\(\*RowBox[{\"SemanticImportString\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"typespec\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) puts the result in the specified form."
SemanticImport::usage = "\!\(\*RowBox[{\"SemanticImport\", \"[\", StyleBox[\"file\", \"TI\"], \"]\"}]\) attempts to import a file semantically to give a Dataset object.\n\!\(\*RowBox[{\"SemanticImport\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) attempts to interpret all elements in the file as being of the specified type.\n\!\(\*RowBox[{\"SemanticImport\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) attempts to interpret elements in successive columns as being of the specified types. \n\!\(\*RowBox[{\"SemanticImport\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"->\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"->\", SubscriptBox[StyleBox[\"type\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}]}], \"]\"}]\) keeps only the columns \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) specified by their positions or names.\n\!\(\*RowBox[{\"SemanticImport\", \"[\", RowBox[{StyleBox[\"file\", \"TI\"], \",\", StyleBox[\"typespec\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) puts the result in the specified form."
SemanticInterpretation::usage = "\!\(\*RowBox[{\"SemanticInterpretation\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) attempts to give the best semantic interpretation of the specified free-form string as a Wolfram Language expression.\n\!\(\*RowBox[{\"SemanticInterpretation\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) filters possible semantic interpretations, returning the best one that matches the specified pattern.\n\!\(\*RowBox[{\"SemanticInterpretation\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"pattern\", \"TI\"], \",\", StyleBox[\"head\", \"TI\"]}], \"]\"}]\) returns the semantic interpretation wrapped with the specified head."
SemialgebraicComponentInstances::usage = "\!\(\*RowBox[{\"SemialgebraicComponentInstances\", \"[\", RowBox[{StyleBox[\"ineqs\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives at least one sample point in each connected component of the semialgebraic set defined by the inequalities \!\(\*StyleBox[\"ineqs\", \"TI\"]\) in the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
SendMail::usage = "\!\(\*RowBox[{\"SendMail\", \"[\", StyleBox[\"body\", \"TI\"], \"]\"}]\) sends mail consisting of \!\(\*StyleBox[\"body\", \"TI\"]\) to the address specified by $WolframID.\n\!\(\*RowBox[{\"SendMail\", \"[\", RowBox[{\"{\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"subject\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"}\"}], \"]\"}]\) sends mail with the specified subject and no body.\n\!\(\*RowBox[{\"SendMail\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"subject\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"body\", \"TI\"]}], \"}\"}], \"]\"}]\) sends mail with the specified subject and body.\n\!\(\*RowBox[{\"SendMail\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"subject\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"body\", \"TI\"], \",\", StyleBox[\"att\", \"TI\"]}], \"}\"}], \"]\"}]\) sends mail with the attachment or attachments \!\(\*StyleBox[\"att\", \"TI\"]\).\n\!\(\*RowBox[{\"SendMail\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"to\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"content\", \"TI\"]}], \"]\"}]\) sends mail to the specified To: address.\n\!\(\*RowBox[{\"SendMail\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"to\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"to\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"content\", \"TI\"]}], \"]\"}]\) sends mail to multiple To: addresses.\n\!\(\*RowBox[{\"SendMail\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"to\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"content\", \"TI\"]}], \"]\"}]\) includes the \!\(\*SubscriptBox[StyleBox[\"cc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as Cc: addresses.\n\!\(\*RowBox[{\"SendMail\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"to\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"bcc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"content\", \"TI\"]}], \"]\"}]\) also includes the \!\(\*SubscriptBox[StyleBox[\"bcc\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as Bcc: addresses.\n\!\(\*RowBox[{\"SendMail\", \"[\", RowBox[{StyleBox[\"recipients\", \"TI\"], \",\", StyleBox[\"content\", \"TI\"], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) uses the options \!\(\*StyleBox[\"opts\", \"TI\"]\).\n\!\(\*RowBox[{\"SendMail\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) sends mail with elements specified in the association \!\(\*StyleBox[\"assoc\", \"TI\"]\)."
SendMessage::usage = "\!\(\*RowBox[{\"SendMessage\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", StyleBox[\"message\", \"TI\"]}], \"]\"}]\) sends a message to the specified channel.\n\!\(\*RowBox[{\"SendMessage\", \"[\", RowBox[{RowBox[{StyleBox[\"channel\", \"TI\"], \"\[Rule]\", StyleBox[\"dest\", \"TI\"]}], \",\", StyleBox[\"message\", \"TI\"]}], \"]\"}]\) sends a message to the destination \!\(\*StyleBox[\"dest\", \"TI\"]\) through the specified channel."
SequenceAlignment::usage = "\!\(\*RowBox[{\"SequenceAlignment\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) finds an optimal alignment of sequences of elements in the strings or lists \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and yields a list of successive matching and differing sequences."
SequenceCases::usage = "\!\(\*RowBox[{\"SequenceCases\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of the sublists in \!\(\*StyleBox[\"list\", \"TI\"]\) that match the sequence pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"SequenceCases\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{StyleBox[\"patt\", \"TI\"], \"\[Rule]\", StyleBox[\"rhs\", \"TI\"]}]}], \"]\"}]\) gives a list of the values of \!\(\*StyleBox[\"rhs\", \"TI\"]\) corresponding to sublists that match \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"SequenceCases\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) includes only the first \!\(\*StyleBox[\"n\", \"TI\"]\) matches."
SequenceCount::usage = "\!\(\*RowBox[{\"SequenceCount\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"sub\", \"TI\"]}], \"]\"}]\) gives a count of the number of times \!\(\*StyleBox[\"sub\", \"TI\"]\) appears as a sublist of \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"SequenceCount\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives the number of sublists in \!\(\*StyleBox[\"list\", \"TI\"]\) that match the general sequence pattern \!\(\*StyleBox[\"patt\", \"TI\"]\). "
SequenceFoldList::usage = "\!\(\*RowBox[{\"SequenceFoldList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"SequenceFoldList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to \!\(\*StyleBox[\"k\", \"TI\"]\) arguments at each step, with the first \!\(\*StyleBox[\"n\", \"TI\"]\) coming from the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) or previous results, and the last \!\(\*RowBox[{StyleBox[\"k\", \"TI\"], \"-\", StyleBox[\"n\", \"TI\"]}]\) coming from the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
SequenceFold::usage = "\!\(\*RowBox[{\"SequenceFold\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the last element of \!\(\*RowBox[{\"SequenceFoldList\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\).\n\!\(\*RowBox[{\"SequenceFold\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to \!\(\*StyleBox[\"k\", \"TI\"]\) arguments at each step, with the first \!\(\*StyleBox[\"n\", \"TI\"]\) coming from the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) or previous results, and the last \!\(\*RowBox[{StyleBox[\"k\", \"TI\"], \"-\", StyleBox[\"n\", \"TI\"]}]\) coming from the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
SequenceForm::usage = "\!\(\*RowBox[{\"SequenceForm\", \"[\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) prints as the textual concatenation of the printed forms of the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
SequenceHold::usage = "SequenceHold is an attribute that specifies that Sequence objects appearing in the arguments of a function should not automatically be flattened out. "
SequenceLimit::usage = "\!\(\*RowBox[{\"SequenceLimit\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) returns the approximation given by Wynn's epsilon algorithm to the limit of a sequence whose first few terms are given by list. Warning: Wynn's epsilon algorithm can give finite results for divergent sequences."
SequencePosition::usage = "\!\(\*RowBox[{\"SequencePosition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"sublist\", \"TI\"]}], \"]\"}]\) gives a list of the starting and ending positions at which \!\(\*StyleBox[\"sublist\", \"TI\"]\) appears in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"SequencePosition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives all positions at which sequences matching \!\(\*StyleBox[\"patt\", \"TI\"]\) occur in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"SequencePosition\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) includes only the first \!\(\*StyleBox[\"n\", \"TI\"]\) occurrences of \!\(\*StyleBox[\"patt\", \"TI\"]\)."
Sequence::usage = "\!\(\*RowBox[{\"Sequence\", \"[\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a sequence of arguments to be spliced automatically into any function. "
SeriesCoefficient::usage = "\!\(\*RowBox[{\"SeriesCoefficient\", \"[\", RowBox[{StyleBox[\"series\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) finds the coefficient of the \!\(\*StyleBox[RowBox[{StyleBox[\"n\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\)-order term in a power series in the form generated by Series. \n\!\(\*RowBox[{\"SeriesCoefficient\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) finds the coefficient of \!\(\*SuperscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"-\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"0\"]}], \")\"}], StyleBox[\"n\", \"TI\"]]\) in the expansion of \!\(\*StyleBox[\"f\", \"TI\"]\) about the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"0\"]}]\).\n\!\(\*RowBox[{\"SeriesCoefficient\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"x\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds a coefficient in a multivariate series. "
SeriesData::usage = "\!\(\*RowBox[{\"SeriesData\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"den\", \"TI\"]}], \"]\"}]\) represents a power series in the variable \!\(\*StyleBox[\"x\", \"TI\"]\) about the point \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\). The \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are the coefficients in the power series. The powers of \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"-\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \")\"}]\) that appear are \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"/\", StyleBox[\"den\", \"TI\"]}]\), \!\(\*RowBox[{RowBox[{\"(\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"+\", \"1\"}], \")\"}], \"/\", StyleBox[\"den\", \"TI\"]}]\), \[Ellipsis], \!\(\*RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]], \"/\", StyleBox[\"den\", \"TI\"]}]\). "
Series::usage = "\!\(\*RowBox[{\"Series\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) generates a power series expansion for \!\(\*StyleBox[\"f\", \"TI\"]\) about the point \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\) to order \!\(\*SuperscriptBox[RowBox[{\"(\", RowBox[{StyleBox[\"x\", \"TI\"], \"-\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \")\"}], StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"Series\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"x\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) successively finds series expansions with respect to \!\(\*StyleBox[\"x\", \"TI\"]\), then \!\(\*StyleBox[\"y\", \"TI\"]\), etc. "
ServiceConnect::usage = "\!\(\*RowBox[{\"ServiceConnect\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"service\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) creates a connection to an external service.\n\!\(\*RowBox[{\"ServiceConnect\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"service\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"id\", \"TI\"]}], \"]\"}]\) uses the specified connection identifier."
ServiceDisconnect::usage = "\!\(\*RowBox[{\"ServiceDisconnect\", \"[\", StyleBox[\"service\", \"TI\"], \"]\"}]\) disconnects from an external service specified by a ServiceObject."
ServiceExecute::usage = "\!\(\*RowBox[{\"ServiceExecute\", \"[\", RowBox[{StyleBox[\"service\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"req\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) executes \"\!\(\*\nStyleBox[\"req\", \"TI\"]\)\" on an external service.\n\!\(\*RowBox[{\"ServiceExecute\", \"[\", RowBox[{StyleBox[\"service\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"req\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"par\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) executes \"\!\(\*\nStyleBox[\"req\", \"TI\"]\)\" with the specified settings for parameters."
ServiceObject::usage = "\!\(\*RowBox[{\"ServiceObject\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"service\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents an open connection to an external service."
SessionTime::usage = "\!\(\*RowBox[{\"SessionTime\", \"[\", \"]\"}]\) gives the total number of seconds of real time that have elapsed since the beginning of your \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) session. "
SetAccuracy::usage = "\!\(\*RowBox[{\"SetAccuracy\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) yields a version of \!\(\*StyleBox[\"expr\", \"TI\"]\) in which all numbers have been set to have accuracy \!\(\*StyleBox[\"a\", \"TI\"]\). "
SetAlphaChannel::usage = "\!\(\*RowBox[{\"SetAlphaChannel\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) adds a fully opaque alpha channel to \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"SetAlphaChannel\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) sets the opacity of all pixels to \!\(\*StyleBox[\"a\", \"TI\"]\).\n\!\(\*RowBox[{\"SetAlphaChannel\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"aimage\", \"TI\"]}], \"]\"}]\) sets the alpha channel of \!\(\*StyleBox[\"image\", \"TI\"]\) to \!\(\*StyleBox[\"aimage\", \"TI\"]\)."
SetAttributes::usage = "\!\(\*RowBox[{\"SetAttributes\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"attr\", \"TI\"]}], \"]\"}]\) adds \!\(\*StyleBox[\"attr\", \"TI\"]\) to the list of attributes of the symbol \!\(\*StyleBox[\"s\", \"TI\"]\). "
SetCloudDirectory::usage = "\!\(\*RowBox[{\"SetCloudDirectory\", \"[\", StyleBox[\"dir\", \"TI\"], \"]\"}]\) sets the current working directory used for cloud objects to \!\(\*StyleBox[\"dir\", \"TI\"]\).\n\!\(\*RowBox[{\"SetCloudDirectory\", \"[\", \"]\"}]\) sets the current working directory for cloud objects to $CloudRootDirectory."
SetDelayed::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \":=\", StyleBox[\"rhs\", \"TI\"]}]\) assigns \!\(\*StyleBox[\"rhs\", \"TI\"]\) to be the delayed value of \!\(\*StyleBox[\"lhs\", \"TI\"]\). \!\(\*StyleBox[\"rhs\", \"TI\"]\) is maintained in an unevaluated form. When \!\(\*StyleBox[\"lhs\", \"TI\"]\) appears, it is replaced by \!\(\*StyleBox[\"rhs\", \"TI\"]\), evaluated afresh each time. "
SetDirectory::usage = "\!\(\*RowBox[{\"SetDirectory\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"dir\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) sets the current working directory to \!\(\*StyleBox[\"dir\", \"TI\"]\). \n\!\(\*RowBox[{\"SetDirectory\", \"[\", \"]\"}]\) sets the current working directory to your \"home\" directory."
SetEnvironment::usage = "\!\(\*RowBox[{\"SetEnvironment\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"var\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"value\", \"TI\"]}], \"]\"}]\) sets the value of an operating system environment variable.\n\!\(\*RowBox[{\"SetEnvironment\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"var\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"value\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) sets values for several environment variables."
SetFileDate::usage = "\!\(\*RowBox[{\"SetFileDate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) sets the modification and access dates for a file to be the current date. "
SetImage::usage = "\!\(\*RowBox[{\"SetImage\", \"[\", RowBox[{StyleBox[\"var\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) checks for a valid \!\(\*StyleBox[\"expr\", \"TI\"]\), assigns it to \!\(\*StyleBox[\"var\", \"TI\"]\) and return True, otherwise return False.\n\!\(\*RowBox[{\"SetImage\", \"[\", RowBox[{StyleBox[\"var\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"head\", \"TI\"]}], \"]\"}]\) sends the \!\(\*RowBox[{StyleBox[\"head\", \"TI\"], \"::\", \"imginv\"}]\) message and throws $Failed if \!\(\*StyleBox[\"expr\", \"TI\"]\) is invalid.\n\!\(\*RowBox[{\"SetImage\", \"[\", RowBox[{StyleBox[\"var\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"head\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) uses the \!\(\*RowBox[{StyleBox[\"head\", \"TI\"], \"::\", StyleBox[\"tag\", \"TI\"]}]\) message."
SetOptions::usage = "\!\(\*RowBox[{\"SetOptions\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) sets the specified default options for a symbol \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"SetOptions\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) or \!\(\*RowBox[{\"SetOptions\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) sets options associated with a particular stream. \n\!\(\*RowBox[{\"SetOptions\", \"[\", RowBox[{StyleBox[\"object\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) sets options associated with an external object such as a NotebookObject. "
SetPermissions::usage = "\!\(\*RowBox[{\"SetPermissions\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"pstring\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) sets permissions for the cloud object \!\(\*StyleBox[\"obj\", \"TI\"]\) to be as specified by the string \!\(\*StyleBox[\"pstring\", \"TI\"]\).\n\!\(\*RowBox[{\"SetPermissions\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", RowBox[{StyleBox[\"class\", \"TI\"], \"\[Rule]\", StyleBox[\"per\", \"TI\"]}]}], \"]\"}]\) sets permissions for the specified class of users to be \!\(\*StyleBox[\"per\", \"TI\"]\).\n\!\(\*RowBox[{\"SetPermissions\", \"[\", StyleBox[\"pers\", \"TI\"], \"]\"}]\) sets permissions as specified by \!\(\*StyleBox[\"pers\", \"TI\"]\) for the cloud object corresponding to the current document."
SetPrecision::usage = "\!\(\*RowBox[{\"SetPrecision\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) yields a version of \!\(\*StyleBox[\"expr\", \"TI\"]\) in which all numbers have been set to have precision \!\(\*StyleBox[\"p\", \"TI\"]\). "
SetProperty::usage = "\!\(\*RowBox[{\"SetProperty\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[RowBox[{\"obj\", \",\", \"itemspec\"}], \"TI\"], StyleBox[\"}\", \"TI\"]}], \",\", RowBox[{StyleBox[\"name\", \"TI\"], \"\[Rule]\", StyleBox[\"value\", \"TI\"]}]}], \"]\"}]\) sets the property \!\(\*RowBox[{StyleBox[\"name\", \"TI\"], \"\[Rule]\", StyleBox[\"value\", \"TI\"]}]\) for \!\(\*StyleBox[\"itemspec\", \"TI\"]\) in \!\(\*StyleBox[\"obj\", \"TI\"]\)."
SetSelectedNotebook::usage = "\!\(\*RowBox[{\"SetSelectedNotebook\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) makes the notebook corresponding to \!\(\*StyleBox[\"obj\", \"TI\"]\) be the currently selected one in the front end."
SetSharedFunction::usage = "\!\(\*RowBox[{\"SetSharedFunction\", \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) declares the symbols \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as shared functions whose downvalues are synchronized among all parallel kernels."
SetSharedVariable::usage = "\!\(\*RowBox[{\"SetSharedVariable\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) declares the symbols \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as shared variables whose values are synchronized among all parallel kernels."
SetStreamPosition::usage = "\!\(\*RowBox[{\"SetStreamPosition\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) sets the current point in an open stream. "
SetSystemOptions::usage = "\!\(\*RowBox[{\"SetSystemOptions\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"value\", \"TI\"]}], \"]\"}]\) resets the value for the internal system option with the specified name."
SetterBar::usage = "\!\(\*RowBox[{\"SetterBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a setter bar with setting \!\(\*StyleBox[\"x\", \"TI\"]\) and with setter buttons for values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SetterBar\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being reset every time a setter button is clicked.\n\!\(\*RowBox[{\"SetterBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a setter bar in which the setter button giving value \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) has label \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
SetterBoxOptions::usage = "\!\(\*RowBox[{SetterBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for SetterBox objects."
Setter::usage = "\!\(\*RowBox[{\"Setter\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) represents a setter button whose setting \!\(\*StyleBox[\"x\", \"TI\"]\) is set to \!\(\*StyleBox[\"val\", \"TI\"]\) when the button is clicked. The button is labeled with \!\(\*StyleBox[\"val\", \"TI\"]\), and appears pressed if the value of \!\(\*StyleBox[\"x\", \"TI\"]\) is \!\(\*StyleBox[\"val\", \"TI\"]\), and unpressed otherwise.\n\!\(\*RowBox[{\"Setter\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being reset if the button is clicked.\n\!\(\*RowBox[{\"Setter\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"], \",\", StyleBox[\"label\", \"TI\"]}], \"]\"}]\) labels the setter button with \!\(\*StyleBox[\"label\", \"TI\"]\).\n\!\(\*RowBox[{\"Setter\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"label\", \"TI\"]}], \"]\"}]\) represents a setter button that sets \!\(\*StyleBox[\"x\", \"TI\"]\) to \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"n\", \"TI\"]]\) if multiclicked \!\(\*StyleBox[\"n\", \"TI\"]\) times. "
Setting::usage = "\!\(\*RowBox[{\"Setting\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) replaces forms and control objects such as sliders or popup menus in \!\(\*StyleBox[\"expr\", \"TI\"]\) by their settings."
Set::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"=\", StyleBox[\"rhs\", \"TI\"]}]\) evaluates \!\(\*StyleBox[\"rhs\", \"TI\"]\) and assigns the result to be the value of \!\(\*StyleBox[\"lhs\", \"TI\"]\). From then on, \!\(\*StyleBox[\"lhs\", \"TI\"]\) is replaced by \!\(\*StyleBox[\"rhs\", \"TI\"]\) whenever it appears. \n\!\(\*RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"=\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) evaluates the \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and assigns the results to be the values of the corresponding \!\(\*SubscriptBox[StyleBox[\"l\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
SetUsers::usage = "\!\(\*RowBox[{\"SetUsers\", \"[\", RowBox[{StyleBox[\"group\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) sets the members of the permissions group \!\(\*StyleBox[\"group\", \"TI\"]\) to be \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"user\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
Shading::usage = "Shading is an option for SurfaceGraphics that specifies whether the surfaces should be shaded. "
Shallow::usage = "\!\(\*RowBox[{\"Shallow\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as a shallow form of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Shallow\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"depth\", \"TI\"]}], \"]\"}]\) prints with all parts of \!\(\*StyleBox[\"expr\", \"TI\"]\) below the specified depth given in skeleton form. \n\!\(\*RowBox[{\"Shallow\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"depth\", \"TI\"], \",\", StyleBox[\"length\", \"TI\"]}], \"}\"}]}], \"]\"}]\) also gives parts whose lengths are above the specified limit in skeleton form. \n\!\(\*RowBox[{\"Shallow\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"depth\", \"TI\"], \",\", StyleBox[\"length\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) uses skeleton form for any parts that match the pattern \!\(\*StyleBox[\"form\", \"TI\"]\). "
ShannonWavelet::usage = "\!\(\*RowBox[{\"ShannonWavelet\", \"[\", \"]\"}]\) represents the Shannon wavelet evaluated on the equally spaced interval \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"-\", \"10\"}], \",\", \"10\"}], \"}\"}]\). \n\!\(\*RowBox[{\"ShannonWavelet\", \"[\", StyleBox[\"lim\", \"TI\"], \"]\"}]\) represents the Shannon wavelet evaluated on the equally spaced interval \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"-\", StyleBox[\"lim\", \"TI\"]}], \",\", StyleBox[\"lim\", \"TI\"]}], StyleBox[\"}\", \"TI\"]}]\). "
ShapiroWilkTest::usage = "\!\(\*RowBox[{\"ShapiroWilkTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed using the Shapiro\[Dash]Wilk test.\n\!\(\*RowBox[{\"ShapiroWilkTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
Share::usage = "\!\(\*RowBox[{\"Share\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) changes the way \!\(\*StyleBox[\"expr\", \"TI\"]\) is stored internally, to try and minimize the amount of memory used. \n\!\(\*RowBox[{\"Share\", \"[\", \"]\"}]\) tries to minimize the memory used to store all expressions. "
Sharpen::usage = "\!\(\*RowBox[{\"Sharpen\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a sharpened version of \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"Sharpen\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives a version of \!\(\*StyleBox[\"image\", \"TI\"]\) sharpened over pixel radius \!\(\*StyleBox[\"r\", \"TI\"]\)."
ShearingMatrix::usage = "\!\(\*RowBox[{\"ShearingMatrix\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the matrix corresponding to shearing by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians along the direction of the vector \!\(\*StyleBox[\"v\", \"TI\"]\), and normal to the vector \!\(\*StyleBox[\"n\", \"TI\"]\). "
ShearingTransform::usage = "\!\(\*RowBox[{\"ShearingTransform\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a TransformationFunction that represents a shear by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) radians along the direction of the vector \!\(\*StyleBox[\"v\", \"TI\"]\), normal to the vector \!\(\*StyleBox[\"n\", \"TI\"]\), and keeping the origin fixed.\n\!\(\*RowBox[{\"ShearingTransform\", \"[\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives a shear that keeps the point \!\(\*StyleBox[\"p\", \"TI\"]\) fixed, rather than the origin."
ShenCastanMatrix::usage = "\!\(\*RowBox[{\"ShenCastanMatrix\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) gives a matrix that corresponds to an exponential kernel of radius \!\(\*StyleBox[\"r\", \"TI\"]\). \n\!\(\*RowBox[{\"ShenCastanMatrix\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a matrix corresponding to an exponential kernel with radius \!\(\*StyleBox[\"r\", \"TI\"]\) and region of support specified by \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"ShenCastanMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives a matrix formed from the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative of the exponential with respect to rows and the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) derivative with respect to columns.\n\!\(\*RowBox[{\"ShenCastanMatrix\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"12\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"22\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a matrix formed from the sums of the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[StyleBox[RowBox[{\"i\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[StyleBox[RowBox[{\"i\", StyleBox[\"2\", FontSlant -> \"Plain\"]}]], \"TI\"]]\) derivatives.\n\!\(\*RowBox[{\"ShenCastanMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives an array corresponding to an exponential kernel with radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) index direction."
ShiftedGompertzDistribution::usage = "\!\(\*RowBox[{\"ShiftedGompertzDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Xi]\", \"TR\"]}], \"]\"}]\) represents a shifted Gompertz distribution with scale parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\) and shape parameter \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\)."
ShortDownArrow::usage = "\!\(\*RowBox[{\"ShortDownArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[ShortDownArrow]\", StyleBox[\"y\", \"TI\"], \"\[ShortDownArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
ShortestMatch::usage = "\!\(\*RowBox[{\"ShortestMatch\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) is a string pattern object matching the shortest sequence of characters consistent with the string pattern \!\(\*StyleBox[\"p\", \"TI\"]\)."
ShortestPathFunction::usage = "\!\(\*RowBox[{\"ShortestPathFunction\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) represents a function that gives the shortest path from a source vertex \!\(\*StyleBox[\"s\", \"TI\"]\) to target vertex \!\(\*StyleBox[\"t\", \"TI\"]\) in a graph."
Shortest::usage = "\!\(\*RowBox[{\"Shortest\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) is a pattern object that matches the shortest sequence consistent with the pattern \!\(\*StyleBox[\"p\", \"TI\"]\). "
ShortLeftArrow::usage = "\!\(\*RowBox[{\"ShortLeftArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[ShortLeftArrow]\", StyleBox[\"y\", \"TI\"], \"\[ShortLeftArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
ShortRightArrow::usage = "\!\(\*RowBox[{\"ShortRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[ShortRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[ShortRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
ShortUpArrow::usage = "\!\(\*RowBox[{\"ShortUpArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[ShortUpArrow]\", StyleBox[\"y\", \"TI\"], \"\[ShortUpArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Short::usage = "\!\(\*RowBox[{\"Short\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as a short form of \!\(\*StyleBox[\"expr\", \"TI\"]\), less than about one line long. \n\!\(\*RowBox[{\"Short\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) prints as a form of \!\(\*StyleBox[\"expr\", \"TI\"]\) about \!\(\*StyleBox[\"n\", \"TI\"]\) lines long. "
ShowAutoStyles::usage = "ShowAutoStyles is an option for Cell that specifies whether styles that are specified to be automatically used for various syntactic and other constructs should be shown. "
ShowCellBracket::usage = "ShowCellBracket is an option for Cell that specifies whether to display the bracket that indicates the extent of the cell. "
ShowCellLabel::usage = "ShowCellLabel is an option for Cell that specifies whether to display the label for a cell. "
ShowCellTags::usage = "ShowCellTags is an option for Cell that specifies whether to display tags for a cell. "
ShowClosedCellArea::usage = "ShowClosedCellArea is an option for cells that specifies whether a rectangular bar is displayed next to a closed cell group to indicate the number of cells in the group."
ShowContents::usage = "ShowContents is an option for selections that specifies whether an object represented by a StyleBox should be displayed on the screen or replaced by blank space."
ShowCursorTracker::usage = "ShowCursorTracker is an option for Cell that specifies whether an elliptical spot should appear momentarily to guide the eye if the cursor position jumps. "
ShowGroupOpenCloseIcon::usage = "ShowGroupOpenCloseIcon is an option for cells that specifies whether a triangular icon is displayed next to the leading cell in a cell group to indicate whether the cell group is open or closed."
ShowGroupOpener::usage = "ShowGroupOpener is an option for cells that specifies whether an opener icon is displayed next to the leading cell in a cell group to indicate whether the cell group is open or closed."
ShowPageBreaks::usage = "ShowPageBreaks is a notebook option that specifies whether to indicate in the on\[Hyphen]screen display of a notebook where page breaks would occur if the notebook were printed. "
ShowSelection::usage = "ShowSelection is an option to Notebook, Cell, and Style that specifies whether to show the current selection highlighted. "
ShowShortBoxForm::usage = "ShowShortBoxForm is an option for cells that specifies whether box expressions, which are used to represent two-dimensional forms in a cell, are displayed in a more compact notation when the expression for that cell is viewed."
ShowStringCharacters::usage = "ShowStringCharacters is an option for Cell that specifies whether to display \" when a string is entered. "
Show::usage = "\!\(\*RowBox[{\"Show\", \"[\", RowBox[{StyleBox[\"graphics\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) shows graphics with the specified options added. \n\!\(\*RowBox[{\"Show\", \"[\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) shows several graphics combined. "
ShrinkingDelay::usage = "ShrinkingDelay is an option for dynamic objects that specifies how long to delay before shrinking the size of the region in which the object is displayed to the actual size of the object. "
SiderealTime::usage = "\!\(\*RowBox[{\"SiderealTime\", \"[\", \"]\"}]\) gives the right ascension of the local meridian for the current date and location.\n\!\(\*RowBox[{\"SiderealTime\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) gives the right ascension of the local meridian for the specified date.\n\!\(\*RowBox[{\"SiderealTime\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) gives the right ascension of the local meridian for the specified location.\n\!\(\*RowBox[{\"SiderealTime\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"date\", \"TI\"]}], \"]\"}]\) gives the right ascension of the local meridian for the specified date and location.\n\!\(\*RowBox[{\"SiderealTime\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the right ascensions of the local meridians for all specified locations on the specified dates.\n\!\(\*RowBox[{\"SiderealTime\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"date\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"func\", \"TI\"]\) to determine what to return for extended locations."
SiegelTheta::usage = "\!\(\*RowBox[{\"SiegelTheta\", \"[\", RowBox[{StyleBox[\"\[CapitalOmega]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the Siegel theta function \!\(\*RowBox[{\"\[CapitalTheta]\", \" \", RowBox[{\"(\", RowBox[{StyleBox[\"\[CapitalOmega]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"]}], \")\"}]}]\) with Riemann modular matrix \!\(\*StyleBox[\"\[CapitalOmega]\", \"TR\"]\) and vector \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{\"SiegelTheta\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Nu]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Nu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[CapitalOmega]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the Siegel theta function \!\(\*RowBox[{RowBox[{\"\[CapitalTheta]\", \" \", \"[\", RowBox[{SubscriptBox[\"\[Nu]\", \"1\"], \",\", SubscriptBox[\"\[Nu]\", \"2\"]}], \"]\"}], RowBox[{\"(\", \" \", RowBox[{StyleBox[\"\[CapitalOmega]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"]}], \")\"}]}]\) with characteristics \!\(\*StyleBox[SubscriptBox[StyleBox[\"\[Nu]\", \"TR\"], \"1\"], \"TR\"]\) and \!\(\*StyleBox[SubscriptBox[StyleBox[\"\[Nu]\", \"TR\"], \"2\"], \"TR\"]\)."
SiegelTukeyTest::usage = "\!\(\*RowBox[{\"SiegelTukeyTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the variances of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"SiegelTukeyTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests a dispersion measure against\!\(\*RowBox[{\" \", SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]]}]\).\n\!\(\*RowBox[{\"SiegelTukeyTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubsuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
Signature::usage = "\!\(\*RowBox[{\"Signature\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the signature of the permutation needed to place the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) in canonical order. "
SignedRankTest::usage = "\!\(\*RowBox[{\"SignedRankTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the median of \!\(\*StyleBox[\"data\", \"TI\"]\) is zero. \n\!\(\*RowBox[{\"SignedRankTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the median of \!\(\*RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"-\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]\) is zero.\n\!\(\*RowBox[{\"SignedRankTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], \"0\"], \"TR\"]}], \"]\"}]\) tests a location measure against \!\(\*StyleBox[SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], \"0\"], \"TR\"]\).\n\!\(\*RowBox[{\"SignedRankTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], \"0\"], \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
SignedRegionDistance::usage = "\!\(\*RowBox[{\"SignedRegionDistance\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the minimum distance from the point \!\(\*StyleBox[\"p\", \"TI\"]\) to the region \!\(\*StyleBox[\"reg\", \"TI\"]\) if \!\(\*StyleBox[\"p\", \"TI\"]\) is outside the region and the minimum distance to the complement of \!\(\*StyleBox[\"reg\", \"TI\"]\) if \!\(\*StyleBox[\"p\", \"TI\"]\) is inside the region.\n\!\(\*RowBox[{\"SignedRegionDistance\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives a \!\(\*RowBox[{\"RegionDistanceFunction\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) that can be applied repeatedly to different points."
SignificanceLevel::usage = "SignificanceLevel is an option to VarianceTest and similar functions that controls cutoffs for diagnostic tests as well as test conclusions. "
SignPadding::usage = "SignPadding is an option for NumberForm and related functions that specifies whether padding should be inserted after signs. "
SignTest::usage = "\!\(\*RowBox[{\"SignTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the median of \!\(\*StyleBox[\"data\", \"TI\"]\) is zero. \n\!\(\*RowBox[{\"SignTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the median of \!\(\*RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Dash]\", \" \", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]\) is zero.\n\!\(\*RowBox[{\"SignTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], \"0\"], \"TR\"]}], \"]\"}]\) tests a location measure against \!\(\*StyleBox[SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], \"0\"], \"TR\"]\).\n\!\(\*RowBox[{\"SignTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", StyleBox[SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], \"0\"], \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
Sign::usage = "\!\(\*RowBox[{\"Sign\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives \!\(\*RowBox[{\"-\", \"1\"}]\), 0, or 1 depending on whether \!\(\*StyleBox[\"x\", \"TI\"]\) is negative, zero, or positive. "
SimilarityRules::usage = "SimilarityRules is an option for functions such as SequenceAlignment that gives a list of rules for similarity scores to assume between pairs of elements."
SimpleGraphQ::usage = "\!\(\*RowBox[{\"SimpleGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a simple graph and False otherwise."
SimpleGraph::usage = "\!\(\*RowBox[{\"SimpleGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the underlying simple graph from the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"SimpleGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
Simplex::usage = "\!\(\*RowBox[{\"Simplex\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents the simplex spanned by points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Simplify::usage = "\!\(\*RowBox[{\"Simplify\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) performs a sequence of algebraic and other transformations on \!\(\*StyleBox[\"expr\", \"TI\"]\) and returns the simplest form it finds. \n\!\(\*RowBox[{\"Simplify\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"assum\", \"TI\"]}], \"]\"}]\) does simplification using assumptions. "
Sinc::usage = "\!\(\*RowBox[{\"Sinc\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives \!\(\*RowBox[{\"sinc\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
SinghMaddalaDistribution::usage = "\!\(\*RowBox[{\"SinghMaddalaDistribution\", \"[\", RowBox[{StyleBox[\"q\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) represents the Singh\[Dash]Maddala distribution with shape parameters \!\(\*StyleBox[\"q\", \"TI\"]\) and \!\(\*StyleBox[\"a\", \"TI\"]\) and scale parameter \!\(\*StyleBox[\"b\", \"TI\"]\)."
SingleLetterItalics::usage = "SingleLetterItalics is an option for Cell that specifies whether single\[Hyphen]letter names should be displayed in italics. "
SingularityDepth::usage = "SingularityDepth is an option for NIntegrate. \!\(\*RowBox[{\"SingularityDepth\", \" \", \"->\", \" \", StyleBox[\"n\", \"TI\"]}]\) specifies that \!\(\*StyleBox[\"n\", \"TI\"]\) recursive subdivisions can be done before a change of variable is used at the endpoints of the interval of integration."
SingularValueDecomposition::usage = "\!\(\*RowBox[{\"SingularValueDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the singular value decomposition for a numerical matrix \!\(\*StyleBox[\"m\", \"TI\"]\) as a list of matrices \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]\), where \!\(\*StyleBox[\"w\", \"TI\"]\) is a diagonal matrix and \!\(\*StyleBox[\"m\", \"TI\"]\) can be written as \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \".\", StyleBox[\"w\", \"TI\"], \".\", RowBox[{\"Conjugate\", \"[\", RowBox[{\"Transpose\", \"[\", StyleBox[\"v\", \"TI\"], \"]\"}], \"]\"}]}]\). \n\!\(\*RowBox[{\"SingularValueDecomposition\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the generalized singular value decomposition of \!\(\*StyleBox[\"m\", \"TI\"]\) with respect to \!\(\*StyleBox[\"a\", \"TI\"]\). \n\!\(\*RowBox[{\"SingularValueDecomposition\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the singular value decomposition associated with the \!\(\*StyleBox[\"k\", \"TI\"]\) largest singular values of \!\(\*StyleBox[\"m\", \"TI\"]\). \!\(\*RowBox[{\"SingularValueDecomposition\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", RowBox[{\"UpTo\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]}], \"]\"}]\) gives the decomposition for the \!\(\*StyleBox[\"k\", \"TI\"]\) largest singular values, or as many as are available.\n\!\(\*RowBox[{\"SingularValueDecomposition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the generalized singular value decomposition associated with the \!\(\*StyleBox[\"k\", \"TI\"]\) largest singular values."
SingularValueList::usage = "\!\(\*RowBox[{\"SingularValueList\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a list of the nonzero singular values of a matrix \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"SingularValueList\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the generalized singular values of \!\(\*StyleBox[\"m\", \"TI\"]\) with respect to \!\(\*StyleBox[\"a\", \"TI\"]\). \n\!\(\*RowBox[{\"SingularValueList\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\) largest singular values of \!\(\*StyleBox[\"m\", \"TI\"]\). \n\!\(\*RowBox[{\"SingularValueList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\) largest generalized singular values of \!\(\*StyleBox[\"m\", \"TI\"]\)."
SingularValuePlot::usage = "\!\(\*RowBox[{\"SingularValuePlot\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) generates a plot of the singular values of the transfer function for the system \!\(\*StyleBox[\"lsys\", \"TI\"]\). \n\!\(\*RowBox[{\"SingularValuePlot\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots for the frequency range \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"SingularValuePlot\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots \!\(\*StyleBox[\"expr\", \"TI\"]\) using the variable \!\(\*StyleBox[\"\[Omega]\", \"TR\"]\)."
SingularValues::usage = "\!\(\*RowBox[{\"SingularValues\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the singular value decomposition for a numerical matrix \!\(\*StyleBox[\"m\", \"TI\"]\)\!\(\*StyleBox[\".\", \"TI\", FontSlant -> \"Plain\"]\) The result is a list \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]\), where \!\(\*StyleBox[\"w\", \"TI\"]\) is the list of singular values, and \!\(\*StyleBox[\"m\", \"TI\"]\) can be written as \!\(\*RowBox[{RowBox[{\"Conjugate\", \"[\", RowBox[{\"Transpose\", \"[\", StyleBox[\"u\", \"TI\"], \"]\"}], \"]\"}], \".\", \" \", RowBox[{\"DiagonalMatrix\", \"[\", StyleBox[\"w\", \"TI\"], \"]\"}], \".\", StyleBox[\"v\", \"TI\"]}]\)."
SinhIntegral::usage = "\!\(\*RowBox[{\"SinhIntegral\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the hyperbolic sine integral function \!\(\*RowBox[{\"Shi\", \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
Sinh::usage = "\!\(\*RowBox[{\"Sinh\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the hyperbolic sine of \!\(\*StyleBox[\"z\", \"TI\"]\). "
SinIntegral::usage = "\!\(\*RowBox[{\"SinIntegral\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the sine integral function \!\(\*RowBox[{\"Si\", \"(\", StyleBox[\"z\", \"TI\"]}]\)). "
Sin::usage = "\!\(\*RowBox[{\"Sin\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the sine of \!\(\*StyleBox[\"z\", \"TI\"]\). "
SixJSymbol::usage = "\!\(\*RowBox[{\"SixJSymbol\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"4\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"5\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"6\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the values of the Racah 6\[Hyphen]\!\(\*StyleBox[\"j\", \"TI\"]\) symbol. "
SkeletonTransform::usage = "\!\(\*RowBox[{\"SkeletonTransform\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives the skeleton transform of \!\(\*StyleBox[\"image\", \"TI\"]\), in which the value of each skeleton pixel is its distance to the nearest background pixel.\n\!\(\*RowBox[{\"SkeletonTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) treats values above \!\(\*StyleBox[\"t\", \"TI\"]\) as foreground."
Skeleton::usage = "\!\(\*RowBox[{\"Skeleton\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a sequence of \!\(\*StyleBox[\"n\", \"TI\"]\) omitted elements in an expression printed with Short or Shallow. The standard print form for Skeleton is \!\(\*RowBox[{\"\[LeftSkeleton]\", StyleBox[\"n\", \"TI\"], \"\[RightSkeleton]\"}]\). "
SkellamDistribution::usage = "\!\(\*RowBox[{\"SkellamDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) represents a Skellam distribution with shape parameters \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
Skewness::usage = "\!\(\*RowBox[{\"Skewness\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the coefficient of skewness for the elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Skewness\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the coefficient of skewness for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
SkewNormalDistribution::usage = "\!\(\*RowBox[{\"SkewNormalDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) represents a skew-normal distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\), location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
Skip::usage = "\!\(\*RowBox[{\"Skip\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) skips one object of the specified type in an input stream. \n\!\(\*RowBox[{\"Skip\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) skips \!\(\*StyleBox[\"n\", \"TI\"]\) objects of the specified type. "
SliceContourPlot3D::usage = "\!\(\*RowBox[{\"SliceContourPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"surf\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a contour plot of \!\(\*StyleBox[\"f\", \"TI\"]\) over the slice surface \!\(\*StyleBox[\"surf\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"SliceContourPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"surf\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) restricts the surface to be within region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"SliceContourPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) generates contour plots over several slices. "
SliceDensityPlot3D::usage = "\!\(\*RowBox[{\"SliceDensityPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"surf\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a density plot of \!\(\*StyleBox[\"f\", \"TI\"]\) over the slice surface \!\(\*StyleBox[\"surf\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"SliceDensityPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"surf\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) restricts the surface to be within region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"SliceDensityPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) generates density plots over several slices. "
SliceDistribution::usage = "\!\(\*RowBox[{\"SliceDistribution\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents the distribution of the process state at time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"SliceDistribution\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the joint distribution of process states at times \!\(\*RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"<\", \"\[CenterEllipsis]\", \"<\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"k\", \"TI\"]]}]\)."
SliceVectorPlot3D::usage = "\!\(\*RowBox[{\"SliceVectorPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"surf\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a vector plot of the field \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}]\) over the slice surface \!\(\*StyleBox[\"surf\", \"TI\"]\). \n\!\(\*RowBox[{\"SliceVectorPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"surf\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) restricts the surface \!\(\*StyleBox[\"surf\", \"TI\"]\) to be within the region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"SliceVectorPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) generates vector plots over several slice surfaces \!\(\*SubscriptBox[StyleBox[\"surf\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Slider2DBoxOptions::usage = "\!\(\*RowBox[{Slider2DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for Slider2DBox objects."
Slider2D::usage = "\!\(\*RowBox[{\"Slider2D\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a 2D slider with settings \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) in the range 0 to 1. \n\!\(\*RowBox[{\"Slider2D\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"pt\", \"TI\"], \"]\"}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"pt\", \"TI\"]\), with the value of \!\(\*StyleBox[\"pt\", \"TI\"]\) being reset if the slider is moved. \n\!\(\*RowBox[{\"Slider2D\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents a 2D slider with range \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\) in each direction. \n\!\(\*RowBox[{\"Slider2D\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents a 2D slider that jumps in steps \!\(\*StyleBox[\"d\", \"TI\"]\) in each direction. \n\!\(\*RowBox[{\"Slider2D\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) specifies different ranges in \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) directions. \n\!\(\*RowBox[{\"Slider2D\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"dx\", \"TI\"], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses jumps \!\(\*StyleBox[\"dx\", \"TI\"]\), \!\(\*StyleBox[\"dy\", \"TI\"]\)."
SliderBoxOptions::usage = "\!\(\*RowBox[{SliderBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for SliderBox objects."
Slider::usage = "\!\(\*RowBox[{\"Slider\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a slider with setting \!\(\*StyleBox[\"x\", \"TI\"]\) in the range 0 to 1. \n\!\(\*RowBox[{\"Slider\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being reset if the slider is moved. \n\!\(\*RowBox[{\"Slider\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a slider with range \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"Slider\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents a slider that jumps in steps \!\(\*StyleBox[\"dx\", \"TI\"]\). \n\!\(\*RowBox[{\"Slider\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) represents a slider in which equally spaced intervals correspond to successive settings \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Slider\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) uses intervals of relative widths \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
SlideView::usage = "\!\(\*RowBox[{\"SlideView\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an object in which the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are set up to be displayed on successive slides. \n\!\(\*RowBox[{\"SlideView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) makes the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) slide be the one currently displayed."
SlotSequence::usage = "## represents the sequence of arguments supplied to a pure function. \n##\!\(\*StyleBox[RowBox[{StyleBox[\"n\", \"TI\"], \"\[Null]\"}]]\) represents the sequence of arguments supplied to a pure function, starting with the \!\(\*StyleBox[RowBox[{StyleBox[\"n\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) argument. "
Slot::usage = "# represents the first argument supplied to a pure function. \n\!\(\*StyleBox[RowBox[{\"#\", StyleBox[\"n\", \"TI\"]}]]\) represents the \!\(\*StyleBox[RowBox[{StyleBox[\"n\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) argument. \n\!\(\*StyleBox[RowBox[{\"#\", StyleBox[\"name\", \"TI\"]}]]\) represents the value associated with key \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" in an association in the first argument. "
SmallCircle::usage = "\!\(\*RowBox[{\"SmallCircle\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SmallCircle]\", StyleBox[\"y\", \"TI\"], \"\[SmallCircle]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Smaller::usage = "Smaller is a style or option setting that specifies that objects should be smaller."
Small::usage = "Small is a style or option setting that specifies that objects should be small."
SmithDecomposition::usage = "\!\(\*RowBox[{\"SmithDecomposition\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives the Smith normal form decomposition of an integer matrix \!\(\*StyleBox[\"m\", \"TI\"]\)."
SmithDelayCompensator::usage = "\!\(\*RowBox[{\"SmithDelayCompensator\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"con\", \"TI\"]}], \"]\"}]\) gives the Smith compensator for the time-delay system \!\(\*StyleBox[\"sys\", \"TI\"]\) and the delay-free controller \!\(\*StyleBox[\"con\", \"TI\"]\)."
SmithWatermanSimilarity::usage = "\!\(\*RowBox[{\"SmithWatermanSimilarity\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives a number representing the Smith\[Dash]Waterman similarity between strings or vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
SmoothDensityHistogram::usage = "\!\(\*RowBox[{\"SmoothDensityHistogram\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a smooth kernel histogram of the values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"SmoothDensityHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"espec\", \"TI\"]}], \"]\"}]\) plots a smooth kernel histogram with estimator specification \!\(\*StyleBox[\"espec\", \"TI\"]\).\n\!\(\*RowBox[{\"SmoothDensityHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"espec\", \"TI\"], \",\", StyleBox[\"dfun\", \"TI\"]}], \"]\"}]\) plots the distribution function \!\(\*StyleBox[\"dfun\", \"TI\"]\)."
SmoothHistogram3D::usage = "\!\(\*RowBox[{\"SmoothHistogram3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a 3D smooth kernel histogram of the values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"SmoothHistogram3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"espec\", \"TI\"]}], \"]\"}]\) plots a 3D smooth kernel histogram with estimator specification \!\(\*StyleBox[\"espec\", \"TI\"]\).\n\!\(\*RowBox[{\"SmoothHistogram3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"espec\", \"TI\"], \",\", StyleBox[\"dfun\", \"TI\"]}], \"]\"}]\) plots the distribution function \!\(\*StyleBox[\"dfun\", \"TI\"]\).\n\!\(\*RowBox[{\"SmoothHistogram3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots smooth kernel histograms for multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
SmoothHistogram::usage = "\!\(\*RowBox[{\"SmoothHistogram\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) plots a smooth kernel histogram of the values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SmoothHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"espec\", \"TI\"]}], \"]\"}]\) plots a smooth kernel histogram with estimator specification \!\(\*StyleBox[\"espec\", \"TI\"]\).\n\!\(\*RowBox[{\"SmoothHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"espec\", \"TI\"], \",\", StyleBox[\"dfun\", \"TI\"]}], \"]\"}]\) plots the distribution function \!\(\*StyleBox[\"dfun\", \"TI\"]\). \n\!\(\*RowBox[{\"SmoothHistogram\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots smooth kernel histograms for multiple datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
SmoothKernelDistribution::usage = "\!\(\*RowBox[{\"SmoothKernelDistribution\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a smooth kernel distribution based on the data values \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SmoothKernelDistribution\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a multivariate smooth kernel distribution based on the data values \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"SmoothKernelDistribution\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"bw\", \"TI\"]}], \"]\"}]\) represents a smooth kernel distribution with bandwidth \!\(\*StyleBox[\"bw\", \"TI\"]\).\n\!\(\*RowBox[{\"SmoothKernelDistribution\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"bw\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) represents a smooth kernel distribution with bandwidth \!\(\*StyleBox[\"bw\", \"TI\"]\) and smoothing kernel \!\(\*StyleBox[\"ker\", \"TI\"]\)."
Snippet::usage = "\!\(\*RowBox[{\"Snippet\", \"[\", StyleBox[\"doc\", \"TI\"], \"]\"}]\) gives a snippet of text from a document or other content object.\n\!\(\*RowBox[{\"Snippet\", \"[\", RowBox[{StyleBox[\"doc\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a snippet about \!\(\*StyleBox[\"n\", \"TI\"]\) lines long. "
SocialMediaData::usage = "\!\(\*RowBox[{\"SocialMediaData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives information about the social media entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"SocialMediaData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specified property for the social media entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"SocialMediaData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"id\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of a property for the specified identifier \!\(\*StyleBox[\"id\", \"TI\"]\)."
SocketConnect::usage = "\!\(\*RowBox[{\"SocketConnect\", \"[\", StyleBox[\"address\", \"TI\"], \"]\"}]\) opens a connection to a server at the specified socket address."
SocketObject::usage = "\!\(\*RowBox[{\"SocketObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents a connected network socket."
Socket::usage = "Socket is a possible value returned by FileType and related functions."
SokalSneathDissimilarity::usage = "\!\(\*RowBox[{\"SokalSneathDissimilarity\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Sokal\[Dash]Sneath dissimilarity between Boolean vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
SolarEclipse::usage = "\!\(\*RowBox[{\"SolarEclipse\", \"[\", \"]\"}]\) gives the time of the next solar eclipse.\n\!\(\*RowBox[{\"SolarEclipse\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the time for the next solar eclipse after the specified date.\n\!\(\*RowBox[{\"SolarEclipse\", \"[\", StyleBox[\"propertyspec\", \"TI\"], \"]\"}]\) gives the specified property value for the next solar eclipse.\n\!\(\*RowBox[{\"SolarEclipse\", \"[\", RowBox[{StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"propertyspec\", \"TI\"]}], \"]\"}]\) gives the specified property value for the next solar eclipse after the specified date."
SolarSystemFeatureData::usage = "\!\(\*RowBox[{\"SolarSystemFeatureData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the solar system feature \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"SolarSystemFeatureData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified feature entities.\n\!\(\*RowBox[{\"SolarSystemFeatureData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
SolidData::usage = "\!\(\*RowBox[{\"SolidData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the solid \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"SolidData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified solid entities.\n\!\(\*RowBox[{\"SolidData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
SolveAlways::usage = "\!\(\*RowBox[{\"SolveAlways\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) gives the values of parameters that make the equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) valid for all values of the variables \!\(\*StyleBox[\"vars\", \"TI\"]\). "
SolveDelayed::usage = "SolveDelayed is an option to NDSolve. \!\(\*RowBox[{\"SolveDelayed\", \" \", \"->\", \" \", \"False\"}]\) causes the derivatives to be solved for symbolically at the beginning. \!\(\*RowBox[{\"SolveDelayed\", \" \", \"->\", \" \", \"True\"}]\) causes the ODEs to be evaluated numerically and the derivatives solved for at each step."
Solve::usage = "\!\(\*RowBox[{\"Solve\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) attempts to solve the system \!\(\*StyleBox[\"expr\", \"TI\"]\) of equations or inequalities for the variables \!\(\*StyleBox[\"vars\", \"TI\"]\). \n\!\(\*RowBox[{\"Solve\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) solves over the domain \!\(\*StyleBox[\"dom\", \"TI\"]\). Common choices of \!\(\*StyleBox[\"dom\", \"TI\"]\) are Reals, Integers, and Complexes."
SortBy::usage = "\!\(\*RowBox[{\"SortBy\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) sorts the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) in the order defined by applying \!\(\*StyleBox[\"f\", \"TI\"]\) to each of them. \n\!\(\*RowBox[{\"SortBy\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) represents an operator form of SortBy that can be applied to an expression."
Sort::usage = "\!\(\*RowBox[{\"Sort\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) sorts the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) into canonical order. \n\!\(\*RowBox[{\"Sort\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) sorts using the ordering function \!\(\*StyleBox[\"p\", \"TI\"]\). "
SoundNote::usage = "\!\(\*RowBox[{\"SoundNote\", \"[\", StyleBox[\"pitch\", \"TI\"], \"]\"}]\) represents a music-like sound note with the specified pitch.\n\!\(\*RowBox[{\"SoundNote\", \"[\", RowBox[{StyleBox[\"pitch\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) takes the note to have duration \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"SoundNote\", \"[\", RowBox[{StyleBox[\"pitch\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) takes the note to occupy the time interval \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"SoundNote\", \"[\", RowBox[{StyleBox[\"pitch\", \"TI\"], \",\", StyleBox[\"tspec\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) takes the note to be in the specified style.\n\!\(\*RowBox[{\"SoundNote\", \"[\", RowBox[{StyleBox[\"pitch\", \"TI\"], \",\", StyleBox[\"tspec\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"opts\", \"TI\"]}], \"]\"}]\) uses the specified rendering options for the note."
Sound::usage = "\!\(\*RowBox[{\"Sound\", \"[\", StyleBox[\"primitives\", \"TI\"], \"]\"}]\) represents a sound. \n\!\(\*RowBox[{\"Sound\", \"[\", RowBox[{StyleBox[\"primitives\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) specifies that the sound should have duration \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"Sound\", \"[\", RowBox[{StyleBox[\"primitives\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) specifies that the sound should extend from time \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to time \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]\)."
SoundVolume::usage = "SoundVolume is an option to Sound and SoundNote and related functions that specifies the relative volume of the sound produced."
Sow::usage = "\!\(\*RowBox[{\"Sow\", \"[\", StyleBox[\"e\", \"TI\"], \"]\"}]\) specifies that \!\(\*StyleBox[\"e\", \"TI\"]\) should be collected by the nearest enclosing Reap. \n\!\(\*RowBox[{\"Sow\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) specifies that \!\(\*StyleBox[\"e\", \"TI\"]\) should be collected by the nearest enclosing Reap whose pattern matches \!\(\*StyleBox[\"tag\", \"TI\"]\). \n\!\(\*RowBox[{\"Sow\", \"[\", RowBox[{StyleBox[\"e\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"tag\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"tag\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) specifies that \!\(\*StyleBox[\"e\", \"TI\"]\) should be collected once for each pattern that matches a \!\(\*SubscriptBox[StyleBox[\"tag\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
SpaceCurveData::usage = "\!\(\*RowBox[{\"SpaceCurveData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the space curve \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"SpaceCurveData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified space curve entities.\n\!\(\*RowBox[{\"SpaceCurveData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
SpaceForm::usage = "\!\(\*RowBox[{\"SpaceForm\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) prints as \!\(\*StyleBox[\"n\", \"TI\"]\) spaces."
Spacer::usage = "\!\(\*RowBox[{\"Spacer\", \"[\", StyleBox[\"w\", \"TI\"], \"]\"}]\) displays as a spacer \!\(\*StyleBox[\"w\", \"TI\"]\) printer's points wide.\n\!\(\*RowBox[{\"Spacer\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"}\"}], \"]\"}]\) displays as a spacer \!\(\*StyleBox[\"w\", \"TI\"]\) points wide and a total of \!\(\*StyleBox[\"h\", \"TI\"]\) points high.\n\!\(\*RowBox[{\"Spacer\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"w\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"dh\", \"TI\"]}], \"}\"}], \"]\"}]\) makes the spacer extend \!\(\*StyleBox[\"dh\", \"TI\"]\) points below the baseline. "
Spacings::usage = "Spacings is an option to Grid and related constructs that specifies the spacings to leave between successive objects."
SpanAdjustments::usage = "SpanAdjustments is an option for selections that specifies the height and width of spanning characters."
SpanCharacterRounding::usage = "SpanCharacterRounding is an option for selections that specifies the method used for rounding a spanning character when its size is to be adjusted."
SpanFromAbove::usage = "SpanFromAbove is a symbol that can appear at a particular position in a Grid or related construct to indicate that the corresponding position is occupied by a spanning element that appears above it."
SpanFromBoth::usage = "SpanFromBoth is a symbol that can appear at a particular position in a Grid or related construct to indicate that the corresponding position is occupied by a spanning element that appears above and to its left."
SpanFromLeft::usage = "SpanFromLeft is a symbol that can appear at a particular position in a Grid or related construct to indicate that the corresponding position is occupied by a spanning element that appears to its left."
SpanLineThickness::usage = "SpanLineThickness is an option for selections that specifies the thickness in printer's points of line-spanning characters such as \[Backslash][VerticalLine] and \[Backslash][HorizontalLine]."
SpanMaxSize::usage = "SpanMaxSize is an option for selections that specifies the maximum size of spanning characters such as parentheses and brackets."
SpanMinSize::usage = "SpanMinSize is an option for selections that specifies the minimum size of spanning characters such as parentheses and brackets."
SpanSymmetric::usage = "SpanSymmetric is an option for selections that specifies whether vertically expandable characters are symmetric about the axis of the selection."
Span::usage = "\!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \";;\", StyleBox[\"j\", \"TI\"]}]\) represents a span of elements \!\(\*StyleBox[\"i\", \"TI\"]\) through \!\(\*StyleBox[\"j\", \"TI\"]\).\n\!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \";;\"}]\) represents a span from \!\(\*StyleBox[\"i\", \"TI\"]\) to the end.\n\!\(\*RowBox[{\";;\", StyleBox[\"j\", \"TI\"]}]\) represents a span from the beginning to \!\(\*StyleBox[\"j\", \"TI\"]\).\n;; represents a span that includes all elements.\n\!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \";;\", StyleBox[\"j\", \"TI\"], \";;\", StyleBox[\"k\", \"TI\"]}]\) represents a span from \!\(\*StyleBox[\"i\", \"TI\"]\) through \!\(\*StyleBox[\"j\", \"TI\"]\) in steps of \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \";;\", \";;\", StyleBox[\"k\", \"TI\"]}]\) represents a span from \!\(\*StyleBox[\"i\", \"TI\"]\) to the end in steps of \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\";;\", StyleBox[\"j\", \"TI\"], \";;\", StyleBox[\"k\", \"TI\"]}]\) represents a span from the beginning to \!\(\*StyleBox[\"j\", \"TI\"]\) in steps of \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\";;\", \";;\", StyleBox[\"k\", \"TI\"]}]\) represents a span from the beginning to the end in steps of \!\(\*StyleBox[\"k\", \"TI\"]\). "
SparseArray::usage = "\!\(\*RowBox[{\"SparseArray\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) yields a sparse array in which values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) appear at positions \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"SparseArray\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields the same sparse array. \n\!\(\*RowBox[{\"SparseArray\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) yields a sparse array version of \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"SparseArray\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields a sparse array representing a \!\(\*RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Times]\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Times]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) array. \n\!\(\*RowBox[{\"SparseArray\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dims\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) yields a sparse array in which unspecified elements are taken to have value \!\(\*StyleBox[\"val\", \"TI\"]\). "
SpatialGraphDistribution::usage = "\!\(\*RowBox[{\"SpatialGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a spatial distribution for graphs with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices uniformly distributed over the unit square and edges between vertices that are at distance at most \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"SpatialGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) represents a spatial distribution for graphs with vertices uniformly distributed over the \!\(\*StyleBox[\"d\", \"TI\"]\)-dimensional unit square.\n\!\(\*RowBox[{\"SpatialGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) represents a spatial distribution for graphs with vertices distributed according to the probability distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
Speak::usage = "\!\(\*RowBox[{\"Speak\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) speaks a spoken representation of the expression \!\(\*StyleBox[\"expr\", \"TI\"]\)."
SpearmanRankTest::usage = "\!\(\*RowBox[{\"SpearmanRankTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"SpearmanRankTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"SpearmanRankTest\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
SpearmanRho::usage = "\!\(\*RowBox[{\"SpearmanRho\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Spearman's rank correlation coefficient \[Rho] for the vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"SpearmanRho\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives Spearman's rank correlation coefficient \[Rho] for the matrix \!\(\*StyleBox[\"m\", \"TI\"]\).\n\!\(\*RowBox[{\"SpearmanRho\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Spearman's rank correlation coefficient \[Rho] for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"SpearmanRho\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives Spearman's rank correlation matrix for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"SpearmanRho\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \"]\"}]\) gives the \!\(\*RowBox[{\"(\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"j\", \"TI\"]}], \")\"}]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) Spearman rank correlation for the multivariate symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
SpeciesData::usage = "\!\(\*RowBox[{\"SpeciesData\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the species \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"SpeciesData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified species entities.\n\!\(\*RowBox[{\"SpeciesData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
SpecificityGoal::usage = "SpecificityGoal is an option for ImageIdentify and related functions that defines what specificity of object to seek to identify."
SpectrogramArray::usage = "\!\(\*RowBox[{\"SpectrogramArray\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) returns the spectrogram data of \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"SpectrogramArray\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses partitions of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"SpectrogramArray\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses partitions with offset \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"SpectrogramArray\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to each partition.\n\!\(\*RowBox[{\"SpectrogramArray\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) returns spectrogram data of sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object."
Spectrogram::usage = "\!\(\*RowBox[{\"Spectrogram\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) plots the spectrogram of \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"Spectrogram\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses partitions of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"Spectrogram\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) uses partitions with offset \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"Spectrogram\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"wfun\", \"TI\"]}], \"]\"}]\) applies a smoothing window \!\(\*StyleBox[\"wfun\", \"TI\"]\) to each partition.\n\!\(\*RowBox[{\"Spectrogram\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots the spectrogram of sampled \!\(\*StyleBox[\"sound\", \"TI\"]\) object. "
Specularity::usage = "\!\(\*RowBox[{\"Specularity\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that surfaces of 3D graphics objects which follow are to be taken to have specularity \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"Specularity\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) uses specular exponent \!\(\*StyleBox[\"n\", \"TI\"]\). "
SpellingCorrection::usage = "SpellingCorrection is an option for StringMatchQ, Names, and related functions that specifies whether strings should be considered to match even when a small fraction of the characters in them are different. "
SpellingDictionariesPath::usage = "SpellingDictionariesPath is a global option that specifies which directories are searched for spelling dictionaries when the \!\(\*StyleBox[\"Edit\", \"MenuName\"]\)\!\(\*StyleBox[\" \[FilledRightTriangle] \", \"MenuNameDelimiter\"]\)\!\(\*StyleBox[\"Check Spelling\", \"MenuName\"]\) menu item is used."
SpellingDictionaries::usage = "\!\(\*RowBox[{\"SpellingDictionaries\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is a global option that specifies settings for spell checking."
SpellingOptions::usage = "\!\(\*RowBox[{\"SpellingOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for notebooks that specifies settings for spell checking."
Sphere::usage = "\!\(\*RowBox[{\"Sphere\", \"[\", StyleBox[\"p\", \"TI\"], \"]\"}]\) represents a unit sphere centered at the point \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"Sphere\", \"[\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a sphere of radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at the point \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"Sphere\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a collection of spheres of radius \!\(\*StyleBox[\"r\", \"TI\"]\)."
SphericalBesselJ::usage = "\!\(\*RowBox[{\"SphericalBesselJ\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the spherical Bessel function of the first kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
SphericalBesselY::usage = "\!\(\*RowBox[{\"SphericalBesselY\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the spherical Bessel function of the second kind \!\(\*RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
SphericalHankelH1::usage = "\!\(\*RowBox[{\"SphericalHankelH1\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the spherical Hankel function of the first kind \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"h\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", \"1\", \")\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
SphericalHankelH2::usage = "\!\(\*RowBox[{\"SphericalHankelH2\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the spherical Hankel function of the second kind \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"h\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", \"2\", \")\"}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
SphericalHarmonicY::usage = "\!\(\*RowBox[{\"SphericalHarmonicY\", \"[\", RowBox[{StyleBox[\"l\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) gives the spherical harmonic \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"Y\", \"TI\"], StyleBox[\"l\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"(\", RowBox[{\"\[Theta]\", \",\", \"\[Phi]\"}], \")\"}]\). "
SphericalPlot3D::usage = "\!\(\*RowBox[{\"SphericalPlot3D\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) generates a 3D plot with a spherical radius \!\(\*StyleBox[\"r\", \"TI\"]\) as a function of spherical coordinates \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\).\n\!\(\*RowBox[{\"SphericalPlot3D\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Phi]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Phi]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Phi]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a 3D spherical plot over the specified ranges of spherical coordinates.\n\!\(\*RowBox[{\"SphericalPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Theta]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Theta]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Phi]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"\[Phi]\", \"TR\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"\[Phi]\", \"TR\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a 3D spherical plot with multiple surfaces."
SphericalRegion::usage = "SphericalRegion is an option for three-dimensional graphics functions that specifies whether the final image should be scaled so that a sphere drawn around the three\[Hyphen]dimensional bounding box would fit in the display area specified. "
SphericalShell::usage = "\!\(\*RowBox[{\"SphericalShell\", \"[\", RowBox[{StyleBox[\"c\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"inner\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"outer\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a filled spherical shell centered at \!\(\*StyleBox[\"c\", \"TI\"]\) with inner radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"inner\", \"TI\"]]\) and outer radius \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"outer\", \"TI\"]]\)."
SpheroidalEigenvalue::usage = "\!\(\*RowBox[{\"SpheroidalEigenvalue\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"]\"}]\) gives the spheroidal eigenvalue with degree \!\(\*StyleBox[\"n\", \"TI\"]\) and order \!\(\*StyleBox[\"m\", \"TI\"]\)."
SpheroidalJoiningFactor::usage = "\!\(\*RowBox[{\"SpheroidalJoiningFactor\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"]}], \"]\"}]\) gives the spheroidal joining factor with degree \!\(\*StyleBox[\"n\", \"TI\"]\) and order \!\(\*StyleBox[\"m\", \"TI\"]\)."
SpheroidalPSPrime::usage = "\!\(\*RowBox[{\"SpheroidalPSPrime\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the derivative with respect to \!\(\*StyleBox[\"z\", \"TI\"]\) of the angular spheroidal function \!\(\*RowBox[{SubscriptBox[StyleBox[\"PS\", FontSlant -> \"Italic\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}]], \"(\", RowBox[{\"\[Gamma]\", \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\) of the first kind."
SpheroidalPS::usage = "\!\(\*RowBox[{\"SpheroidalPS\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the angular spheroidal function \!\(\*RowBox[{SubscriptBox[StyleBox[\"PS\", FontSlant -> \"Italic\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}]], \"(\", RowBox[{\"\[Gamma]\", \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\) of the first kind."
SpheroidalQSPrime::usage = "\!\(\*RowBox[{\"SpheroidalQSPrime\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the derivative with respect to \!\(\*StyleBox[\"z\", \"TI\"]\) of the angular spheroidal function \!\(\*RowBox[{SubscriptBox[StyleBox[\"QS\", FontSlant -> \"Italic\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}]], \"(\", RowBox[{\"\[Gamma]\", \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\) of the second kind."
SpheroidalQS::usage = "\!\(\*RowBox[{\"SpheroidalQS\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the angular spheroidal function \!\(\*RowBox[{SubscriptBox[StyleBox[\"QS\", FontSlant -> \"Italic\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}]], \"(\", RowBox[{\"\[Gamma]\", \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\) of the second kind."
SpheroidalRadialFactor::usage = "\!\(\*RowBox[{\"SpheroidalRadialFactor\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) gives the spheroidal radial factor with degree \!\(\*StyleBox[\"n\", \"TI\"]\) and order \!\(\*StyleBox[\"m\", \"TI\"]\)."
SpheroidalS1Prime::usage = "\!\(\*RowBox[{\"SpheroidalS1Prime\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the derivative with respect to \!\(\*StyleBox[\"z\", \"TI\"]\) of the radial spheroidal function \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"S\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], RowBox[{\"(\", \"1\", \")\"}]], \"(\", RowBox[{\"\[Gamma]\", \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\) of the first kind."
SpheroidalS1::usage = "\!\(\*RowBox[{\"SpheroidalS1\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the radial spheroidal function \!\(\*RowBox[{SubsuperscriptBox[\"S\", RowBox[{\"n\", \",\", \"m\"}], RowBox[{\"(\", \"1\", \")\"}]], \"(\", RowBox[{\"\[Gamma]\", \",\", \"z\"}], \")\"}]\) of the first kind."
SpheroidalS2Prime::usage = "\!\(\*RowBox[{\"SpheroidalS2Prime\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the derivative with respect to \!\(\*StyleBox[\"z\", \"TI\"]\) of the radial spheroidal function \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"S\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], RowBox[{\"(\", \"2\", \")\"}]], \"(\", RowBox[{\"\[Gamma]\", \",\", StyleBox[\"z\", \"TI\"]}], \")\"}]\) of the second kind."
SpheroidalS2::usage = "\!\(\*RowBox[{\"SpheroidalS2\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the radial spheroidal function \!\(\*RowBox[{SubsuperscriptBox[\"S\", RowBox[{\"n\", \",\", \"m\"}], RowBox[{\"(\", \"2\", \")\"}]], \"(\", RowBox[{\"\[Gamma]\", \",\", \"z\"}], \")\"}]\) of the second kind."
SplicedDistribution::usage = "\!\(\*RowBox[{\"SplicedDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], RowBox[{StyleBox[\"1\", \"TR\"], \",\"}]], SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents the distribution obtained by splicing the distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] truncated on the intervals \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]\), \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\), \[Ellipsis] with weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] ."
SplineClosed::usage = "SplineClosed is an option for B-spline functions and graphics primitives that specifies whether spline curves or surfaces should be closed. "
SplineDegree::usage = "SplineDegree is an option for spline functions and graphics primitives that specifies the degree of polynomial basis to use."
SplineKnots::usage = "SplineKnots is an option for B-spline functions and graphics primitives that specifies the positions of knots."
Splines`Bezier::usage = "Bezier is a setting specifying the type of spline generated by Spline and SplineFit."
Splines`CompositeBezier::usage = "CompositeBezier is a setting specifying the type of spline generated by Spline and SplineFit."
Splines`Cubic::usage = "Cubic is a setting specifying the type of spline generated by Spline and SplineFit."
Splines`RenderSpline::usage = "\!\(\*RowBox[{\"RenderSpline\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"splinefunction\", \"TI\"]}], \"]\"}]\) is an alternative rendering method for splines."
Splines`SplineDivision::usage = "SplineDivision is an option for Spline which specifies the maximum number of subdivisions to be used in attempting to generate a smooth spline."
Splines`SplineDots::usage = "SplineDots is an option for Spline that specifies a style for a point. "
Splines`SplineFit::usage = "\!\(\*RowBox[{\"SplineFit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) generates a SplineFunction object of the specified \!\(\*StyleBox[\"type\", \"TI\"]\) from the points \!\(\*RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Splines`SplineFunction::usage = "\!\(\*RowBox[{\"SplineFunction\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"domain\", \"TI\"], \",\", StyleBox[\"internal\", \"TI\"]}], \"]\"}]\) represents a spline function created by the SplineFit function parametrizing a curve with the parameter in the specified \!\(\*StyleBox[\"domain\", \"TI\"]\). When given a parameter value as an argument it returns the corresponding point on the curve."
Splines`SplinePoints::usage = "SplinePoints is an option for Spline which determines the number of initial samples for rendering a spline. "
Splines`Spline::usage = "\!\(\*RowBox[{\"Spline\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) is a two-dimensional graphics primitive which represents a spline of type \!\(\*StyleBox[\"type\", \"TI\"]\) through (or controlled by) points \!\(\*RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \" \", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\). "
SplineWeights::usage = "SplineWeights is an option for B-spline functions and graphics primitives that specifies weights of control points."
SplitBy::usage = "\!\(\*RowBox[{\"SplitBy\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) splits \!\(\*StyleBox[\"list\", \"TI\"]\) into sublists consisting of runs of successive elements that give the same value when \!\(\*StyleBox[\"f\", \"TI\"]\) is applied.\n\!\(\*RowBox[{\"SplitBy\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) recursively splits \!\(\*StyleBox[\"list\", \"TI\"]\) into sublists by testing elements successively with each of the \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
Split::usage = "\!\(\*RowBox[{\"Split\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) splits \!\(\*StyleBox[\"list\", \"TI\"]\) into sublists consisting of runs of identical elements. \n\!\(\*RowBox[{\"Split\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) treats pairs of adjacent elements as identical whenever applying the function \!\(\*StyleBox[\"test\", \"TI\"]\) to them yields True. "
SpokenString::usage = "\!\(\*RowBox[{\"SpokenString\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives a string of text corresponding to a spoken representation of the expression \!\(\*StyleBox[\"expr\", \"TI\"]\)."
SqrtBoxOptions::usage = "\!\(\*RowBox[{SqrtBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for SqrtBox objects."
SqrtBox::usage = "\!\(\*RowBox[{SqrtBox, \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) is a low-level box construct that represents the displayed object \!\(\*SqrtBox[StyleBox[\"x\", \"TI\"]]\) in notebook expressions. "
Sqrt::usage = "\!\(\*RowBox[{\"Sqrt\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) or \!\(\*SqrtBox[StyleBox[\"z\", \"TI\"]]\) gives the square root of \!\(\*StyleBox[\"z\", \"TI\"]\). "
SquaredEuclideanDistance::usage = "\!\(\*RowBox[{\"SquaredEuclideanDistance\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the squared Euclidean distance between vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
SquareFreeQ::usage = "\!\(\*RowBox[{\"SquareFreeQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a square-free polynomial or number, and False otherwise.\n\!\(\*RowBox[{\"SquareFreeQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vars\", \"TI\"]}], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is square-free with respect to the variables \!\(\*StyleBox[\"vars\", \"TI\"]\). "
SquareIntersection::usage = "\!\(\*RowBox[{\"SquareIntersection\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SquareIntersection]\", StyleBox[\"y\", \"TI\"], \"\[SquareIntersection]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SquareMatrixQ::usage = "\!\(\*RowBox[{\"SquareMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is a square matrix, and False otherwise."
SquaresR::usage = "\!\(\*RowBox[{\"SquaresR\", \"[\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the number of ways \!\(\*RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"d\", \"TI\"]], \"(\", StyleBox[\"n\", \"TI\"], \")\"}]\) to represent the integer \!\(\*StyleBox[\"n\", \"TI\"]\) as a sum of \!\(\*StyleBox[\"d\", \"TI\"]\) squares."
SquareSubsetEqual::usage = "\!\(\*RowBox[{\"SquareSubsetEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SquareSubsetEqual]\", StyleBox[\"y\", \"TI\"], \"\[SquareSubsetEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SquareSubset::usage = "\!\(\*RowBox[{\"SquareSubset\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SquareSubset]\", StyleBox[\"y\", \"TI\"], \"\[SquareSubset]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SquareSupersetEqual::usage = "\!\(\*RowBox[{\"SquareSupersetEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SquareSupersetEqual]\", StyleBox[\"y\", \"TI\"], \"\[SquareSupersetEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SquareSuperset::usage = "\!\(\*RowBox[{\"SquareSuperset\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SquareSuperset]\", StyleBox[\"y\", \"TI\"], \"\[SquareSuperset]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SquareUnion::usage = "\!\(\*RowBox[{\"SquareUnion\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SquareUnion]\", StyleBox[\"y\", \"TI\"], \"\[SquareUnion]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Square::usage = "\!\(\*RowBox[{\"Square\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) displays as \!\(\*RowBox[{\"\[Square]\", StyleBox[\"x\", \"TI\"]}]\)."
SquareWave::usage = "\!\(\*RowBox[{\"SquareWave\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives a square wave that alternates between +1 and -1 with unit period.\n\!\(\*RowBox[{\"SquareWave\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a square wave that alternates between \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with unit period. "
SSSTriangle::usage = "\!\(\*RowBox[{\"SSSTriangle\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) returns a filled triangle with sides of lengths \!\(\*StyleBox[\"a\", \"TI\"]\), \!\(\*StyleBox[\"b\", \"TI\"]\), and \!\(\*StyleBox[\"c\", \"TI\"]\)."
StabilityMarginsStyle::usage = "StabilityMarginsStyle is an option to frequency response plots such as BodePlot, NyquistPlot, and NicholsPlot that specifies the styles in which the gain and phase margins are to be drawn."
StabilityMargins::usage = "StabilityMargins is an option to frequency response plots such as BodePlot, NyquistPlot, and NicholsPlot that specifies the gain and phase margins to be shown on the plot."
StableDistribution::usage = "\!\(\*RowBox[{\"StableDistribution\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents the stable distribution \!\(\*SubscriptBox[StyleBox[\"S\", \"TI\"], StyleBox[\"type\", \"TI\"]]\) with index of stability \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\), skewness parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\), location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
StackBegin::usage = "\!\(\*RowBox[{\"StackBegin\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), starting a fresh evaluation stack. "
StackComplete::usage = "\!\(\*RowBox[{\"StackComplete\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) with intermediate expressions in evaluation chains included on the stack. "
StackInhibit::usage = "\!\(\*RowBox[{\"StackInhibit\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) without modifying the evaluation stack. "
Stack::usage = "\!\(\*RowBox[{\"Stack\", \"[\", \"]\"}]\) shows the current evaluation stack, giving a list of the tags associated with evaluations that are currently being done. \n\!\(\*RowBox[{\"Stack\", \"[\", StyleBox[\"pattern\", \"TI\"], \"]\"}]\) gives a list of expressions currently being evaluated which match the pattern. "
StadiumShape::usage = "\!\(\*RowBox[{\"StadiumShape\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a stadium of radius \!\(\*StyleBox[\"r\", \"TI\"]\) between the points \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]\) and \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\)."
StandardAtmosphere`AtmosphericPlot::usage = "\!\(\*RowBox[{\"AtmosphericPlot\", \"[\", StyleBox[\"property\", \"TI\"], \"]\"}]\) generates a plot of the specified property \!\(\*StyleBox[\"property\", \"TI\"]\) as a function of geometric altitude. "
StandardAtmosphere`CollisionFrequency::usage = "\!\(\*RowBox[{\"CollisionFrequency\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the collision frequency at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphereData::usage = "\!\(\*RowBox[{\"StandardAtmosphereData\", \"[\", RowBox[{StyleBox[\"altitude\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) returns the value of the property at the specified geometrical altitude for the chosen model of the standard Earth atmosphere.\n\!\(\*RowBox[{\"StandardAtmosphereData\", \"[\", RowBox[{StyleBox[\"layer\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) returns a piecewise symbolic approximation with the range of an atmospheric layer for the property.\n\!\(\*RowBox[{\"StandardAtmosphereData\", \"[\", RowBox[{StyleBox[\"\\\"SymbolicApproximation\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) returns the full piecewise symbolic approximation for the property."
StandardAtmosphere`DynamicViscosity::usage = "\!\(\*RowBox[{\"DynamicViscosity\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the coefficient of dynamic viscosity at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`GravityAcceleration::usage = "\!\(\*RowBox[{\"GravityAcceleration\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the 45-degree-latitude acceleration of gravity at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`KinematicViscosity::usage = "\!\(\*RowBox[{\"KinematicViscosity\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the kinematic viscosity at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`KineticTemperature::usage = "\!\(\*RowBox[{\"KineticTemperature\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the kinetic temperature at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`MeanDensity::usage = "\!\(\*RowBox[{\"MeanDensity\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the mean density of air at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`MeanFreePath::usage = "\!\(\*RowBox[{\"MeanFreePath\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the mean free path at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`MeanMolecularWeight::usage = "\!\(\*RowBox[{\"MeanMolecularWeight\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the mean molecular weight at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`MeanParticleSpeed::usage = "\!\(\*RowBox[{\"MeanParticleSpeed\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the mean particle speed at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`NumberDensity::usage = "\!\(\*RowBox[{\"NumberDensity\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the total number density of the mixture of neutral atmospheric gas particles at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`PressureScaleHeight::usage = "\!\(\*RowBox[{\"PressureScaleHeight\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the local pressure scale height of the mixture of gases comprising the atmosphere at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`Pressure::usage = "\!\(\*RowBox[{\"Pressure\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the total atmospheric pressure at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`SoundSpeed::usage = "\!\(\*RowBox[{\"SoundSpeed\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the speed of sound at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardAtmosphere`ThermalConductivityCoefficient::usage = "\!\(\*RowBox[{\"ThermalConductivityCoefficient\", \"[\", StyleBox[\"altitude\", \"TI\"], \"]\"}]\) gives the coefficient of thermal conductivity at the specified altitude \!\(\*StyleBox[\"altitude\", \"TI\"]\)."
StandardDeviationFilter::usage = "\!\(\*RowBox[{\"StandardDeviationFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) filters \!\(\*StyleBox[\"image\", \"TI\"]\) by replacing every value by the standard deviations of the values in its range \!\(\*StyleBox[\"r\", \"TI\"]\) neighborhood. \n\!\(\*RowBox[{\"StandardDeviationFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) applies standard deviation filtering to an array of data."
StandardDeviation::usage = "\!\(\*RowBox[{\"StandardDeviation\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the sample standard deviation of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"StandardDeviation\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the standard deviation of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
StandardForm::usage = "\!\(\*RowBox[{\"StandardForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as the standard \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) two-dimensional representation of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Standardized::usage = "Standardized is an option that determines whether to standardize the data."
Standardize::usage = "\!\(\*RowBox[{\"Standardize\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) shifts and rescales the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) to have zero mean and unit sample variance.\n\!\(\*RowBox[{\"Standardize\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}]\) shifts the elements in \!\(\*StyleBox[\"list\", \"TI\"]\) by \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) and rescales them to have unit sample variance.\n\!\(\*RowBox[{\"Standardize\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) shifts by \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) and scales by \!\(\*RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\)."
StandardOceanData::usage = "\!\(\*RowBox[{\"StandardOceanData\", \"[\", StyleBox[\"spec\", \"TI\"], \"]\"}]\) returns the thermodynamic properties of seawater for the specified parameters.\n\!\(\*RowBox[{\"StandardOceanData\", \"[\", StyleBox[RowBox[{\"spec\", \",\", \"property\"}], \"TI\"], \"]\"}]\) returns the specified property for the given parameters. "
StandbyDistribution::usage = "\!\(\*RowBox[{\"StandbyDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a standby distribution with component lifetime distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). When component \!\(\*StyleBox[\"i\", \"TI\"]\) fails, component \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"+\", \"1\"}]\) will become active. \n\!\(\*RowBox[{\"StandbyDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents a standby distribution where switching from component \!\(\*StyleBox[\"i\", \"TI\"]\) to component \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"+\", \"1\"}]\) succeeds with probability \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"StandbyDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"sdist\", \"TI\"]}], \"]\"}]\) represents a standby distribution where the switch component has lifetime distribution \!\(\*StyleBox[\"sdist\", \"TI\"]\).\n\!\(\*RowBox[{\"StandbyDistribution\", \"[\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[RowBox[{\"i\", \",\", \"inactive\"}], \"TI\"]], \",\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[RowBox[{\"i\", \",\", \"active\"}], \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a standby distribution where the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) component lifetime distribution follows \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[RowBox[{\"i\", \",\", \"inactive\"}], \"TI\"]]\) in inactive mode and \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[RowBox[{\"i\", \",\", \"active\"}], \"TI\"]]\) in active mode."
StarClusterData::usage = "\!\(\*RowBox[{\"StarClusterData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the star cluster \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"StarClusterData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified star cluster entities.\n\!\(\*RowBox[{\"StarClusterData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
StarData::usage = "\!\(\*RowBox[{\"StarData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified property for the star \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"StarData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified star entities.\n\!\(\*RowBox[{\"StarData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the property."
StarGraph::usage = "\!\(\*RowBox[{\"StarGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the star graph with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices \!\(\*SubscriptBox[StyleBox[\"S\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
StartAsynchronousTask::usage = "\!\(\*RowBox[{\"StartAsynchronousTask\", \"[\", StyleBox[\"task\", \"TI\"], \"]\"}]\) allows asynchronous evaluations from \!\(\*StyleBox[\"task\", \"TI\"]\) after it has been stopped."
StartingStepSize::usage = "StartingStepSize is an option to NDSolve and related functions that specifies the initial step size to use in trying to generate results."
StartOfLine::usage = "StartOfLine represents the start of a line in a string for purposes of matching in StringExpression."
StartOfString::usage = "StartOfString represents the start of a string for purposes of matching in StringExpression."
StartScheduledTask::usage = "\!\(\*RowBox[{\"StartScheduledTask\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) starts the local or cloud scheduled task represented by \!\(\*StyleBox[\"obj\", \"TI\"]\)."
StartupSound::usage = "StartupSound is a global option that specifies whether \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) plays a sound when it is launched."
Star::usage = "\!\(\*RowBox[{\"Star\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Star]\", StyleBox[\"y\", \"TI\"], \"\[Star]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
StateDimensions::usage = "StateDimensions is an option to TemporalData that specifies the dimensions of the state space. "
StateFeedbackGains::usage = "\!\(\*RowBox[{\"StateFeedbackGains\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the state feedback gain matrix for the state-space model \!\(\*StyleBox[\"ssm\", \"TI\"]\), such that the poles of the closed-loop system are \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"StateFeedbackGains\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) specifies control inputs \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to use. "
StateOutputEstimator::usage = "\!\(\*RowBox[{\"StateOutputEstimator\", \"[\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) constructs an estimator for the StateSpaceModel \!\(\*StyleBox[\"ssm\", \"TI\"]\), with estimator gain matrix \!\(\*StyleBox[\"l\", \"TI\"]\).\n\!\(\*RowBox[{\"StateOutputEstimator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) uses only \!\(\*StyleBox[\"sensors\", \"TI\"]\) as the measurements of \!\(\*StyleBox[\"ssm\", \"TI\"]\).\n\!\(\*RowBox[{\"StateOutputEstimator\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"ssm\", \"TI\"], \",\", StyleBox[\"sensors\", \"TI\"], \",\", StyleBox[\"dinputs\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"l\", \"TI\"]}], \"]\"}]\) specifies \!\(\*StyleBox[\"dinputs\", \"TI\"]\) as the deterministic inputs of \!\(\*StyleBox[\"ssm\", \"TI\"]\)."
StateResponse::usage = "\!\(\*RowBox[{\"StateResponse\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the numeric state response of the state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\) to input \!\(\*StyleBox[\"u\", \"TI\"]\) for \!\(\*RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \"\[LessEqual]\", StyleBox[\"t\", \"TI\"], \"\[LessEqual]\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"StateResponse\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", \"0\", \"]\"}], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", \"1\", \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the response of the discrete-time state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\) to the input sequence \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[\"i\", \"TI\"], \"]\"}]\).\n\!\(\*RowBox[{\"StateResponse\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the symbolic state response as a function of time \!\(\*StyleBox[\"t\", \"TI\"]\).\n\!\(\*RowBox[{\"StateResponse\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the state response for multiple inputs \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StateResponse\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"10\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"20\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the response with initial states \!\(\*SubscriptBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], StyleBox[\"0\", \"TR\"]]\)."
StateSpaceModel::usage = "\!\(\*RowBox[{\"StateSpaceModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"}\"}], \"]\"}]\) represents the standard state-space model with state matrix \!\(\*StyleBox[\"a\", \"TI\"]\), input matrix \!\(\*StyleBox[\"b\", \"TI\"]\), output matrix \!\(\*StyleBox[\"c\", \"TI\"]\), and transmission matrix \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"StateSpaceModel\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"e\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a descriptor state-space model with descriptor matrix \!\(\*StyleBox[\"e\", \"TI\"]\).\n\!\(\*RowBox[{\"StateSpaceModel\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives a state-space model corresponding to the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\).\n\!\(\*RowBox[{\"StateSpaceModel\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"10\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"10\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Tau]\", \"TI\"]}], \"]\"}]\) gives the state-space model obtained by Taylor linearization about the point \!\(\*RowBox[{StyleBox[\"(\", \"TI\"], RowBox[{SubscriptBox[SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], StyleBox[\"0\", \"TR\"]], \",\", SubscriptBox[SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"i\", \"TI\"]], StyleBox[\"0\", \"TR\"]]}], \")\"}]\) of the differential or difference equations \!\(\*StyleBox[\"eqns\", \"TI\"]\) with outputs \!\(\*SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and independent variable \!\(\*StyleBox[\"\[Tau]\", \"TI\"]\)."
StateSpaceRealization::usage = "StateSpaceRealization is an option to StateSpaceModel that specifies its canonical representation."
StateSpaceTransform::usage = "\!\(\*RowBox[{\"StateSpaceTransform\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"}\"}]}], \"]\"}]\) transforms the state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\) using the matrices \!\(\*StyleBox[\"p\", \"TI\"]\) and \!\(\*StyleBox[\"q\", \"TI\"]\). \n\!\(\*RowBox[{\"StateSpaceTransform\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) transforms using the variable transformations \!\(\*RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) and \!\(\*RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", RowBox[{SubscriptBox[StyleBox[\"q\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\)."
StateTransformationLinearize::usage = "\!\(\*RowBox[{\"StateTransformationLinearize\", \"[\", StyleBox[\"asys\", \"TI\"], \"]\"}]\) linearizes the AffineStateSpaceModel \!\(\*StyleBox[\"asys\", \"TI\"]\) by state transformation.\n\!\(\*RowBox[{\"StateTransformationLinearize\", \"[\", RowBox[{StyleBox[\"asys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"lform\", \"TI\"]}], \"}\"}]}], \"]\"}]\) specifies the new states \!\(\*StyleBox[\"z\", \"TI\"]\) and form of linearization \!\(\*StyleBox[\"lform\", \"TI\"]\). \n\!\(\*RowBox[{\"StateTransformationLinearize\", \"[\", RowBox[{StyleBox[\"asys\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) computes the property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\"."
StationaryDistribution::usage = "\!\(\*RowBox[{\"StationaryDistribution\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) represents the stationary distribution of the process \!\(\*StyleBox[\"proc\", \"TI\"]\), when it exists. "
StationaryWaveletPacketTransform::usage = "\!\(\*RowBox[{\"StationaryWaveletPacketTransform\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) gives the stationary wavelet packet transform (SWPT) of an array of \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"StationaryWaveletPacketTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"]}], \"]\"}]\) gives the stationary wavelet packet transform using the wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\).\n\!\(\*RowBox[{\"StationaryWaveletPacketTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the stationary wavelet packet transform using \!\(\*StyleBox[\"r\", \"TI\"]\) levels of refinement.\n\!\(\*RowBox[{\"StationaryWaveletPacketTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the stationary wavelet packet transform of an image.\n\!\(\*RowBox[{\"StationaryWaveletPacketTransform\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the stationary wavelet packet transform of sampled sound."
StationaryWaveletTransform::usage = "\!\(\*RowBox[{\"StationaryWaveletTransform\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) gives the stationary wavelet transform (SWT) of an array of \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"StationaryWaveletTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"]}], \"]\"}]\) gives the stationary wavelet transform using the wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\).\n\!\(\*RowBox[{\"StationaryWaveletTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"wave\", \"TI\"], StyleBox[\",\", \"TI\"], StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the stationary wavelet transform using \!\(\*StyleBox[\"r\", \"TI\"]\) levels of refinement.\n\!\(\*RowBox[{\"StationaryWaveletTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the stationary wavelet transform of an image.\n\!\(\*RowBox[{\"StationaryWaveletTransform\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives the stationary wavelet transform of sampled sound."
StatisticalPlots`BoxExtraSpacing::usage = "BoxExtraSpacing is an option for BoxWhiskerPlot that specifies spacing adjustments to be applied when plotting multiple boxes."
StatisticalPlots`BoxFillingStyle::usage = "BoxFillingStyle is an option for BoxWhiskerPlot that specifies a color to be used in drawing the box."
StatisticalPlots`BoxLabels::usage = "BoxLabels is an option for BoxWhiskerPlot that specifies labels to be given for each of the datasets."
StatisticalPlots`BoxLineStyle::usage = "BoxLineStyle is an option for BoxWhiskerPlot that specifies styles to be applied to the lines drawn in the plot."
StatisticalPlots`BoxMedianStyle::usage = "BoxMedianStyle is an option for BoxWhiskerPlot that specifies additional styles to be applied specifically to the median lines in the plot."
StatisticalPlots`BoxOrientation::usage = "BoxOrientation is an option for BoxWhiskerPlot that specifies the orientation of the boxes."
StatisticalPlots`BoxOutlierMarkers::usage = "BoxOutlierMarkers is an option for BoxWhiskerPlot that specifies markers to be used for outliers."
StatisticalPlots`BoxOutliers::usage = "BoxOutliers is an option for BoxWhiskerPlot that specifies the outliers to draw."
StatisticalPlots`BoxQuantile::usage = "BoxQuantile is an option for BoxWhiskerPlot that specifies how far the box extends from the median."
StatisticalPlots`BoxWhiskerPlot::usage = "\!\(\*RowBox[{BoxWhiskerPlot, \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) creates a box\[Hyphen]and\[Hyphen]whisker plot of the given vector of \!\(\*StyleBox[\"data\", \"TI\"]\). \n\!\(\*RowBox[{BoxWhiskerPlot, \"[\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"]\"}]\) creates multiple box\[Hyphen]and\[Hyphen]whisker plots. \n\!\(\*RowBox[{BoxWhiskerPlot, \"[\", StyleBox[\"matrix\", \"TI\"], \"]\"}]\) also creates multiple box\[Hyphen]and\[Hyphen]whisker plots, with each column of the \!\(\*StyleBox[\"matrix\", \"TI\"]\) used for a separate box."
StatisticalPlots`ColumnLabels::usage = "ColumnLabels is an option for StemLeafPlot that specifies the labels for columns."
StatisticalPlots`DataLabels::usage = "DataLabels is an option for PairwiseScatterPlot that specifies labels for each column of data."
StatisticalPlots`DataRanges::usage = "DataRanges is an option for PairwiseScatterPlot that specifies range limits for each column of data."
StatisticalPlots`DataSpacing::usage = "DataSpacing is an option for PairwiseScatterPlot that specifies spacing between the subplots."
StatisticalPlots`DataTicks::usage = "DataTicks is an option for PairwiseScatterPlot that specifies ticks to place on the plot for each column of data."
StatisticalPlots`IncludeEmptyStems::usage = "IncludeEmptyStems is an option for StemLeafPlot that specifies whether stems with no leaves should be included in the plot."
StatisticalPlots`IncludeStemCounts::usage = "IncludeStemCounts is an option for StemLeafPlot that specifies whether a column of counts for each stem should be included."
StatisticalPlots`IncludeStemUnits::usage = "IncludeStemUnits is an option for StemLeafPlot that specifies whether the units of the stems should be included with the plot."
StatisticalPlots`Leaves::usage = "Leaves is an option for StemLeafPlot that specifies how leaves should be displayed."
StatisticalPlots`PairwiseScatterPlot::usage = "\!\(\*RowBox[{\"PairwiseScatterPlot\", \"[\", StyleBox[\"m\", \"TI\"], StyleBox[\"]\", \"TI\"]}]\) creates a matrix of scatter plots comparing the data in each column of \!\(\*StyleBox[\"m\", \"TI\"]\) against columns of \!\(\*StyleBox[\"m\", \"TI\"]\)."
StatisticalPlots`ParetoPlot::usage = "\!\(\*RowBox[{\"ParetoPlot\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) creates a Pareto plot from the frequencies of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"ParetoPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cat\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"freq\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cat\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"freq\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a Pareto plot from categories \!\(\*SubscriptBox[StyleBox[\"cat\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with frequencies \!\(\*SubscriptBox[StyleBox[\"freq\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
StatisticalPlots`PlotDirection::usage = "PlotDirection is an option for PairwiseScatterPlot that specifies the direction in which scatter plots are generated."
StatisticalPlots`StemExponent::usage = "StemExponent is an option for StemLeafPlot which specifies the integer power of 10 to be used as the stem unit."
StatisticalPlots`StemLeafPlot::usage = "\!\(\*RowBox[{\"StemLeafPlot\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) creates a stem-and-leaf plot for the real-valued vector \!\(\*StyleBox[\"data\", \"TI\"]\).\n\!\(\*RowBox[{\"StemLeafPlot\", \"[\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) creates a side-by-side stem-and-leaf plot for the vectors \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
StatusArea::usage = "\!\(\*RowBox[{\"StatusArea\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"string\", \"TI\"]}], \"]\"}]\) displays \!\(\*StyleBox[\"string\", \"TI\"]\) in the status area of the current notebook when the mouse pointer is in the region where \!\(\*StyleBox[\"expr\", \"TI\"]\) appears. "
StatusCentrality::usage = "\!\(\*RowBox[{\"StatusCentrality\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of status centralities for the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"StatusCentrality\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
StepMonitor::usage = "StepMonitor is an option for iterative numerical computation functions that gives an expression to evaluate whenever a step is taken by the numerical method used. "
StieltjesGamma::usage = "\!\(\*RowBox[{\"StieltjesGamma\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the Stieltjes constant \!\(\*SubscriptBox[\"\[Gamma]\", StyleBox[\"n\", \"TI\"]]\). \n\!\(\*RowBox[{\"StieltjesGamma\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives the generalized Stieltjes constant \!\(\*RowBox[{SubscriptBox[\"\[Gamma]\", StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"a\", \"TI\"], \")\"}]\)."
StirlingS1::usage = "\!\(\*RowBox[{\"StirlingS1\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Stirling number of the first kind \!\(\*SubsuperscriptBox[StyleBox[\"S\", \"TI\"], StyleBox[\"n\", \"TI\"], RowBox[{\"(\", StyleBox[\"m\", \"TI\"], \")\"}]]\). "
StirlingS2::usage = "\!\(\*RowBox[{\"StirlingS2\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) gives the Stirling number of the second kind \!\(\*SubsuperscriptBox[\"\[ScriptCapitalS]\", StyleBox[\"n\", \"TI\"], RowBox[{\"(\", StyleBox[\"m\", \"TI\"], \")\"}]]\). "
StopAsynchronousTask::usage = "\!\(\*RowBox[{\"StopAsynchronousTask\", \"[\", StyleBox[\"task\", \"TI\"], \"]\"}]\) stops asynchronous evaluations from \!\(\*StyleBox[\"task\", \"TI\"]\)."
StoppingPowerData::usage = "\!\(\*RowBox[{\"StoppingPowerData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"\\\"Particle\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"particle\", \"TI\"]}], \",\", RowBox[{StyleBox[\"\\\"Energy\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"quantity\", \"TI\"]}]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specific property for the substance for the specified particle and the energy of that particle."
StoppingTest::usage = "StoppingTest is an option for NDSolve that can be used to stop the integration of the ode when a certain condition is found to be True. The condition can evaluate to True/False only and should contain the dependent and independent variables explicitly. This option cannot be used for linear boundary value problems."
StopScheduledTask::usage = "\!\(\*RowBox[{\"StopScheduledTask\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) deactivates the local or cloud scheduled task represented by \!\(\*StyleBox[\"obj\", \"TI\"]\)."
StrataVariables::usage = "StrataVariables is an option for fitting functions such as CoxModelFit that specify the variables on which the model should be stratified. "
StratonovichProcess::usage = "\!\(\*RowBox[{\"StratonovichProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents a Stratonovich process \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\), where \!\(\*RowBox[{RowBox[{\"\[DifferentialD]\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \"\[LongEqual]\", RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}], RowBox[{\"\[DifferentialD]\", StyleBox[\"t\", \"TI\"]}]}], \"+\", RowBox[{RowBox[{StyleBox[\"b\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}], \"\[EmptySmallCircle]\", \" \", RowBox[{\"\[DifferentialD]\", RowBox[{StyleBox[\"w\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \" \"}]}]}]}]\).\n\!\(\*RowBox[{\"StratonovichProcess\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents a Stratonovich process \!\(\*RowBox[{RowBox[{StyleBox[\"y\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \"\[LongEqual]\", RowBox[{StyleBox[\"c\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}]}]\), where \!\(\*RowBox[{RowBox[{\"\[DifferentialD]\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \"\[LongEqual]\", RowBox[{RowBox[{RowBox[{StyleBox[\"a\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}], RowBox[{\"\[DifferentialD]\", StyleBox[\"t\", \"TI\"]}]}], \"+\", RowBox[{RowBox[{StyleBox[\"b\", \"TI\"], \"(\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]}], \")\"}], \"\[EmptySmallCircle]\", \" \", RowBox[{\"\[DifferentialD]\", RowBox[{StyleBox[\"w\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}], \" \"}]}]}]}]\).\n\!\(\*RowBox[{\"StratonovichProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents a Stratonovich process with initial condition \!\(\*RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"(\", SubscriptBox[StyleBox[\"t\", \"TI\"], \"0\"], \")\"}], \"\[LongEqual]\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"0\"]}]\).\n\!\(\*RowBox[{\"StratonovichProcess\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) uses a Wiener process \!\(\*RowBox[{StyleBox[\"w\", \"TI\"], \"(\", StyleBox[\"t\", \"TI\"], \")\"}]\), with covariance \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"StratonovichProcess\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) converts \!\(\*StyleBox[\"proc\", \"TI\"]\) to a standard Stratonovich process whenever possible.\n\!\(\*RowBox[{\"StratonovichProcess\", \"[\", RowBox[{StyleBox[\"sdeqns\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", RowBox[{StyleBox[\"w\", \"TI\"], \"\[Distributed]\", StyleBox[\"dproc\", \"TI\"]}]}], \"]\"}]\) represents a Stratonovich process specified by a stochastic differential equation \!\(\*StyleBox[\"sdeqns\", \"TI\"]\), output expression \!\(\*StyleBox[\"expr\", \"TI\"]\), with state \!\(\*StyleBox[\"x\", \"TI\"]\) and time \!\(\*StyleBox[\"t\", \"TI\"]\), driven by \!\(\*StyleBox[\"w\", \"TI\"]\) following the process \!\(\*StyleBox[\"dproc\", \"TI\"]\). "
StreamColorFunctionScaling::usage = "StreamColorFunctionScaling is an option for graphics functions that specifies whether arguments supplied to a stream color function should be scaled to lie between 0 and 1. "
StreamColorFunction::usage = "StreamColorFunction is an option for StreamPlot and related functions that specifies a function to apply to determine colors along streamlines. "
StreamDensityPlot::usage = "\!\(\*RowBox[{\"StreamDensityPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a stream plot of the vector field \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\), superimposed on a background density plot of the scalar field \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"StreamDensityPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) takes the scalar field to be the norm of the vector field.\n\!\(\*RowBox[{\"StreamDensityPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"]}], StyleBox[\"}\", \"TR\"]}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates plots of several vector fields. \n\!\(\*RowBox[{\"StreamDensityPlot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes the variables \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\). "
StreamPlot::usage = "\!\(\*RowBox[{\"StreamPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a stream plot of the vector field \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{\"StreamPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates plots of several vector fields. \n\!\(\*RowBox[{\"StreamPlot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes the variables \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\). "
StreamPoints::usage = "StreamPoints is an option to StreamPlot, ListStreamPlot, and related functions that determines how many streamlines to draw."
StreamPosition::usage = "\!\(\*RowBox[{\"StreamPosition\", \"[\", StyleBox[\"stream\", \"TI\"], \"]\"}]\) returns an integer that specifies the position of the current point in an open stream. "
StreamScale::usage = "StreamScale is an option to StreamPlot, ListStreamPlot, and related functions that determines the length and arrowhead size of streamlines that are drawn. "
StreamStyle::usage = "StreamStyle is an option to StreamPlot, StreamDensityPlot, and related functions that determines the style to use for drawing streamlines."
Streams::usage = "\!\(\*RowBox[{\"Streams\", \"[\", \"]\"}]\) gives a list of all streams that are currently open. \n\!\(\*RowBox[{\"Streams\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) lists only streams with the specified name. "
StringByteCount::usage = "\!\(\*RowBox[{\"StringByteCount\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the total number of bytes used to store the characters in a string."
StringCases::usage = "\!\(\*RowBox[{\"StringCases\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of the substrings in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" that match the string expression \!\(\*StyleBox[\"patt\", \"TI\"]\). \n\!\(\*RowBox[{\"StringCases\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{StyleBox[\"lhs\", \"TI\"], \"\[Rule]\", StyleBox[\"rhs\", \"TI\"]}]}], \"]\"}]\) gives a list of the values of \!\(\*StyleBox[\"rhs\", \"TI\"]\) corresponding to the substrings that match the string expression \!\(\*StyleBox[\"lhs\", \"TI\"]\). \n\!\(\*RowBox[{\"StringCases\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) includes only the first \!\(\*StyleBox[\"n\", \"TI\"]\) substrings that match. \n\!\(\*RowBox[{\"StringCases\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives substrings that match any of the \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringCases\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringCases\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) represents an operator form of StringCases that can be applied to an expression."
StringContainsQ::usage = "\!\(\*RowBox[{\"StringContainsQ\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) yields True if any part of \!\(\*StyleBox[\"string\", \"TI\"]\) matches the string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\), and yields False otherwise.\n\!\(\*RowBox[{\"StringContainsQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of the results for each of the \!\(\*SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"StringContainsQ\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) represents an operator form of StringContainsQ that can be applied to an expression."
StringCount::usage = "\!\(\*RowBox[{\"StringCount\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"sub\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a count of the number of times \"\!\(\*\nStyleBox[\"sub\", \"TI\"]\)\" appears as a substring of \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringCount\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives the number of substrings in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" that match the general string expression \!\(\*StyleBox[\"patt\", \"TI\"]\). \n\!\(\*RowBox[{\"StringCount\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) counts the number of occurrences of any of the \!\(\*SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringCount\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringDelete::usage = "\!\(\*RowBox[{\"StringDelete\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) yields the string obtained by deleting from \!\(\*StyleBox[\"string\", \"TI\"]\) all occurrences of anything matching the string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"StringDelete\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) represents an operator form of StringDelete that can be applied to an expression."
StringDrop::usage = "\!\(\*RowBox[{\"StringDrop\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" with its first \!\(\*StyleBox[\"n\", \"TI\"]\) characters dropped. \n\!\(\*RowBox[{\"StringDrop\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) gives \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" with its last \!\(\*StyleBox[\"n\", \"TI\"]\) characters dropped. \n\!\(\*RowBox[{\"StringDrop\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) gives \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" with its \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) character dropped. \n\!\(\*RowBox[{\"StringDrop\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" with characters \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) dropped. \n\!\(\*RowBox[{\"StringDrop\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"spec\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringEndsQ::usage = "\!\(\*RowBox[{\"StringEndsQ\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) yields True if the end of \!\(\*StyleBox[\"string\", \"TI\"]\) matches the string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\), and yields False otherwise.\n\!\(\*RowBox[{\"StringEndsQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of the results for each of the \!\(\*SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"StringEndsQ\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) represents an operator form of StringEndsQ that can be applied to an expression."
StringExpression::usage = "\!\(\*RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"~~\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"~~\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]\) or \!\(\*RowBox[{\"StringExpression\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a sequence of strings and symbolic string objects \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringExtract::usage = "\!\(\*RowBox[{\"StringExtract\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) extracts the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) block of characters in \!\(\*StyleBox[\"string\", \"TI\"]\), where blocks of characters are defined as delimited by whitespace.\n\!\(\*RowBox[{\"StringExtract\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) extracts blocks at several positions in \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"StringExtract\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{StyleBox[\"sep\", \"TI\"], \"\[Rule]\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) takes blocks to be delimited by separators that match \!\(\*StyleBox[\"sep\", \"TI\"]\).\n\!\(\*RowBox[{\"StringExtract\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{StyleBox[\"sep\", \"TI\"], \"\[Rule]\", StyleBox[\"pos\", \"TI\"]}]}], \"]\"}]\) extracts blocks at positions specified by \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"StringExtract\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) extracts blocks at positions \!\(\*SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), delimiting with whitespace for the lowest level, newlines for the next level, and multiple newlines thereafter.\n\!\(\*RowBox[{\"StringExtract\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{SubscriptBox[StyleBox[\"sep\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"sep\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a nested list of blocks, with the \!\(\*SubscriptBox[StyleBox[\"sep\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) used as separators for successive levels."
StringFormat::usage = "\!\(\*RowBox[{\"StringFormat\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) attempts to determine what ImportString format could be used to import the string \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\"."
StringForm::usage = "\!\(\*RowBox[{\"StringForm\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"controlstring\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) prints as the text of the \!\(\*StyleBox[\"controlstring\", \"TI\"]\), with the printed forms of the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) embedded. "
StringFreeQ::usage = "\!\(\*RowBox[{\"StringFreeQ\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) yields True if no substring in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" matches the string expression \!\(\*StyleBox[\"patt\", \"TI\"]\), and yields False otherwise. \n\!\(\*RowBox[{\"StringFreeQ\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields True if no substring matches any of the \!\(\*SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringFreeQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringInsert::usage = "\!\(\*RowBox[{\"StringInsert\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"snew\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) yields a string with \"\!\(\*\nStyleBox[\"snew\", \"TI\"]\)\" inserted starting at position \!\(\*StyleBox[\"n\", \"TI\"]\) in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringInsert\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"snew\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) inserts at position \!\(\*StyleBox[\"n\", \"TI\"]\) from the end of \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringInsert\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"snew\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) inserts a copy of \"\!\(\*\nStyleBox[\"snew\", \"TI\"]\)\" at each of the positions \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringInsert\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"snew\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringJoin::usage = "\!\(\*RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"s\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \"<>\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"s\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \"<>\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\), \!\(\*RowBox[{\"StringJoin\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"s\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"s\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\), or \!\(\*RowBox[{\"StringJoin\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"s\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"s\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) yields a string consisting of a concatenation of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringLength::usage = "\!\(\*RowBox[{\"StringLength\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the number of characters in a string. "
StringMatchQ::usage = "\!\(\*RowBox[{\"StringMatchQ\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) tests whether \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" matches the string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\). \n\!\(\*RowBox[{\"StringMatchQ\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"RegularExpression\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"regex\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]}], \"]\"}]\) tests whether \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" matches the specified regular expression. \n\!\(\*RowBox[{\"StringMatchQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringPadLeft::usage = "\!\(\*RowBox[{\"StringPadLeft\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) makes \!\(\*StyleBox[\"string\", \"TI\"]\) be of length \!\(\*StyleBox[\"n\", \"TI\"]\), padding it on the left with spaces or truncating it if necessary. \n\!\(\*RowBox[{\"StringPadLeft\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"padding\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) pads by repeating copies of the string \!\(\*StyleBox[\"padding\", \"TI\"]\).\n\!\(\*RowBox[{\"StringPadLeft\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) pads strings with spaces on the left to make them all the same length.\n\!\(\*RowBox[{\"StringPadLeft\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) pads or truncates to make all strings of length \!\(\*StyleBox[\"n\", \"TI\"]\)."
StringPadRight::usage = "\!\(\*RowBox[{\"StringPadRight\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) makes \!\(\*StyleBox[\"string\", \"TI\"]\) be of length \!\(\*StyleBox[\"n\", \"TI\"]\), padding it on the right with spaces or truncating it if necessary. \n\!\(\*RowBox[{\"StringPadRight\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"padding\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) pads by repeating copies of the string \!\(\*StyleBox[\"padding\", \"TI\"]\).\n\!\(\*RowBox[{\"StringPadRight\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) pads strings with spaces on the right to make them all the same length.\n\!\(\*RowBox[{\"StringPadRight\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) pads or truncates to make all strings of length \!\(\*StyleBox[\"n\", \"TI\"]\)."
StringPartition::usage = "\!\(\*RowBox[{\"StringPartition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) partitions string into nonoverlapping substrings of length \!\(\*StyleBox[\"n\", \"TI\"]\).\n\!\(\*RowBox[{\"StringPartition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"]}], \"]\"}]\) generates substrings with offset \!\(\*StyleBox[\"d\", \"TI\"]\)."
StringPosition::usage = "\!\(\*RowBox[{\"StringPosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"sub\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a list of the starting and ending character positions at which \"\!\(\*\nStyleBox[\"sub\", \"TI\"]\)\" appears as a substring of \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringPosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives all positions at which substrings matching the general string expression \!\(\*StyleBox[\"patt\", \"TI\"]\) appear in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringPosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) includes only the first \!\(\*StyleBox[\"n\", \"TI\"]\) occurrences of \!\(\*StyleBox[\"patt\", \"TI\"]\). \n\!\(\*RowBox[{\"StringPosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives positions of all the \!\(\*SubscriptBox[StyleBox[\"patt\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringPosition\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringQ::usage = "\!\(\*RowBox[{\"StringQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a string, and False otherwise."
StringRepeat::usage = "\!\(\*RowBox[{\"StringRepeat\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"str\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) creates a string consisting of \"\!\(\*\nStyleBox[\"str\", \"TI\"]\)\" repeated \!\(\*StyleBox[\"n\", \"TI\"]\) times.\n\!\(\*RowBox[{\"StringRepeat\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"str\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"]\"}]\) creates a string consisting of up to \!\(\*StyleBox[\"n\", \"TI\"]\) copies of \"\!\(\*\nStyleBox[\"str\", \"TI\"]\)\", truncated to be of maximum total length at most \!\(\*StyleBox[\"max\", \"TI\"]\)."
StringReplaceList::usage = "\!\(\*RowBox[{\"StringReplaceList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{StyleBox[\"s\", \"TI\"], \"\[Rule]\", StyleBox[\"sp\", \"TI\"]}]}], \"]\"}]\) or \!\(\*RowBox[{\"StringReplaceList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"sp\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"sp\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of the strings obtained by replacing each individual occurrence of substrings in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" matching the string expressions \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringReplaceList\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"srules\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a list of the first \!\(\*StyleBox[\"n\", \"TI\"]\) results obtained. \n\!\(\*RowBox[{\"StringReplaceList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"srules\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringReplacePart::usage = "\!\(\*RowBox[{\"StringReplacePart\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"snew\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) replaces the characters at positions \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" by \"\!\(\*\nStyleBox[\"snew\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringReplacePart\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"snew\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) inserts copies of \"\!\(\*\nStyleBox[\"snew\", \"TI\"]\)\" at several positions. \n\!\(\*RowBox[{\"StringReplacePart\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"snew\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"snew\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) replaces characters at positions \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) through \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" by \"\!\(\*SubscriptBox[\nStyleBox[\"snew\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\". "
StringReplace::usage = "\!\(\*RowBox[{\"StringReplace\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{StyleBox[\"s\", \"TI\"], \"\[Rule]\", StyleBox[\"sp\", \"TI\"]}]}], \"]\"}]\) replaces the string expression \!\(\*StyleBox[\"s\", \"TI\"]\) by \!\(\*StyleBox[\"sp\", \"TI\"]\) wherever it appears in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringReplace\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"sp\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"sp\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) replaces the string expressions \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) by \!\(\*SubscriptBox[StyleBox[\"sp\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) whenever they appear as substrings of \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\".\n\!\(\*RowBox[{\"StringReplace\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"srules\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) does only the first \!\(\*StyleBox[\"n\", \"TI\"]\) replacements. \n\!\(\*RowBox[{\"StringReplace\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"srules\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringReverse::usage = "\!\(\*RowBox[{\"StringReverse\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) reverses the order of the characters in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". "
StringRiffle::usage = "\!\(\*RowBox[{\"StringRiffle\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a string by concatenating all the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), with spaces inserted between them.\n\!\(\*RowBox[{\"StringRiffle\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a string by concatenating the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"ij\", \"TI\"]]\), and inserting spaces at the lowest level and newlines at the higher level.\n\!\(\*RowBox[{\"StringRiffle\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"sep\", \"TI\"]}], \"]\"}]\) inserts the separator \!\(\*StyleBox[\"sep\", \"TI\"]\) between all elements in \!\(\*StyleBox[\"list\", \"TI\"]\).\n\!\(\*RowBox[{\"StringRiffle\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"left\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"sep\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"right\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"}\"}]}], \"]\"}]\) use \!\(\*StyleBox[\"left\", \"TI\"]\) and \!\(\*StyleBox[\"right\", \"TI\"]\) as delimiters after concatenation.\n\!\(\*RowBox[{\"StringRiffle\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", SubscriptBox[StyleBox[\"sep\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sep\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) inserts separator \!\(\*SubscriptBox[StyleBox[\"sep\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) between elements of \!\(\*StyleBox[\"list\", \"TI\"]\) at level \!\(\*StyleBox[\"i\", \"TI\"]\)."
StringRotateLeft::usage = "\!\(\*RowBox[{\"StringRotateLeft\", \"[\", RowBox[{StyleBox[\"string\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) cycles the characters in \!\(\*StyleBox[\"string\", \"TI\"]\) \!\(\*StyleBox[\"n\", \"TI\"]\) positions to the left.\n\!\(\*RowBox[{\"StringRotateLeft\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) cycles one position to the left."
StringRotateRight::usage = "\!\(\*RowBox[{\"StringRotateRight\", \"[\", RowBox[{StyleBox[\"string\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) cycles the characters in \!\(\*StyleBox[\"string\", \"TI\"]\) \!\(\*StyleBox[\"n\", \"TI\"]\) positions to the right.\n\!\(\*RowBox[{\"StringRotateRight\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) cycles one position to the right."
StringSkeleton::usage = "\!\(\*RowBox[{\"StringSkeleton\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a sequence of \!\(\*StyleBox[\"n\", \"TI\"]\) omitted characters in a string printed with Short. The standard print form for StringSkeleton is an ellipsis. "
StringSplit::usage = "\!\(\*RowBox[{\"StringSplit\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) splits \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" into a list of substrings separated by whitespace. \n\!\(\*RowBox[{\"StringSplit\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) splits into substrings separated by delimiters matching the string expression \!\(\*StyleBox[\"patt\", \"TI\"]\). \n\!\(\*RowBox[{\"StringSplit\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) splits at any of the \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringSplit\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{StyleBox[\"patt\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}]}], \"]\"}]\) inserts \!\(\*StyleBox[\"val\", \"TI\"]\) at the position of each delimiter. \n\!\(\*RowBox[{\"StringSplit\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) inserts \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at the position of each delimiter \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"StringSplit\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) splits into at most \!\(\*StyleBox[\"n\", \"TI\"]\) substrings. \n\!\(\*RowBox[{\"StringSplit\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringStartsQ::usage = "\!\(\*RowBox[{\"StringStartsQ\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) yields True if the beginning of \!\(\*StyleBox[\"string\", \"TI\"]\) matches the string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\), and yields False otherwise.\n\!\(\*RowBox[{\"StringStartsQ\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of the results for each of the \!\(\*SubscriptBox[StyleBox[\"string\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"StringStartsQ\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) represents an operator form of StringStartsQ that can be applied to an expression."
StringTake::usage = "\!\(\*RowBox[{\"StringTake\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives a string containing the first \!\(\*StyleBox[\"n\", \"TI\"]\) characters in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringTake\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) gives the last \!\(\*StyleBox[\"n\", \"TI\"]\) characters in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringTake\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) gives the \!\(\*StyleBox[RowBox[{StyleBox[\"n\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) character in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringTake\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives characters \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) in \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\". \n\!\(\*RowBox[{\"StringTake\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of the substrings specified by the \!\(\*SubscriptBox[StyleBox[\"spec\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"StringTake\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"spec\", \"TI\"]}], \"]\"}]\) gives the list of results for each of the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
StringTemplate::usage = "\!\(\*RowBox[{\"StringTemplate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) yields a TemplateObject that represents a string template to be applied using functions like TemplateApply.\n\!\(\*RowBox[{\"StringTemplate\", \"[\", RowBox[{\"File\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}]\) takes the source for the string template from a file."
StringToStream::usage = "\!\(\*RowBox[{\"StringToStream\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) opens an input stream for reading from a string. "
StringTrim::usage = "\!\(\*RowBox[{\"StringTrim\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) trims whitespace from the beginning and end of \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\".\n\!\(\*RowBox[{\"StringTrim\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) trims substrings matching \!\(\*StyleBox[\"patt\", \"TI\"]\) from the beginning and end."
String::usage = "String is the head of a character string \"\!\(\*\nStyleBox[\"text\", \"TI\"]\)\". "
StripBoxes::usage = "\!\(\*RowBox[{StripBoxes, \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) will strip out unnecessary boxes, spaces, and styles from a format expression."
StripOnInput::usage = "StripOnInput is an option for certain boxes that determines whether the box should be stripped on evaluation."
StripWrapperBoxes::usage = "StripWrapperBoxes is an option to TagBox that controls how boxes are stripped upon evaluation."
StructuralImportance::usage = "\!\(\*RowBox[{\"StructuralImportance\", \"[\", StyleBox[\"rdist\", \"TI\"], \"]\"}]\) gives the structural importances for all components in the ReliabilityDistribution \!\(\*StyleBox[\"rdist\", \"TI\"]\).\n\!\(\*RowBox[{\"StructuralImportance\", \"[\", StyleBox[\"fdist\", \"TI\"], \"]\"}]\) gives the structural importances for all components in the FailureDistribution \!\(\*StyleBox[\"fdist\", \"TI\"]\).\n\!\(\*RowBox[{\"StructuralImportance\", \"[\", RowBox[{StyleBox[\"bexpr\", \"TI\"], StyleBox[\",\", \"TI\"], RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the structural importance for the components \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] in the Boolean expression \!\(\*StyleBox[\"bexpr\", \"TI\"]\)."
StructuredArray::usage = "\!\(\*RowBox[{\"StructuredArray\", \"[\", RowBox[{StyleBox[\"st\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"data\", \"TI\"]}], \"]\"}]\) represents a \!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)\[Times]\!\(\*SubscriptBox[StyleBox[\"d\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)\[Times]\[Ellipsis] array with structure type \!\(\*StyleBox[\"st\", \"TI\"]\) and specific content \!\(\*StyleBox[\"data\", \"TI\"]\). "
StructuredSelection::usage = "StructuredSelection is an option for Cell that specifies whether to allow only complete subexpressions in the cell to be selected interactively using the front end. "
StruveH::usage = "\!\(\*RowBox[{\"StruveH\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Struve function \!\(\*RowBox[{SubscriptBox[StyleBox[\"H\", SingleLetterItalics -> False, FontWeight -> \"Bold\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
StruveL::usage = "\!\(\*RowBox[{\"StruveL\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the modified Struve function \!\(\*RowBox[{SubscriptBox[StyleBox[\"L\", SingleLetterItalics -> False, FontWeight -> \"Bold\"], StyleBox[\"n\", \"TI\"]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
Stub::usage = "Stub is an attribute which specifies that if a symbol is ever used, Needs should automatically be called on the context of the symbol. "
StudentTDistribution::usage = "\!\(\*RowBox[{\"StudentTDistribution\", \"[\", StyleBox[\"\[Nu]\", \"TR\"], \"]\"}]\) represents a Student \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom.\n\!\(\*RowBox[{\"StudentTDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents a Student \!\(\*StyleBox[\"t\", \"TI\"]\) distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) degrees of freedom."
StyleBoxAutoDelete::usage = "StyleBoxAutoDelete is an option for selections that specifies whether a StyleBox wrapped around them should be automatically removed when the expression is edited."
StyleBox::usage = "\!\(\*RowBox[{StyleBox, \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) is a low-level representation of \!\(\*StyleBox[\"boxes\", \"TI\"]\) to be shown with the specified option settings. \n\!\(\*RowBox[{StyleBox, \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses the option setting for the specified style in the current notebook. "
StyleData::usage = "\!\(\*RowBox[{\"StyleData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) is a low-level representation of the contents of a style definition cell.\n\!\(\*RowBox[{\"StyleData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"environment\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents the contents of a style definition cell in the style environment \"\!\(\*\nStyleBox[\"environment\", \"TI\"]\)\"."
StyleDefinitions::usage = "StyleDefinitions is an option for notebooks that gives definitions for the styles that can be used in a notebook. "
StyleForm::usage = "\!\(\*RowBox[{\"StyleForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) prints using the specified style options. \n\!\(\*RowBox[{\"StyleForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) prints using the specified cell style in the current notebook. "
StyleMenuListing::usage = "StyleMenuListing is an option for cells that specifies whether a given cell style is listed in the \!\(\*StyleBox[\"Format \[FilledRightTriangle] Style\", \"MenuName\"]\) submenu."
StyleNameDialogSettings::usage = "\!\(\*RowBox[{\"StyleNameDialogSettings\", \"\[Rule]\", RowBox[{\"{\", RowBox[{StyleBox[\"opt\", \"TI\"], \"\[Rule]\", StyleBox[\"val\", \"TI\"]}], \"}\"}]}]\) is a global option that specifies the cell style displayed in the \!\(\*StyleBox[\"Custom Style\", \"DialogElementName\"]\) dialog box."
StylePrint::usage = "\!\(\*RowBox[{\"StylePrint\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) creates a new cell in the current notebook with the specified style, and prints \!\(\*StyleBox[\"expr\", \"TI\"]\) into it. \n\!\(\*RowBox[{\"StylePrint\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) uses the default style for the current notebook. "
StyleSheetPath::usage = "StyleSheetPath is a global option that specifies which directories \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) searches to find stylesheets."
Style::usage = "\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) displays with \!\(\*StyleBox[\"expr\", \"TI\"]\) formatted using the specified option settings. \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) uses the option settings for the specified style in the current notebook. \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"color\", \"TI\"]}], \"]\"}]\) displays using the specified color. \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"Bold\"}], \"]\"}]\) displays with fonts made bold. \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"Italic\"}], \"]\"}]\) displays with fonts made italic. \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"Underlined\"}], \"]\"}]\) displays with fonts underlined. \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"Larger\"}], \"]\"}]\) displays with fonts made larger. \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"Smaller\"}], \"]\"}]\) displays with fonts made smaller. \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) displays with font size \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"Tiny\"}], \"]\"}]\), \!\(\*RowBox[{\"Style\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"Small\"}], \"]\"}]\), etc. display with fonts that are tiny, small, etc. "
Subdivide::usage = "\!\(\*RowBox[{\"Subdivide\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) generates the list \!\(\*RowBox[{\"{\", RowBox[{\"0\", \",\", RowBox[{\"1\", \"/\", StyleBox[\"n\", \"TI\"]}], \",\", RowBox[{\"2\", \"/\", StyleBox[\"n\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", \"1\"}], \"}\"}]\).\n\!\(\*RowBox[{\"Subdivide\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates the list of values obtained by subdividing the interval 0 to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) into \!\(\*StyleBox[\"n\", \"TI\"]\) equal parts.\n\!\(\*RowBox[{\"Subdivide\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates the list of values from subdividing the internal \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\)."
Subfactorial::usage = "\!\(\*RowBox[{\"Subfactorial\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the number of permutations of \!\(\*StyleBox[\"n\", \"TI\"]\) objects that leave no object fixed."
Subgraph::usage = "\!\(\*RowBox[{\"Subgraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the subgraph of the graph \!\(\*StyleBox[\"g\", \"TI\"]\) generated by the vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"Subgraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the subgraph generated by the edges \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"j\", \"TI\"]]\).\n\!\(\*RowBox[{\"Subgraph\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives the subgraph generated by the vertices and edges that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"Subgraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
SubMinus::usage = "\!\(\*RowBox[{\"SubMinus\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"-\", \"TR\"]]\)."
SubPlus::usage = "\!\(\*RowBox[{\"SubPlus\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], \"+\"]\)."
SubresultantPolynomialRemainders::usage = "\!\(\*RowBox[{\"SubresultantPolynomialRemainders\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) gives the subresultant polynomial remainder sequence of the polynomials \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with respect to the variable \!\(\*StyleBox[\"var\", \"TI\"]\).\n\!\(\*RowBox[{\"SubresultantPolynomialRemainders\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"var\", \"TI\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) computes the subresultant polynomial remainder sequence modulo the prime \!\(\*StyleBox[\"p\", \"TI\"]\)."
SubresultantPolynomials::usage = "\!\(\*RowBox[{\"SubresultantPolynomials\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) generates a list of subresultant polynomials of the polynomials \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with respect to the variable \!\(\*StyleBox[\"var\", \"TI\"]\).\n\!\(\*RowBox[{\"SubresultantPolynomials\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"var\", \"TI\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) computes the subresultant polynomials modulo the prime \!\(\*StyleBox[\"p\", \"TI\"]\)."
Subresultants::usage = "\!\(\*RowBox[{\"Subresultants\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) generates a list of the principal subresultant coefficients of the polynomials \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) with respect to the variable \!\(\*StyleBox[\"var\", \"TI\"]\).\n\!\(\*RowBox[{\"Subresultants\", \"[\", RowBox[{SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"poly\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"var\", \"TI\"], \",\", RowBox[{\"Modulus\", \"\[Rule]\", StyleBox[\"p\", \"TI\"]}]}], \"]\"}]\) computes the principal subresultant coefficients modulo the prime \!\(\*StyleBox[\"p\", \"TI\"]\). "
SubscriptBoxOptions::usage = "\!\(\*RowBox[{SubscriptBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for selections that specifies settings for SubscriptBox objects."
SubscriptBox::usage = "\!\(\*RowBox[{SubscriptBox, \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is the low\[Hyphen]level box representation for \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\) in notebook expressions. "
Subscript::usage = "\!\(\*RowBox[{\"Subscript\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is an object that formats as \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\). \n\!\(\*RowBox[{\"Subscript\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) formats as \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \"\[Ellipsis]\"}]]\)."
SubsetEqual::usage = "\!\(\*RowBox[{\"SubsetEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SubsetEqual]\", StyleBox[\"y\", \"TI\"], \"\[SubsetEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SubsetQ::usage = "\!\(\*RowBox[{\"SubsetQ\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) yields True if \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) is a subset of \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), and False otherwise."
Subsets::usage = "\!\(\*RowBox[{\"Subsets\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a list of all possible subsets of \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Subsets\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives all subsets containing at most \!\(\*StyleBox[\"n\", \"TI\"]\) elements. \n\!\(\*RowBox[{\"Subsets\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) gives all subsets containing exactly \!\(\*StyleBox[\"n\", \"TI\"]\) elements. \n\!\(\*RowBox[{\"Subsets\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives all subsets containing between \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) elements. \n\!\(\*RowBox[{\"Subsets\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"nspec\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) limits the result to the first \!\(\*StyleBox[\"s\", \"TI\"]\) subsets. \n\!\(\*RowBox[{\"Subsets\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"nspec\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"s\", \"TI\"], \"}\"}]}], \"]\"}]\) gives if possible the \!\(\*StyleBox[RowBox[{StyleBox[\"s\", \"TI\"], \"\[Null]\"}]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) subset. "
Subset::usage = "\!\(\*RowBox[{\"Subset\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Subset]\", StyleBox[\"y\", \"TI\"], \"\[Subset]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SubStar::usage = "\!\(\*RowBox[{\"SubStar\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], \"*\"]\)."
SubstitutionSystem::usage = "\!\(\*RowBox[{\"SubstitutionSystem\", \"[\", RowBox[{StyleBox[\"rule\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) generates a list representing the evolution of the substitution system with the specified rule from initial condition \!\(\*StyleBox[\"init\", \"TI\"]\) for \!\(\*StyleBox[\"t\", \"TI\"]\) steps.\n\!\(\*RowBox[{\"SubstitutionSystem\", \"[\", RowBox[{StyleBox[\"rule\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) gives the result of evolving \!\(\*StyleBox[\"init\", \"TI\"]\) for one step.\n\!\(\*RowBox[{\"SubstitutionSystem\", \"[\", StyleBox[\"rule\", \"TI\"], \"]\"}]\) is an operator form of SubstitutionSystem that corresponds to one step of evolution. "
SubsuperscriptBoxOptions::usage = "\!\(\*RowBox[{SubsuperscriptBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for selections that specifies settings for SubsuperscriptBox objects."
SubsuperscriptBox::usage = "\!\(\*RowBox[{SubsuperscriptBox, \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the low\[Hyphen]level box representation for \!\(\*SubsuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"], StyleBox[\"z\", \"TI\"]]\) in notebook expressions. "
Subsuperscript::usage = "\!\(\*RowBox[{\"Subsuperscript\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is an object that formats as \!\(\*SubsuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"], StyleBox[\"z\", \"TI\"]]\). "
SubtractFrom::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"-=\", StyleBox[\"dx\", \"TI\"]}]\) subtracts \!\(\*StyleBox[\"dx\", \"TI\"]\) from \!\(\*StyleBox[\"x\", \"TI\"]\) and returns the new value of \!\(\*StyleBox[\"x\", \"TI\"]\). "
Subtract::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"-\", StyleBox[\"y\", \"TI\"]}]\) is equivalent to \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"+\", RowBox[{\"(\", RowBox[{RowBox[{\"-\", \"1\"}], \"*\", StyleBox[\"y\", \"TI\"]}], \")\"}]}]\). "
SubValues::usage = "\!\(\*RowBox[{\"SubValues\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives a list of transformation rules corresponding to all subvalues (values for \!\(\*RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\), etc.) defined for the symbol \!\(\*StyleBox[\"f\", \"TI\"]\)."
SucceedsEqual::usage = "\!\(\*RowBox[{\"SucceedsEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SucceedsEqual]\", StyleBox[\"y\", \"TI\"], \"\[SucceedsEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SucceedsSlantEqual::usage = "\!\(\*RowBox[{\"SucceedsSlantEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SucceedsSlantEqual]\", StyleBox[\"y\", \"TI\"], \"\[SucceedsSlantEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SucceedsTilde::usage = "\!\(\*RowBox[{\"SucceedsTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SucceedsTilde]\", StyleBox[\"y\", \"TI\"], \"\[SucceedsTilde]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Succeeds::usage = "\!\(\*RowBox[{\"Succeeds\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Succeeds]\", StyleBox[\"y\", \"TI\"], \"\[Succeeds]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SuchThat::usage = "\!\(\*RowBox[{\"SuchThat\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SuchThat]\", StyleBox[\"y\", \"TI\"]}]\)."
SumConvergence::usage = "\!\(\*RowBox[{\"SumConvergence\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives conditions for the sum \!\(\*RowBox[{UnderoverscriptBox[\"\[Sum]\", StyleBox[\"n\", \"TI\"], \"\[Infinity]\"], StyleBox[\"f\", \"TI\"]}]\) to be convergent.\n\!\(\*RowBox[{\"SumConvergence\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives conditions for the multiple sum \!\(\*RowBox[{UnderoverscriptBox[\"\[Sum]\", SubscriptBox[StyleBox[\"n\", \"TI\"], \"1\"], \"\[Infinity]\"], RowBox[{UnderoverscriptBox[\"\[Sum]\", SubscriptBox[StyleBox[\"n\", \"TI\"], \"2\"], \"\[Infinity]\"], RowBox[{\"\[Ellipsis]\", \" \", StyleBox[\"f\", \"TI\"]}]}]}]\) to be convergent."
Sum::usage = "\!\(\*RowBox[{\"Sum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) evaluates the sum \!\(\*RowBox[{UnderoverscriptBox[\"\[Sum]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", \"1\"}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], StyleBox[\"f\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Sum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) starts with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"Sum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*RowBox[{StyleBox[\"d\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"i\", \"TI\"]}]\). \n\!\(\*RowBox[{\"Sum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses successive values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"Sum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) evaluates the multiple sum \!\(\*RowBox[{UnderoverscriptBox[\"\[Sum]\", RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]]}], SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], RowBox[{UnderoverscriptBox[\"\[Sum]\", RowBox[{StyleBox[\"j\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]]}], SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]], LimitsPositioning -> True], RowBox[{\"\[Ellipsis]\", StyleBox[\"f\", \"TI\"]}]}]}]\). \n\!\(\*RowBox[{\"Sum\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) gives the indefinite sum \!\(\*RowBox[{UnderscriptBox[\"\[Sum]\", StyleBox[\"i\", \"TI\"]], StyleBox[\"f\", \"TI\"]}]\)."
Sunday::usage = "Sunday is a day of the week."
SunPosition::usage = "\!\(\*RowBox[{\"SunPosition\", \"[\", \"]\"}]\) gives the position of the Sun for the current date and location.\n\!\(\*RowBox[{\"SunPosition\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the position of the Sun for the specified date.\n\!\(\*RowBox[{\"SunPosition\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the positions of the Sun for the specified location.\n\!\(\*RowBox[{\"SunPosition\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the position of the Sun for the specified date and location.\n\!\(\*RowBox[{\"SunPosition\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the positions of the Sun for all specified locations on the specified dates.\n\!\(\*RowBox[{\"SunPosition\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"func\", \"TI\"]\) to determine what to return for extended locations."
Sunrise::usage = "\!\(\*RowBox[{\"Sunrise\", \"[\", \"]\"}]\) gives the time of the next sunrise for the current date and location.\n\!\(\*RowBox[{\"Sunrise\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the times of the next sunrise for the specified dates.\n\!\(\*RowBox[{\"Sunrise\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the times of the next sunrise for the specified locations.\n\!\(\*RowBox[{\"Sunrise\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the time of the next sunrise for the specified date and location.\n\!\(\*RowBox[{\"Sunrise\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the times of the next sunrise for all specified locations on the specified dates.\n\!\(\*RowBox[{\"Sunrise\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"func\", \"TI\"]\) to determine what to return for extended locations."
Sunset::usage = "\!\(\*RowBox[{\"Sunset\", \"[\", \"]\"}]\) gives the time of the next sunset for the current date and location.\n\!\(\*RowBox[{\"Sunset\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the time of the next sunset for the specified dates.\n\!\(\*RowBox[{\"Sunset\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the times of the next sunset for the specified locations.\n\!\(\*RowBox[{\"Sunset\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the time of the next sunset for the specified date and location.\n\!\(\*RowBox[{\"Sunset\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the times of the next sunset for all specified locations on the specified dates.\n\!\(\*RowBox[{\"Sunset\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"func\", \"TI\"]\) to determine what to return for extended locations."
SuperDagger::usage = "\!\(\*RowBox[{\"SuperDagger\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as \!\(\*SuperscriptBox[StyleBox[\"expr\", \"TI\"], \"\[Dagger]\"]\)."
SuperMinus::usage = "\!\(\*RowBox[{\"SuperMinus\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as \!\(\*SuperscriptBox[StyleBox[\"expr\", \"TI\"], \"-\"]\)."
SupernovaData::usage = "\!\(\*RowBox[{\"SupernovaData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the supernova \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"SupernovaData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified supernova entities.\n\!\(\*RowBox[{\"SupernovaData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
SuperPlus::usage = "\!\(\*RowBox[{\"SuperPlus\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as \!\(\*SuperscriptBox[StyleBox[\"expr\", \"TI\"], \"+\"]\)."
SuperscriptBoxOptions::usage = "\!\(\*RowBox[{SuperscriptBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for selections that specifies settings for SuperscriptBox objects."
SuperscriptBox::usage = "\!\(\*RowBox[{SuperscriptBox, \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is the low\[Hyphen]level box representation for \!\(\*SuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\) in notebook expressions. "
Superscript::usage = "\!\(\*RowBox[{\"Superscript\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is an object that formats as \!\(\*SuperscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\). "
SupersetEqual::usage = "\!\(\*RowBox[{\"SupersetEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[SupersetEqual]\", StyleBox[\"y\", \"TI\"], \"\[SupersetEqual]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Superset::usage = "\!\(\*RowBox[{\"Superset\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Superset]\", StyleBox[\"y\", \"TI\"], \"\[Superset]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
SuperStar::usage = "\!\(\*RowBox[{\"SuperStar\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays as \!\(\*SuperscriptBox[StyleBox[\"expr\", \"TI\"], \"*\"]\)."
Surd::usage = "\!\(\*RowBox[{\"Surd\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the real-valued \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) root of \!\(\*StyleBox[\"x\", \"TI\"]\)."
SurfaceColor::usage = "\!\(\*RowBox[{\"SurfaceColor\", \"[\", StyleBox[\"dcol\", \"TI\"], \"]\"}]\) is a three-dimensional graphics directive which specifies that the surfaces which follow should act as diffuse reflectors of light with a color given by \!\(\*StyleBox[\"dcol\", \"TI\"]\). \n\!\(\*RowBox[{\"SurfaceColor\", \"[\", RowBox[{StyleBox[\"dcol\", \"TI\"], \",\", StyleBox[\"scol\", \"TI\"]}], \"]\"}]\) specifies that a specular reflection component should be included, with a color given by \!\(\*StyleBox[\"scol\", \"TI\"]\). \n\!\(\*RowBox[{\"SurfaceColor\", \"[\", RowBox[{StyleBox[\"dcol\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"scol\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) specifies that the reflection should occur with specular exponent\[NonBreakingSpace]\!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"SurfaceColor\", \"[\", RowBox[{StyleBox[\"dcol\", \"TI\"], \",\", StyleBox[\"scol\", \"TI\"], \",\", StyleBox[\"gcol\", \"TI\"]}], \"]\"}]\) specifies that a color \!\(\*StyleBox[\"gcol\", \"TI\"]\) should be added as if there were an intrinsic glow in the polygon. "
SurfaceData::usage = "\!\(\*RowBox[{\"SurfaceData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the surface \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"SurfaceData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified surface entities.\n\!\(\*RowBox[{\"SurfaceData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", \" \", StyleBox[\"property\", \"TI\"], \",\", \" \", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
SurfaceGraphics::usage = "\!\(\*RowBox[{\"SurfaceGraphics\", \"[\", StyleBox[\"array\", \"TI\"], \"]\"}]\) is a representation of a three-dimensional plot of a surface, with heights of each point on a grid specified by values in \!\(\*StyleBox[\"array\", \"TI\"]\). \n\!\(\*RowBox[{\"SurfaceGraphics\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"shades\", \"TI\"]}], \"]\"}]\) represents a surface, whose parts are shaded according to the array \!\(\*StyleBox[\"shades\", \"TI\"]\). "
SurvivalDistribution::usage = "\!\(\*RowBox[{\"SurvivalDistribution\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a survival distribution with event times \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SurvivalDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"cw\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"cw\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a survival distribution where events \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) occur with censor weights \!\(\*SubscriptBox[StyleBox[\"cw\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
SurvivalFunction::usage = "\!\(\*RowBox[{\"SurvivalFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the survival function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) evaluated at \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"SurvivalFunction\", \"[\", RowBox[{StyleBox[\"dist\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the multivariate survival function for the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) evaluated at \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"SurvivalFunction\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the survival function as a pure function."
SurvivalModelFit::usage = "\!\(\*RowBox[{\"SurvivalModelFit\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a survival model for event times\!\(\*RowBox[{\" \", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\)."
SurvivalModel::usage = "\!\(\*RowBox[{\"SurvivalModel\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents the symbolic survival model obtained from functions like SurvivalModelFit."
SuspendPacket::usage = "\!\(\*RowBox[{\"SuspendPacket\", \"[\", \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet used for synchronization with the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) kernel."
SuzukiDistribution::usage = "\!\(\*RowBox[{\"SuzukiDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents the Suzuki distribution with shape parameters \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\)."
SuzukiGroupSuz::usage = "\!\(\*RowBox[{\"SuzukiGroupSuz\", \"[\", \"]\"}]\) represents the sporadic simple Suzuki group Suz."
SwatchLegend::usage = "\!\(\*RowBox[{\"SwatchLegend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) generates a legend that associates swatches of colors \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SwatchLegend\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"Automatic\"}], \"]\"}]\) generates a legend with placeholder labels for the colors \!\(\*SubscriptBox[StyleBox[\"col\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SwatchLegend\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a legend with inherited colors within visualization functions."
Switch::usage = "\!\(\*RowBox[{\"Switch\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), then compares it with each of the \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in turn, evaluating and returning the \!\(\*SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the first match found. "
Symbol`EchoFunction::usage = "\!\(\*RowBox[{RowBox[{\"EchoFunction\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) and returns \!\(\*StyleBox[\"expr\", \"TI\"]\).\n\!\(\*RowBox[{RowBox[{\"EchoFunction\", \"[\", RowBox[{StyleBox[\"label\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\), prepending \!\(\*StyleBox[\"label\", \"TI\"]\), and returns \!\(\*StyleBox[\"expr\", \"TI\"]\)."
SymbolicC`CAddress::usage = "\!\(\*RowBox[{\"CAddress\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) is a symbolic representation of the address of an object."
SymbolicC`CArray::usage = "\!\(\*RowBox[{\"CArray\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) is a symbolic representation of an array."
SymbolicC`CAssign::usage = "\!\(\*RowBox[{\"CAssign\", \"[\", RowBox[{StyleBox[\"lhs\", \"TI\"], \",\", StyleBox[\"rhs\", \"TI\"]}], \"]\"}]\) is a symbolic representation of an assignment statement."
SymbolicC`CBlock::usage = "\!\(\*RowBox[{\"CBlock\", \"[\", StyleBox[\"args\", \"TI\"], \"]\"}]\) is a symbolic representation of a block of statements."
SymbolicC`CBreak::usage = "\!\(\*RowBox[{\"CBreak\", \"[\", \"]\"}]\) is a symbolic representation of a break statement."
SymbolicC`CCall::usage = "\!\(\*RowBox[{\"CCall\", \"[\", RowBox[{StyleBox[\"fname\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a call to a function."
SymbolicC`CCast::usage = "\!\(\*RowBox[{\"CCast\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"obj\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a cast of \!\(\*StyleBox[\"obj\", \"TI\"]\) to \!\(\*StyleBox[\"type\", \"TI\"]\)."
SymbolicC`CComment::usage = "\!\(\*RowBox[{\"CComment\", \"[\", StyleBox[\"text\", \"TI\"], \"]\"}]\) is a symbolic representation of a comment. \n\!\(\*RowBox[{\"CComment\", \"[\", RowBox[{StyleBox[\"text\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"pre\", \"TI\"], \",\", StyleBox[\"post\", \"TI\"]}], \"}\"}]}], \"]\"}]\) includes text to add before and after the comment."
SymbolicC`CConditional::usage = "\!\(\*RowBox[{\"CConditional\", \"[\", RowBox[{StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"trueArg\", \"TI\"], \",\", StyleBox[\"falseArg\", \"TI\"]}], \"]\"}]\) is a symbolic representation of an inline conditional expression."
SymbolicC`CConstant::usage = "\!\(\*RowBox[{\"CConstant\", \"[\", \"]\"}]\) is a symbolic representation of a constant."
SymbolicC`CContinue::usage = "\!\(\*RowBox[{\"CContinue\", \"[\", \"]\"}]\) is a symbolic representation of a continue statement."
SymbolicC`CDeclare::usage = "\!\(\*RowBox[{\"CDeclare\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a variable declaration.\n\!\(\*RowBox[{\"CDeclare\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"var\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) declares a number of variables."
SymbolicC`CDefault::usage = "\!\(\*RowBox[{\"CDefault\", \"[\", \"]\"}]\) is a symbolic representation of a default statement."
SymbolicC`CDefine::usage = "\!\(\*RowBox[{\"CDefine\", \"[\", StyleBox[\"def\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor define."
SymbolicC`CDereference::usage = "\!\(\*RowBox[{\"CDereference\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) is a symbolic representation of the dereferencing of a pointer."
SymbolicC`CDo::usage = "\!\(\*RowBox[{\"CDo\", \"[\", RowBox[{StyleBox[\"body\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a do/while statement."
SymbolicC`CEnum::usage = "\!\(\*RowBox[{\"CEnum\", \"[\", StyleBox[\"members\", \"TI\"], \"]\"}]\) is a symbolic representation of an enum statement."
SymbolicC`CError::usage = "\!\(\*RowBox[{\"CError\", \"[\", StyleBox[\"line\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor error directive."
SymbolicC`CExpression::usage = "\!\(\*RowBox[{\"CExpression\", \"[\", StyleBox[\"arg\", \"TI\"], \"]\"}]\) is a symbolic representation of code that will format using \!\(\*RowBox[{\"CForm\", \"[\", StyleBox[\"arg\", \"TI\"], \"]\"}]\)."
SymbolicC`CFor::usage = "\!\(\*RowBox[{\"CFor\", \"[\", RowBox[{StyleBox[\"init\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"incr\", \"TI\"], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a for loop."
SymbolicC`CFunction::usage = "\!\(\*RowBox[{\"CFunction\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a function definition.\n\!\(\*RowBox[{\"CFunction\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a function declaration."
SymbolicC`CGoto::usage = "\!\(\*RowBox[{\"CGoto\", \"[\", StyleBox[\"label\", \"TI\"], \"]\"}]\) is a symbolic representation of a goto statement."
SymbolicC`CIf::usage = "\!\(\*RowBox[{\"CIf\", \"[\", RowBox[{StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"trueArg\", \"TI\"], \",\", StyleBox[\"falseArg\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a conditional statement. \n\!\(\*RowBox[{\"CIf\", \"[\", RowBox[{StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"trueArg\", \"TI\"]}], \"]\"}]\) only has a branch if test is true."
SymbolicC`CInclude::usage = "\!\(\*RowBox[{\"CInclude\", \"[\", StyleBox[\"header\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor include statement. "
SymbolicC`CLabel::usage = "\!\(\*RowBox[{\"CLabel\", \"[\", StyleBox[\"label\", \"TI\"], \"]\"}]\) is a symbolic representation of a label."
SymbolicC`CLine::usage = "\!\(\*RowBox[{\"CLine\", \"[\", StyleBox[\"line\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor line directive."
SymbolicC`CMember::usage = "\!\(\*RowBox[{\"CMember\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"mem\", \"TI\"]}], \"]\"}]\) is a symbolic representation of access from a struct."
SymbolicC`COperator::usage = "\!\(\*RowBox[{\"COperator\", \"[\", RowBox[{StyleBox[\"oper\", \"TI\"], \",\", SubscriptBox[StyleBox[\"arg\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is a symbolic representation of an operator."
SymbolicC`CParentheses::usage = "\!\(\*RowBox[{\"CParentheses\", \"[\", StyleBox[\"symb\", \"TI\"], \"]\"}]\) adds parentheses around an expression."
SymbolicC`CPointerMember::usage = "\!\(\*RowBox[{\"CPointerMember\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"mem\", \"TI\"]}], \"]\"}]\) is a symbolic representation of access from a pointer to a struct."
SymbolicC`CPointerType::usage = "\!\(\*RowBox[{\"CPointerType\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) is a symbolic representation of a type that is a pointer to a type."
SymbolicC`CPragma::usage = "\!\(\*RowBox[{\"CPragma\", \"[\", StyleBox[\"line\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor pragma directive."
SymbolicC`CPreprocessorElif::usage = "\!\(\*RowBox[{\"CPreprocessorElif\", \"[\", StyleBox[\"cond\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor elif conditional."
SymbolicC`CPreprocessorElse::usage = "\!\(\*RowBox[{\"CPreprocessorElse\", \"[\", \" \", \"]\"}]\) is a symbolic representation of a preprocessor else conditional."
SymbolicC`CPreprocessorEndif::usage = "\!\(\*RowBox[{\"CPreprocessorEndif\", \"[\", \" \", \"]\"}]\) is a symbolic representation of a preprocessor endif conditional."
SymbolicC`CPreprocessorIfdef::usage = "\!\(\*RowBox[{\"CPreprocessorIfdef\", \"[\", StyleBox[\"cond\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor ifdef conditional.\n\!\(\*RowBox[{\"CPreprocessorIfdef\", \"[\", RowBox[{StyleBox[\"cond\", \"TI\"], \",\", StyleBox[\"true\", \"TI\"], \",\", StyleBox[\"false\", \"TI\"]}], \"]\"}]\) represents the true and false cases."
SymbolicC`CPreprocessorIfndef::usage = "\!\(\*RowBox[{\"CPreprocessorIfndef\", \"[\", StyleBox[\"cond\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor ifndef conditional.\n\!\(\*RowBox[{\"CPreprocessorIfndef\", \"[\", RowBox[{StyleBox[\"cond\", \"TI\"], \",\", StyleBox[\"true\", \"TI\"], \",\", StyleBox[\"false\", \"TI\"]}], \"]\"}]\) represents the true and false cases."
SymbolicC`CPreprocessorIf::usage = "\!\(\*RowBox[{\"CPreprocessorIf\", \"[\", StyleBox[\"cond\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor if conditional.\n\!\(\*RowBox[{\"CPreprocessorIf\", \"[\", RowBox[{StyleBox[\"cond\", \"TI\"], \",\", StyleBox[\"true\", \"TI\"], \",\", StyleBox[\"false\", \"TI\"]}], \"]\"}]\) represents the true and false cases."
SymbolicC`CProgram::usage = "\!\(\*RowBox[{\"CProgram\", \"[\", StyleBox[\"args\", \"TI\"], \"]\"}]\) is a symbolic representation of an entire program."
SymbolicC`CReturn::usage = "\!\(\*RowBox[{\"CReturn\", \"[\", \" \", \"]\"}]\) is a symbolic representation of a return from a function. \n\!\(\*RowBox[{\"CReturn\", \"[\", StyleBox[\"arg\", \"TI\"], \"]\"}]\) returns the argument \!\(\*StyleBox[\"arg\", \"TI\"]\)."
SymbolicC`CSizeOf::usage = "\!\(\*RowBox[{\"CSizeOf\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) is a symbolic representation of a sizeof expression."
SymbolicC`CStandardMathOperator::usage = "\!\(\*RowBox[{\"CStandardMathOperator\", \"[\", RowBox[{StyleBox[\"oper\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a standard math operator."
SymbolicC`CStatement::usage = "\!\(\*RowBox[{\"CStatement\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) is a symbolic representation of a statement. "
SymbolicC`CString::usage = "\!\(\*RowBox[{\"CString\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) is a symbolic representation of a string expression."
SymbolicC`CStruct::usage = "\!\(\*RowBox[{\"CStruct\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"members\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a struct.\n\!\(\*RowBox[{\"CStruct\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) declares a struct without specifying the contents.\n\!\(\*RowBox[{\"CStruct\", \"[\", RowBox[{\"None\", \",\", StyleBox[\"members\", \"TI\"]}], \"]\"}]\) does not give the struct a name."
SymbolicC`CSwitch::usage = "\!\(\*RowBox[{\"CSwitch\", \"[\", RowBox[{StyleBox[\"cond\", \"TI\"], \",\", StyleBox[\"statements\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a switch statement."
SymbolicC`CTypedef::usage = "\!\(\*RowBox[{\"CTypedef\", \"[\", RowBox[{StyleBox[\"type\", \"TI\"], \",\", StyleBox[\"var\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a type declaration."
SymbolicC`CUndef::usage = "\!\(\*RowBox[{\"CUndef\", \"[\", StyleBox[\"def\", \"TI\"], \"]\"}]\) is a symbolic representation of a preprocessor undef."
SymbolicC`CUnion::usage = "\!\(\*RowBox[{\"CUnion\", \"[\", RowBox[{StyleBox[\"name\", \"TI\"], \",\", StyleBox[\"members\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a union.\n\!\(\*RowBox[{\"CUnion\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) declares a union without specifying the contents.\n\!\(\*RowBox[{\"CUnion\", \"[\", RowBox[{\"None\", \",\", StyleBox[\"members\", \"TI\"]}], \"]\"}]\) does not give the union a name."
SymbolicC`CWhile::usage = "\!\(\*RowBox[{\"CWhile\", \"[\", RowBox[{StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) is a symbolic representation of a while statement."
SymbolicC`ToCCodeString::usage = "\!\(\*RowBox[{\"ToCCodeString\", \"[\", StyleBox[\"symbolicC\", \"TI\"], \"]\"}]\) generates a string of C code from a symbolic C expression."
SymbolName::usage = "\!\(\*RowBox[{\"SymbolName\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) gives the name of the specified symbol. "
Symbol::usage = "\!\(\*RowBox[{\"Symbol\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) refers to a symbol with the specified name. "
Symbol`WordOrientation::usage = "WordOrientation is an option for WordCloud that specifies the orientations in which words appear."
SymletWavelet::usage = "\!\(\*RowBox[{\"SymletWavelet\", \"[\", \"]\"}]\) represents the Symlet wavelet of order 4.\n\!\(\*RowBox[{\"SymletWavelet\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the Symlet wavelet of order \!\(\*StyleBox[\"n\", \"TI\"]\)."
SymmetricGroup::usage = "\!\(\*RowBox[{\"SymmetricGroup\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the symmetric group of degree \!\(\*StyleBox[\"n\", \"TI\"]\)."
SymmetricKey::usage = "\!\(\*RowBox[{\"SymmetricKey\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) represents all the information needed for encryption, decryption, and other operations in a symmetric cryptographic system."
SymmetricMatrixQ::usage = "\!\(\*RowBox[{\"SymmetricMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is explicitly symmetric, and False otherwise. "
SymmetricPolynomial::usage = "\!\(\*RowBox[{\"SymmetricPolynomial\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) elementary symmetric polynomial in the variables \!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\)."
SymmetricReduction::usage = "\!\(\*RowBox[{\"SymmetricReduction\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives a pair of polynomials \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"}\"}]\) in \!\(\*RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"1\"], \",\", \"\[Ellipsis]\", \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\) such that \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"==\", RowBox[{StyleBox[\"p\", \"TI\"], \"+\", StyleBox[\"q\", \"TI\"]}]}]\), where \!\(\*StyleBox[\"p\", \"TI\"]\) is the symmetric part and \!\(\*StyleBox[\"q\", \"TI\"]\) is the remainder.\n\!\(\*RowBox[{\"SymmetricReduction\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the pair \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"q\", \"TI\"]}], \"}\"}]\) with the elementary symmetric polynomials in \!\(\*StyleBox[\"p\", \"TI\"]\) replaced by \!\(\*RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], \"1\"], \",\", \"\[Ellipsis]\", \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"n\", \"TI\"]]}]\)."
Symmetric::usage = "\!\(\*RowBox[{\"Symmetric\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents the symmetry of a tensor that is symmetric in the slots \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
SymmetrizedArrayRules::usage = "\!\(\*RowBox[{\"SymmetrizedArrayRules\", \"[\", StyleBox[\"sa\", \"TI\"], \"]\"}]\) returns a list of rules \!\(\*RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\) of the symmetrized array \!\(\*StyleBox[\"sa\", \"TI\"]\).\n\!\(\*RowBox[{\"SymmetrizedArrayRules\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"sym\", \"TI\"]}], \"]\"}]\) returns a list of rules \!\(\*RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\) of the array \!\(\*StyleBox[\"a\", \"TI\"]\) after being symmetrized with symmetry \!\(\*StyleBox[\"sym\", \"TI\"]\)."
SymmetrizedArray::usage = "\!\(\*RowBox[{RowBox[{\"SymmetrizedArray\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"->\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"\", \"TR\"]], \"->\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dims\", \"TI\"], \",\", StyleBox[\"sym\", \"TI\"]}], \"]\"}], \" \"}]\) yields an array of dimensions \!\(\*StyleBox[\"dims\", \"TI\"]\) whose entries are given by those in the rules \!\(\*RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\) or through the symmetry \!\(\*StyleBox[\"sym\", \"TI\"]\).\n\!\(\*RowBox[{\"SymmetrizedArray\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) yields a symmetrized array version of \!\(\*StyleBox[\"list\", \"TI\"]\)."
SymmetrizedDependentComponents::usage = "\!\(\*RowBox[{\"SymmetrizedDependentComponents\", \"[\", RowBox[{StyleBox[\"comp\", \"TI\"], \",\", StyleBox[\"sym\", \"TI\"]}], \"]\"}]\) gives the list of components that are equivalent to the component \!\(\*StyleBox[\"comp\", \"TI\"]\) by the symmetry \!\(\*StyleBox[\"sym\", \"TI\"]\)."
SymmetrizedIndependentComponents::usage = "\!\(\*RowBox[{\"SymmetrizedIndependentComponents\", \"[\", RowBox[{StyleBox[\"dims\", \"TI\"], \",\", StyleBox[\"sym\", \"TI\"]}], \"]\"}]\) gives the list of independent components of an array of dimensions \!\(\*StyleBox[\"dims\", \"TI\"]\) with the symmetry \!\(\*StyleBox[\"sym\", \"TI\"]\)."
SymmetrizedReplacePart::usage = "\!\(\*RowBox[{RowBox[{\"SymmetrizedReplacePart\", \"[\", RowBox[{StyleBox[\"sa\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}], \"]\"}]\) replaces independent values of the symmetrized array \!\(\*StyleBox[\"sa\", \"TI\"]\) as given by the rules \!\(\*RowBox[{SubscriptBox[StyleBox[\"pos\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]}]\)."
Symmetrize::usage = "\!\(\*RowBox[{\"Symmetrize\", \"[\", RowBox[{StyleBox[\"tensor\", \"TI\"], \",\", StyleBox[\"sym\", \"TI\"]}], \"]\"}]\) returns the symmetrization of \!\(\*StyleBox[\"tensor\", \"TI\"]\) under the symmetry \!\(\*StyleBox[\"sym\", \"TI\"]\)."
SynchronousInitialization::usage = "SynchronousInitialization is an option for Manipulate, DynamicModule, and related functions that specifies whether or not to evaluate the expression given as the setting for Initialization synchronously."
SynchronousUpdating::usage = "SynchronousUpdating is an option for Manipulate, Dynamic, and related functions that specifies whether or not to evaluate their contents synchronously. "
SyntaxForm::usage = "SyntaxForm is an option for InterpretationBox and TagBox objects that specifies the precedence level to use when the InterpretationBox or TagBox is considered as an operator."
SyntaxInformation::usage = "\!\(\*RowBox[{\"SyntaxInformation\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives information used to generate syntax coloring and other advisories when \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) is entered as input. "
SyntaxLength::usage = "\!\(\*RowBox[{\"SyntaxLength\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) finds the number of characters starting at the beginning of a string that correspond to syntactically correct input for a single \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) expression. "
SyntaxPacket::usage = "\!\(\*RowBox[{\"SyntaxPacket\", \"[\", StyleBox[\"integer\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet where \!\(\*StyleBox[\"integer\", \"TI\"]\) indicates the position at which a syntax error was detected in the input line."
SyntaxQ::usage = "\!\(\*RowBox[{\"SyntaxQ\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) returns True if the string corresponds to syntactically correct input for a single \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) expression, and returns False otherwise. "
SystemDialogInput::usage = "\!\(\*RowBox[{\"SystemDialogInput\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) brings up an interactive system dialog and returns the value chosen in the dialog. \n\!\(\*RowBox[{\"SystemDialogInput\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"init\", \"TI\"]\) as the initial setting in the dialog."
SystemHelpPath::usage = "SystemHelpPath is a global option that specifies which directories are searched for the help notebooks used within the help system."
SystemInformation::usage = "\!\(\*RowBox[{\"SystemInformation\", \"[\", \"]\"}]\) gives detailed information about the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\", \"ReplacedText\" -> {StyleBox[\"Mathematica\", FontSlant -> \"Italic\"], \" system\"}]\) being run. \n\!\(\*RowBox[{\"SystemInformation\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"comp\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of rules with information about the component \"\!\(\*\nStyleBox[\"comp\", \"TI\"]\)\". \n\!\(\*RowBox[{\"SystemInformation\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"comp\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of property \"\!\(\*\nStyleBox[\"prop\", \"TI\"]\)\" for component \"\!\(\*\nStyleBox[\"comp\", \"TI\"]\)\"."
SystemOpen::usage = "\!\(\*RowBox[{\"SystemOpen\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"target\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) opens the specified file, URL, or other target with the associated program on your computer system."
SystemOptions::usage = "\!\(\*RowBox[{\"SystemOptions\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the current setting for the internal system option with the specified name.\n\!\(\*RowBox[{\"SystemOptions\", \"[\", \"]\"}]\) gives the current settings for all settable internal system options."
SystemsModelDelayApproximate::usage = "\!\(\*RowBox[{\"SystemsModelDelayApproximate\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"ord\", \"TI\"]}], \"]\"}]\) gives a delay-free system by using approximations of order \!\(\*StyleBox[\"ord\", \"TI\"]\) of the time delays in system \!\(\*StyleBox[\"sys\", \"TI\"]\)."
SystemsModelDelay::usage = "\!\(\*RowBox[{\"SystemsModelDelay\", \"[\", StyleBox[\"\[Delta]\", \"TR\"], \"]\"}]\) represents a time delay of \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\) in a StateSpaceModel or TransferFunctionModel."
SystemsModelDelete::usage = "\!\(\*RowBox[{\"SystemsModelDelete\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}]}], \"]\"}]\) deletes the subsystem of the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\) associated with inputs at position \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SystemsModelDelete\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}]}], \"]\"}]\) also deletes the subsystem associated with outputs at positions \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SystemsModelDelete\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \" \", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) deletes the subsystem of the state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\) associated with inputs, outputs, and states at \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), respectively."
SystemsModelDimensions::usage = "\!\(\*RowBox[{\"SystemsModelDimensions\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives the number of inputs and outputs of the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\)."
SystemsModelExtract::usage = "\!\(\*RowBox[{\"SystemsModelExtract\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}]}], \"]\"}]\) extracts the subsystem of the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\) associated with inputs at position \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SystemsModelExtract\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) extracts the subsystem associated with inputs and outputs at positions \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), respectively.\n\!\(\*RowBox[{\"SystemsModelExtract\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) extracts the subsystem of the state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\) associated with inputs, outputs, and states at \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), respectively."
SystemsModelFeedbackConnect::usage = "\!\(\*RowBox[{\"SystemsModelFeedbackConnect\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) connects the outputs from \!\(\*StyleBox[\"sys\", \"TI\"]\) to the inputs with negative feedback. \n\!\(\*RowBox[{\"SystemsModelFeedbackConnect\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"con\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) only feedback connect the outputs and inputs in \!\(\*SubscriptBox[StyleBox[\"con\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"SystemsModelFeedbackConnect\", \"[\", RowBox[{SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) connects the outputs of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) and the outputs of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) to the inputs of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) in feedback.\n\!\(\*RowBox[{\"SystemsModelFeedbackConnect\", \"[\", RowBox[{SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ftype\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) connects output \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) input of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) and the \!\(\*StyleBox[\"j\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) output of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) to input \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) with feedback type \!\(\*SubscriptBox[StyleBox[\"ftype\", \"TI\"], StyleBox[\"j\", \"TI\"]]\)."
SystemsModelLabels::usage = "SystemsModelLabels is an option to StateSpaceModel etc. that specifies labels of variables."
SystemsModelLinearity::usage = "\!\(\*RowBox[{\"SystemsModelLinearity\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives the linearity of the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\).\n\!\(\*RowBox[{RowBox[{\"SystemsModelLinearity\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]}]}], \"]\"}]\) only considers the subsystem associated with inputs \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), outputs \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"j\", \"TI\"]]\), and states \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"k\", \"TI\"]]\)."
SystemsModelMerge::usage = "\!\(\*RowBox[{\"SystemsModelMerge\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) merges the systems models \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"j\", \"TI\"]]\). "
SystemsModelOrder::usage = "\!\(\*RowBox[{\"SystemsModelOrder\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives the order of the state-space model \!\(\*StyleBox[\"sys\", \"TI\"]\)."
SystemsModelParallelConnect::usage = "\!\(\*RowBox[{\"SystemsModelParallelConnect\", \"[\", RowBox[{SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) connects the systems models \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in parallel.\n\!\(\*RowBox[{\"SystemsModelParallelConnect\", \"[\", RowBox[{SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"21\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"21\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) connects the inputs \!\(\*SubscriptBox[SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], StyleBox[\"i\", \"TI\"]]\) to inputs \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], RowBox[{StyleBox[\"2\", \"TR\"], StyleBox[\"i\", \"TI\"]}]]\) and sums the outputs \!\(\*SubscriptBox[SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"1\", \"TR\"]], StyleBox[\"k\", \"TI\"]]\) and outputs \!\(\*SubscriptBox[SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"2\", \"TR\"]], StyleBox[\"k\", \"TI\"]]\)."
SystemsModelSeriesConnect::usage = "\!\(\*RowBox[{\"SystemsModelSeriesConnect\", \"[\", RowBox[{SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) connects systems models \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in series. \n\!\(\*RowBox[{\"SystemsModelSeriesConnect\", \"[\", RowBox[{SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"out\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"21\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) connects outputs \!\(\*SubscriptBox[StyleBox[\"out\", \"TI\"], RowBox[{StyleBox[\"1\", \"TR\"], StyleBox[\"i\", \"TI\"]}]]\) of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to inputs \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], RowBox[{StyleBox[\"2\", \"TR\"], StyleBox[\"i\", \"TI\"]}]]\) of \!\(\*SubscriptBox[StyleBox[\"sys\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
SystemsModelStateFeedbackConnect::usage = "\!\(\*RowBox[{\"SystemsModelStateFeedbackConnect\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"con\", \"TI\"]}], \"]\"}]\) connects the states of the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\) to the controller \!\(\*StyleBox[\"con\", \"TI\"]\) and the outputs of \!\(\*StyleBox[\"con\", \"TI\"]\) to the inputs of \!\(\*StyleBox[\"sys\", \"TI\"]\) in feedback.\n\!\(\*RowBox[{\"SystemsModelStateFeedbackConnect\", \"[\", RowBox[{StyleBox[\"sys\", \"TI\"], \",\", StyleBox[\"con\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ftype\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) connects state \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) of \!\(\*StyleBox[\"sys\", \"TI\"]\) to the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) input of \!\(\*StyleBox[\"con\", \"TI\"]\) and the \!\(\*StyleBox[\"j\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) output of \!\(\*StyleBox[\"con\", \"TI\"]\) to input \!\(\*SubscriptBox[StyleBox[\"in\", \"TI\"], StyleBox[\"j\", \"TI\"]]\) of \!\(\*StyleBox[\"sys\", \"TI\"]\) with feedback type \!\(\*SubscriptBox[StyleBox[\"ftype\", \"TI\"], StyleBox[\"j\", \"TI\"]]\)"
SystemsModelVectorRelativeOrders::usage = "\!\(\*RowBox[{\"SystemsModelVectorRelativeOrders\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives the vector-relative orders of the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\)."
TabFilling::usage = "TabFilling is an option for character selections that specifies how a \!\(\*StyleBox[\"Tab\", \"KeyEvent\"]\) character is represented on the screen."
TableAlignments::usage = "TableAlignments is an option for TableForm and MatrixForm which specifies how entries in each dimension should be aligned. "
TableDepth::usage = "TableDepth is an option for TableForm and MatrixForm which specifies the maximum number of levels to be printed in tabular or matrix format. "
TableDirections::usage = "TableDirections is an option for TableForm and MatrixForm which specifies whether successive dimensions should be arranged as rows or columns. "
TableForm::usage = "\!\(\*RowBox[{\"TableForm\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) prints with the elements of \!\(\*StyleBox[\"list\", \"TI\"]\) arranged in an array of rectangular cells. "
TableHeadings::usage = "TableHeadings is an option for TableForm and MatrixForm which gives the labels to be printed for entries in each dimension of a table or matrix. "
TableSpacing::usage = "TableSpacing is an option for TableForm and MatrixForm which specifies how many spaces should be left between each successive row or column. "
Table::usage = "\!\(\*RowBox[{\"Table\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates a list of \!\(\*StyleBox[\"n\", \"TI\"]\) copies of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Table\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a list of the values of \!\(\*StyleBox[\"expr\", \"TI\"]\) when \!\(\*StyleBox[\"i\", \"TI\"]\) runs from 1 to \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"Table\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) starts with \!\(\*RowBox[{StyleBox[\"i\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]]}]\). \n\!\(\*RowBox[{\"Table\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"di\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"di\", \"TI\"]\). \n\!\(\*RowBox[{\"Table\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}]}], \"]\"}]\) uses the successive values \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"Table\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"i\", \"TI\"], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"i\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a nested list. The list associated with \!\(\*StyleBox[\"i\", \"TI\"]\) is outermost."
TabSpacings::usage = "TabSpacings is an option for character selections that specifies the number of spaces in ems that the cursor advances when the \!\(\*StyleBox[\"Tab\", \"KeyEvent\"]\) key is pressed."
TabViewBoxOptions::usage = "\!\(\*RowBox[{TabViewBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for TabViewBox objects."
TabView::usage = "\!\(\*RowBox[{\"TabView\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", \" \", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents an object in which clicking the tab with label \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) displays \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"TabView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"i\", \"TI\"]}], \"]\"}]\) makes the \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) tab be the one currently selected.\n\!\(\*RowBox[{\"TabView\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]]}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) associates values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with successive tabs, and makes the tab with value \!\(\*StyleBox[\"v\", \"TI\"]\) be the one currently selected. \n\!\(\*RowBox[{\"TabView\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) takes the tab labels to be successive integers."
TagBoxOptions::usage = "\!\(\*RowBox[{TagBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for TagBox objects."
TagBox::usage = "\!\(\*RowBox[{TagBox, \"[\", RowBox[{StyleBox[\"boxes\", \"TI\"], \",\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) is a low-level box construct that displays as \!\(\*StyleBox[\"boxes\", \"TI\"]\) but maintains \!\(\*StyleBox[\"tag\", \"TI\"]\) to guide the interpretation of \!\(\*StyleBox[\"boxes\", \"TI\"]\) on input. "
TaggingRules::usage = "TaggingRules is an option for selections that specifies a list of strings to be associated with a selection."
TagSetDelayed::usage = "\!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"/:\", StyleBox[\"lhs\", \"TI\"], \":=\", StyleBox[\"rhs\", \"TI\"]}]\) assigns \!\(\*StyleBox[\"rhs\", \"TI\"]\) to be the delayed value of \!\(\*StyleBox[\"lhs\", \"TI\"]\), and associates the assignment with the symbol \!\(\*StyleBox[\"f\", \"TI\"]\). "
TagSet::usage = "\!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"/:\", StyleBox[\"lhs\", \"TI\"], \"=\", StyleBox[\"rhs\", \"TI\"]}]\) assigns \!\(\*StyleBox[\"rhs\", \"TI\"]\) to be the value of \!\(\*StyleBox[\"lhs\", \"TI\"]\), and associates the assignment with the symbol \!\(\*StyleBox[\"f\", \"TI\"]\). "
TagUnset::usage = "\!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"/:\", RowBox[{StyleBox[\"lhs\", \"TI\"], \"=.\"}]}]\) removes any rules defined for \!\(\*StyleBox[\"lhs\", \"TI\"]\), associated with the symbol \!\(\*StyleBox[\"f\", \"TI\"]\). "
TakeDrop::usage = "\!\(\*RowBox[{\"TakeDrop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the pair \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]\), where \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) contains the first \!\(\*StyleBox[\"n\", \"TI\"]\) elements of \!\(\*StyleBox[\"list\", \"TI\"]\) and \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) contains the rest.\n\!\(\*RowBox[{\"TakeDrop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"seq\", \"TI\"]}], \"]\"}]\) gives the pair \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"Take\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"seq\", \"TI\"]}], \"]\"}], \",\", RowBox[{\"Drop\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"seq\", \"TI\"]}], \"]\"}]}], \"}\"}]\)."
TakeLargestBy::usage = "\!\(\*RowBox[{\"TakeLargestBy\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) elements \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in \!\(\*StyleBox[\"list\", \"TI\"]\) for which \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is largest, sorted in descending order.\n\!\(\*RowBox[{\"TakeLargestBy\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents an operator form of TakeLargestBy that can be applied to an expression. "
TakeLargest::usage = "\!\(\*RowBox[{\"TakeLargest\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) numerically largest elements in \!\(\*StyleBox[\"list\", \"TI\"]\), sorted in descending order.\n\!\(\*RowBox[{\"TakeLargest\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents an operator form of TakeLargest that can be applied to an expression."
TakeSmallestBy::usage = "\!\(\*RowBox[{\"TakeSmallestBy\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) elements \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in \!\(\*StyleBox[\"list\", \"TI\"]\) for which \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is smallest, sorted in ascending order.\n\!\(\*RowBox[{\"TakeSmallestBy\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) represents an operator form of TakeSmallestBy that can be applied to an expression. "
TakeSmallest::usage = "\!\(\*RowBox[{\"TakeSmallest\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\) numerically smallest elements in \!\(\*StyleBox[\"list\", \"TI\"]\), sorted in ascending order.\n\!\(\*RowBox[{\"TakeSmallest\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents an operator form of TakeSmallest that can be applied to an expression."
Take::usage = "\!\(\*RowBox[{\"Take\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"n\", \"TI\"]\) elements of \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Take\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"-\", StyleBox[\"n\", \"TI\"]}]}], \"]\"}]\) gives the last \!\(\*StyleBox[\"n\", \"TI\"]\) elements of \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Take\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives elements \!\(\*StyleBox[\"m\", \"TI\"]\) through \!\(\*StyleBox[\"n\", \"TI\"]\) of \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Take\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", SubscriptBox[StyleBox[\"seq\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"seq\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a nested list in which elements specified by \!\(\*SubscriptBox[StyleBox[\"seq\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are taken at level \!\(\*StyleBox[\"i\", \"TI\"]\) in \!\(\*StyleBox[\"list\", \"TI\"]\). "
TakeWhile::usage = "\!\(\*RowBox[{\"TakeWhile\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) gives elements \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) from the beginning of \!\(\*StyleBox[\"list\", \"TI\"]\), continuing so long as \!\(\*RowBox[{StyleBox[\"crit\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True."
Tally::usage = "\!\(\*RowBox[{\"Tally\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) tallies the elements in \!\(\*StyleBox[\"list\", \"TI\"]\), listing all distinct elements together with their multiplicities.\n\!\(\*RowBox[{\"Tally\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) uses \!\(\*StyleBox[\"test\", \"TI\"]\) to determine whether pairs of elements should be considered equivalent, and gives a list of the first representatives of each equivalence class, together with their multiplicities."
Tanh::usage = "\!\(\*RowBox[{\"Tanh\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the hyperbolic tangent of \!\(\*StyleBox[\"z\", \"TI\"]\)."
Tan::usage = "\!\(\*RowBox[{\"Tan\", \"[\", StyleBox[\"z\", \"TI\"], \"]\"}]\) gives the tangent of \!\(\*StyleBox[\"z\", \"TI\"]\)."
TargetFunctions::usage = "TargetFunctions is an option for functions such as ComplexExpand and FindDistribution that specifies what functions to attempt to generate in the output. "
TargetUnits::usage = "TargetUnits is an option used to specify the desired output units for visualization functions operating on Quantity expressions."
TautologyQ::usage = "\!\(\*RowBox[{\"TautologyQ\", \"[\", StyleBox[\"bf\", \"TI\"], \"]\"}]\) gives True if all combinations of values of variables make the Boolean function \!\(\*StyleBox[\"bf\", \"TI\"]\) yield True.\n\!\(\*RowBox[{\"TautologyQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives True if all combinations of values of the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) make the Boolean expression \!\(\*StyleBox[\"expr\", \"TI\"]\) yield True."
TelegraphProcess::usage = "\!\(\*RowBox[{\"TelegraphProcess\", \"[\", StyleBox[\"\[Mu]\", \"TR\"], \"]\"}]\) represents a telegraph process with rate \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
TemplateApply::usage = "\!\(\*RowBox[{\"TemplateApply\", \"[\", StyleBox[\"template\", \"TI\"], \"]\"}]\) applies a template, evaluating all template elements it contains.\n\!\(\*RowBox[{\"TemplateApply\", \"[\", RowBox[{StyleBox[\"template\", \"TI\"], \",\", StyleBox[\"args\", \"TI\"]}], \"]\"}]\) applies a template, using \!\(\*StyleBox[\"args\", \"TI\"]\) to fill slots in the template."
TemplateBoxOptions::usage = "\!\(\*RowBox[{TemplateBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for TemplateBox objects."
TemplateBox::usage = "\!\(\*RowBox[{TemplateBox, \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) is a low-level box structure that parameterizes the display and evaluation of the boxes \!\(\*SubscriptBox[StyleBox[\"box\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
TemplateExpression::usage = "\!\(\*RowBox[{\"TemplateExpression\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents an expression held until a template is applied, and then evaluated."
TemplateIf::usage = "\!\(\*RowBox[{\"TemplateIf\", \"[\", RowBox[{StyleBox[\"condition\", \"TI\"], \",\", StyleBox[\"tclause\", \"TI\"]}], \"]\"}]\) represents an element of a template object that inserts \!\(\*StyleBox[\"tclause\", \"TI\"]\) if the condition evaluates to True.\n\!\(\*RowBox[{\"TemplateIf\", \"[\", RowBox[{StyleBox[\"condition\", \"TI\"], \",\", StyleBox[\"tclause\", \"TI\"], \",\", StyleBox[\"fclause\", \"TI\"]}], \"]\"}]\) inserts \!\(\*StyleBox[\"fclause\", \"TI\"]\) if the condition does not evaluate to True."
TemplateObject::usage = "\!\(\*RowBox[{\"TemplateObject\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents a template object to be applied using functions like TemplateApply."
TemplateSequence::usage = "\!\(\*RowBox[{\"TemplateSequence\", \"[\", RowBox[{StyleBox[\"body\", \"TI\"], \",\", StyleBox[\"list\", \"TI\"]}], \"]\"}]\) represents an element of a template object that yields a sequence consisting of \!\(\*StyleBox[\"body\", \"TI\"]\) applied to each element in \!\(\*StyleBox[\"list\", \"TI\"]\)."
TemplateSlot::usage = "\!\(\*RowBox[{\"TemplateSlot\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a template slot to be filled from the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) argument when the template is applied.\n\!\(\*RowBox[{\"TemplateSlot\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) represents a template slot to be filled from an element with key \!\(\*StyleBox[\"name\", \"TI\"]\) in an association appearing in the first argument."
TemplateWith::usage = "\!\(\*RowBox[{\"TemplateWith\", \"[\", RowBox[{RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"value\", \"TI\"]}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) represents an element of a template object that evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) after replacing \!\(\*RowBox[{\"TemplateSlot\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) with \!\(\*StyleBox[\"value\", \"TI\"]\).\n\!\(\*RowBox[{\"TemplateWith\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"name\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\) with a list of key-value pairs."
TemporalData::usage = "\!\(\*RowBox[{\"TemporalData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"tspec\", \"TI\"]}], \"]\"}]\) represents temporal data with values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at times specified by \!\(\*StyleBox[\"tspec\", \"TI\"]\).\n\!\(\*RowBox[{\"TemporalData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"tspec\", \"TI\"]}], \"]\"}]\) represents a temporal data collection with values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"ij\", \"TI\"]]\) at times specified by \!\(\*StyleBox[\"tspec\", \"TI\"]\).\n\!\(\*RowBox[{\"TemporalData\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}], \"}\"}], \"]\"}]\) represents temporal data specified by time-value pairs \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"TemporalData\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"11\", \"TR\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"12\", \"TR\"]]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"21\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"22\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a temporal data collection given as lists of time-value pairs \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"ij\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"ij\", \"TI\"]]}], \"}\"}]\)."
TemporalRegularity::usage = "TemporalRegularity is an option for TemporalData, TimeSeries, and EventSeries that controls whether the paths are assumed to be uniformly spaced in time."
Temporary::usage = "Temporary is an attribute assigned to symbols which are created as local variables by Module. "
TensorContract::usage = "\!\(\*RowBox[{\"TensorContract\", \"[\", RowBox[{StyleBox[\"tensor\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"12\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"22\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) yields the contraction of \!\(\*StyleBox[\"tensor\", \"TI\"]\) in the pairs \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[StyleBox[RowBox[{\"i\", StyleBox[\"1\", FontSlant -> \"Plain\"]}]], \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[StyleBox[RowBox[{\"i\", StyleBox[\"2\", FontSlant -> \"Plain\"]}]], \"TI\"]]}], \"}\"}]\) of slots."
TensorDimensions::usage = "\!\(\*RowBox[{\"TensorDimensions\", \"[\", StyleBox[\"tensor\", \"TI\"], \"]\"}]\) gives the list of dimensions of \!\(\*StyleBox[\"tensor\", \"TI\"]\)."
TensorExpand::usage = "\!\(\*RowBox[{\"TensorExpand\", \"[\", StyleBox[\"texpr\", \"TI\"], \"]\"}]\) expands out tensor-related products in the symbolic tensor expression \!\(\*StyleBox[\"texpr\", \"TI\"]\)."
TensorProduct::usage = "\!\(\*RowBox[{\"TensorProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"tensor\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"tensor\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the tensor product of the \!\(\*SubscriptBox[StyleBox[\"tensor\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
TensorRank::usage = "\!\(\*RowBox[{\"TensorRank\", \"[\", StyleBox[\"tensor\", \"TI\"], \"]\"}]\) gives the rank of \!\(\*StyleBox[\"tensor\", \"TI\"]\)."
TensorReduce::usage = "\!\(\*RowBox[{\"TensorReduce\", \"[\", StyleBox[\"texpr\", \"TI\"], \"]\"}]\) attempts to return a canonical form for the symbolic tensor expression \!\(\*StyleBox[\"texpr\", \"TI\"]\)."
TensorSymmetry::usage = "\!\(\*RowBox[{\"TensorSymmetry\", \"[\", StyleBox[\"tensor\", \"TI\"], \"]\"}]\) gives the symmetry of \!\(\*StyleBox[\"tensor\", \"TI\"]\) under permutations of its slots.\n\!\(\*RowBox[{\"TensorSymmetry\", \"[\", RowBox[{StyleBox[\"tensor\", \"TI\"], \",\", StyleBox[\"slots\", \"TI\"]}], \"]\"}]\) gives the symmetry under permutation of the specified list of slots."
TensorTranspose::usage = "\!\(\*RowBox[{\"TensorTranspose\", \"[\", RowBox[{StyleBox[\"tensor\", \"TI\"], \",\", StyleBox[\"perm\", \"TI\"]}], \"]\"}]\) represents the tensor obtained by transposing the slots of \!\(\*StyleBox[\"tensor\", \"TI\"]\) as given by the permutation \!\(\*StyleBox[\"perm\", \"TI\"]\)."
TensorWedge::usage = "\!\(\*RowBox[{\"TensorWedge\", \"[\", RowBox[{SubscriptBox[StyleBox[\"tensor\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"tensor\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the antisymmetrized tensor product of the \!\(\*SubscriptBox[StyleBox[\"tensor\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
TestID::usage = "TestID is an option to VerificationTest that specifies a string used as an identifier for the test."
TestReportObject::usage = "\!\(\*RowBox[{\"TestReportObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) gives an object that represents the results of TestReport."
TestReport::usage = "\!\(\*RowBox[{\"TestReport\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"test\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"test\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a report of the results of the verification tests \!\(\*SubscriptBox[StyleBox[\"test\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"TestReport\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) runs tests from a file, returning an analysis of the completed test run."
TestResultObject::usage = "\!\(\*RowBox[{\"TestResultObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) gives an object that represents the results of a VerificationTest."
TetGenLink`TetGenConvexHull::usage = "\!\(\*RowBox[{\"TetGenConvexHull\", \"[\", StyleBox[\"points\", \"TI\"], \"]\"}]\) generates a convex hull for a 3D point set."
TetGenLink`TetGenCreate::usage = "\!\(\*RowBox[{\"TetGenCreate\", \"[\", \"]\"}]\) creates an instance of a TetGen expression."
TetGenLink`TetGenDelaunay::usage = "\!\(\*RowBox[{\"TetGenDelaunay\", \"[\", StyleBox[\"points\", \"TI\"], \"]\"}]\) generates a Delaunay tetrahedralization for a 3D point set."
TetGenLink`TetGenDelete::usage = "\!\(\*RowBox[{\"TetGenDelete\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) removes an instance of a TetGen expression, freeing up memory."
TetGenLink`TetGenDetectIntersectingFacets::usage = "\!\(\*RowBox[{\"TetGenDetectIntersectingFacets\", \"[\", RowBox[{StyleBox[\"points\", \"TI\"], \",\", StyleBox[\"facets\", \"TI\"]}], \"]\"}]\) returns a list of points and intersecting facets."
TetGenLink`TetGenExport::usage = "\!\(\*RowBox[{\"TetGenExport\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file, TI]StyleBox[., TI]StyleBox[ext\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) exports data from a TetGen expression into a file.\n\!\(\*RowBox[{\"TetGenExport\", \"[\", RowBox[{\"StyleBox[file, TI]StyleBox[\", TI], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"format\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) exports data in the specified format."
TetGenLink`TetGenExpressions::usage = "\!\(\*RowBox[{\"TetGenExpressions\", \"[\", \"]\"}]\) returns a list of active TetGen expressions."
TetGenLink`TetGenExpression::usage = "\!\(\*RowBox[{\"TetGenExpression\", \"[\", StyleBox[\"id\", \"TI\"], \"]\"}]\) represents an instance of a TetGen object."
TetGenLink`TetGenGetEdges::usage = "\!\(\*RowBox[{\"TetGenGetEdges\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gets the edges in a TetGen expression."
TetGenLink`TetGenGetElementAttributes::usage = "\!\(\*RowBox[{\"TetGenGetElementAttributes\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gets the element attributes in a TetGen expression."
TetGenLink`TetGenGetElements::usage = "\!\(\*RowBox[{\"TetGenGetElements\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gets the elements in a TetGen expression."
TetGenLink`TetGenGetFaceMarkers::usage = "\!\(\*RowBox[{\"TetGenGetFaceMarkers\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the face markers for a TetGen expression."
TetGenLink`TetGenGetFaces::usage = "\!\(\*RowBox[{\"TetGenGetFaces\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gets the faces in a TetGen expression."
TetGenLink`TetGenGetFacetHoles::usage = "\!\(\*RowBox[{\"TetGenGetFacetHoles\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gets the holes in the facets."
TetGenLink`TetGenGetFacetMarkers::usage = "\!\(\*RowBox[{\"TetGenGetFacetMarkers\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the facet markers for a TetGen expression."
TetGenLink`TetGenGetFacets::usage = "\!\(\*RowBox[{\"TetGenGetFacets\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the facets for a TetGen expression."
TetGenLink`TetGenGetHoles::usage = "\!\(\*RowBox[{\"TetGenGetHoles\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the holes in a TetGen expression."
TetGenLink`TetGenGetNeighbors::usage = "\!\(\*RowBox[{\"TetGenGetNeighbors\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gets the neighbors in a TetGen expression."
TetGenLink`TetGenGetPointMarkers::usage = "\!\(\*RowBox[{\"TetGenGetPointMarkers\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the point markers in a TetGen expression."
TetGenLink`TetGenGetPoints::usage = "\!\(\*RowBox[{\"TetGenGetPoints\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the points in a TetGen expression."
TetGenLink`TetGenGetRegions::usage = "\!\(\*RowBox[{\"TetGenGetRegions\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns the regions in a TetGen expression."
TetGenLink`TetGenImport::usage = "\!\(\*RowBox[{\"TetGenImport\", \"[\", RowBox[{\"StyleBox[file, TI]StyleBox[., TI]StyleBox[ext, TI]StyleBox[\", TI], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) imports data from a file into a TetGen expression.\n\!\(\*RowBox[{\"TetGenImport\", \"[\", RowBox[{\"StyleBox[file, TI]StyleBox[\", TI], \",\", StyleBox[\"expr\", \"TI\"], \",\", \"StyleBox[format, TI]StyleBox[\", TI]}], \"]\"}]\) imports data in the specified format."
TetGenLink`TetGenSetFacetHoles::usage = "\!\(\*RowBox[{\"TetGenSetFacetHoles\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"holes\", \"TI\"]}], \"]\"}]\) sets the holes in the facets."
TetGenLink`TetGenSetFacetMarkers::usage = "\!\(\*RowBox[{\"TetGenSetFacetMarkers\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vertices\", \"TI\"]}], \"]\"}]\) sets the facet markers for a TetGen expression. "
TetGenLink`TetGenSetFacets::usage = "\!\(\*RowBox[{\"TetGenSetFacets\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"vertices\", \"TI\"]}], \"]\"}]\) sets the facets for a TetGen expression."
TetGenLink`TetGenSetHoles::usage = "\!\(\*RowBox[{\"TetGenSetHoles\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"points\", \"TI\"]}], \"]\"}]\) sets the holes in a TetGen expression."
TetGenLink`TetGenSetMessages::usage = "\!\(\*RowBox[{\"TetGenSetMessages\", \"[\", RowBox[{\"True\", \"|\", \"False\"}], \"]\"}]\) enables or disables the issuing of messages from TetGen."
TetGenLink`TetGenSetPointMarkers::usage = "\!\(\*RowBox[{\"TetGenSetPointMarkers\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"markers\", \"TI\"]}], \"]\"}]\) sets the point markers in a TetGen expression."
TetGenLink`TetGenSetPoints::usage = "\!\(\*RowBox[{\"TetGenSetPoints\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"points\", \"TI\"]}], \"]\"}]\) sets the points in a TetGen expression."
TetGenLink`TetGenSetRegions::usage = "\!\(\*RowBox[{\"TetGenSetRegions\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pts\", \"TI\"], \",\", StyleBox[\"index\", \"TI\"], \",\", StyleBox[\"attrs\", \"TI\"]}], \"]\"}]\) sets the regions in a TetGen expression."
TetGenLink`TetGenSetTetrahedraVolumes::usage = "\!\(\*RowBox[{\"TetGenSetTetrahedraVolumes\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"volumes\", \"TI\"]}], \"]\"}]\) constrains tetrahedra volumes for refinement."
TetGenLink`TetGenTetrahedralize::usage = "\!\(\*RowBox[{\"TetGenTetrahedralize\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"settings\", \"TI\"]}], \"]\"}]\) tetrahedralizes a TetGen expression using \!\(\*StyleBox[\"settings\", \"TI\"]\) and returns the result in a new TetGen expression."
TetGenLink`$TetGenInstallationDirectory::usage = "$TetGenInstallationDirectory gives the top-level directory in which your TetGen installation resides."
TetGenLink`$TetGenLibrary::usage = "$TetGenLibrary is the full path to the TetGen library loaded by \!\(\*StyleBox[\"TetGenLink\", FontSlant -> \"Italic\"]\)."
TetGenLink`$TetGenVersion::usage = "\!\(\*RowBox[{\"$TetGenVersion\", \" \"}]\) gives the version number of the TetGen library."
Tetrahedron::usage = "\!\(\*RowBox[{\"Tetrahedron\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"4\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents a filled tetrahedron with corners \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"3\", \"TR\"]]\), and \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"4\", \"TR\"]]\).\n\!\(\*RowBox[{\"Tetrahedron\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \",\", \"1\"}], \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \",\", \"2\"}], \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \",\", \"3\"}], \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"1\", \",\", \"4\"}], \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[RowBox[{\"2\", \",\", \"1\"}], \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a collection of tetrahedra."
TeXForm::usage = "\!\(\*RowBox[{\"TeXForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as a TeX version of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
TeXSave::usage = "\!\(\*RowBox[{\"TeXSave\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).tex\\\"\",ShowStringCharacters->True], \"]\"}]\) saves a TeX version of the current input notebook in the front end. \n\!\(\*RowBox[{\"TeXSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).tex\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"source\\\",\\\"TI\\\"]\\).nb\\\"\",ShowStringCharacters->True]}], \"]\"}]\) saves a TeX version of the notebook from the file \!\(\*RowBox[{StyleBox[\"source\", \"TI\"], \".\", \"nb\"}]\). \n\!\(\*RowBox[{\"TeXSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\).tex\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"notebook\", \"TI\"]}], \"]\"}]\) saves a TeX version of the notebook corresponding to the specified notebook object. "
Text3DBoxOptions::usage = "\!\(\*RowBox[{Text3DBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for Text3DBox objects."
TextAlignment::usage = "TextAlignment is an option for Cell, Style and related constructs which specifies how successive lines of text should be aligned. "
TextCases::usage = "\!\(\*RowBox[{\"TextCases\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives a list of all cases of \!\(\*StyleBox[\"form\", \"TI\"]\) that occur in \!\(\*StyleBox[\"text\", \"TI\"]\).\n\!\(\*RowBox[{\"TextCases\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"n\", \"TI\"]\) cases that occur."
TextCell::usage = "\!\(\*RowBox[{\"TextCell\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a text cell that can appear in a \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) notebook.\n\!\(\*RowBox[{\"TextCell\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"style\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a text cell with the specified style."
TextClipboardType::usage = "TextClipboardType is an option for cells that specifies how \!\(\*StyleBox[\"Edit\", \"MenuName\"]\)\!\(\*StyleBox[\" \[FilledRightTriangle] \", \"MenuNameDelimiter\"]\)\!\(\*StyleBox[\"Copy\", \"MenuName\"]\) treats a cell when converting it for the system's textual clipboard."
TextData::usage = "\!\(\*RowBox[{\"TextData\", \"[\", StyleBox[\"exprs\", \"TI\"], \"]\"}]\) is a low-level representation of the contents of a textual cell."
TextElement::usage = "\!\(\*RowBox[{\"TextElement\", \"[\", RowBox[{StyleBox[\"text\", \"TI\"], \",\", StyleBox[\"props\", \"TI\"]}], \"]\"}]\) represents an element of text with the specified properties.\n\!\(\*RowBox[{\"TextElement\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"elem\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"props\", \"TI\"]}], \"]\"}]\) represents text formed from a sequence of elements.\n\!\(\*RowBox[{\"TextElement\", \"[\", StyleBox[\"elems\", \"TI\"], \"]\"}]\) represents text where no properties are specified. "
TextGrid::usage = "\!\(\*RowBox[{\"TextGrid\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"22\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) is an object that formats \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"ij\", \"TI\"]]\) textually and arranged in a two-dimensional grid. "
TextJustification::usage = "TextJustification is an option for Cell and Inset which specifies how much lines of text can be stretched in order to make them be the same length. "
TextPacket::usage = "\!\(\*RowBox[{\"TextPacket\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) is a \!\(\*StyleBox[\"WSTP\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"WolframLink\", FontSlant -> \"Italic\"]]\) packet containing \!\(\*StyleBox[\"string\", \"TI\"]\), the text output from \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\"]\) as produced by functions such as Print."
TextPosition::usage = "\!\(\*RowBox[{\"TextPosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives a list of the starting and ending positions at which instances of \!\(\*StyleBox[\"form\", \"TI\"]\) occur in \!\(\*StyleBox[\"text\", \"TI\"]\).\n\!\(\*RowBox[{\"TextPosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the positions of the first \!\(\*StyleBox[\"n\", \"TI\"]\) instances that occur."
TextRecognize::usage = "\!\(\*RowBox[{\"TextRecognize\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) recognizes text in \!\(\*StyleBox[\"image\", \"TI\"]\) and returns it as a string."
TextSearchReport::usage = "\!\(\*RowBox[{\"TextSearchReport\", \"[\", RowBox[{StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives a structured report of files referenced by \!\(\*StyleBox[\"source\", \"TI\"]\) that contain text matching \!\(\*StyleBox[\"form\", \"TI\"]\)."
TextSearch::usage = "\!\(\*RowBox[{\"TextSearch\", \"[\", RowBox[{StyleBox[\"source\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) searches for files referenced by \!\(\*StyleBox[\"source\", \"TI\"]\) that contain text matching \!\(\*StyleBox[\"form\", \"TI\"]\)."
TextSentences::usage = "\!\(\*RowBox[{\"TextSentences\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the runs of characters identified as sentences in \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"TextSentences\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"n\", \"TI\"]\) sentences in \!\(\*StyleBox[\"string\", \"TI\"]\)."
TextString::usage = "\!\(\*RowBox[{\"TextString\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives a human-readable string representation of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
TextStructure::usage = "\!\(\*RowBox[{\"TextStructure\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) generates a nested collection of TextElement objects representing the grammatical structure of natural language text.\n\!\(\*RowBox[{\"TextStructure\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"text\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) generates a representation of the type specified by \!\(\*StyleBox[\"form\", \"TI\"]\) of the grammatical structure of text."
TextStyle::usage = "TextStyle is an option for graphics functions and for Text which specifies the default style and font options with which text should be rendered. "
TextureCoordinateFunction::usage = "TextureCoordinateFunction is an option to Plot3D and similar functions that specifies a function that computes texture coordinates."
TextureCoordinateScaling::usage = "TextureCoordinateScaling is an option to Plot3D and similar functions that specifies whether arguments supplied to a texture coordinate function should be scaled to lie between 0 and 1."
Texture::usage = "\!\(\*RowBox[{\"Texture\", \"[\", StyleBox[\"obj\", \"TI\"], \"]\"}]\) is a graphics directive that specifies that \!\(\*StyleBox[\"obj\", \"TI\"]\) should be used as a texture on faces of polygons and other filled graphics objects. "
Text::usage = "\!\(\*RowBox[{\"Text\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays with \!\(\*StyleBox[\"expr\", \"TI\"]\) in plain text format. \n\!\(\*RowBox[{\"Text\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"coords\", \"TI\"]}], \"]\"}]\) is a graphics primitive that displays the textual form of \!\(\*StyleBox[\"expr\", \"TI\"]\) centered at the point specified by \!\(\*StyleBox[\"coords\", \"TI\"]\). "
TextWords::usage = "\!\(\*RowBox[{\"TextWords\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the runs of characters identified as words in \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"TextWords\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the first \!\(\*StyleBox[\"n\", \"TI\"]\) words in \!\(\*StyleBox[\"string\", \"TI\"]\)."
Therefore::usage = "\!\(\*RowBox[{\"Therefore\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Therefore]\", StyleBox[\"y\", \"TI\"]}]\)."
ThermodynamicData::usage = "\!\(\*RowBox[{\"ThermodynamicData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the value of the specific property for the substance \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\".\n\!\(\*RowBox[{\"ThermodynamicData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"\\\"Temperature\\\"\",ShowStringCharacters->True], \"\[Rule]\", SubscriptBox[StyleBox[\"quantity\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{StyleBox[\"\\\"Pressure\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"quantity\", \"TI\"]}]}], \"}\"}]}], \"]\"}]\) gives the value of the specific property for the substance \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" at the specified temperature and pressure."
ThermometerGauge::usage = "\!\(\*RowBox[{\"ThermometerGauge\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}]\) draws a thermometer showing \!\(\*StyleBox[\"value\", \"TI\"]\) in a range of 0 to 1.\n\!\(\*RowBox[{\"ThermometerGauge\", \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) draws a thermometer showing \!\(\*StyleBox[\"value\", \"TI\"]\) in a range of \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"ThermometerGauge\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) allows \!\(\*StyleBox[\"value\", \"TI\"]\) to be set interactively using the thermometer."
Thickness::usage = "\!\(\*RowBox[{\"Thickness\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) is a graphics directive which specifies that lines which follow are to be drawn with thickness \!\(\*StyleBox[\"r\", \"TI\"]\). The thickness \!\(\*StyleBox[\"r\", \"TI\"]\) is given as a fraction of the horizontal plot range. "
Thick::usage = "Thick is a graphics directive that specifies that lines which follow should be drawn thick."
Thinning::usage = "\!\(\*RowBox[{\"Thinning\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) finds the skeletons of foreground regions in \!\(\*StyleBox[\"image\", \"TI\"]\) by applying morphological thinning until convergence.\n\!\(\*RowBox[{\"Thinning\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) performs \!\(\*StyleBox[\"n\", \"TI\"]\) iterations of morphological thinning.\n\!\(\*RowBox[{\"Thinning\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) treats values above \!\(\*StyleBox[\"t\", \"TI\"]\) as foreground."
Thin::usage = "Thin is a graphics directive that specifies that lines which follow should be drawn thin."
ThisLink::usage = "ThisLink is used in patterns for external packages to distinguish between several instances of the same package."
ThompsonGroupTh::usage = "\!\(\*RowBox[{\"ThompsonGroupTh\", \"[\", \"]\"}]\) represents the sporadic simple Thompson group Th."
ThreadDepth::usage = "ThreadDepth is an option for Quantity that specifies the level to which a unit should be threaded across its magnitude."
Thread::usage = "\!\(\*RowBox[{\"Thread\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"args\", \"TI\"], \"]\"}], \"]\"}]\) \"threads\" \!\(\*StyleBox[\"f\", \"TI\"]\) over any lists that appear in \!\(\*StyleBox[\"args\", \"TI\"]\). \n\!\(\*RowBox[{\"Thread\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"args\", \"TI\"], \"]\"}], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) threads \!\(\*StyleBox[\"f\", \"TI\"]\) over any objects with head \!\(\*StyleBox[\"h\", \"TI\"]\) that appear in \!\(\*StyleBox[\"args\", \"TI\"]\). \n\!\(\*RowBox[{\"Thread\", \"[\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", StyleBox[\"args\", \"TI\"], \"]\"}], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) threads \!\(\*StyleBox[\"f\", \"TI\"]\) over objects with head \!\(\*StyleBox[\"h\", \"TI\"]\) that appear in the first \!\(\*StyleBox[\"n\", \"TI\"]\) \!\(\*StyleBox[\"args\", \"TI\"]\). "
ThreeJSymbol::usage = "\!\(\*RowBox[{\"ThreeJSymbol\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"j\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the values of the Wigner 3\[Hyphen]\!\(\*StyleBox[\"j\", \"TI\"]\) symbol. "
Threshold::usage = "\!\(\*RowBox[{\"Threshold\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) thresholds \!\(\*StyleBox[\"data\", \"TI\"]\) by replacing values close to zero by zero.\n\!\(\*RowBox[{\"Threshold\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"tspec\", \"TI\"]}], \"]\"}]\) thresholds \!\(\*StyleBox[\"data\", \"TI\"]\) using threshold specification \!\(\*StyleBox[\"tspec\", \"TI\"]\).\n\!\(\*RowBox[{\"Threshold\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) thresholds an image.\n\!\(\*RowBox[{\"Threshold\", \"[\", RowBox[{StyleBox[\"sound\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) thresholds a sound object."
Through::usage = "\!\(\*RowBox[{\"Through\", \"[\", RowBox[{RowBox[{StyleBox[\"p\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\) gives \!\(\*RowBox[{StyleBox[\"p\", \"TI\"], \"[\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]}], \"]\"}]\). \n\!\(\*RowBox[{\"Through\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) performs the transformation wherever \!\(\*StyleBox[\"h\", \"TI\"]\) occurs in the head of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Throw::usage = "\!\(\*RowBox[{\"Throw\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}]\) stops evaluation and returns \!\(\*StyleBox[\"value\", \"TI\"]\) as the value of the nearest enclosing Catch.\n\!\(\*RowBox[{\"Throw\", \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", StyleBox[\"tag\", \"TI\"]}], \"]\"}]\) is caught only by \!\(\*RowBox[{\"Catch\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\), where \!\(\*StyleBox[\"tag\", \"TI\"]\) matches \!\(\*StyleBox[\"form\", \"TI\"]\)."
ThueMorse::usage = "\!\(\*RowBox[{\"ThueMorse\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) term in the Thue\[Dash]Morse sequence."
Thumbnail::usage = "\!\(\*RowBox[{\"Thumbnail\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) gives a thumbnail version of an image.\n\!\(\*RowBox[{\"Thumbnail\", \"[\", StyleBox[\"file\", \"TI\"], \"]\"}]\) gives a thumbnail of an image stored in a file.\n\!\(\*RowBox[{\"Thumbnail\", \"[\", StyleBox[\"url\", \"TI\"], \"]\"}]\) gives a thumbnail of an image stored at a URL.\n\!\(\*RowBox[{\"Thumbnail\", \"[\", RowBox[{StyleBox[\"spec\", \"TI\"], \",\", StyleBox[\"size\", \"TI\"]}], \"]\"}]\) gives a thumbnail with the specified maximum pixel size."
Thursday::usage = "Thursday is a day of the week."
TicksStyle::usage = "TicksStyle is an option for graphics functions which specifies how ticks should be rendered."
Ticks::usage = "Ticks is an option for graphics functions that specifies tick marks for axes. "
TildeEqual::usage = "\!\(\*RowBox[{\"TildeEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[TildeEqual]\", StyleBox[\"y\", \"TI\"], \"\[TildeEqual]\", \"\[Ellipsis]\"}]\)."
TildeFullEqual::usage = "\!\(\*RowBox[{\"TildeFullEqual\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[TildeFullEqual]\", StyleBox[\"y\", \"TI\"], \"\[TildeFullEqual]\", \"\[Ellipsis]\"}]\)."
TildeTilde::usage = "\!\(\*RowBox[{\"TildeTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[TildeTilde]\", StyleBox[\"y\", \"TI\"], \"\[TildeTilde]\", \"\[Ellipsis]\"}]\)."
Tilde::usage = "\!\(\*RowBox[{\"Tilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Tilde]\", StyleBox[\"y\", \"TI\"], \"\[Tilde]\", \"\[Ellipsis]\"}]\)."
TimeConstrained::usage = "\!\(\*RowBox[{\"TimeConstrained\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), stopping after \!\(\*StyleBox[\"t\", \"TI\"]\) seconds. \n\!\(\*RowBox[{\"TimeConstrained\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"failexpr\", \"TI\"]}], \"]\"}]\) returns \!\(\*StyleBox[\"failexpr\", \"TI\"]\) if the time constraint is not met. "
TimeConstraint::usage = "TimeConstraint is an option for various algorithmic functions that specifies how long to spend trying a particular transformation or part of an algorithm. "
TimeDirection::usage = "TimeDirection is an option for Sunrise, Sunset, and related functions that specifies whether the next or last event should be returned."
TimeFormat::usage = "TimeFormat is an option that determines the time formatting that is used when formatting a TimeObject using TextString. "
TimelinePlot::usage = "\!\(\*RowBox[{\"TimelinePlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a timeline plot with dates \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\). \n\!\(\*RowBox[{\"TimelinePlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a timeline plot with events \!\(\*SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"event\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\). \n\!\(\*RowBox[{\"TimelinePlot\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a timeline plot from multiple event datasets \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
TimeObjectQ::usage = "\!\(\*RowBox[{\"TimeObjectQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a TimeObject with valid arguments, and False otherwise."
TimeObject::usage = "\!\(\*RowBox[{\"TimeObject\", \"[\", \"]\"}]\) represents the current time.\n\!\(\*RowBox[{\"TimeObject\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a time object of standard normalized form.\n\!\(\*RowBox[{\"TimeObject\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) gives the time component of the specified date representation."
TimesBy::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"*=\", StyleBox[\"c\", \"TI\"]}]\) multiplies \!\(\*StyleBox[\"x\", \"TI\"]\) by \!\(\*StyleBox[\"c\", \"TI\"]\) and returns the new value of \!\(\*StyleBox[\"x\", \"TI\"]\). "
TimeSeriesAggregate::usage = "\!\(\*RowBox[{\"TimeSeriesAggregate\", \"[\", RowBox[{StyleBox[\"tseries\", \"TI\"], \",\", StyleBox[\"dt\", \"TI\"]}], \"]\"}]\) computes the mean value of \!\(\*StyleBox[\"tseries\", \"TI\"]\) over non-overlapping windows of width \!\(\*StyleBox[\"dt\", \"TI\"]\).\n\!\(\*RowBox[{\"TimeSeriesAggregate\", \"[\", RowBox[{StyleBox[\"tseries\", \"TI\"], \",\", StyleBox[\"dt\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the values of \!\(\*StyleBox[\"tseries\", \"TI\"]\) in non-overlapping windows of width \!\(\*StyleBox[\"dt\", \"TI\"]\)."
TimeSeriesForecast::usage = "\!\(\*RowBox[{\"TimeSeriesForecast\", \"[\", RowBox[{StyleBox[\"tproc\", \"TI\"], \",\", StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-step-ahead forecast beyond \!\(\*StyleBox[\"data\", \"TI\"]\) according to the time series process \!\(\*StyleBox[\"tproc\", \"TI\"]\).\n\!\(\*RowBox[{\"TimeSeriesForecast\", \"[\", RowBox[{StyleBox[\"tsmod\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-step-ahead forecast for TimeSeriesModel \!\(\*StyleBox[\"tsmod\", \"TI\"]\). "
TimeSeriesInsert::usage = "\!\(\*RowBox[{\"TimeSeriesInsert\", \"[\", RowBox[{StyleBox[\"tseries\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"}\"}]}], \"]\"}]\) inserts a value \!\(\*StyleBox[\"v\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\) in the time series \!\(\*StyleBox[\"tseries\", \"TI\"]\).\n\!\(\*RowBox[{\"TimeSeriesInsert\", \"[\", RowBox[{SubscriptBox[StyleBox[\"tseries\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"tseries\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) inserts the time-value pairs from \!\(\*SubscriptBox[StyleBox[\"tseries\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) into \!\(\*SubscriptBox[StyleBox[\"tseries\", \"TI\"], StyleBox[\"1\", \"TR\"]]\)."
TimeSeriesInvertibility::usage = "\!\(\*RowBox[{\"TimeSeriesInvertibility\", \"[\", StyleBox[\"tproc\", \"TI\"], \"]\"}]\) gives conditions for the time series process \!\(\*StyleBox[\"tproc\", \"TI\"]\) to be invertible. "
TimeSeriesMapThread::usage = "\!\(\*RowBox[{\"TimeSeriesMapThread\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"tseries\", \"TI\"]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"]\"}]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) for the time series \!\(\*StyleBox[\"tseries\", \"TI\"]\).\n\!\(\*RowBox[{\"TimeSeriesMapThread\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"tseries\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives \!\(\*RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{StyleBox[\"f\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) for the time series \!\(\*StyleBox[\"tseries\", \"TI\"]\)."
TimeSeriesMap::usage = "\!\(\*RowBox[{\"TimeSeriesMap\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"tseries\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the values in \!\(\*StyleBox[\"tseries\", \"TI\"]\)."
TimeSeriesModelFit::usage = "\!\(\*RowBox[{\"TimeSeriesModelFit\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) constructs a time series model for \!\(\*StyleBox[\"data\", \"TI\"]\) from an automatically selected model family.\n\!\(\*RowBox[{\"TimeSeriesModelFit\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"mspec\", \"TI\"]}], \"]\"}]\) constructs a time series model for \!\(\*StyleBox[\"data\", \"TI\"]\) from a model family specified by \!\(\*StyleBox[\"mspec\", \"TI\"]\)."
TimeSeriesModel::usage = "\!\(\*RowBox[{\"TimeSeriesModel\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents the symbolic time series model obtained from TimeSeriesModelFit."
TimeSeriesResample::usage = "\!\(\*RowBox[{\"TimeSeriesResample\", \"[\", StyleBox[\"tseries\", \"TI\"], \"]\"}]\) uniformly resamples \!\(\*StyleBox[\"tseries\", \"TI\"]\) according to its minimum time increment.\n\!\(\*RowBox[{\"TimeSeriesResample\", \"[\", RowBox[{StyleBox[\"tseries\", \"TI\"], \",\", StyleBox[\"rspec\", \"TI\"]}], \"]\"}]\) resamples \!\(\*StyleBox[\"tseries\", \"TI\"]\) according to \!\(\*StyleBox[\"rspec\", \"TI\"]\)."
TimeSeriesRescale::usage = "\!\(\*RowBox[{\"TimeSeriesRescale\", \"[\", RowBox[{StyleBox[\"tseries\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) rescales the times in time series \!\(\*StyleBox[\"tseries\", \"TI\"]\) to run from \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"TimeSeriesRescale\", \"[\", RowBox[{StyleBox[\"tseries\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"u\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) rescales times in units of \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"u\", \"TI\"]]\) including \"Month\", \"Quarter\", or \"Year\"."
TimeSeriesShift::usage = "\!\(\*RowBox[{\"TimeSeriesShift\", \"[\", RowBox[{StyleBox[\"tseries\", \"TI\"], \",\", StyleBox[\"shift\", \"TI\"]}], \"]\"}]\) shifts the time series \!\(\*StyleBox[\"tseries\", \"TI\"]\) to the left or right according to \!\(\*StyleBox[\"shift\", \"TI\"]\)."
TimeSeriesThread::usage = "\!\(\*RowBox[{\"TimeSeriesThread\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"tseries\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"tseries\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) combines the \!\(\*SubscriptBox[StyleBox[\"tseries\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) using the function \!\(\*StyleBox[\"f\", \"TI\"]\)."
TimeSeries::usage = "\!\(\*RowBox[{\"TimeSeries\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}], \"}\"}], \"]\"}]\) represents a time series specified by time-value pairs \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"i\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]}], \"}\"}]\).\n\!\(\*RowBox[{\"TimeSeries\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"tspec\", \"TI\"]}], \"]\"}]\) represents a time series with values \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) at times specified by \!\(\*StyleBox[\"tspec\", \"TI\"]\)."
TimeSeriesWindow::usage = "\!\(\*RowBox[{\"TimeSeriesWindow\", \"[\", RowBox[{StyleBox[\"tseries\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the elements of the time series \!\(\*StyleBox[\"tseries\", \"TI\"]\) that fall between \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]\)."
Times::usage = "\!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"*\", StyleBox[\"y\", \"TI\"], \"*\", StyleBox[\"z\", \"TI\"]}]\), \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Times]\", StyleBox[\"y\", \"TI\"], \"\[Times]\", StyleBox[\"z\", \"TI\"]}]\), or \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \" \", StyleBox[\"y\", \"TI\"], \" \", StyleBox[\"z\", \"TI\"]}]\) represents a product of terms. "
TimeUsed::usage = "\!\(\*RowBox[{\"TimeUsed\", \"[\", \"]\"}]\) gives the total number of seconds of CPU time used so far in the current \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\"]\) session. "
TimeValue::usage = "\!\(\*RowBox[{\"TimeValue\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"i\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) calculates the time value of a security \!\(\*StyleBox[\"s\", \"TI\"]\) at time \!\(\*StyleBox[\"t\", \"TI\"]\) for an interest specified by \!\(\*StyleBox[\"i\", \"TI\"]\)."
TimeWarpingCorrespondence::usage = "\!\(\*RowBox[{\"TimeWarpingCorrespondence\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the time warping (DTW) similarity path between sequences \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"TimeWarpingCorrespondence\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) uses a window of radius \!\(\*StyleBox[\"r\", \"TI\"]\) for local search."
TimeWarpingDistance::usage = "\!\(\*RowBox[{\"TimeWarpingDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the dynamic time warping (DTW) distance between sequences \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"TimeWarpingDistance\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) uses a window of radius \!\(\*StyleBox[\"r\", \"TI\"]\) for local search."
TimeZoneConvert::usage = "\!\(\*RowBox[{\"TimeZoneConvert\", \"[\", RowBox[{StyleBox[\"time\", \"TI\"], \",\", StyleBox[\"timezone\", \"TI\"]}], \"]\"}]\) converts the date or time object \!\(\*StyleBox[\"time\", \"TI\"]\) to the specified time zone \!\(\*StyleBox[\"timezone\", \"TI\"]\).\n\!\(\*RowBox[{\"TimeZoneConvert\", \"[\", StyleBox[\"time\", \"TI\"], \"]\"}]\) converts to the current $TimeZone value.\n\!\(\*RowBox[{\"TimeZoneConvert\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"time\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"time\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"timezone\", \"TI\"]}], \"]\"}]\) converts \!\(\*SubscriptBox[StyleBox[\"time\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"time\", \"TI\"], StyleBox[\"n\", \"TI\"]]\) to the specified \!\(\*StyleBox[\"timezone\", \"TI\"]\)."
TimeZoneOffset::usage = "\!\(\*RowBox[{\"TimeZoneOffset\", \"[\", StyleBox[\"tz\", \"TI\"], \"]\"}]\) gives the numeric offset between the time zone \!\(\*StyleBox[\"tz\", \"TI\"]\) and GMT on the current date.\n\!\(\*RowBox[{\"TimeZoneOffset\", \"[\", StyleBox[\"loc\", \"TI\"], \"]\"}]\) gives the numeric offset between the time zone for the location \!\(\*StyleBox[\"loc\", \"TI\"]\) and GMT.\n\!\(\*RowBox[{\"TimeZoneOffset\", \"[\", RowBox[{StyleBox[\"tz\", \"TI\"], \",\", StyleBox[\"base\", \"TI\"]}], \"]\"}]\) gives the numeric offset between \!\(\*StyleBox[\"tz\", \"TI\"]\) and the specified \!\(\*StyleBox[\"base\", \"TI\"]\) time zone.\n\!\(\*RowBox[{\"TimeZoneOffset\", \"[\", RowBox[{StyleBox[\"tz\", \"TI\"], \",\", StyleBox[\"base\", \"TI\"], \",\", StyleBox[\"date\", \"TI\"]}], \"]\"}]\) gives the numeric offset between \!\(\*StyleBox[\"tz\", \"TI\"]\) and \!\(\*StyleBox[\"base\", \"TI\"]\) on the specified \!\(\*StyleBox[\"date\", \"TI\"]\)."
TimeZone::usage = "TimeZone is an option for DateObject, DateString, and related functions that specifies the time zone to use for dates and times. "
Timing::usage = "\!\(\*RowBox[{\"Timing\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), and returns a list of the time in seconds used, together with the result obtained. "
Tiny::usage = "Tiny is a style or option setting that specifies that objects should be tiny."
TitsGroupT::usage = "\!\(\*RowBox[{\"TitsGroupT\", \"[\", \"]\"}]\) represents the simple Tits group T."
ToBoxes::usage = "\!\(\*RowBox[{ToBoxes, \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) generates boxes corresponding to the printed form of \!\(\*StyleBox[\"expr\", \"TI\"]\) in StandardForm. \n\!\(\*RowBox[{ToBoxes, \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the boxes corresponding to output in the specified form. "
ToCharacterCode::usage = "\!\(\*RowBox[{\"ToCharacterCode\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of the integer codes corresponding to the characters in a string. \n\!\(\*RowBox[{\"ToCharacterCode\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"encoding\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives integer codes according to the specified encoding. "
ToColor::usage = "\!\(\*RowBox[{\"ToColor\", \"[\", RowBox[{StyleBox[\"color\", \"TI\"], \",\", \" \", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) converts \!\(\*StyleBox[\"color\", \"TI\"]\) to \!\(\*StyleBox[\"form\", \"TI\"]\) if \!\(\*StyleBox[\"form\", \"TI\"]\) is GrayLevel, RGBColor or CMYKColor. Otherwise \!\(\*RowBox[{StyleBox[\"form\", \"TI\"], \"[\", StyleBox[\"color\", \"TI\"], \"]\"}]\) is evaluated and the result is expected to be a valid color directive."
ToContinuousTimeModel::usage = "\!\(\*RowBox[{\"ToContinuousTimeModel\", \"[\", StyleBox[\"lsys\", \"TI\"], \"]\"}]\) gives the continuous-time approximation of the discrete-time systems models \!\(\*StyleBox[\"lsys\", \"TI\"]\).\n\!\(\*RowBox[{\"ToContinuousTimeModel\", \"[\", RowBox[{StyleBox[\"tfm\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) specifies the transform variable \!\(\*StyleBox[\"s\", \"TI\"]\)."
ToDate::usage = "\!\(\*RowBox[{\"ToDate\", \"[\", StyleBox[\"time\", \"TI\"], \"]\"}]\) converts an absolute time in seconds since the beginning of January 1, 1900 to a date of the form \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}]\). "
Today::usage = "Today gives a DateObject representing the current day."
ToDiscreteTimeModel::usage = "\!\(\*RowBox[{\"ToDiscreteTimeModel\", \"[\", RowBox[{StyleBox[\"lsys\", \"TI\"], \",\", StyleBox[\"\[Tau]\", \"TR\"]}], \"]\"}]\) gives the discrete-time approximation, with sampling period \!\(\*StyleBox[\"\[Tau]\", \"TR\"]\), of the continuous-time systems models \!\(\*StyleBox[\"lsys\", \"TI\"]\).\n\!\(\*RowBox[{\"ToDiscreteTimeModel\", \"[\", RowBox[{StyleBox[\"tfm\", \"TI\"], \",\", StyleBox[\"\[Tau]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) specifies the transform variable \!\(\*StyleBox[\"z\", \"TI\"]\)."
ToEntity::usage = "\!\(\*RowBox[{\"ToEntity\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns an entity object corresponding to the given expression.\n\!\(\*RowBox[{\"ToEntity\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"type\", \"TI\"]}], \"]\"}]\) returns an entity object of the specified \!\(\*StyleBox[\"type\", \"TI\"]\) corresponding to \!\(\*StyleBox[\"expr\", \"TI\"]\)."
ToeplitzMatrix::usage = "\!\(\*RowBox[{\"ToeplitzMatrix\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)\[Times]\!\(\*StyleBox[\"n\", \"TI\"]\) Toeplitz matrix with first row and first column being successive integers.\n\!\(\*RowBox[{\"ToeplitzMatrix\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the Toeplitz matrix whose first column consists of elements \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"ToeplitzMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"m\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \"\[Ellipsis]\", \",\", \" \", SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the Toeplitz matrix with elements \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) down the first column, and \!\(\*SubscriptBox[StyleBox[\"r\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) across the first row."
ToExpression::usage = "\!\(\*RowBox[{\"ToExpression\", \"[\", StyleBox[\"input\", \"TI\"], \"]\"}]\) gives the expression obtained by interpreting strings or boxes as \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) input. \n\!\(\*RowBox[{\"ToExpression\", \"[\", RowBox[{StyleBox[\"input\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) uses interpretation rules corresponding to the specified form. \n\!\(\*RowBox[{\"ToExpression\", \"[\", RowBox[{StyleBox[\"input\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) wraps the head \!\(\*StyleBox[\"h\", \"TI\"]\) around the expression produced before evaluating it. "
ToFileName::usage = "\!\(\*RowBox[{\"ToFileName\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"directory\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) assembles a full file name from a directory name and a file name. \n\!\(\*RowBox[{\"ToFileName\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"name\", \"TI\"]}], \"]\"}]\) assembles a full file name from a hierarchy of directory names. \n\!\(\*RowBox[{\"ToFileName\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dir\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) assembles a single directory name from a hierarchy of directory names. "
Together::usage = "\!\(\*RowBox[{\"Together\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) puts terms in a sum over a common denominator, and cancels factors in the result. "
TogglerBar::usage = "\!\(\*RowBox[{\"TogglerBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a toggler bar with setting \!\(\*StyleBox[\"x\", \"TI\"]\) and with toggler buttons for values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to include in the list \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"TogglerBar\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the values in the list \!\(\*StyleBox[\"x\", \"TI\"]\) being reset every time a toggler button is clicked.\n\!\(\*RowBox[{\"TogglerBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a toggler bar in which the toggler button associated with value \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) has label \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
TogglerBoxOptions::usage = "\!\(\*RowBox[{TogglerBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for TogglerBox objects."
Toggler::usage = "\!\(\*RowBox[{\"Toggler\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a toggler button with setting \!\(\*StyleBox[\"x\", \"TI\"]\), that toggles between True and False. \n\!\(\*RowBox[{\"Toggler\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \"]\"}]\) takes the setting to be the dynamically updated current value of \!\(\*StyleBox[\"x\", \"TI\"]\), with the value of \!\(\*StyleBox[\"x\", \"TI\"]\) being toggled if the button is clicked. \n\!\(\*RowBox[{\"Toggler\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents a toggler button that cycles through any sequence of values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Toggler\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"pict\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"pict\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) cycles through values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) displaying them as \!\(\*SubscriptBox[StyleBox[\"pict\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Toggler\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"vlist\", \"TI\"], \",\", StyleBox[\"dpict\", \"TI\"]}], \"]\"}]\) displays as \!\(\*StyleBox[\"dpict\", \"TI\"]\) if \!\(\*StyleBox[\"x\", \"TI\"]\) is none of the \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
ToInvertibleTimeSeries::usage = "\!\(\*RowBox[{\"ToInvertibleTimeSeries\", \"[\", StyleBox[\"tproc\", \"TI\"], \"]\"}]\) returns an invertible version of a time series process \!\(\*StyleBox[\"tproc\", \"TI\"]\)."
TokenWords::usage = "TokenWords is an option for Read and related functions which gives a list of token words to be used to delimit words. "
Tolerance::usage = "Tolerance is an option for various numerical options which specifies the tolerance that should be allowed in computing results."
ToLowerCase::usage = "\!\(\*RowBox[{\"ToLowerCase\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) yields a string in which all letters have been converted to lowercase. "
Tomorrow::usage = "Tomorrow gives a DateObject representing the following day."
ToNumberField::usage = "\!\(\*RowBox[{\"ToNumberField\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) expresses the algebraic number \!\(\*StyleBox[\"a\", \"TI\"]\) in the number field generated by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\). \n\!\(\*RowBox[{\"ToNumberField\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) expresses the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the field generated by \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\).\n\!\(\*RowBox[{\"ToNumberField\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) expresses the \!\(\*SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in a common extension field generated by a single algebraic number."
TooBig::usage = "TooBig is an internal symbol."
TooltipBoxOptions::usage = "\!\(\*RowBox[{TooltipBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for TooltipBox objects."
TooltipDelay::usage = "TooltipDelay is an option for objects such as Tooltip that specifies how long to delay after the mouse is over the object before displaying the tooltip."
TooltipStyle::usage = "TooltipStyle is an option for tooltips that specifies the style to use in displaying their elements. "
Tooltip::usage = "\!\(\*RowBox[{\"Tooltip\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"label\", \"TI\"]}], \"]\"}]\) displays \!\(\*StyleBox[\"label\", \"TI\"]\) as a tooltip while the mouse pointer is in the area where \!\(\*StyleBox[\"expr\", \"TI\"]\) is displayed. "
TopHatTransform::usage = "\!\(\*RowBox[{\"TopHatTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"ker\", \"TI\"]}], \"]\"}]\) gives the morphological top-hat transform of \!\(\*StyleBox[\"image\", \"TI\"]\) with respect to structuring element \!\(\*StyleBox[\"ker\", \"TI\"]\).\n\!\(\*RowBox[{\"TopHatTransform\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the top-hat transform with respect to a range-\!\(\*StyleBox[\"r\", \"TI\"]\) square.\n\!\(\*RowBox[{\"TopHatTransform\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies top-hat transform to an array of data."
ToPolarCoordinates::usage = "\!\(\*RowBox[{\"ToPolarCoordinates\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"}\"}]\) polar coordinates corresponding to the Cartesian coordinates \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"ToPolarCoordinates\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives the hyperspherical coordinates corresponding to the Cartesian coordinates \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]\)."
TopologicalSort::usage = "\!\(\*RowBox[{\"TopologicalSort\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a list of vertices of \!\(\*StyleBox[\"g\", \"TI\"]\) in topologically sorted order for a directed acyclic graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"TopologicalSort\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Top::usage = "Top is a symbol that represents the top for purposes of alignment and positioning. "
ToRadicals::usage = "\!\(\*RowBox[{\"ToRadicals\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) attempts to express all Root objects in \!\(\*StyleBox[\"expr\", \"TI\"]\) in terms of radicals. "
ToRules::usage = "\!\(\*RowBox[{\"ToRules\", \"[\", StyleBox[\"eqns\", \"TI\"], \"]\"}]\) takes logical combinations of equations, in the form generated by Roots and Reduce, and converts them to lists of rules, of the form produced by Solve. "
ToSphericalCoordinates::usage = "\!\(\*RowBox[{\"ToSphericalCoordinates\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"}\"}]\) spherical coordinates corresponding to the Cartesian coordinates \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"}\"}]\)."
ToString::usage = "\!\(\*RowBox[{\"ToString\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives a string corresponding to the printed form of \!\(\*StyleBox[\"expr\", \"TI\"]\) in OutputForm. \n\!\(\*RowBox[{\"ToString\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) gives the string corresponding to output in the specified form. "
Total::usage = "\!\(\*RowBox[{\"Total\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the total of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Total\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) totals all elements down to level \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"Total\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", StyleBox[\"n\", \"TI\"], \"}\"}]}], \"]\"}]\) totals elements at level \!\(\*StyleBox[\"n\", \"TI\"]\). \n\!\(\*RowBox[{\"Total\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) totals elements at levels \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) through \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]]\). "
TotalVariationFilter::usage = "\!\(\*RowBox[{\"TotalVariationFilter\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) iteratively reduces noise while preserving edges in \!\(\*StyleBox[\"image\", \"TI\"]\).\n\!\(\*RowBox[{\"TotalVariationFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"param\", \"TI\"]}], \"]\"}]\) assumes a regularization parameter value \!\(\*StyleBox[\"param\", \"TI\"]\)."
TotalWidth::usage = "TotalWidth is an option which can be set for output streams to specify the maximum total number of characters of text that should be printed for each output expression. Short forms of expressions are given if the number of characters needed to print the whole expression is too large. "
TouchPosition::usage = "\!\(\*RowBox[{\"TouchPosition\", \"[\", \"]\"}]\) gives the list of current positions being touched in the notebook front end.\n\!\(\*RowBox[{\"TouchPosition\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"coords\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the touch positions with respect to the specified coordinate system.\n\!\(\*RowBox[{\"TouchPosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"coords\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives the position of the \!\(\*StyleBox[\"n\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) position being touched in an object in the specified coordinate system.\n\!\(\*RowBox[{\"TouchPosition\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"coords\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"def\", \"TI\"]}], \"]\"}]\) returns \!\(\*StyleBox[\"def\", \"TI\"]\) if there are not \!\(\*StyleBox[\"n\", \"TI\"]\) positions being touched."
TouchscreenAutoZoom::usage = "TouchscreenAutoZoom is an option for Manipulate and Graphics3D that determines whether the interface zooms to full-screen when it is activated by touching it on supported touch screen platforms."
TouchscreenControlPlacement::usage = "TouchscreenControlPlacement is an option for Manipulate that determines the placement of the slide-out control panel on supported touchscreen platforms."
ToUpperCase::usage = "\!\(\*RowBox[{\"ToUpperCase\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) yields a string in which all letters have been converted to uppercase. "
TraceAbove::usage = "TraceAbove is an option for Trace and related functions which specifies whether to include evaluation chains which contain the evaluation chain containing the pattern \!\(\*StyleBox[\"form\", \"TI\"]\) sought. "
TraceAction::usage = "TraceAction is an option for TracePrint and TraceDialog that specifies the function to be applied to each expression they trace."
TraceBackward::usage = "TraceBackward is an option for Trace and related functions which specifies whether to include preceding expressions on the evaluation chain that contains the pattern \!\(\*StyleBox[\"form\", \"TI\"]\) sought. "
TraceDepth::usage = "TraceDepth is an option for Trace and related functions which specifies the maximum nesting of evaluation chains that are to be included. "
TraceDialog::usage = "\!\(\*RowBox[{\"TraceDialog\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) initiates a dialog for every expression used in the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"TraceDialog\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) initiates a dialog only for expressions which match \!\(\*StyleBox[\"form\", \"TI\"]\). \n\!\(\*RowBox[{\"TraceDialog\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) initiates dialogs only for expressions whose evaluations use transformation rules associated with the symbol \!\(\*StyleBox[\"s\", \"TI\"]\). "
TraceForward::usage = "TraceForward is an option for Trace and related functions which specifies whether to include later expressions on the evaluation chain that contains the pattern \!\(\*StyleBox[\"form\", \"TI\"]\) sought. "
TraceInternal::usage = "TraceInternal is an option for Trace and related functions which, if True or False, specifies whether to trace evaluations of expressions generated internally by \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\). The intermediate Automatic setting traces a selected set of internal evaluations including Messages and sets or unsets of visible symbols."
TraceLevel::usage = "\!\(\*RowBox[{\"TraceLevel\", \"[\", \"]\"}]\) returns the level currently being traced when it appears within Trace and related functions."
TraceOff::usage = "TraceOff is an option for Trace and related functions which specifies forms inside which tracing should be switched off. "
TraceOn::usage = "TraceOn is an option for Trace and related functions which specifies when tracing should be switched on. "
TraceOriginal::usage = "TraceOriginal is an option for Trace and related functions which specifies whether to test the form of each expression before its head and arguments are evaluated. "
TracePrint::usage = "\!\(\*RowBox[{\"TracePrint\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints all expressions used in the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"TracePrint\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) includes only those expressions which match \!\(\*StyleBox[\"form\", \"TI\"]\). \n\!\(\*RowBox[{\"TracePrint\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) includes all evaluations which use transformation rules associated with the symbol \!\(\*StyleBox[\"s\", \"TI\"]\). "
TraceScan::usage = "\!\(\*RowBox[{\"TraceScan\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to all expressions used in the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"TraceScan\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) includes only those expressions which match \!\(\*StyleBox[\"form\", \"TI\"]\). \n\!\(\*RowBox[{\"TraceScan\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) includes all evaluations which use transformation rules associated with the symbol \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"TraceScan\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"], \",\", StyleBox[\"fp\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) before evaluation and \!\(\*StyleBox[\"fp\", \"TI\"]\) after evaluation to expressions used in the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Trace::usage = "\!\(\*RowBox[{\"Trace\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) generates a list of all expressions used in the evaluation of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"Trace\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"form\", \"TI\"]}], \"]\"}]\) includes only those expressions which match \!\(\*StyleBox[\"form\", \"TI\"]\). \n\!\(\*RowBox[{\"Trace\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) includes all evaluations which use transformation rules associated with the symbol \!\(\*StyleBox[\"s\", \"TI\"]\). "
TrackedSymbols::usage = "TrackedSymbols is an option to Refresh, Manipulate, and related functions that specifies which symbols should trigger updates when their values are changed."
TrackingFunction::usage = "TrackingFunction is an option for Manipulate controls that specifies functions to use during interactive changing or editing."
TracyWidomDistribution::usage = "\!\(\*RowBox[{\"TracyWidomDistribution\", \"[\", StyleBox[\"\[Beta]\", \"TR\"], \"]\"}]\) represents a Tracy\[Dash]Widom distribution with Dyson index \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\)."
TradingChart::usage = "\!\(\*RowBox[{\"TradingChart\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"open\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"high\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"low\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"close\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"volume\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) makes a chart showing prices and volume for each date. \n\!\(\*RowBox[{\"TradingChart\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"name\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"daterange\", \"TI\"]}], StyleBox[\"}\", \"TI\"]}], \"]\"}]\) makes a financial chart for the financial entity \"\!\(\*\nStyleBox[\"name\", \"TI\"]\)\" over the \!\(\*StyleBox[\"daterange\", \"TI\"]\). \n\!\(\*RowBox[{\"TradingChart\", \"[\", RowBox[{RowBox[{\"{\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"ind\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"ind\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) makes a financial chart with indicators \!\(\*SubscriptBox[StyleBox[\"ind\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"ind\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]. "
TraditionalForm::usage = "\!\(\*RowBox[{\"TraditionalForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) prints as an approximation to the traditional mathematical notation for \!\(\*StyleBox[\"expr\", \"TI\"]\). "
TraditionalFunctionNotation::usage = "TraditionalFunctionNotation is an option for selections that specifies whether input of the form \!\(\*RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\) is interpreted by the kernel as a function or as a product."
TransferFunctionCancel::usage = "\!\(\*RowBox[{\"TransferFunctionCancel\", \"[\", StyleBox[\"tfm\", \"TI\"], \"]\"}]\) cancels common poles and zeros in the TransferFunctionModel \!\(\*StyleBox[\"tfm\", \"TI\"]\).\n\!\(\*RowBox[{\"TransferFunctionCancel\", \"[\", RowBox[{StyleBox[\"tfm\", \"TI\"], \",\", StyleBox[\"crit\", \"TI\"]}], \"]\"}]\) cancels only common pole-zero pairs \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for which \!\(\*RowBox[{StyleBox[\"crit\", \"TI\"], \"[\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"]\"}]\) is True."
TransferFunctionExpand::usage = "\!\(\*RowBox[{\"TransferFunctionExpand\", \"[\", StyleBox[\"tfm\", \"TI\"], \"]\"}]\) expands polynomial terms in the numerators and denominators of the TransferFunctionModel \!\(\*StyleBox[\"tfm\", \"TI\"]\)."
TransferFunctionFactor::usage = "\!\(\*RowBox[{\"TransferFunctionFactor\", \"[\", StyleBox[\"tfm\", \"TI\"], \"]\"}]\) factors the polynomial terms in the numerators and denominators of the TransferFunctionModel \!\(\*StyleBox[\"tfm\", \"TI\"]\)."
TransferFunctionModel::usage = "\!\(\*RowBox[{\"TransferFunctionModel\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) represents the model of the transfer-function matrix \!\(\*StyleBox[\"m\", \"TI\"]\) with complex variable \!\(\*StyleBox[\"s\", \"TI\"]\).\n\!\(\*RowBox[{\"TransferFunctionModel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"num\", \"TI\"], \",\", StyleBox[\"den\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) specifies the numerator \!\(\*StyleBox[\"num\", \"TI\"]\) and denominator \!\(\*StyleBox[\"den\", \"TI\"]\) of a transfer-function model.\n\!\(\*RowBox[{\"TransferFunctionModel\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) specifies the zeros \!\(\*StyleBox[\"z\", \"TI\"]\), poles \!\(\*StyleBox[\"p\", \"TI\"]\), and gain \!\(\*StyleBox[\"g\", \"TI\"]\) of a transfer-function model.\n\!\(\*RowBox[{\"TransferFunctionModel\", \"[\", StyleBox[\"sys\", \"TI\"], \"]\"}]\) gives the transfer-function model of the systems model \!\(\*StyleBox[\"sys\", \"TI\"]\)."
TransferFunctionPoles::usage = "\!\(\*RowBox[{\"TransferFunctionPoles\", \"[\", StyleBox[\"tfm\", \"TI\"], \"]\"}]\) gives a matrix of roots of the denominators in the TransferFunctionModel \!\(\*StyleBox[\"tfm\", \"TI\"]\).\n\!\(\*RowBox[{\"TransferFunctionPoles\", \"[\", RowBox[{StyleBox[\"tfm\", \"TI\"], \",\", StyleBox[\"reg\", \"TI\"]}], \"]\"}]\) only gives the roots inside the region \!\(\*StyleBox[\"reg\", \"TI\"]\) on the complex plane."
TransferFunctionTransform::usage = "\!\(\*RowBox[{\"TransferFunctionTransform\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"tf\", \"TI\"]}], \"]\"}]\) transforms the TransferFunctionModel object \!\(\*StyleBox[\"tf\", \"TI\"]\) using the transformation function \!\(\*StyleBox[\"f\", \"TI\"]\)."
TransferFunctionZeros::usage = "\!\(\*RowBox[{\"TransferFunctionZeros\", \"[\", StyleBox[\"tfm\", \"TI\"], \"]\"}]\) gives a matrix of roots of the numerators in the TransferFunctionModel \!\(\*StyleBox[\"tfm\", \"TI\"]\).\n\!\(\*RowBox[{\"TransferFunctionZeros\", \"[\", RowBox[{StyleBox[\"tfm\", \"TI\"], \",\", StyleBox[\"reg\", \"TI\"]}], \"]\"}]\) only gives the roots inside the region \!\(\*StyleBox[\"reg\", \"TI\"]\) on the complex plane."
TransformationClass::usage = "TransformationClass is an option that specifies the class of geometric transformations to be used."
TransformationFunctions::usage = "TransformationFunctions is an option for Simplify and FullSimplify which gives the list of functions to apply to try to transform parts of an expression. "
TransformationFunction::usage = "\!\(\*RowBox[{\"TransformationFunction\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) represents a transformation function that applies geometric and other transformations."
TransformationMatrix::usage = "\!\(\*RowBox[{\"TransformationMatrix\", \"[\", StyleBox[\"tfun\", \"TI\"], \"]\"}]\) gives the homogeneous matrix associated with a TransformationFunction object."
TransformedDistribution::usage = "\!\(\*RowBox[{\"TransformedDistribution\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) represents the transformed distribution of \!\(\*StyleBox[\"expr\", \"TI\"]\) where the random variable \!\(\*StyleBox[\"x\", \"TI\"]\) follows the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"TransformedDistribution\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Distributed]\", StyleBox[\"dist\", \"TI\"]}]}], \"]\"}]\) represents the transformed distribution of \!\(\*StyleBox[\"expr\", \"TI\"]\) where \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\) follows the multivariate distribution \!\(\*StyleBox[\"dist\", \"TI\"]\).\n\!\(\*RowBox[{\"TransformedDistribution\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \" \", \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}]}], \"]\"}]\) represents a transformed distribution where \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] are independent and follow the distributions \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dist\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
TransformedField::usage = "\!\(\*RowBox[{\"TransformedField\", \"[\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}]}]}], \"]\"}]\) uses the coordinate transformation \!\(\*StyleBox[\"t\", \"TI\"]\) to transform the scalar, vector, or tensor field \!\(\*StyleBox[\"f\", \"TI\"]\) from coordinates \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
TransformedProcess::usage = "\!\(\*RowBox[{\"TransformedProcess\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"\[Distributed]\", StyleBox[\"proc\", \"TI\"]}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents the transformed process of \!\(\*StyleBox[\"expr\", \"TI\"]\) where the variable \!\(\*StyleBox[\"x\", \"TI\"]\) follows the random process \!\(\*StyleBox[\"proc\", \"TI\"]\) and \!\(\*StyleBox[\"t\", \"TI\"]\) denotes the time.\n\!\(\*RowBox[{\"TransformedProcess\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"proc\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Distributed]\", SubscriptBox[StyleBox[\"proc\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents a transformed process where \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] are independent and follow the processes \!\(\*SubscriptBox[StyleBox[\"proc\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"proc\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
TransformedRegion::usage = "\!\(\*RowBox[{\"TransformedRegion\", \"[\", RowBox[{StyleBox[\"reg\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) represents the transformed region \!\(\*RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"f\", \"TI\"], \"(\", StyleBox[\"p\", \"TI\"], \")\"}], \"|\", RowBox[{StyleBox[\"p\", \"TI\"], \"\[Element]\", StyleBox[\"reg\", FontSlant -> \"Italic\"]}]}], \"}\"}]\), where \!\(\*StyleBox[\"reg\", \"TI\"]\) is a region and \!\(\*StyleBox[\"f\", \"TI\"]\) is a function."
TransformPixelCoordinates::usage = "\!\(\*RowBox[{\"Image`TransformPixelCoordinates\", \"[\", RowBox[{StyleBox[\"coord\", \"TI\"], \",\", StyleBox[\"dims\", \"TI\"], \",\", RowBox[{StyleBox[\"s\", \"TI\"], \"\[Rule]\", StyleBox[\"t\", \"TI\"]}]}], \"]\"}]\) applies the transformation between the pixel coordinate systems \!\(\*StyleBox[\"s\", \"TI\"]\) and \!\(\*StyleBox[\"t\", \"TI\"]\) to the coordinates \!\(\*StyleBox[\"coord\", \"TI\"]\), assuming that the image dimensions are \!\(\*StyleBox[\"dims\", \"TI\"]\)."
TransitionDirection::usage = "TransitionDirection is an option for PaneSelector that specifies the direction in which a transition moves."
TransitionDuration::usage = "TransitionDuration is an option for PaneSelector that specifies the duration in seconds that a transition effect should last."
TransitionEffect::usage = "TransitionEffect is an option for PaneSelector that specifies the visual effect used when transitioning between states."
TransitiveClosureGraph::usage = "\!\(\*RowBox[{\"TransitiveClosureGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the transitive closure of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"TransitiveClosureGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
TransitiveReductionGraph::usage = "\!\(\*RowBox[{\"TransitiveReductionGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a transitive reduction of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"TransitiveReductionGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
Translate::usage = "\!\(\*RowBox[{\"Translate\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents graphics primitives \!\(\*StyleBox[\"g\", \"TI\"]\) translated by the vector \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\). \n\!\(\*RowBox[{\"Translate\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], StyleBox[\"}\", \"TR\"]}], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents multiple copies of \!\(\*StyleBox[\"g\", \"TI\"]\) translated by a collection of vectors."
TranslationOptions::usage = "\!\(\*RowBox[{\"TranslationOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for Style and Cell that controls how code translations are displayed."
TranslationTransform::usage = "\!\(\*RowBox[{\"TranslationTransform\", \"[\", StyleBox[\"v\", \"TI\"], \"]\"}]\) gives a TransformationFunction that represents translation of points by a vector \!\(\*StyleBox[\"v\", \"TI\"]\)."
Transliterate::usage = "\!\(\*RowBox[{\"Transliterate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) attempts to transliterate \!\(\*StyleBox[\"string\", \"TI\"]\) into plain ASCII.\n\!\(\*RowBox[{\"Transliterate\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"script\", \"TI\"]}], \"]\"}]\) attempts to transliterate \!\(\*StyleBox[\"string\", \"TI\"]\) into the specified writing script \!\(\*StyleBox[\"script\", \"TI\"]\).\n\!\(\*RowBox[{\"Transliterate\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{SubscriptBox[StyleBox[\"script\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"script\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"]\"}]\) attempts to transliterate \!\(\*StyleBox[\"string\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"script\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"script\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
Transparent::usage = "Transparent represents perfect transparency in graphics or style specifications. "
Transpose::usage = "\!\(\*RowBox[{\"Transpose\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) transposes the first two levels in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Transpose\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) transposes \!\(\*StyleBox[\"list\", \"TI\"]\) so that the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) level in \!\(\*StyleBox[\"list\", \"TI\"]\) is the \!\(\*SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"k\", \"TI\"]]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) level in the result. "
TravelDirectionsData::usage = "\!\(\*RowBox[{\"TravelDirectionsData\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}]\) represents travel directions generated by TravelDirections."
TravelDirections::usage = "\!\(\*RowBox[{\"TravelDirections\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates directions for travel from \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"TravelDirections\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"prop\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the property \!\(\*StyleBox[\"prop\", \"TI\"]\) of travel directions."
TravelDistance::usage = "\!\(\*RowBox[{\"TravelDistance\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the estimated distance for travel from \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
TravelMethod::usage = "TravelMethod is an option for TravelDirections and related functions that specifies the mode of transportation to assume."
TravelTime::usage = "\!\(\*RowBox[{\"TravelTime\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives the estimated time to travel from \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"loc\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis]."
TreeForm::usage = "\!\(\*RowBox[{\"TreeForm\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays \!\(\*StyleBox[\"expr\", \"TI\"]\) as a tree with different levels at different depths. \n\!\(\*RowBox[{\"TreeForm\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) displays \!\(\*StyleBox[\"expr\", \"TI\"]\) as a tree only down to level \!\(\*StyleBox[\"n\", \"TI\"]\)."
TreeGraphQ::usage = "\!\(\*RowBox[{\"TreeGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a tree and False otherwise."
TreePlot::usage = "\!\(\*RowBox[{\"TreePlot\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) generates a tree plot of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"TreePlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"2\", \"TR\"]}]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a tree plot of the graph in which vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"ik\", \"TI\"]]\) is connected to vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"jk\", \"TI\"]]\).\n\!\(\*RowBox[{\"TreePlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"i\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]], \"\[Rule]\", SubscriptBox[StyleBox[\"v\", \"TI\"], RowBox[{StyleBox[\"j\", \"TI\"], \"\[InvisibleSpace]\", StyleBox[\"1\", \"TR\"]}]]}], \",\", SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) associates labels \!\(\*SubscriptBox[StyleBox[\"lbl\", \"TI\"], StyleBox[\"k\", \"TI\"]]\) with edges in the graph.\n\!\(\*RowBox[{\"TreePlot\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"]}], \"]\"}]\) places roots of trees in the plot at position \!\(\*StyleBox[\"pos\", \"TI\"]\).\n\!\(\*RowBox[{\"TreePlot\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"pos\", \"TI\"], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"k\", \"TI\"]]}], \"]\"}]\) uses vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"k\", \"TI\"]]\) as the root node in the tree plot."
TrendStyle::usage = "TrendStyle is an option to CandlestickChart, RenkoChart, and other financial charting functions that specifies how to style price trends. "
Triangle::usage = "\!\(\*RowBox[{\"Triangle\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}], \"]\"}]\) represents a filled triangle with corner points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"3\", \"TR\"]]\).\n\!\(\*RowBox[{\"Triangle\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"13\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a collection of triangles. "
TriangleWave::usage = "\!\(\*RowBox[{\"TriangleWave\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives a triangle wave that varies between \!\(\*RowBox[{\"-\", \"1\"}]\) and \!\(\*RowBox[{\"+\", \"1\"}]\) with unit period.\n\!\(\*RowBox[{\"TriangleWave\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives a triangle wave that varies between \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*StyleBox[\"max\", \"TI\"]\) with unit period."
TriangularDistribution::usage = "\!\(\*RowBox[{\"TriangularDistribution\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a symmetric triangular statistical distribution giving values between \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*StyleBox[\"max\", \"TI\"]\). \n\!\(\*RowBox[{\"TriangularDistribution\", \"[\", \"]\"}]\) represents a symmetric triangular statistical distribution giving values between 0 and 1.\n\!\(\*RowBox[{\"TriangularDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents a triangular distribution with mode at \!\(\*StyleBox[\"c\", \"TI\"]\)."
TriangulateMesh::usage = "\!\(\*RowBox[{\"TriangulateMesh\", \"[\", StyleBox[\"bmr\", \"TI\"], \"]\"}]\) generates a MeshRegion by triangulating inside the boundaries of a BoundaryMeshRegion \!\(\*StyleBox[\"bmr\", \"TI\"]\)."
TrigExpand::usage = "\!\(\*RowBox[{\"TrigExpand\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) expands out trigonometric functions in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
TrigFactorList::usage = "\!\(\*RowBox[{\"TrigFactorList\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) factors trigonometric functions in \!\(\*StyleBox[\"expr\", \"TI\"]\), yielding a list of lists containing trigonometric monomials and exponents. "
TrigFactor::usage = "\!\(\*RowBox[{\"TrigFactor\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) factors trigonometric functions in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
Trigger::usage = "\!\(\*RowBox[{\"Trigger\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"u\", \"TI\"], \"]\"}], \"]\"}]\) represents a trigger that can be pressed to make the dynamically updated value of \!\(\*StyleBox[\"u\", \"TI\"]\) be continually increased with time from 0 to 1. \n\!\(\*RowBox[{\"Trigger\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"u\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) makes \!\(\*StyleBox[\"u\", \"TI\"]\) vary from \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]\) when triggered. \n\!\(\*RowBox[{\"Trigger\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"u\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"du\", \"TI\"]}], \"}\"}]}], \"]\"}]\) makes \!\(\*StyleBox[\"u\", \"TI\"]\) vary in steps \!\(\*StyleBox[\"du\", \"TI\"]\) when triggered. \n\!\(\*RowBox[{\"Trigger\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"u\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"ups\", \"TI\"]}], \"]\"}]\) makes the value of \!\(\*StyleBox[\"u\", \"TI\"]\) increase at a rate of \!\(\*StyleBox[\"ups\", \"TI\"]\) units per second when triggered. "
TrigReduce::usage = "\!\(\*RowBox[{\"TrigReduce\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) rewrites products and powers of trigonometric functions in \!\(\*StyleBox[\"expr\", \"TI\"]\) in terms of trigonometric functions with combined arguments. "
TrigToExp::usage = "\!\(\*RowBox[{\"TrigToExp\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts trigonometric functions in \!\(\*StyleBox[\"expr\", \"TI\"]\) to exponentials. "
Trig::usage = "Trig is an option for various polynomial manipulation functions that specifies whether trigonometric functions should be treated like polynomial elements."
TrimmedMean::usage = "\!\(\*RowBox[{\"TrimmedMean\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) gives the mean of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\) after dropping a fraction \!\(\*StyleBox[\"f\", \"TI\"]\) of the smallest and largest elements.\n\!\(\*RowBox[{\"TrimmedMean\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the mean when a fraction \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) of the smallest elements and a fraction \!\(\*SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) of the largest elements are removed.\n\!\(\*RowBox[{\"TrimmedMean\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the 5% trimmed mean \!\(\*RowBox[{\"TrimmedMean\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", \"0.05\"}], \"]\"}]\)."
TropicalStormData::usage = "\!\(\*RowBox[{\"TropicalStormData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the tropical storm \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"TropicalStormData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified tropical storm entities.\n\!\(\*RowBox[{\"TropicalStormData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
TrueQ::usage = "\!\(\*RowBox[{\"TrueQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) yields True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is True, and yields False otherwise. "
True::usage = "True is the symbol for the Boolean value true. "
TruncatedDistribution::usage = "\!\(\*RowBox[{\"TruncatedDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) represents the distribution obtained by truncating the values of \!\(\*StyleBox[\"dist\", \"TI\"]\) to lie between \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\).\n\!\(\*RowBox[{\"TruncatedDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) represents the distribution obtained by truncating the values of the multivariate distribution \!\(\*StyleBox[\"dist\", \"TI\"]\) to lie between \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]\), etc."
Tr::usage = "\!\(\*RowBox[{\"Tr\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) finds the trace of the matrix or tensor \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Tr\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"]}], \"]\"}]\) finds a generalized trace, combining terms with \!\(\*StyleBox[\"f\", \"TI\"]\) instead of Plus. \n\!\(\*RowBox[{\"Tr\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) goes down to level \!\(\*StyleBox[\"n\", \"TI\"]\) in \!\(\*StyleBox[\"list\", \"TI\"]\). "
TsallisQExponentialDistribution::usage = "\!\(\*RowBox[{\"TsallisQExponentialDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents a Tsallis \!\(\*StyleBox[\"q\", \"TI\"]\)-exponential distribution with scale inversely proportional to parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\)."
TsallisQGaussianDistribution::usage = "\!\(\*RowBox[{\"TsallisQGaussianDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"q\", \"TI\"]}], \"]\"}]\) represents a Tsallis \!\(\*StyleBox[\"q\", \"TI\"]\)-Gaussian distribution with mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\), and deformation parameter \!\(\*StyleBox[\"q\", \"TI\"]\).\n\!\(\*RowBox[{\"TsallisQGaussianDistribution\", \"[\", StyleBox[\"q\", \"TI\"], \"]\"}]\) represents a Tsallis \!\(\*StyleBox[\"q\", \"TI\"]\)-Gaussian distribution with mean 0 and scale parameter 1."
TTest::usage = "\!\(\*RowBox[{\"TTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the mean of \!\(\*StyleBox[\"data\", \"TI\"]\) is zero. \n\!\(\*RowBox[{\"TTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the means of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"TTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) tests the mean against \!\(\*SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]\).\n\!\(\*RowBox[{\"TTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
TubeBezierCurveBoxOptions::usage = "\!\(\*RowBox[{TubeBezierCurveBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for TubeBezierCurveBox objects."
TubeBoxOptions::usage = "\!\(\*RowBox[{TubeBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for TubeBox objects."
TubeBSplineCurveBoxOptions::usage = "\!\(\*RowBox[{TubeBSplineCurveBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for TubeBSplineCurveBox objects."
Tube::usage = "\!\(\*RowBox[{\"Tube\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a 3D tube around the line joining a sequence of points.\n\!\(\*RowBox[{\"Tube\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a tube of radius \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"Tube\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"21\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a collection of tubes.\n\!\(\*RowBox[{\"Tube\", \"[\", RowBox[{StyleBox[\"curve\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents a tube around the specified 3D curve."
Tuesday::usage = "Tuesday is a day of the week."
TukeyLambdaDistribution::usage = "\!\(\*RowBox[{\"TukeyLambdaDistribution\", \"[\", StyleBox[\"\[Lambda]\", \"TR\"], \"]\"}]\) represents Tukey's lambda distribution with shape parameter \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\).\n\!\(\*RowBox[{\"TukeyLambdaDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents Tukey's lambda distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"TukeyLambdaDistribution\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) represents the generalized Tukey's lambda distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), scale parameters \!\(\*SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\), and shape parameters \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"\[Lambda]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\)."
TukeyWindow::usage = "\!\(\*RowBox[{\"TukeyWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Tukey window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"TukeyWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
TunnelData::usage = "\!\(\*RowBox[{\"TunnelData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the tunnel \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"TunnelData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified tunnel entities.\n\!\(\*RowBox[{\"TunnelData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
Tuples::usage = "\!\(\*RowBox[{\"Tuples\", \"[\", RowBox[{StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) generates a list of all possible \!\(\*StyleBox[\"n\", \"TI\"]\)\[Hyphen]tuples of elements from \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Tuples\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a list of all possible tuples whose \!\(\*StyleBox[\"i\", \"TI\"]\)\!\(\*RowBox[{\"\[Null]\", SuperscriptBox[\"\[Null]\", \"th\"]}]\) element is from \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
TuranGraph::usage = "\!\(\*RowBox[{\"TuranGraph\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"k\", \"TI\"]\)-partite Tur\[AAcute]n graph with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices \!\(\*SubscriptBox[StyleBox[\"T\", \"TI\"], RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}]]\)."
TuringMachine::usage = "\!\(\*RowBox[{\"TuringMachine\", \"[\", RowBox[{StyleBox[\"rule\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) generates a list representing the evolution of the Turing machine with the specified rule from initial condition \!\(\*StyleBox[\"init\", \"TI\"]\) for \!\(\*StyleBox[\"t\", \"TI\"]\) steps. \n\!\(\*RowBox[{\"TuringMachine\", \"[\", RowBox[{StyleBox[\"rule\", \"TI\"], \",\", StyleBox[\"init\", \"TI\"]}], \"]\"}]\) gives the result of evolving \!\(\*StyleBox[\"init\", \"TI\"]\) for one step. \n\!\(\*RowBox[{\"TuringMachine\", \"[\", StyleBox[\"rule\", \"TI\"], \"]\"}]\) is an operator form of TuringMachine that corresponds to one step of evolution."
TuttePolynomial::usage = "\!\(\*RowBox[{\"TuttePolynomial\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the Tutte polynomial of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"TuttePolynomial\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
UnateQ::usage = "\!\(\*RowBox[{\"UnateQ\", \"[\", RowBox[{StyleBox[\"bexpr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) tests whether the Boolean expression \!\(\*StyleBox[\"bexpr\", \"TI\"]\) is positive unate in the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"UnateQ\", \"[\", RowBox[{StyleBox[\"bexpr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"\[Not]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{\"\[Not]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) tests whether the Boolean expression \!\(\*StyleBox[\"bexpr\", \"TI\"]\) is negative unate in the variables \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] ."
Uncompress::usage = "\!\(\*RowBox[{\"Uncompress\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) recovers an expression from a compressed string representation generated by Compress.\n\!\(\*RowBox[{\"Uncompress\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"h\", \"TI\"]}], \"]\"}]\) wraps the head \!\(\*StyleBox[\"h\", \"TI\"]\) around the expression produced before evaluating it. "
Undefined::usage = "Undefined is a symbol that represents a quantity with no defined value."
UnderBar::usage = "\!\(\*RowBox[{\"UnderBar\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) displays with a bar under \!\(\*StyleBox[\"expr\", \"TI\"]\)."
Underflow::usage = "\!\(\*RowBox[{\"Underflow\", \"[\", \"]\"}]\) represents a number too small to represent explicitly on your computer system."
Underlined::usage = "Underlined represents an underlined font."
UnderoverscriptBoxOptions::usage = "\!\(\*RowBox[{UnderoverscriptBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for selections that specifies settings for UnderoverscriptBox objects."
UnderoverscriptBox::usage = "\!\(\*RowBox[{UnderoverscriptBox, \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is the low\[Hyphen]level box representation for \!\(\*UnderoverscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"], StyleBox[\"z\", \"TI\"]]\) in notebook expressions. "
Underoverscript::usage = "\!\(\*RowBox[{\"Underoverscript\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is an object that formats as \!\(\*UnderoverscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"], StyleBox[\"z\", \"TI\"]]\). "
UnderscriptBoxOptions::usage = "\!\(\*RowBox[{UnderscriptBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for selections that specifies settings for UnderscriptBox objects."
UnderscriptBox::usage = "\!\(\*RowBox[{UnderscriptBox, \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is the low\[Hyphen]level box representation for \!\(\*UnderscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\) in notebook expressions. "
Underscript::usage = "\!\(\*RowBox[{\"Underscript\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) is an object that formats as \!\(\*UnderscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"y\", \"TI\"]]\). "
UnderseaFeatureData::usage = "\!\(\*RowBox[{\"UnderseaFeatureData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the undersea feature \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"UnderseaFeatureData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified undersea feature entities.\n\!\(\*RowBox[{\"UnderseaFeatureData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
UndirectedEdge::usage = "\!\(\*RowBox[{\"UndirectedEdge\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) or \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"\[UndirectedEdge]\", StyleBox[\"v\", \"TI\"]}]\) represents an undirected edge of a graph with vertices \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
UndirectedGraphQ::usage = "\!\(\*RowBox[{\"UndirectedGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is an undirected graph and False otherwise."
UndirectedGraph::usage = "\!\(\*RowBox[{\"UndirectedGraph\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives an undirected graph from the directed graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"UndirectedGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
UndoOptions::usage = "\!\(\*RowBox[{\"UndoOptions\", \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option for Style that specifies settings for controlling the behavior of the front end's interactive undo/redo system."
UndoTrackedVariables::usage = "UndoTrackedVariables is an option for Manipulate, DynamicModule, and related functions that sets variables that should be tracked by the front end's undo mechanism."
Unequal::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"!=\", StyleBox[\"rhs\", \"TI\"]}]\) or \!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"\[NotEqual]\", StyleBox[\"rhs\", \"TI\"]}]\) returns False if \!\(\*StyleBox[\"lhs\", \"TI\"]\) and \!\(\*StyleBox[\"rhs\", \"TI\"]\) are identical. "
Unevaluated::usage = "\!\(\*RowBox[{\"Unevaluated\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents the unevaluated form of \!\(\*StyleBox[\"expr\", \"TI\"]\) when it appears as the argument to a function. "
UniformDistribution::usage = "\!\(\*RowBox[{\"UniformDistribution\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}], \"]\"}]\) represents a continuous uniform statistical distribution giving values between \!\(\*StyleBox[\"min\", \"TI\"]\) and \!\(\*StyleBox[\"max\", \"TI\"]\). \n\!\(\*RowBox[{\"UniformDistribution\", \"[\", \"]\"}]\) represents a uniform distribution giving values between 0 and 1.\n\!\(\*RowBox[{\"UniformDistribution\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) represents a multivariate uniform distribution over the region \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"UniformDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents a multivariate uniform distribution over the standard \!\(\*StyleBox[\"n\", \"TI\"]\) dimensional unit hypercube. "
UniformGraphDistribution::usage = "\!\(\*RowBox[{\"UniformGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}], \"]\"}]\) represents a uniform graph distribution on \!\(\*StyleBox[\"n\", \"TI\"]\)-vertex, \!\(\*StyleBox[\"m\", \"TI\"]\)-edge graphs."
UniformSumDistribution::usage = "\!\(\*RowBox[{\"UniformSumDistribution\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) represents the distribution of a sum of \!\(\*StyleBox[\"n\", \"TI\"]\) random variables uniformly distributed from 0 to 1.\n\!\(\*RowBox[{\"UniformSumDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents the distribution of a sum of \!\(\*StyleBox[\"n\", \"TI\"]\) random variables uniformly distributed from \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\)."
Uninstall::usage = "\!\(\*RowBox[{\"Uninstall\", \"[\", StyleBox[\"link\", \"TI\"], \"]\"}]\) terminates an external program started by Install, and removes \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\"]\) definitions set up by it. "
UnionPlus::usage = "\!\(\*RowBox[{\"UnionPlus\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UnionPlus]\", StyleBox[\"y\", \"TI\"], \"\[UnionPlus]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Union::usage = "\!\(\*RowBox[{\"Union\", \"[\", RowBox[{SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) gives a sorted list of all the distinct elements that appear in any of the \!\(\*SubscriptBox[StyleBox[\"list\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Union\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives a sorted version of a list, in which all duplicated elements have been dropped. "
Unique::usage = "\!\(\*RowBox[{\"Unique\", \"[\", \"]\"}]\) generates a new symbol, whose name is of the form \!\(\*StyleBox[RowBox[{\"$\", StyleBox[\"nnn\", \"TI\"]}]]\). \n\!\(\*RowBox[{\"Unique\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) generates a new symbol, with a name of the form \!\(\*StyleBox[RowBox[{StyleBox[\"x\", \"TI\"], \"$\", StyleBox[\"nnn\", \"TI\"]}]]\). \n\!\(\*RowBox[{\"Unique\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a list of new symbols. \n\!\(\*RowBox[{\"Unique\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"xxx\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) generates a new symbol, with a name of the form \!\(\*StyleBox[\"xxxnnn\", \"TI\"]\). "
UnitaryMatrixQ::usage = "\!\(\*RowBox[{\"UnitaryMatrixQ\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"m\", \"TI\"]\) is a unitary matrix, and False otherwise."
UnitBox::usage = "\!\(\*RowBox[{UnitBox, \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the unit box function, equal to 1 for \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", StyleBox[\"x\", \"TI\"], \"\[RightBracketingBar]\"}], \"\[LessEqual]\", FractionBox[\"1\", \"2\"]}]\) and 0 otherwise.\n\!\(\*RowBox[{UnitBox, \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the multidimensional unit box function, equal to 1 if \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[RightBracketingBar]\"}], \"\[LessEqual]\", FractionBox[\"1\", \"2\"]}]\) and 0 otherwise."
UnitConvert::usage = "\!\(\*RowBox[{\"UnitConvert\", \"[\", RowBox[{StyleBox[\"quantity\", \"TI\"], \",\", StyleBox[\"targetunit\", \"TI\"]}], \"]\"}]\) attempts to convert the specified \!\(\*StyleBox[\"quantity\", \"TI\"]\) to the specified \!\(\*StyleBox[\"targetunit\", \"TI\"]\).\n\!\(\*RowBox[{\"UnitConvert\", \"[\", StyleBox[\"quantity\", \"TI\"], \"]\"}]\) converts the specified \!\(\*StyleBox[\"quantity\", \"TI\"]\) to its \"SIBase\" units."
UnitDimensions::usage = "\!\(\*RowBox[{\"UnitDimensions\", \"[\", StyleBox[\"unit\", \"TI\"], \"]\"}]\) returns a list of base dimensions associated with the specified \!\(\*StyleBox[\"unit\", \"TI\"]\).\n\!\(\*RowBox[{\"UnitDimensions\", \"[\", StyleBox[\"quantity\", \"TI\"], \"]\"}]\) returns a list of base dimensions associated with the unit of the specified \!\(\*StyleBox[\"quantity\", \"TI\"]\)."
Unitize::usage = "\!\(\*RowBox[{\"Unitize\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) gives 0 when \!\(\*StyleBox[\"x\", \"TI\"]\) is zero, and 1 when \!\(\*StyleBox[\"x\", \"TI\"]\) has any other numerical value."
UnitRootTest::usage = "\!\(\*RowBox[{\"UnitRootTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether data came from an autoregressive time series process with unit root.\n\!\(\*RowBox[{\"UnitRootTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"model\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\!\(\*\nStyleBox[\"\\\"\", \"TI\"]\) for a given model."
Units`Abampere::usage = "Abampere is a unit of electric current in the CGS system."
Units`Abcoulomb::usage = "Abcoulomb is a unit of electric charge in the CGS system."
Units`Abfarad::usage = "Abfarad is a unit of electric capacitance in the CGS system."
Units`Abhenry::usage = "Abhenry is a unit of inductance in the CGS system."
Units`Abmho::usage = "Abmho is a unit of electric conductance in the CGS system."
Units`Abohm::usage = "Abohm is a unit of electric resistance in the CGS system."
Units`Abvolt::usage = "Abvolt is a unit of electric potential difference in the CGS system."
Units`Acre::usage = "Acre is a unit of area."
Units`Ampere::usage = "Ampere is the fundamental SI unit of electric current."
Units`Amp::usage = "Amp is an abbreviation for Ampere."
Units`AMU::usage = "AMU is a unit of mass. "
Units`Angstrom::usage = "Angstrom is a unit of length."
Units`Apostilb::usage = "Apostilb is a unit of luminance (photometric brightness)."
Units`ArcMinute::usage = "ArcMinute is a unit multiplier."
Units`ArcSecond::usage = "ArcSecond is a unit multiplier."
Units`Are::usage = "Are is a unit of area."
Units`AssayTon::usage = "AssayTon is a unit of mass."
Units`AstronomicalUnit::usage = "AstronomicalUnit is a unit of length."
Units`Atmosphere::usage = "Atmosphere is a unit of pressure."
Units`AtomicMassUnit::usage = "AtomicMassUnit is a unit of mass."
Units`Atto::usage = "Atto is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"18\"}]]\)."
Units`AU::usage = "AU is a unit of length."
Units`AvoirdupoisOunce::usage = "AvoirdupoisOunce is a unit of weight."
Units`AvoirdupoisPound::usage = "AvoirdupoisPound is a unit of weight."
Units`Bag::usage = "Bag is a unit of volume."
Units`BakersDozen::usage = "BakersDozen is a unit multiplier."
Units`Bale::usage = "Bale is a unit of weight."
Units`Barn::usage = "Barn is a unit of area."
Units`Barrel::usage = "Barrel is a unit of volume."
Units`Bar::usage = "Bar is a unit of pressure."
Units`Barye::usage = "Barye is a unit of pressure."
Units`Baud::usage = "Baud is a unit of information."
Units`Becquerel::usage = "Becquerel is the derived SI unit of radioactivity."
Units`Biot::usage = "Biot is a unit of electric current."
Units`Bit::usage = "Bit is the fundamental unit of information."
Units`BoardFoot::usage = "BoardFoot is a unit of volume."
Units`BohrMagneton::usage = "BohrMagneton is a unit of magnetic moment."
Units`Bolt::usage = "Bolt is a unit of length."
Units`BritishThermalUnit::usage = "BritishThermalUnit is a unit of energy."
Units`BTU::usage = "BTU is a unit of energy."
Units`Bucket::usage = "Bucket is a unit of volume."
Units`Bushel::usage = "Bushel is a unit of volume."
Units`Butt::usage = "Butt is a unit of volume."
Units`Cable::usage = "Cable is a unit of length."
Units`Caliber::usage = "Caliber is a unit of length."
Units`Calorie::usage = "Calorie is a unit of energy."
Units`Candela::usage = "Candela is the fundamental SI unit of luminous intensity."
Units`Candle::usage = "Candle is a unit of luminous intensity."
Units`Carat::usage = "Carat is a unit of weight."
Units`Celsius::usage = "Celsius is a unit of temperature."
Units`Cental::usage = "Cental is a unit of weight."
Units`Centigrade::usage = "Centigrade is a unit of temperature."
Units`Centimeter::usage = "Centimeter is the fundamental CGS unit of length."
Units`Centi::usage = "Centi is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"2\"}]]\)."
Units`Century::usage = "Century is a unit of time."
Units`CGS::usage = "\!\(\*RowBox[{\"CGS\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts \!\(\*StyleBox[\"expr\", \"TI\"]\) to CGS units (centimeter/gram/second)."
Units`Chain::usage = "Chain is a unit of length."
Units`ChevalVapeur::usage = "ChevalVapeur is a unit of power."
Units`Cicero::usage = "Cicero is a unit of length."
Units`ConvertTemperature::usage = "\!\(\*RowBox[{\"ConvertTemperature\", \"[\", RowBox[{StyleBox[\"temp\", \"TI\"], \",\", StyleBox[\"oldscale\", \"TI\"], \",\", StyleBox[\"newscale\", \"TI\"]}], \"]\"}]\) converts temperature \!\(\*StyleBox[\"temp\", \"TI\"]\) from temperature scale \!\(\*StyleBox[\"oldscale\", \"TI\"]\) to scale \!\(\*StyleBox[\"newscale\", \"TI\"]\)."
Units`Convert::usage = "\!\(\*RowBox[{\"Convert\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"newunits\", \"TI\"]}], \"]\"}]\) converts \!\(\*StyleBox[\"expr\", \"TI\"]\) to a form involving a combination of units \!\(\*StyleBox[\"newunits\", \"TI\"]\)."
Units`Cord::usage = "Cord is a unit of volume."
Units`Coulomb::usage = "Coulomb is the derived SI unit of electric charge."
Units`Cubit::usage = "Cubit is a unit of length."
Units`Curie::usage = "Curie is a unit of radioactivity."
Units`Dalton::usage = "Dalton is a unit of mass."
Units`Day::usage = "Day is a unit of time."
Units`Decade::usage = "Decade is a unit of time."
Units`Deca::usage = "Deca is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"1\"]\)."
Units`Deci::usage = "Deci is the SI unit prefix denoting \!\(\*FractionBox[\"1\", \"10\"]\)."
Units`Denier::usage = "Denier is a unit of fineness for yarn or thread."
Units`DidotPoint::usage = "DidotPoint is a unit of length."
Units`Didot::usage = "Didot is a unit of length."
Units`Diopter::usage = "Diopter is a unit of inverse length."
Units`Dozen::usage = "Dozen is a unit multiplier."
Units`Drachma::usage = "Drachma is a unit of weight."
Units`Dyne::usage = "Dyne is the derived CGS unit of force."
Units`ElectronVolt::usage = "ElectronVolt is a unit of energy."
Units`Ell::usage = "Ell is a unit of length."
Units`Ephah::usage = "Ephah is a unit of volume."
Units`Erg::usage = "Erg is the derived CGS unit of energy."
Units`Exa::usage = "Exa is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"18\"]\)."
Units`Fahrenheit::usage = "Fahrenheit is a unit of temperature."
Units`Farad::usage = "Farad is the derived SI unit of electric capacitance."
Units`Fathom::usage = "Fathom is a unit of length."
Units`Feet::usage = "Feet is a unit of length."
Units`Femto::usage = "Femto is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"15\"}]]\)."
Units`Fermi::usage = "Fermi is a unit of length."
Units`Fifth::usage = "Fifth is a unit of volume."
Units`Firkin::usage = "Firkin is a unit of volume."
Units`FluidDram::usage = "FluidDram is a unit of volume."
Units`FluidOunce::usage = "FluidOunce is a unit of volume."
Units`FootCandle::usage = "FootCandle is a unit of illumination (illuminance)."
Units`Foot::usage = "Foot is a unit of length."
Units`Fortnight::usage = "Fortnight is a unit of time."
Units`Furlong::usage = "Furlong is a unit of length."
Units`Gallon::usage = "Gallon is a US volume unit."
Units`Gal::usage = "Gal is the derived CGS measure of acceleration due to gravity."
Units`Gauss::usage = "Gauss is the derived CGS unit of magnetic flux density."
Units`Geepound::usage = "Geepound is a unit of mass."
Units`Giga::usage = "Giga is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"9\"]\)."
Units`Gilbert::usage = "Gilbert is a unit of magnetomotive force."
Units`Gill::usage = "Gill is a unit of volume."
Units`Grade::usage = "Grade is a unit multiplier."
Units`Grain::usage = "Grain is a unit of weight."
Units`Gram::usage = "Gram is the fundamental CGS unit of mass."
Units`GramWeight::usage = "GramWeight is a unit of force."
Units`Gravity::usage = "Gravity is a measure of the acceleration due to gravity."
Units`GrayDose::usage = "GrayDose is the derived SI unit of absorbed dose of radiation."
Units`GrossHundredweight::usage = "GrossHundredweight is a unit of weight."
Units`Gross::usage = "Gross is a unit multiplier."
Units`Hand::usage = "Hand is a unit of length."
Units`Hectare::usage = "Hectare is a unit of area."
Units`Hecto::usage = "Hecto is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"2\"]\)."
Units`Hefner::usage = "Hefner is a unit of luminous intensity."
Units`Henry::usage = "Henry is the derived SI unit of inductance."
Units`Hertz::usage = "Hertz is the derived SI unit of frequency."
Units`Hogshead::usage = "Hogshead is a unit of volume."
Units`Horsepower::usage = "Horsepower is a unit of power."
Units`Hour::usage = "Hour is a unit of time."
Units`Hundredweight::usage = "Hundredweight is a unit of weight."
Units`ImperialGallon::usage = "ImperialGallon is a British volume unit."
Units`ImperialPint::usage = "ImperialPint is a British volume unit."
UnitSimplify::usage = "\!\(\*RowBox[{\"UnitSimplify\", \"[\", StyleBox[\"quantity\", \"TI\"], \"]\"}]\) attempts to simplify the units of the specified \!\(\*StyleBox[\"quantity\", \"TI\"]\)."
Units`InchMercury::usage = "InchMercury is a unit of pressure."
Units`Inch::usage = "Inch is a unit of length."
Units`Jeroboam::usage = "Jeroboam is a unit of volume."
Units`Jigger::usage = "Jigger is a unit of volume."
Units`Joule::usage = "Joule is the derived SI unit of energy."
Units`Kayser::usage = "Kayser is a unit of inverse length."
Units`Kelvin::usage = "Kelvin is the fundamental SI unit of thermodynamic temperature."
Units`KilogramForce::usage = "KilogramForce is a unit of force."
Units`Kilogram::usage = "Kilogram is the fundamental SI unit of mass."
Units`KilogramWeight::usage = "KilogramWeight is a unit of force."
Units`Kilo::usage = "Kilo is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"3\"]\)."
Units`Knot::usage = "Knot is a unit of speed."
Units`Lambert::usage = "Lambert is a unit of luminance (photometric brightness)."
Units`League::usage = "League is a unit of length."
Units`Libra::usage = "Libra is a unit of weight."
Units`LightYear::usage = "LightYear is a unit of length."
Units`Link::usage = "Link is a unit of length."
Units`Liter::usage = "Liter is a unit of volume."
Units`LongTon::usage = "LongTon is a unit of weight."
Units`Lumen::usage = "Lumen is the derived SI unit of luminous flux."
Units`Lumerg::usage = "Lumerg is a unit of luminous energy (quantity of light)."
Units`Lux::usage = "Lux is the derived SI unit of illumination (illuminance)."
Units`Magnum::usage = "Magnum is a unit of volume."
Units`Maxwell::usage = "Maxwell is the derived CGS unit of magnetic flux."
Units`Mega::usage = "Mega is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"6\"]\)."
Units`Meter::usage = "Meter is the fundamental SI unit of length."
Units`MetricTon::usage = "MetricTon is a unit of mass."
Units`Mho::usage = "Mho is a unit of electric conductance."
Units`Micron::usage = "Micron is a unit of length."
Units`Micro::usage = "Micro is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"6\"}]]\)."
Units`Mile::usage = "Mile is a unit of length."
Units`Millennium::usage = "Millennium is a unit of time."
Units`MillimeterMercury::usage = "MillimeterMercury is a unit of pressure."
Units`Milli::usage = "Milli is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"3\"}]]\)."
Units`Mil::usage = "Mil is a unit of length."
Units`Mina::usage = "Mina is a unit of weight."
Units`Minim::usage = "Minim is a unit of volume."
Units`Minute::usage = "Minute is a unit of time."
Units`MKS::usage = "\!\(\*RowBox[{\"MKS\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts \!\(\*StyleBox[\"expr\", \"TI\"]\) to MKS units (meter/kilogram/second)."
Units`Mole::usage = "Mole is the fundamental SI unit of amount of substance."
Units`Month::usage = "Month is a unit of time."
Units`Nano::usage = "Nano is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"9\"}]]\)."
Units`NauticalMile::usage = "NauticalMile is a unit of length."
Units`NetHundredweight::usage = "NetHundredweight is a unit of weight."
Units`Newton::usage = "Newton is the derived SI unit of force."
Units`Nibble::usage = "Nibble is a unit of information."
Units`Nit::usage = "Nit is a unit of luminance (photometric brightness)."
Units`Noggin::usage = "Noggin is a unit of volume."
Units`NuclearMagneton::usage = "NuclearMagneton is a unit of magnetic moment."
Units`Obolos::usage = "Obolos is a unit of weight."
Units`Oersted::usage = "Oersted is the derived CGS unit of magnetic intensity."
Units`Ohm::usage = "Ohm is the derived SI unit of electric resistance."
Units`Omer::usage = "Omer is a unit of volume."
Units`Ounce::usage = "Ounce is a unit of weight."
Units`Parsec::usage = "Parsec is a unit of length."
Units`Pascal::usage = "Pascal is the derived SI unit of pressure."
Units`Peck::usage = "Peck is a unit of volume."
Units`Pennyweight::usage = "Pennyweight is a unit of weight."
Units`Percent::usage = "Percent is a unit multiplier."
Units`Perch::usage = "Perch is a unit of length."
Units`Peta::usage = "Peta is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"15\"]\)."
Units`Phot::usage = "Phot is the derived CGS unit of illumination (illuminance)."
Units`Pica::usage = "Pica is a unit of length."
Units`Pico::usage = "Pico is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"12\"}]]\)."
Units`Pint::usage = "Pint is a unit of volume."
Units`Poise::usage = "Poise is the derived CGS unit of absolute viscosity."
Units`Pole::usage = "Pole is a unit of length."
Units`Pondus::usage = "Pondus is a unit of weight."
Units`Pony::usage = "Pony is a unit of volume."
Units`Poundal::usage = "Poundal is a unit of force."
Units`PoundForce::usage = "PoundForce is a unit of force."
Units`PoundsPerSquareInch::usage = "PoundsPerSquareInch is a unit of pressure."
Units`Pound::usage = "Pound is a unit of weight."
Units`PoundWeight::usage = "PoundWeight is a unit of force."
Units`PrintersPoint::usage = "PrintersPoint is a unit of length."
Units`PSI::usage = "PSI is a unit of pressure."
Units`Puncheon::usage = "Puncheon is a unit of volume."
Units`Quadrant::usage = "Quadrant is a unit multiplier."
Units`Quart::usage = "Quart is a unit of volume."
Units`Quintal::usage = "Quintal is a unit of mass."
Units`Radian::usage = "Radian is a dimensionless measure of plane angle."
Units`Rad::usage = "Rad is a unit of absorbed dose of radiation."
Units`Rankine::usage = "Rankine is a unit of temperature."
Units`RegisterTon::usage = "RegisterTon is a unit of volume."
Units`Reyn::usage = "Reyn is a unit of absolute viscosity."
Units`Rhes::usage = "Rhes is a unit of viscosity."
Units`RightAngle::usage = "RightAngle is a unit multiplier."
Units`Rod::usage = "Rod is a unit of length."
Units`Roentgen::usage = "Roentgen is a unit of exposure to X or gamma radiation."
Units`Rontgen::usage = "Rontgen is a unit of exposure to X or gamma radiation."
Units`Rood::usage = "Rood is a unit of area."
Units`Rope::usage = "Rope is a unit of length."
Units`Rutherford::usage = "Rutherford is a unit of radioactivity."
Units`Rydberg::usage = "Rydberg is a unit of energy."
Units`Seam::usage = "Seam is a unit of volume."
Units`Second::usage = "Second is the fundamental SI unit of time."
Units`Section::usage = "Section is a unit of area."
Units`Shekel::usage = "Shekel is a unit of weight."
Units`ShortHundredweight::usage = "ShortHundredweight is a unit of weight."
Units`ShortTon::usage = "ShortTon is a unit of weight."
Units`Shot::usage = "Shot is a unit of volume."
Units`SiderealSecond::usage = "SiderealSecond is a unit of time."
Units`SiderealYear::usage = "SiderealYear is a unit of time."
Units`Siemens::usage = "Siemens is the derived SI unit of electric conductance."
Units`SI::usage = "\!\(\*RowBox[{\"SI\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts \!\(\*StyleBox[\"expr\", \"TI\"]\) to SI units (International System)."
Units`Skein::usage = "Skein is a unit of length."
Units`Slug::usage = "Slug is a unit of mass."
Units`SolarMass::usage = "SolarMass is a unit of mass."
Units`Stadion::usage = "Stadion is a unit of length."
Units`Stadium::usage = "Stadium is a unit of length."
Units`Statampere::usage = "Statampere is a unit of electric current."
Units`Statcoulomb::usage = "Statcoulomb is a unit of electric charge."
Units`Statfarad::usage = "Statfarad is a unit of electric capacitance."
Units`Stathenry::usage = "Stathenry is a unit of inductance."
Units`Statohm::usage = "Statohm is a unit of electric resistance."
Units`StatuteMile::usage = "StatuteMile is a unit of length."
Units`Statvolt::usage = "Statvolt is a unit of electric potential difference."
Units`Steradian::usage = "Steradian is a dimensionless measure of solid angle."
Units`Stere::usage = "Stere is a unit of volume."
Units`Stilb::usage = "Stilb is the derived CGS unit of luminance (photometric brightness)."
Units`Stokes::usage = "Stokes is the derived CGS unit of kinematic viscosity."
Units`Stone::usage = "Stone is a unit of weight."
Units`SurveyMile::usage = "SurveyMile is a unit of length."
Units`Tablespoon::usage = "Tablespoon is a unit of volume."
Units`Talbot::usage = "Talbot is a unit of luminous energy (quantity of light)."
Units`Talent::usage = "Talent is a unit of weight."
Units`Teaspoon::usage = "Teaspoon is a unit of volume."
UnitStep::usage = "\!\(\*RowBox[{\"UnitStep\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the unit step function, equal to 0 for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"<\", \"0\"}]\) and 1 for \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[GreaterEqual]\", \"0\"}]\). \n\!\(\*RowBox[{\"UnitStep\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the multidimensional unit step function which is 1 only if none of the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are negative. "
Units`Tera::usage = "Tera is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"12\"]\)."
Units`Tesla::usage = "Tesla is the derived SI unit of magnetic flux density."
Units`Therm::usage = "Therm is a unit of energy."
Units`TonForce::usage = "TonForce is a unit of force."
Units`Tonne::usage = "Tonne is a unit of mass."
Units`Ton::usage = "Ton is a unit of weight."
Units`Torr::usage = "Torr is a unit of pressure."
Units`Township::usage = "Township is a unit of area."
Units`TropicalYear::usage = "TropicalYear is a unit of time."
Units`TroyOunce::usage = "TroyOunce is a unit of weight."
Units`Tun::usage = "Tun is a unit of volume."
Units`UKGallon::usage = "UKGallon is a British volume unit."
Units`UKPint::usage = "UKPint is a British volume unit."
Units`Volt::usage = "Volt is the derived SI unit of electric potential difference."
Units`Watt::usage = "Watt is the derived SI unit of power."
Units`Weber::usage = "Weber is the derived SI unit of magnetic flux."
Units`Week::usage = "Week is a unit of time."
Units`Wey::usage = "Wey is a unit of weight."
Units`WineBottle::usage = "WineBottle is a unit of volume."
Units`XUnit::usage = "XUnit is a unit of length."
Units`Yard::usage = "Yard is a unit of length."
Units`Year::usage = "Year is a unit of time."
Units`Yocto::usage = "Yocto is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"24\"}]]\)."
Units`Yotta::usage = "Yotta is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"24\"]\)."
UnitSystem::usage = "UnitSystem is an option for functions like AirTemperatureData that determines the units of the result."
Units`Zepto::usage = "Zepto is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", RowBox[{\"-\", \"21\"}]]\)."
Units`Zetta::usage = "Zetta is the SI unit prefix denoting \!\(\*SuperscriptBox[\"10\", \"21\"]\)."
UnitTriangle::usage = "\!\(\*RowBox[{\"UnitTriangle\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents the unit triangle function on the interval \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", StyleBox[\"x\", \"TI\"], \"\[RightBracketingBar]\"}], \"\[LessEqual]\", \"1\"}]\) .\n\!\(\*RowBox[{\"UnitTriangle\", \"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) represents the multidimensional unit triangle function on the interval \!\(\*RowBox[{RowBox[{\"\[LeftBracketingBar]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]], \"\[RightBracketingBar]\"}], \"\[LessEqual]\", \"1\"}]\)."
UnitVector::usage = "\!\(\*RowBox[{\"UnitVector\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]\) gives the two-dimensional unit vector in the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) direction.\n\!\(\*RowBox[{\"UnitVector\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"n\", \"TI\"]\)-dimensional unit vector in the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) direction."
UnityDimensions::usage = "UnityDimensions is an option for UnitSimplify that specifies which UnitDimensions should be factored out."
UniversityData::usage = "\!\(\*RowBox[{\"UniversityData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the university \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"UniversityData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified university entities.\n\!\(\*RowBox[{\"UniversityData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
UnixTime::usage = "\!\(\*RowBox[{\"UnixTime\", \"[\", \"]\"}]\) gives the total number of seconds since the beginning of January 1, 1970, in the GMT time zone.\n\!\(\*RowBox[{\"UnixTime\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"h\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \"]\"}]\) gives the Unix time specification corresponding to a date list.\n\!\(\*RowBox[{\"UnixTime\", \"[\", StyleBox[\"date\", \"TI\"], \"]\"}]\) gives the Unix time specification corresponding to a DateObject.\n\!\(\*RowBox[{\"UnixTime\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the Unix time specification corresponding to a date string.\n\!\(\*RowBox[{\"UnixTime\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"}\"}], \"]\"}]\) takes the date string to contain the elements \"\!\(\*SubscriptBox[\nStyleBox[\"e\", \"TI\"], \nStyleBox[\"i\", \"TI\"]]\)\"."
Unprotect::usage = "\!\(\*RowBox[{\"Unprotect\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) removes the attribute Protected for the symbols \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"Unprotect\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_1\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"form\\\",\\\"TI\\\"]\\_2\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) unprotects all symbols whose names textually match any of the \!\(\*SubscriptBox[StyleBox[\"form\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
UnsameQ::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"=!=\", StyleBox[\"rhs\", \"TI\"]}]\) yields True if the expression \!\(\*StyleBox[\"lhs\", \"TI\"]\) is not identical to \!\(\*StyleBox[\"rhs\", \"TI\"]\), and yields False otherwise. "
UnsavedVariables::usage = "UnsavedVariables is an option for Manipulate, DynamicModule, and related functions that specifies local symbols that should not be saved when the notebook containing them is saved."
UnsetShared::usage = "\!\(\*RowBox[{\"UnsetShared\", \"[\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) stops the sharing of the variables or functions \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) among parallel kernels.\n\!\(\*RowBox[{\"UnsetShared\", \"[\", StyleBox[\"patt\", \"TI\"], \"]\"}]\) stops the sharing of all variables and functions whose names match the string pattern \!\(\*StyleBox[\"patt\", \"TI\"]\)."
Unset::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"=.\"}]\) removes any rules defined for \!\(\*StyleBox[\"lhs\", \"TI\"]\). "
UpArrowBar::usage = "\!\(\*RowBox[{\"UpArrowBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpArrowBar]\", StyleBox[\"y\", \"TI\"], \"\[UpArrowBar]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
UpArrowDownArrow::usage = "\!\(\*RowBox[{\"UpArrowDownArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpArrowDownArrow]\", StyleBox[\"y\", \"TI\"], \"\[UpArrowDownArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
UpArrow::usage = "\!\(\*RowBox[{\"UpArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpArrow]\", StyleBox[\"y\", \"TI\"], \"\[UpArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
UpdateInterval::usage = "UpdateInterval is an option to Refresh and Dynamic that specifies at what time interval to do updates."
UpdateSearchIndex::usage = "\!\(\*RowBox[{\"UpdateSearchIndex\", \"[\", StyleBox[\"index\", \"TI\"], \"]\"}]\) updates the given search index."
Update::usage = "\!\(\*RowBox[{\"Update\", \"[\", StyleBox[\"symbol\", \"TI\"], \"]\"}]\) tells \!\(\*StyleBox[\"the Wolfram Language\", \"RebrandingTerm\"]\) that hidden changes have been made which could affect values associated with a symbol. \n\!\(\*RowBox[{\"Update\", \"[\", \"]\"}]\) specifies that the value of any symbol could be affected. "
UpDownArrow::usage = "\!\(\*RowBox[{\"UpDownArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpDownArrow]\", StyleBox[\"y\", \"TI\"], \"\[UpDownArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
UpEquilibrium::usage = "\!\(\*RowBox[{\"UpEquilibrium\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpEquilibrium]\", StyleBox[\"y\", \"TI\"], \"\[UpEquilibrium]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
UpperCaseQ::usage = "\!\(\*RowBox[{\"UpperCaseQ\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) yields True if all the characters in the string are uppercase letters, and yields False otherwise. "
UpperLeftArrow::usage = "\!\(\*RowBox[{\"UpperLeftArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpperLeftArrow]\", StyleBox[\"y\", \"TI\"], \"\[UpperLeftArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
UpperRightArrow::usage = "\!\(\*RowBox[{\"UpperRightArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpperRightArrow]\", StyleBox[\"y\", \"TI\"], \"\[UpperRightArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
UpperTriangularize::usage = "\!\(\*RowBox[{\"UpperTriangularize\", \"[\", StyleBox[\"m\", \"TI\"], \"]\"}]\) gives a matrix in which all but the upper triangular elements of \!\(\*StyleBox[\"m\", \"TI\"]\) are replaced with zeros. \n\!\(\*RowBox[{\"UpperTriangularize\", \"[\", RowBox[{StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) replaces with zeros only the elements below the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) subdiagonal of \!\(\*StyleBox[\"m\", \"TI\"]\)."
Upsample::usage = "\!\(\*RowBox[{\"Upsample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) returns an upsampled version of the array by inserting \!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \"-\", \"1\"}]\) zeros between array elements.\n\!\(\*RowBox[{\"Upsample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"offset\", \"TI\"]}], \"]\"}]\) shifts \!\(\*StyleBox[\"array\", \"TI\"]\) so that its first element moves to the position \!\(\*StyleBox[\"offset\", \"TI\"]\) in the resulting array.\n\!\(\*RowBox[{\"Upsample\", \"[\", RowBox[{StyleBox[\"array\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"offset\", \"TI\"], \",\", StyleBox[\"val\", \"TI\"]}], \"]\"}]\) inserts \!\(\*RowBox[{StyleBox[\"n\", \"TI\"], \"-\", \"1\"}]\) elements of value \!\(\*StyleBox[\"val\", \"TI\"]\) between array elements."
UpSetDelayed::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"^:=\", StyleBox[\"rhs\", \"TI\"]}]\) assigns \!\(\*StyleBox[\"rhs\", \"TI\"]\) to be the delayed value of \!\(\*StyleBox[\"lhs\", \"TI\"]\), and associates the assignment with symbols that occur at level one in \!\(\*StyleBox[\"lhs\", \"TI\"]\). "
UpSet::usage = "\!\(\*RowBox[{StyleBox[\"lhs\", \"TI\"], \"^=\", StyleBox[\"rhs\", \"TI\"]}]\) assigns \!\(\*StyleBox[\"rhs\", \"TI\"]\) to be the value of \!\(\*StyleBox[\"lhs\", \"TI\"]\), and associates the assignment with symbols that occur at level one in \!\(\*StyleBox[\"lhs\", \"TI\"]\). "
UpTeeArrow::usage = "\!\(\*RowBox[{\"UpTeeArrow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpTeeArrow]\", StyleBox[\"y\", \"TI\"], \"\[UpTeeArrow]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
UpTee::usage = "\!\(\*RowBox[{\"UpTee\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[UpTee]\", StyleBox[\"y\", \"TI\"]}]\)."
UpTo::usage = "\!\(\*RowBox[{\"UpTo\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) is a symbolic specification that represents up to \!\(\*StyleBox[\"n\", \"TI\"]\) objects or positions. If \!\(\*StyleBox[\"n\", \"TI\"]\) objects or positions are available, all are used. If fewer are available, only those available are used."
UpValues::usage = "\!\(\*RowBox[{\"UpValues\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives a list of transformation rules corresponding to all upvalues defined for the symbol \!\(\*StyleBox[\"f\", \"TI\"]\). "
URLBuild::usage = "\!\(\*RowBox[{\"URLBuild\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"base\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) builds a URL with the specified base and query parameters and values \!\(\*SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"URLBuild\", \"[\", StyleBox[\"assoc\", \"TI\"], \"]\"}]\) builds a URL from an association of components.\n\!\(\*RowBox[{\"URLBuild\", \"[\", RowBox[{StyleBox[\"assoc\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) builds a URL from an association of components, plus query parameters and values."
URLDecode::usage = "\!\(\*RowBox[{\"URLDecode\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) decodes a URL-style percent-encoded string."
URLEncode::usage = "\!\(\*RowBox[{\"URLEncode\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) converts \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" into a URL-style, percent-encoded ASCII string. "
URLExecute::usage = "\!\(\*RowBox[{\"URLExecute\", \"[\", StyleBox[\"url\", \"TI\"], \"]\"}]\) executes the specified URL, importing whatever result is generated.\n\!\(\*RowBox[{\"URLExecute\", \"[\", RowBox[{StyleBox[\"url\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) executes the specified URL, adding elements with names \!\(\*SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"URLExecute\", \"[\", RowBox[{StyleBox[\"url\", \"TI\"], \",\", StyleBox[\"params\", \"TI\"], \",\", StyleBox[\"format\", \"TI\"]}], \"]\"}]\) imports the result using the specified format.\n\!\(\*RowBox[{\"URLExecute\", \"[\", RowBox[{StyleBox[\"obj\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) executes the cloud object \!\(\*StyleBox[\"obj\", \"TI\"]\)."
URLExpand::usage = "\!\(\*RowBox[{\"URLExpand\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) expands a shortened \"\!\(\*\nStyleBox[\"url\", \"TI\"]\)\"."
URLFetchAsynchronous::usage = "\!\(\*RowBox[{\"URLFetchAsynchronous\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) performs a connection in the background, calling \!\(\*StyleBox[\"func\", \"TI\"]\) when an event is raised."
URLFetch::usage = "\!\(\*RowBox[{\"URLFetch\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) returns the contents of a URL as a string.\n\!\(\*RowBox[{\"URLFetch\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"elements\", \"TI\"]}], \"]\"}]\) returns the specified elements from a URL."
URLParse::usage = "\!\(\*RowBox[{\"URLParse\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) takes a well-formed URL and gives an association whose values correspond to the components of the URL.\n\!\(\*RowBox[{\"URLParse\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"component\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns only the specified component.\n\!\(\*RowBox[{\"URLParse\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"component\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns only the specified component list."
URLQueryDecode::usage = "\!\(\*RowBox[{\"URLQueryDecode\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) decodes a URL-style query string into a list of key-value rules. "
URLQueryEncode::usage = "\!\(\*RowBox[{\"URLQueryEncode\", \"[\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}], \"]\"}]\) creates a URL-style query string from an association of keys and values. \n\!\(\*RowBox[{\"URLQueryEncode\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"param\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) creates a query string from a list of rules."
URLSaveAsynchronous::usage = "\!\(\*RowBox[{\"URLSaveAsynchronous\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) performs a download to \"\!\(\*\nStyleBox[\"file\", \"TI\"]\)\" in the background, calling \!\(\*StyleBox[\"func\", \"TI\"]\) when an event is raised."
URLSave::usage = "\!\(\*RowBox[{\"URLSave\", \"[\", \"StyleBox[url, TI]StyleBox[\", TI], \"]\"}]\) saves the content of the URL to a file in $TemporaryDirectory.\n\!\(\*RowBox[{\"URLSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) saves the content of the URL to a file.\n\!\(\*RowBox[{\"URLSave\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"elements\", \"TI\"]}], \"]\"}]\) returns the specified elements from a URL."
URLShorten::usage = "\!\(\*RowBox[{\"URLShorten\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) creates a shortened URL that redirects to \"\!\(\*\nStyleBox[\"url\", \"TI\"]\)\".\n\!\(\*RowBox[{\"URLShorten\", \"[\", RowBox[{\"CloudObject\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}]\) creates a shortened URL that redirects to the URL for the specified cloud object."
UsingFrontEnd::usage = "\!\(\*RowBox[{\"UsingFrontEnd\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) evaluates \!\(\*StyleBox[\"expr\", \"TI\"]\), making use of a front end if necessary."
Using::usage = "Using is an option to Roots that specifies any subsidiary equations that are to be used."
UtilityFunction::usage = "UtilityFunction is an option for Predict, Classify, and related functions that specifies the utility value to assign to each possible pairing of actual and predicted values."
V2Get::usage = "\!\(\*RowBox[{\"V2Get\", \"[\", StyleBox[\"name\", \"TI\"], \"]\"}]\) reads in a file written by the V2.x versions."
ValidationLength::usage = "ValidationLength is an option to FindSequenceFunction and related functions that specifies the number of elements in the input sequence that should be used to validate a potential representation found."
ValidationSet::usage = "ValidationSet is an option for Predict, Classify, and related functions that specifies the validation set to be used during the training phase."
ValueBoxOptions::usage = "\!\(\*RowBox[{ValueBoxOptions, \"\[Rule]\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"opt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}]\) is an option that specifies settings for ValueBox objects."
ValueDimensions::usage = "ValueDimensions is an option to TemporalData, TimeSeries, and EventSeries that specifies the dimension of the value space. "
ValueForm::usage = "ValueForm is an internal symbol."
ValueQ::usage = "\!\(\*RowBox[{\"ValueQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if a value has been defined for \!\(\*StyleBox[\"expr\", \"TI\"]\), and gives False otherwise. "
Values::usage = "\!\(\*RowBox[{\"Values\", \"[\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}], \"]\"}]\) gives a list of the values \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in an association.\n\!\(\*RowBox[{\"Values\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"key\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives a list of the \!\(\*SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in a list of rules."
Variables::usage = "\!\(\*RowBox[{\"Variables\", \"[\", StyleBox[\"poly\", \"TI\"], \"]\"}]\) gives a list of all independent variables in a polynomial. "
VarianceEquivalenceTest::usage = "\!\(\*RowBox[{\"VarianceEquivalenceTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) tests whether the variances of the \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are equal. \n\!\(\*RowBox[{\"VarianceEquivalenceTest\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], StyleBox[\",\", \"TI\"], StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
VarianceEstimatorFunction::usage = "VarianceEstimatorFunction is an option for LinearModelFit and NonlinearModelFit which specifies the variance estimator to use."
VarianceGammaDistribution::usage = "\!\(\*RowBox[{\"VarianceGammaDistribution\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a variance\[Hyphen]gamma distribution with location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), skewness parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) and shape parameters \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
VarianceTest::usage = "\!\(\*RowBox[{\"VarianceTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the variance of the \!\(\*StyleBox[\"data\", \"TI\"]\) is one. \n\!\(\*RowBox[{\"VarianceTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the variances of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"VarianceTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SuperscriptBox[SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"]], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests a dispersion measure against \!\(\*SuperscriptBox[SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"]], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"VarianceTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SuperscriptBox[SubscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"0\", \"TR\"]], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
Variance::usage = "\!\(\*RowBox[{\"Variance\", \"[\", StyleBox[\"list\", \"TI\"], \"]\"}]\) gives the sample variance of the elements in \!\(\*StyleBox[\"list\", \"TI\"]\). \n\!\(\*RowBox[{\"Variance\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) gives the variance of the symbolic distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
VariationalMethods`EulerEquations::usage = "\!\(\*RowBox[{\"EulerEquations\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], RowBox[{\"]\", \",\"}], StyleBox[\"x\", \"TI\"]}], \"]\"}]}]}]\) returns the Euler\[Dash]Lagrange differential equation obeyed by \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) derived from the functional \!\(\*StyleBox[\"f\", \"TI\"]\), where \!\(\*StyleBox[\"f\", \"TI\"]\) depends on the function \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) and its derivatives, as well as the independent variable \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"EulerEquations\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns the Euler\[Dash]Lagrange differential equation obeyed by \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\).\n\!\(\*RowBox[{\"EulerEquations\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{StyleBox[\"v\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns a list of Euler\[Dash]Lagrange differential equations obeyed by \!\(\*RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{StyleBox[\"v\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
VariationalMethods`FirstIntegrals::usage = "\!\(\*RowBox[{\"FirstIntegrals\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"x\", \"TI\"], \"[\", StyleBox[\"t\", \"TI\"], \"]\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) returns a list of first integrals corresponding to the coordinate \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"[\", StyleBox[\"t\", \"TI\"], \"]\"}]\) and independent variable \!\(\*StyleBox[\"t\", \"TI\"]\) of the integrand \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"FirstIntegrals\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"[\", StyleBox[\"t\", \"TI\"], \"]\"}], \",\", RowBox[{StyleBox[\"y\", \"TI\"], \"[\", StyleBox[\"t\", \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) returns a list of first integrals corresponding to the coordinates \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), ... and independent variable \!\(\*StyleBox[\"t\", \"TI\"]\)."
VariationalMethods`FirstIntegral::usage = "\!\(\*RowBox[{\"FirstIntegral\", \"[\", StyleBox[\"u\", \"TI\"], \"]\"}]\) represents a first integral associated with the variable \!\(\*StyleBox[\"u\", \"TI\"]\) in the output of the function FirstIntegrals."
VariationalMethods`NVariationalBound::usage = "\!\(\*RowBox[{\"NVariationalBound\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], RowBox[{\"]\", \",\"}], RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"t\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"b\", \"TI\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"]\"}]}]}]\) numerically searches for values of the parameters \!\(\*StyleBox[\"a\", \"TI\"]\), \!\(\*StyleBox[\"b\", \"TI\"]\), ... of a trial function \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"t\", \"TI\"]]\), starting from \!\(\*RowBox[{StyleBox[\"a\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\), \!\(\*RowBox[{StyleBox[\"b\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"0\", \"TR\"]]}]\), ..., that extremize the functional \!\(\*RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"f\", \"TI\"], RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}]}]}]\), where the integrand \!\(\*StyleBox[\"f\", \"TI\"]\) is a function of \!\(\*StyleBox[\"u\", \"TI\"]\), its derivatives, and \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"NVariationalBound\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"t\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"b\", \"TI\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) searches for values of the parameters of a trial function of two or more variables.\n\!\(\*RowBox[{\"NVariationalBound\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"}\"}], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"t\", \"TI\"]], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", SubscriptBox[StyleBox[\"a\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"b\", \"TI\"], \",\", SubscriptBox[StyleBox[\"b\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) searches for values of the parameters that extremize the ratio \!\(\*RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"f\", \"TI\"], RowBox[{RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}], \"/\", RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"g\", \"TI\"], RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}]}]}]}]}]}]\), where the integrands \!\(\*StyleBox[\"f\", \"TI\"]\) and \!\(\*StyleBox[\"g\", \"TI\"]\) are functions of \!\(\*StyleBox[\"u\", \"TI\"]\), its derivatives, and \!\(\*StyleBox[\"x\", \"TI\"]\)."
VariationalMethods`VariationalBound::usage = "\!\(\*RowBox[{\"VariationalBound\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], RowBox[{\"]\", \",\"}], RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"t\", \"TI\"]], \",\", RowBox[{\"{\", StyleBox[\"a\", \"TI\"], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"b\", \"TI\"], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"]\"}]}]}]\) finds values of the parameters \!\(\*StyleBox[\"a\", \"TI\"]\), \!\(\*StyleBox[\"b\", \"TI\"]\), ... of a trial function \!\(\*SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"t\", \"TI\"]]\) that extremize the functional \!\(\*RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"f\", \"TI\"], RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}]}]}]\), where the integrand \!\(\*StyleBox[\"f\", \"TI\"]\) is a function of \!\(\*StyleBox[\"u\", \"TI\"]\), its derivatives, and \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"VariationalBound\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"t\", \"TI\"]], \",\", RowBox[{\"{\", StyleBox[\"a\", \"TI\"], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"b\", \"TI\"], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds values of the parameters of a trial function of two or more variables.\n\!\(\*RowBox[{\"VariationalBound\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"g\", \"TI\"]}], \"}\"}], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"t\", \"TI\"]], \",\", RowBox[{\"{\", StyleBox[\"a\", \"TI\"], \"}\"}], \",\", RowBox[{\"{\", StyleBox[\"b\", \"TI\"], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) finds values of the parameters that extremize the ratio \!\(\*RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"f\", \"TI\"], RowBox[{RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}], \"/\", RowBox[{SubsuperscriptBox[\"\[Integral]\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", FontSlant -> \"Italic\"]], SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", FontSlant -> \"Italic\"]]], RowBox[{StyleBox[\"g\", \"TI\"], RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}]}]}]}]}]}]\), where the integrands \!\(\*StyleBox[\"f\", \"TI\"]\) and \!\(\*StyleBox[\"g\", \"TI\"]\) are functions of \!\(\*StyleBox[\"u\", \"TI\"]\), its derivatives, and \!\(\*StyleBox[\"x\", \"TI\"]\)."
VariationalMethods`VariationalD::usage = "\!\(\*RowBox[{\"VariationalD\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], RowBox[{\"]\", \",\"}], StyleBox[\"x\", \"TI\"]}], \"]\"}]}]}]\) returns the variational derivative of the integral \!\(\*RowBox[{\"\[Integral]\", RowBox[{StyleBox[\"f\", \"TI\"], RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}]}]}]\) with respect to \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\), where the integrand \!\(\*StyleBox[\"f\", \"TI\"]\) is a function of \!\(\*StyleBox[\"u\", \"TI\"]\), its derivatives, and \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"VariationalD\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) returns the variational derivative of the multiple integral \!\(\*RowBox[{\"\[Integral]\", RowBox[{StyleBox[\"f\", \"TI\"], RowBox[{\"\[DifferentialD]\", StyleBox[\"x\", \"TI\"]}], RowBox[{\"\[DifferentialD]\", StyleBox[\"y\", \"TI\"]}], \" \", \"\[Ellipsis]\"}]}]\) with respect to \!\(\*RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\), where \!\(\*StyleBox[\"f\", \"TI\"]\) is a function of \!\(\*StyleBox[\"u\", \"TI\"]\), its derivatives, and the coordinates \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), ... .\n\!\(\*RowBox[{\"VariationalD\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", RowBox[{StyleBox[\"v\", \"TI\"], \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives a list of variational derivatives with respect to \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), ... ."
VectorAnalysis`ArcLengthFactor::usage = "\!\(\*RowBox[{\"ArcLengthFactor\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the derivative of the arc length of the curve described by the parametrized curve coordinates \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]\) with respect to the parameter \!\(\*StyleBox[\"t\", \"TI\"]\) in the default coordinate system. \n\!\(\*RowBox[{\"ArcLengthFactor\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"t\", \"TI\"], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the derivative of the arc length of a curve in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`Biharmonic::usage = "\!\(\*RowBox[{\"Biharmonic\", \"[\", StyleBox[\"f\", \"TI\"], \"]\"}]\) gives the biharmonic, \!\(\*RowBox[{SuperscriptBox[\"\[Del]\", \"4\"], StyleBox[\"f\", \"TI\"]}]\), of the scalar function \!\(\*StyleBox[\"f\", \"TI\"]\) in the default coordinate system. \n\!\(\*RowBox[{\"Biharmonic\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the biharmonic of \!\(\*StyleBox[\"f\", \"TI\"]\) in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`Bipolar::usage = "Bipolar represents the bipolar coordinate system with default variables Uu, Vv, and Zz and default parameter value 1. \n\!\(\*RowBox[{\"Bipolar\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) represents the bipolar coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\) and default parameter value 1. \n\!\(\*RowBox[{\"Bipolar\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) represents the bipolar coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\) and parameter \!\(\*StyleBox[\"a\", \"TI\"]\)."
VectorAnalysis`Bispherical::usage = "Bispherical represents the bispherical coordinate system with default variables Uu, Vv, and Pphi and default parameter value 1. \n\!\(\*RowBox[{\"Bispherical\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) represents the bispherical coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\) and default parameter value 1. \n\!\(\*RowBox[{\"Bispherical\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) represents the bispherical coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\) and parameter \!\(\*StyleBox[\"a\", \"TI\"]\)."
VectorAnalysis`Cartesian::usage = "Cartesian represents the Cartesian coordinate system with default variables Xx, Yy, and Zz.\n\!\(\*RowBox[{\"Cartesian\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) represents the Cartesian coordinate system with variables \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\)."
VectorAnalysis`ConfocalEllipsoidal::usage = "ConfocalEllipsoidal represents the confocal ellipsoidal coordinate system with default variables Llambda, Mmu, and Nnu and default parameter values 3, 2, and 1. \n\!\(\*RowBox[{\"ConfocalEllipsoidal\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents the confocal ellipsoidal coordinate system with variables \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\), \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) and default parameter values 3, 2, and 1. \n\!\(\*RowBox[{\"ConfocalEllipsoidal\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"], \",\", StyleBox[\"c\", \"TI\"]}], \"]\"}]\) represents the confocal ellipsoidal coordinate system with variables \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\), \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) and parameters \!\(\*StyleBox[\"a\", \"TI\"]\), \!\(\*StyleBox[\"b\", \"TI\"]\), and \!\(\*StyleBox[\"c\", \"TI\"]\)."
VectorAnalysis`ConfocalParaboloidal::usage = "ConfocalParaboloidal represents the confocal paraboloidal coordinate system with default variables Llambda, Mmu, and Nnu and default parameter values 2 and 1. \n\!\(\*RowBox[{\"ConfocalParaboloidal\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents the confocal paraboloidal coordinate system with variables \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\), \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) and default parameter values 2 and 1.\n\!\(\*RowBox[{\"ConfocalParaboloidal\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) represents the confocal paraboloidal coordinate system with variables \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\), \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) and parameters \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\)."
VectorAnalysis`Conical::usage = "Conical represents the conical coordinate system with default variables Llambda, Mmu, and Nnu and default parameter values 1 and 2. \n\!\(\*RowBox[{\"Conical\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"]}], \"]\"}]\) represents the conical coordinate system with variables \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\), \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) and default parameter values 1 and 2. \n\!\(\*RowBox[{\"Conical\", \"[\", RowBox[{StyleBox[\"\[Lambda]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"b\", \"TI\"]}], \"]\"}]\) represents the conical coordinate system with variables \!\(\*StyleBox[\"\[Lambda]\", \"TR\"]\), \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) and parameters \!\(\*StyleBox[\"a\", \"TI\"]\) and \!\(\*StyleBox[\"b\", \"TI\"]\)."
VectorAnalysis`CoordinateRanges::usage = "\!\(\*RowBox[{\"CoordinateRanges\", \"[\", \"]\"}]\) gives the intervals over which each of the coordinates in the default coordinate system may range. \n\!\(\*RowBox[{\"CoordinateRanges\", \"[\", StyleBox[\"coordsys\", \"TI\"], \"]\"}]\) gives the ranges for each of the coordinates in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`CoordinatesFromCartesian::usage = "\!\(\*RowBox[{\"CoordinatesFromCartesian\", \"[\", StyleBox[\"pt\", \"TI\"], \"]\"}]\) gives the coordinates in the default coordinate system of the point \!\(\*StyleBox[\"pt\", \"TI\"]\) given in Cartesian coordinates. \n\!\(\*RowBox[{\"CoordinatesFromCartesian\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the coordinates in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\) of the point given in Cartesian coordinates."
VectorAnalysis`CoordinatesToCartesian::usage = "\!\(\*RowBox[{\"CoordinatesToCartesian\", \"[\", StyleBox[\"pt\", \"TI\"], \"]\"}]\) gives the Cartesian coordinates of the point \!\(\*StyleBox[\"pt\", \"TI\"]\) given in the default coordinate system. \n\!\(\*RowBox[{\"CoordinatesToCartesian\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the Cartesian coordinates of the point given in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`Coordinates::usage = "\!\(\*RowBox[{\"Coordinates\", \"[\", \"]\"}]\) gives a list of the default coordinate variables in the default coordinate system. \n\!\(\*RowBox[{\"Coordinates\", \"[\", StyleBox[\"coordsys\", \"TI\"], \"]\"}]\) gives a list of the default coordinate variables in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`CoordinateSystem::usage = "CoordinateSystem gives the name of the default coordinate system."
VectorAnalysis`CrossProduct::usage = "\!\(\*RowBox[{\"CrossProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the cross product of the two 3-vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in the default coordinate system. \n\!\(\*RowBox[{\"CrossProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the cross product of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`Cylindrical::usage = "Cylindrical represents the cylindrical coordinate system with default variables Rr, Ttheta, and Zz.\n\!\(\*RowBox[{\"Cylindrical\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) represents the cylindrical coordinate system with variables \!\(\*StyleBox[\"r\", \"TI\"]\), \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\)."
VectorAnalysis`DotProduct::usage = "\!\(\*RowBox[{\"DotProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives the dot product of the two 3-vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in the default coordinate system. \n\!\(\*RowBox[{\"DotProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the dot product of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`Eeta::usage = "Eeta is one of the default coordinates for the ProlateSpheroidal and OblateSpheroidal coordinate systems."
VectorAnalysis`EllipticCylindrical::usage = "EllipticCylindrical represents the elliptic cylindrical coordinate system with default variables Uu, Vv, and Zz and default parameter value 1. \n\!\(\*RowBox[{\"EllipticCylindrical\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) represents the elliptic cylindrical coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\) and default parameter value 1. \n\!\(\*RowBox[{\"EllipticCylindrical\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) represents the elliptic cylindrical coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\) and parameter \!\(\*StyleBox[\"a\", \"TI\"]\)."
VectorAnalysis`JacobianDeterminant::usage = "\!\(\*RowBox[{\"JacobianDeterminant\", \"[\", StyleBox[\"pt\", \"TI\"], \"]\"}]\) gives the determinant of the Jacobian matrix of the transformation from the default coordinate system to the Cartesian coordinate system at the point \!\(\*StyleBox[\"pt\", \"TI\"]\). \n\!\(\*RowBox[{\"JacobianDeterminant\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the determinant of the Jacobian matrix of the transformation from the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\) to the Cartesian coordinate system at the point \!\(\*StyleBox[\"pt\", \"TI\"]\)."
VectorAnalysis`JacobianMatrix::usage = "\!\(\*RowBox[{\"JacobianMatrix\", \"[\", StyleBox[\"pt\", \"TI\"], \"]\"}]\) gives the Jacobian matrix of the transformation from the default coordinate system to the Cartesian coordinate system at the point \!\(\*StyleBox[\"pt\", \"TI\"]\). \n\!\(\*RowBox[{\"JacobianMatrix\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the Jacobian matrix of the transformation from the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\) to the Cartesian coordinate system at the point \!\(\*StyleBox[\"pt\", \"TI\"]\)."
VectorAnalysis`Llambda::usage = "Llambda is one of the default coordinates for the Conical, ConfocalEllipsoidal, and ConfocalParaboloidal coordinate systems."
VectorAnalysis`Mmu::usage = "Mmu is one of the default coordinates for the Conical, ConfocalEllipsoidal, and ConfocalParaboloidal coordinate systems."
VectorAnalysis`Nnu::usage = "Nnu is one of the default coordinates for the Conical, ConfocalEllipsoidal, and ConfocalParaboloidal coordinate systems."
VectorAnalysis`OblateSpheroidal::usage = "OblateSpheroidal represents the oblate spheroidal coordinate system with default variables Xxi, Eeta, and Pphi and default parameter value 1. \n\!\(\*RowBox[{\"OblateSpheroidal\", \"[\", RowBox[{StyleBox[\"\[Xi]\", \"TR\"], \",\", StyleBox[\"\[Eta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) represents the oblate spheroidal coordinate system with variables \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\), \!\(\*StyleBox[\"\[Eta]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\) and default parameter value 1. \n\!\(\*RowBox[{\"OblateSpheroidal\", \"[\", RowBox[{StyleBox[\"\[Xi]\", \"TR\"], \",\", StyleBox[\"\[Eta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) represents the oblate spheroidal coordinate system with variables \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\), \!\(\*StyleBox[\"\[Eta]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\) and parameter \!\(\*StyleBox[\"a\", \"TI\"]\)."
VectorAnalysis`ParabolicCylindrical::usage = "ParabolicCylindrical represents the parabolic cylindrical coordinate system with default variables Uu, Vv, and Zz. \n\!\(\*RowBox[{\"ParabolicCylindrical\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) represents the parabolic cylindrical coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\)."
VectorAnalysis`Paraboloidal::usage = "Paraboloidal represents the paraboloidal coordinate system with default variables Uu, Vv, and Pphi.\n\!\(\*RowBox[{\"Paraboloidal\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) represents the paraboloidal coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\)."
VectorAnalysis`ParameterRanges::usage = "\!\(\*RowBox[{\"ParameterRanges\", \"[\", \"]\"}]\) gives the intervals over which each the of the parameters in the default coordinate system may range. \n\!\(\*RowBox[{\"ParameterRanges\", \"[\", StyleBox[\"coordsys\", \"TI\"], \"]\"}]\) gives the ranges for each of the parameters in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`Parameters::usage = "\!\(\*RowBox[{\"Parameters\", \"[\", \"]\"}]\) gives a list of the default parameters of the default coordinate system. \n\!\(\*RowBox[{\"Parameters\", \"[\", StyleBox[\"coordsys\", \"TI\"], \"]\"}]\) gives a list of the default parameters in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`Pphi::usage = "Pphi is one of the default coordinates for the Bispherical, OblateSpheroidal, Paraboloidal, ProlateSpheroidal, Spherical, and Toroidal coordinate systems."
VectorAnalysis`ProlateSpheroidal::usage = "ProlateSpheroidal represents the prolate spheroidal coordinate system with default variables Xxi, Eeta, and Pphi and default parameter value 1. \n\!\(\*RowBox[{\"ProlateSpheroidal\", \"[\", RowBox[{StyleBox[\"\[Xi]\", \"TR\"], \",\", StyleBox[\"\[Eta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) represents the prolate spheroidal coordinate system with variables \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\), \!\(\*StyleBox[\"\[Eta]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\) and default parameter value 1. \n\!\(\*RowBox[{\"ProlateSpheroidal\", \"[\", RowBox[{StyleBox[\"\[Xi]\", \"TR\"], \",\", StyleBox[\"\[Eta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) represents the prolate spheroidal coordinate system with variables \!\(\*StyleBox[\"\[Xi]\", \"TR\"]\), \!\(\*StyleBox[\"\[Eta]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\) and parameter \!\(\*StyleBox[\"a\", \"TI\"]\)."
VectorAnalysis`Rr::usage = "Rr is one of the default coordinates for the Cylindrical and Spherical coordinate systems."
VectorAnalysis`ScalarTripleProduct::usage = "\!\(\*RowBox[{\"ScalarTripleProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"]\"}]\) gives the scalar triple product of the three 3-vectors \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"3\", \"TR\"]]\) in the default coordinate system. \n\!\(\*RowBox[{\"ScalarTripleProduct\", \"[\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"3\", \"TR\"]], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives the scalar triple product of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"3\", \"TR\"]]\) in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`ScaleFactors::usage = "\!\(\*RowBox[{\"ScaleFactors\", \"[\", StyleBox[\"pt\", \"TI\"], \"]\"}]\) gives a list of the scale factors at the point \!\(\*StyleBox[\"pt\", \"TI\"]\) in the default coordinate system. \n\!\(\*RowBox[{\"ScaleFactors\", \"[\", RowBox[{StyleBox[\"pt\", \"TI\"], \",\", StyleBox[\"coordsys\", \"TI\"]}], \"]\"}]\) gives a list of the scale factors in the coordinate system \!\(\*StyleBox[\"coordsys\", \"TI\"]\)."
VectorAnalysis`SetCoordinates::usage = "\!\(\*RowBox[{\"SetCoordinates\", \"[\", StyleBox[\"coordsys\", \"TI\"], \"]\"}]\) sets the default coordinate system to be \!\(\*StyleBox[\"coordsys\", \"TI\"]\) with default variables. \n\!\(\*RowBox[{\"SetCoordinates\", \"[\", RowBox[{StyleBox[\"coordsys\", \"TI\"], \"[\", RowBox[{SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"]\"}], \"]\"}]\) sets the default coordinate system to be \!\(\*StyleBox[\"coordsys\", \"TI\"]\) with variables \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), and \!\(\*SubscriptBox[StyleBox[\"c\", \"TI\"], StyleBox[\"3\", \"TR\"]]\)."
VectorAnalysis`Spherical::usage = "Spherical represents the spherical coordinate system with default variables Rr, Ttheta, and Pphi. \n\!\(\*RowBox[{\"Spherical\", \"[\", RowBox[{StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) represents the spherical coordinate system with variables \!\(\*StyleBox[\"r\", \"TI\"]\), \!\(\*StyleBox[\"\[Theta]\", \"TR\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\)."
VectorAnalysis`Toroidal::usage = "Toroidal represents the toroidal coordinate system with default variables Uu, Vv, and Pphi and default parameter value 1. \n\!\(\*RowBox[{\"Toroidal\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) represents the toroidal coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\) and default parameter value 1.\n\!\(\*RowBox[{\"Toroidal\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"], \",\", StyleBox[\"\[Phi]\", \"TR\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) represents the toroidal coordinate system with variables \!\(\*StyleBox[\"u\", \"TI\"]\), \!\(\*StyleBox[\"v\", \"TI\"]\), and \!\(\*StyleBox[\"\[Phi]\", \"TR\"]\) and parameter \!\(\*StyleBox[\"a\", \"TI\"]\)."
VectorAnalysis`Ttheta::usage = "Ttheta is one of the default coordinates for the Cylindrical and Spherical coordinate systems."
VectorAnalysis`Uu::usage = "Uu is one of the default coordinates for the Bipolar, Bispherical, ParabolicCylindrical, Paraboloidal, EllipticCylindrical, and Toroidal coordinate systems."
VectorAnalysis`Vv::usage = "Vv is one of the default coordinates for the Bipolar, Bispherical, ParabolicCylindrical, Paraboloidal, EllipticCylindrical, and Toroidal coordinate systems."
VectorAnalysis`Xxi::usage = "Xxi is one of the default coordinates for the ProlateSpheroidal and OblateSpheroidal coordinate systems."
VectorAnalysis`Xx::usage = "Xx is one of the default coordinates for the Cartesian coordinate system."
VectorAnalysis`Yy::usage = "Yy is one of the default coordinates for the Cartesian coordinate system."
VectorAnalysis`Zz::usage = "Zz is one of the default coordinates for the Bipolar, Cartesian, Cylindrical, EllipticCylindrical, and ParabolicCylindrical coordinate systems."
VectorAngle::usage = "\!\(\*RowBox[{\"VectorAngle\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the angle between the vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
VectorColorFunctionScaling::usage = "VectorColorFunctionScaling is an option for graphics functions which specifies whether arguments supplied to a vector color function should be scaled to lie between 0 and 1. "
VectorColorFunction::usage = "VectorColorFunction is an option for VectorPlot and related functions which specifies a function to apply to determine colors of field vectors drawn. "
VectorDensityPlot::usage = "\!\(\*RowBox[{\"VectorDensityPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"s\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a vector plot of the vector field \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\), superimposed on a density plot of the scalar field \!\(\*StyleBox[\"s\", \"TI\"]\). \n\!\(\*RowBox[{\"VectorDensityPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) takes the scalar field to be the norm of the vector field.\n\!\(\*RowBox[{\"VectorDensityPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", StyleBox[\"s\", \"TI\"]}], StyleBox[\"}\", \"TR\"]}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots several vector fields. \n\!\(\*RowBox[{\"VectorDensityPlot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes the variables \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\). "
VectorFieldPlots`GradientFieldPlot3D::usage = "\!\(\*RowBox[{\"GradientFieldPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a three-dimensional plot of the gradient vector field of the scalar function \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\) and \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"GradientFieldPlot3D\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dz\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dx\", \"TI\"]\), \!\(\*StyleBox[\"dy\", \"TI\"]\) and \!\(\*StyleBox[\"dz\", \"TI\"]\) in variables \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\) and \!\(\*StyleBox[\"z\", \"TI\"]\) respectively."
VectorFieldPlots`GradientFieldPlot::usage = "\!\(\*RowBox[{\"GradientFieldPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the gradient vector field of the scalar function \!\(\*StyleBox[\"f\", \"TI\"]\).\n\!\(\*RowBox[{\"GradientFieldPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dx\", \"TI\"]\) in variable \!\(\*StyleBox[\"x\", \"TI\"]\), and steps \!\(\*StyleBox[\"dy\", \"TI\"]\) in variable \!\(\*StyleBox[\"y\", \"TI\"]\)."
VectorFieldPlots`HamiltonianFieldPlot::usage = "\!\(\*RowBox[{\"HamiltonianFieldPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the Hamiltonian vector field of the scalar-valued function \!\(\*StyleBox[\"f\", \"TI\"]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\).\n\!\(\*RowBox[{\"HamiltonianFieldPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dx\", \"TI\"]\) in variable \!\(\*StyleBox[\"x\", \"TI\"]\), and steps \!\(\*StyleBox[\"dy\", \"TI\"]\) in variable \!\(\*StyleBox[\"y\", \"TI\"]\)."
VectorFieldPlots`ListVectorFieldPlot3D::usage = "\!\(\*RowBox[{\"ListVectorFieldPlot3D\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a three-dimensional plot of the list of vectors \!\(\*RowBox[{SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", \" \", SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", \" \", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\), with each vector based at a corresponding point \!\(\*RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
VectorFieldPlots`ListVectorFieldPlot::usage = "\!\(\*RowBox[{\"ListVectorFieldPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"11\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"12\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"12\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a plot of the vector field corresponding to the array of vectors \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"11\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"11\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]\).\n\!\(\*RowBox[{\"ListVectorFieldPlot\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"pt\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"vec\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a plot of a list of vectors, each based at the corresponding point."
VectorFieldPlots`MaxArrowLength::usage = "MaxArrowLength is an option for the vector field visualization functions that determines the longest vector to be drawn."
VectorFieldPlots`PolyaFieldPlot::usage = "\!\(\*RowBox[{\"PolyaFieldPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the complex-valued function \!\(\*StyleBox[\"f\", \"TI\"]\) in the complex plane using the Polya representation.\n\!\(\*RowBox[{\"PolyaFieldPlot\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dx\", \"TI\"]\) in real component \!\(\*StyleBox[\"x\", \"TI\"]\) and steps \!\(\*StyleBox[\"dy\", \"TI\"]\) in imaginary component \!\(\*StyleBox[\"y\", \"TI\"]\)."
VectorFieldPlots`ScaleFactor::usage = "ScaleFactor is an option for the vector field visualization functions that scales the vectors so that the longest vector displayed is of the length specified."
VectorFieldPlots`ScaleFunction::usage = "ScaleFunction is an option for the vector field visualization functions that rescales each vector to a length determined by applying a pure function to the current length of that vector."
VectorFieldPlots`VectorFieldPlot3D::usage = "\!\(\*RowBox[{\"VectorFieldPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a three-dimensional plot of the vector field given by the vector-valued function \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\) and \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"VectorFieldPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}], \",\", RowBox[{StyleBox[\"{\", \"TR\"], RowBox[{StyleBox[\"y\", \"TR\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dz\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dx\", \"TI\"]\), \!\(\*StyleBox[\"dy\", \"TI\"]\) and \!\(\*StyleBox[\"dz\", \"TI\"]\) for variables \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\) and \!\(\*StyleBox[\"z\", \"TI\"]\) respectively."
VectorFieldPlots`VectorFieldPlot::usage = "\!\(\*RowBox[{\"VectorFieldPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a plot of the vector field given by the vector valued function \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\).\n\!\(\*RowBox[{\"VectorFieldPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"f\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dx\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]}], \"]\"}]\) uses steps \!\(\*StyleBox[\"dx\", \"TI\"]\) in variable \!\(\*StyleBox[\"x\", \"TI\"]\), and steps \!\(\*StyleBox[\"dy\", \"TI\"]\) in variable \!\(\*StyleBox[\"y\", \"TI\"]\)."
VectorFieldPlots`VectorHeads::usage = "VectorHeads is an option for the three-dimensional vector field functions, including VectorFieldPlot3D, that determines whether the vectors will be displayed with heads. "
VectorPlot3D::usage = "\!\(\*RowBox[{\"VectorPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a 3D vector plot of the vector field \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"z\", \"TI\"]]}], \"}\"}]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"VectorPlot3D\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"field\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"field\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"z\", \"TI\"], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots several vector fields."
VectorPlot::usage = "\!\(\*RowBox[{\"VectorPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) generates a vector plot of the vector field \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}]\) as a function of \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\). \n\!\(\*RowBox[{\"VectorPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"x\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"y\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) plots several vector fields. \n\!\(\*RowBox[{\"VectorPlot\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}], \"\[Element]\", StyleBox[\"reg\", \"TI\"]}]}], \"]\"}]\) takes the variables \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"]}], \"}\"}]\) to be in the geometric region \!\(\*StyleBox[\"reg\", \"TI\"]\). "
VectorPoints::usage = "VectorPoints is an option to VectorPlot, ListVectorPlot, and related functions that determines how many field vectors to draw. "
VectorQ::usage = "\!\(\*RowBox[{\"VectorQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) gives True if \!\(\*StyleBox[\"expr\", \"TI\"]\) is a list or a one\[Hyphen]dimensional SparseArray object, none of whose elements are themselves lists, and gives False otherwise. \n\!\(\*RowBox[{\"VectorQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"test\", \"TI\"]}], \"]\"}]\) gives True only if \!\(\*StyleBox[\"test\", \"TI\"]\) yields True when applied to each of the elements in \!\(\*StyleBox[\"expr\", \"TI\"]\). "
VectorScale::usage = "VectorScale is an option to VectorPlot, ListVectorPlot, and related functions that determines the length and arrowhead size of field vectors that are drawn. "
VectorStyle::usage = "VectorStyle is an option to VectorPlot, ListVectorPlot, and related functions that determines the style to use for drawing field vectors."
Vectors::usage = "\!\(\*RowBox[{\"Vectors\", \"[\", StyleBox[\"d\", \"TI\"], \"]\"}]\) represents the domain of vectors of dimension \!\(\*StyleBox[\"d\", \"TI\"]\).\n\!\(\*RowBox[{\"Vectors\", \"[\", RowBox[{StyleBox[\"d\", \"TI\"], \",\", StyleBox[\"dom\", \"TI\"]}], \"]\"}]\) represents the domain of vectors of dimension \!\(\*StyleBox[\"d\", \"TI\"]\), with components in the domain \!\(\*StyleBox[\"dom\", \"TI\"]\)."
Vee::usage = "\!\(\*RowBox[{\"Vee\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Vee]\", StyleBox[\"y\", \"TI\"], \"\[Vee]\", \"\[Ellipsis]\"}]\)."
Verbatim::usage = "\!\(\*RowBox[{\"Verbatim\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) represents \!\(\*StyleBox[\"expr\", \"TI\"]\) in pattern matching, requiring that \!\(\*StyleBox[\"expr\", \"TI\"]\) be matched exactly as it appears, with no substitutions for blanks or other transformations. "
VerificationTest::usage = "\!\(\*RowBox[{\"VerificationTest\", \"[\", StyleBox[\"input\", \"TI\"], \"]\"}]\) runs a verification test to determine whether \!\(\*StyleBox[\"input\", \"TI\"]\) evaluates to True, without issuing messages.\n\!\(\*RowBox[{\"VerificationTest\", \"[\", RowBox[{StyleBox[\"input\", \"TI\"], \",\", StyleBox[\"expected\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"input\", \"TI\"]\) evaluates to \!\(\*StyleBox[\"expected\", \"TI\"]\), without issuing messages.\n\!\(\*RowBox[{\"VerificationTest\", \"[\", RowBox[{StyleBox[\"input\", \"TI\"], \",\", StyleBox[\"expected\", \"TI\"], \",\", StyleBox[\"messages\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"input\", \"TI\"]\) evaluates to \!\(\*StyleBox[\"expected\", \"TI\"]\), generating the list of message names \!\(\*StyleBox[\"messages\", \"TI\"]\)."
VerifyConvergence::usage = "VerifyConvergence is an option to Sum, NSum, and similar functions that specifies whether convergence checking should be done."
VerifySolutions::usage = "VerifySolutions is an option to Solve and related functions that controls whether to verify solutions. "
VerifyTestAssumptions::usage = "VerifyTestAssumptions is an option to LocationTest and similar functions that controls which assumptions to verify through diagnostic tests."
VertexAdd::usage = "\!\(\*RowBox[{\"VertexAdd\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) makes a graph by adding the vertex \!\(\*StyleBox[\"v\", \"TI\"]\) to the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexAdd\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) adds a collection of vertices to \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexAdd\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
VertexCapacity::usage = "VertexCapacity is an option and property for Graph and related functions that specifies a vertex capacity."
VertexColors::usage = "VertexColors is an option for graphics primitives which specifies the colors to assign to vertices."
VertexComponent::usage = "\!\(\*RowBox[{\"VertexComponent\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) that have a path to at least one of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"VertexComponent\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the vertices with a path to at least one of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] of at most length \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexComponent\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexConnectivity::usage = "\!\(\*RowBox[{\"VertexConnectivity\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the vertex connectivity of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexConnectivity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) gives the \!\(\*StyleBox[\"s\", \"TI\"]\)-\!\(\*StyleBox[\"t\", \"TI\"]\) vertex connectivity of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexConnectivity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexContract::usage = "\!\(\*RowBox[{\"VertexContract\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) contracts a collection of vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] into a single vertex of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexContract\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) contracts several collections of vertices. \n\!\(\*RowBox[{\"VertexContract\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexCoordinateRules::usage = "VertexCoordinateRules is an option for GraphPlot and related functions which specifies rules for determining the coordinates at which vertices should be placed."
VertexCoordinates::usage = "VertexCoordinates is an option to Graph and related functions that specifies the coordinates to use to place the center of vertices."
VertexCorrelationSimilarity::usage = "\!\(\*RowBox[{\"VertexCorrelationSimilarity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the correlation similarity between vertices \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\) of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexCorrelationSimilarity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexCosineSimilarity::usage = "\!\(\*RowBox[{\"VertexCosineSimilarity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the cosine similarity between vertices \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\) of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexCosineSimilarity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexCount::usage = "\!\(\*RowBox[{\"VertexCount\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives a count of the number of vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexCount\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a count of the number of vertices that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexCount\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexCoverQ::usage = "\!\(\*RowBox[{\"VertexCoverQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"vlist\", \"TI\"]}], \"]\"}]\) yields True if the vertex list \!\(\*StyleBox[\"vlist\", \"TI\"]\) is a vertex cover of the graph \!\(\*StyleBox[\"g\", \"TI\"]\), and False otherwise."
VertexDataCoordinates::usage = "VertexDataCoordinates is an option to Raster3D that determines how to map data to the displayed range."
VertexDegree::usage = "\!\(\*RowBox[{\"VertexDegree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of vertex degrees for all vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexDegree\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the vertex degree for the vertex \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexDegree\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexDelete::usage = "\!\(\*RowBox[{\"VertexDelete\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) makes a graph by deleting the vertex \!\(\*StyleBox[\"\[Nu]\", \"TR\"]\) and all edges connected to \!\(\*StyleBox[\"v\", \"TI\"]\) from the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexDelete\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{StyleBox[\"{\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) deletes a collection of vertices from \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexDelete\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) deletes all vertices that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexDelete\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexDiceSimilarity::usage = "\!\(\*RowBox[{\"VertexDiceSimilarity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Dice similarity between vertices \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\) of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexDiceSimilarity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexEccentricity::usage = "\!\(\*RowBox[{\"VertexEccentricity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"s\", \"TI\"]}], \"]\"}]\) gives the length of the longest shortest path from the source \!\(\*StyleBox[\"s\", \"TI\"]\) to every other vertex in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexEccentricity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
VertexInComponent::usage = "\!\(\*RowBox[{\"VertexInComponent\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) that have a directed path to at least one of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"VertexInComponent\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the vertices with a directed path to at least one of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] of at most length \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexInComponent\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexInDegree::usage = "\!\(\*RowBox[{\"VertexInDegree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of vertex in-degrees for all vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexInDegree\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the vertex in-degree for the vertex \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexInDegree\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexIndex::usage = "\!\(\*RowBox[{\"VertexIndex\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the integer index for the vertex \!\(\*StyleBox[\"v\", \"TI\"]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexIndex\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\)."
VertexJaccardSimilarity::usage = "\!\(\*RowBox[{\"VertexJaccardSimilarity\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Jaccard similarity between vertices \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\) of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexJaccardSimilarity\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
VertexLabeling::usage = "VertexLabeling is an option for GraphPlot and related functions which specifies whether labeling should be included by default for vertices in graphs."
VertexLabelStyle::usage = "VertexLabelStyle is an option and property for Graph and related functions that specifies the style to use for vertex labels."
VertexLabels::usage = "VertexLabels is an option and property for Graph and related functions that specifies what labels and label positions should be used for vertices."
VertexList::usage = "\!\(\*RowBox[{\"VertexList\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of vertices for the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexList\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives a list of vertices that match the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexList\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
VertexNormals::usage = "VertexNormals is an option for graphics primitives which specifies the normal directions to assign to 3D vertices."
VertexOutComponent::usage = "\!\(\*RowBox[{\"VertexOutComponent\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) that have a directed path from at least one of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"VertexOutComponent\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) gives the vertices with a directed path from at least one of \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] of at most length \!\(\*StyleBox[\"k\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexOutComponent\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
VertexOutDegree::usage = "\!\(\*RowBox[{\"VertexOutDegree\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the list of vertex out-degrees for all vertices in the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexOutDegree\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the vertex out-degree for the vertex \!\(\*StyleBox[\"v\", \"TI\"]\).\n\!\(\*RowBox[{\"VertexOutDegree\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
VertexQ::usage = "\!\(\*RowBox[{\"VertexQ\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) yields True if \!\(\*StyleBox[\"v\", \"TI\"]\) is a vertex in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) and False otherwise."
VertexRenderingFunction::usage = "VertexRenderingFunction is an option for GraphPlot and related functions that gives a function to generate the graphics primitives to use in rendering each vertex."
VertexReplace::usage = "\!\(\*RowBox[{\"VertexReplace\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) replaces each vertex \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in the graph \!\(\*StyleBox[\"g\", \"TI\"]\) by \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"VertexReplace\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
VertexShapeFunction::usage = "VertexShapeFunction is an option and property for Graph and related functions that specifies a function to use to generate primitives for rendering each vertex. "
VertexShape::usage = "VertexShape is an option and property for Graph and related functions that specifies the graphics used for vertices."
VertexSize::usage = "VertexSize is an option and property for Graph and related functions that specifies the size used for vertices. "
VertexStyle::usage = "VertexStyle is an option and property for Graph and related functions that specifies what style to use for vertices. "
VertexTextureCoordinates::usage = "VertexTextureCoordinates is an option for graphics primitives that specifies the texture coordinates to assign to vertices."
VertexWeight::usage = "VertexWeight is an option and property for Graph and related functions that specifies a vertex weight."
VerticalBar::usage = "\!\(\*RowBox[{\"VerticalBar\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[VerticalBar]\", StyleBox[\"y\", \"TI\"], \"\[VerticalBar]\", \"\[Ellipsis]\"}]\)."
VerticalForm::usage = "VerticalForm is an internal symbol used for formatting and printing."
VerticalGauge::usage = "\!\(\*RowBox[{\"VerticalGauge\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}]\) draws a linear gauge showing \!\(\*StyleBox[\"value\", \"TI\"]\) in a range of 0 to 1.\n\!\(\*RowBox[{\"VerticalGauge\", \"[\", RowBox[{StyleBox[\"value\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"min\", \"TI\"], \",\", StyleBox[\"max\", \"TI\"]}], \"}\"}]}], \"]\"}]\) draws a linear gauge showing \!\(\*StyleBox[\"value\", \"TI\"]\) in a range of \!\(\*StyleBox[\"min\", \"TI\"]\) to \!\(\*StyleBox[\"max\", \"TI\"]\).\n\!\(\*RowBox[{\"VerticalGauge\", \"[\", RowBox[{RowBox[{\"Dynamic\", \"[\", StyleBox[\"value\", \"TI\"], \"]\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) allows \!\(\*StyleBox[\"value\", \"TI\"]\) to be set interactively using the gauge.\n\!\(\*RowBox[{\"VerticalGauge\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) draws a gauge showing multiple values."
VerticalSeparator::usage = "\!\(\*RowBox[{\"VerticalSeparator\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[VerticalSeparator]\", StyleBox[\"y\", \"TI\"], \"\[VerticalSeparator]\", \"\[Ellipsis]\"}]\)."
VerticalSlider::usage = "\!\(\*RowBox[{\"VerticalSlider\", \"[\", StyleBox[\"y\", \"TI\"], \"]\"}]\) represents a vertical slider at position \!\(\*StyleBox[\"y\", \"TI\"]\) with range 0 to 1. \n\!\(\*RowBox[{\"VerticalSlider\", \"[\", RowBox[{\"Dynamic\", \"[\", StyleBox[\"y\", \"TI\"], \"]\"}], \"]\"}]\) takes the position to be the dynamically updated current value of \!\(\*StyleBox[\"y\", \"TI\"]\), with the value of \!\(\*StyleBox[\"y\", \"TI\"]\) being reset if the slider is moved. \n\!\(\*RowBox[{\"VerticalSlider\", \"[\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) represents a vertical slider with range \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]]\) to \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]]\). \n\!\(\*RowBox[{\"VerticalSlider\", \"[\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"max\", \"TI\"]], \",\", StyleBox[\"dy\", \"TI\"]}], \"}\"}]}], \"]\"}]\) represents a vertical slider that jumps in steps \!\(\*StyleBox[\"dy\", \"TI\"]\). \n\!\(\*RowBox[{\"VerticalSlider\", \"[\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) represents a slider in which equally spaced intervals correspond to successive settings \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"VerticalSlider\", \"[\", RowBox[{StyleBox[\"y\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"h\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"h\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"}\"}]}], \"]\"}]\) uses intervals of relative heights \!\(\*SubscriptBox[StyleBox[\"h\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) for the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). "
VerticalTilde::usage = "\!\(\*RowBox[{\"VerticalTilde\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[VerticalTilde]\", StyleBox[\"y\", \"TI\"], \"\[VerticalTilde]\", \"\[Ellipsis]\"}]\)."
ViewAngle::usage = "ViewAngle is an option for Graphics3D and related functions that gives the opening angle for a simulated camera used to view the three-dimensional scene. "
ViewCenter::usage = "ViewCenter is an option for Graphics3D and related functions which gives the scaled coordinates of the point which should appear at the center of the final image. "
ViewMatrix::usage = "ViewMatrix is an option for Graphics3D and related functions that can be used to specify a pair of explicit homogeneous transformation and projection matrices for 3D coordinates."
ViewPoint::usage = "ViewPoint is an option for Graphics3D and related functions which gives the point in space from which three\[Hyphen]dimensional objects are to be viewed. "
ViewRange::usage = "ViewRange is an option for Graphics3D and related functions which specifies the range of distances from the view point to be included in displaying a three-dimensional scene. "
ViewVector::usage = "ViewVector is an option for Graphics3D and related functions which specifies the position and direction of a simulated camera used to view three-dimensional objects. "
ViewVertical::usage = "ViewVertical is an option for Graphics3D and related functions which specifies what direction in scaled coordinates should be vertical in the final image. "
Visible::usage = "Visible is a notebook option which specifies whether the notebook should be explicitly displayed on the screen. "
VoigtDistribution::usage = "\!\(\*RowBox[{\"VoigtDistribution\", \"[\", RowBox[{StyleBox[\"\[Delta]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents Voigt distribution with parameters \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\)."
VolcanoData::usage = "\!\(\*RowBox[{\"VolcanoData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the volcano \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"VolcanoData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified volcano entities.\n\!\(\*RowBox[{\"VolcanoData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
Volume::usage = "\!\(\*RowBox[{\"Volume\", \"[\", StyleBox[\"reg\", \"TI\"], \"]\"}]\) gives the volume of the three-dimensional region \!\(\*StyleBox[\"reg\", \"TI\"]\).\n\!\(\*RowBox[{\"Volume\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}]}], \"]\"}]\) gives the volume of the parametrized region whose Cartesian coordinates \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are functions of \!\(\*StyleBox[\"s\", \"TI\"]\), \!\(\*StyleBox[\"t\", \"TI\"]\), \!\(\*StyleBox[\"u\", \"TI\"]\).\n\!\(\*RowBox[{\"Volume\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"t\", \"TI\"], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"t\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"u\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"chart\", \"TI\"]}], \"]\"}]\) interprets the \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) as coordinates in the specified coordinate chart."
VonMisesDistribution::usage = "\!\(\*RowBox[{\"VonMisesDistribution\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Kappa]\", \"TR\"]}], \"]\"}]\) represents a von Mises distribution with mean \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and concentration \!\(\*StyleBox[\"\[Kappa]\", \"TR\"]\)."
VoronoiMesh::usage = "\!\(\*RowBox[{\"VoronoiMesh\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) gives a MeshRegion representing the Voronoi mesh from the points \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis].\n\!\(\*RowBox[{\"VoronoiMesh\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"min\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"max\", \"TI\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) clips the mesh to the bounds \!\(\*RowBox[{RowBox[{\"[\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], \"min\"], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], \"max\"]}], \"]\"}], \"\[Times]\", \"\[CenterEllipsis]\"}]\)."
WaitAll::usage = "\!\(\*RowBox[{\"WaitAll\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) waits for all concurrent evaluations represented by EvaluationObject expressions in \!\(\*StyleBox[\"expr\", \"TI\"]\) to finish, then returns the resulting expression obtained."
WaitAsynchronousTask::usage = "\!\(\*RowBox[{\"WaitAsynchronousTask\", \"[\", StyleBox[\"task\", \"TI\"], \"]\"}]\) waits for \!\(\*StyleBox[\"task\", \"TI\"]\) to complete."
WaitNext::usage = "\!\(\*RowBox[{\"WaitNext\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"eid\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"eid\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) waits until the first evaluation represented by any of the \!\(\*SubscriptBox[StyleBox[\"eid\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) finishes, then returns its result, the corresponding \!\(\*SubscriptBox[StyleBox[\"eid\", \"TI\"], StyleBox[\"i\", \"TI\"]]\), and the list of remaining \!\(\*SubscriptBox[StyleBox[\"eid\", \"TI\"], StyleBox[\"k\", \"TI\"]]\). "
WakebyDistribution::usage = "\!\(\*RowBox[{\"WakebyDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Gamma]\", \"TR\"], \",\", StyleBox[\"\[Delta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents Wakeby distribution with shape parameters \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Delta]\", \"TR\"]\), scale parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Gamma]\", \"TR\"]\), and location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
WalleniusHypergeometricDistribution::usage = "\!\(\*RowBox[{\"WalleniusHypergeometricDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"succ\", \"TI\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"tot\", \"TI\"]], \",\", StyleBox[\"w\", \"TI\"]}], \"]\"}]\) represents a Wallenius noncentral hypergeometric distribution."
WaringYuleDistribution::usage = "\!\(\*RowBox[{\"WaringYuleDistribution\", \"[\", StyleBox[\"\[Alpha]\", \"TR\"], \"]\"}]\) represents the Yule distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\).\n\!\(\*RowBox[{\"WaringYuleDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents the Waring distribution with shape parameters \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\)."
WatershedComponents::usage = "\!\(\*RowBox[{\"WatershedComponents\", \"[\", StyleBox[\"image\", \"TI\"], \"]\"}]\) computes the watershed transform of \!\(\*StyleBox[\"image\", \"TI\"]\), returning the result as an array in which positive integers label the catchment basins.\n\!\(\*RowBox[{\"WatershedComponents\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"marker\", \"TI\"]}], \"]\"}]\) uses a binary image \!\(\*StyleBox[\"marker\", \"TI\"]\) to indicate regions where basins may be created."
WatsonUSquareTest::usage = "\!\(\*RowBox[{\"WatsonUSquareTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is normally distributed using the Watson \!\(\*SuperscriptBox[StyleBox[\"U\", \"TI\"], \"2\"]\) test.\n\!\(\*RowBox[{\"WatsonUSquareTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"]}], \"]\"}]\) tests whether \!\(\*StyleBox[\"data\", \"TI\"]\) is distributed according to \!\(\*StyleBox[\"dist\", \"TI\"]\) using the Watson \!\(\*SuperscriptBox[StyleBox[\"U\", \"TI\"], \"2\"]\) test.\n\!\(\*RowBox[{\"WatsonUSquareTest\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"dist\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
WattsStrogatzGraphDistribution::usage = "\!\(\*RowBox[{\"WattsStrogatzGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"]}], \"]\"}]\) represents the Watts\[Dash]Strogatz graph distribution for \!\(\*StyleBox[\"n\", \"TI\"]\)-vertex graphs with rewiring probability \!\(\*StyleBox[\"p\", \"TI\"]\).\n\!\(\*RowBox[{\"WattsStrogatzGraphDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"p\", \"TI\"], \",\", StyleBox[\"k\", \"TI\"]}], \"]\"}]\) represents the Watts\[Dash]Strogatz graph distribution for \!\(\*StyleBox[\"n\", \"TI\"]\)-vertex graphs with rewiring probability \!\(\*StyleBox[\"p\", \"TI\"]\) starting from a \!\(\*RowBox[{\"2\", StyleBox[\"k\", \"TI\"]}]\)-regular graph."
WaveletBestBasis::usage = "\!\(\*RowBox[{\"WaveletBestBasis\", \"[\", StyleBox[\"dwd\", \"TI\"], \"]\"}]\) computes a best basis representation in the DiscreteWaveletData object \!\(\*StyleBox[\"dwd\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletBestBasis\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"cspec\", \"TI\"]}], \"]\"}]\) computes a best basis representation using the cost specification \!\(\*StyleBox[\"cspec\", \"TI\"]\)."
WaveletFilterCoefficients::usage = "\!\(\*RowBox[{\"WaveletFilterCoefficients\", \"[\", RowBox[{StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"filt\", \"TI\"]}], \"]\"}]\) gives the filter coefficients for the symbolic wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\) of type \!\(\*StyleBox[\"filt\", \"TI\"]\). "
WaveletImagePlot::usage = "\!\(\*RowBox[{\"WaveletImagePlot\", \"[\", StyleBox[\"dwd\", \"TI\"], \"]\"}]\) plots the basis tree of wavelet image coefficients in the DiscreteWaveletData \!\(\*StyleBox[\"dwd\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletImagePlot\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) plots coefficients up to refinement level \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletImagePlot\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"ifunc\", \"TI\"]}], \"]\"}]\) applies the image function \!\(\*StyleBox[\"ifunc\", \"TI\"]\) to coefficients and wavelet indexes before plotting."
WaveletListPlot::usage = "\!\(\*RowBox[{\"WaveletListPlot\", \"[\", StyleBox[\"dwd\", \"TI\"], \"]\"}]\) plots wavelet transform coefficients in the DiscreteWaveletData \!\(\*StyleBox[\"dwd\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletListPlot\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"wind\", \"TI\"]}], \"]\"}]\) plots wavelet transform coefficients corresponding to the wavelet index specification \!\(\*StyleBox[\"wind\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletListPlot\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"wind\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"func\", \"TI\"]\) to coefficients before plotting. \n\!\(\*RowBox[{\"WaveletListPlot\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"dwd\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"dwd\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) plots wavelet transform coefficients from several DiscreteWaveletData objects \!\(\*SubscriptBox[StyleBox[\"dwd\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"dwd\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \!\(\*StyleBox[\"\[Ellipsis]\", \"TR\"]\)."
WaveletMapIndexed::usage = "\!\(\*RowBox[{\"WaveletMapIndexed\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"wd\", \"TI\"]}], \"]\"}]\) applies the function \!\(\*StyleBox[\"f\", \"TI\"]\) to the arrays of coefficients and indices of a ContinuousWaveletData or DiscreteWaveletData object.\n\!\(\*RowBox[{\"WaveletMapIndexed\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"wind\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the DiscreteWaveletData coefficients specified by \!\(\*StyleBox[\"wind\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletMapIndexed\", \"[\", RowBox[{StyleBox[\"f\", \"TI\"], \",\", StyleBox[\"cwd\", \"TI\"], \",\", StyleBox[\"octvoc\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"f\", \"TI\"]\) to the ContinuousWaveletData coefficients specified by \!\(\*StyleBox[\"octvoc\", \"TI\"]\)."
WaveletMatrixPlot::usage = "\!\(\*RowBox[{\"WaveletMatrixPlot\", \"[\", StyleBox[\"dwd\", \"TI\"], \"]\"}]\) plots the basis tree of wavelet matrix coefficients in the DiscreteWaveletData \!\(\*StyleBox[\"dwd\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletMatrixPlot\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) plots coefficients up to refinement level \!\(\*StyleBox[\"r\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletMatrixPlot\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"func\", \"TI\"]\) to coefficients before plotting. "
WaveletPhi::usage = "\!\(\*RowBox[{\"WaveletPhi\", \"[\", RowBox[{StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the scaling function \!\(\*RowBox[{\"\[Phi]\", \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\) for the symbolic wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\) evaluated at \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletPhi\", \"[\", StyleBox[\"wave\", \"TI\"], \"]\"}]\) gives the scaling function as a pure function."
WaveletPsi::usage = "\!\(\*RowBox[{\"WaveletPsi\", \"[\", RowBox[{StyleBox[\"wave\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the wavelet function \!\(\*RowBox[{\"\[Psi]\", \"(\", StyleBox[\"x\", \"TI\"], \")\"}]\) for the symbolic wavelet \!\(\*StyleBox[\"wave\", \"TI\"]\) evaluated at \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletPsi\", \"[\", StyleBox[\"wave\", \"TI\"], \"]\"}]\) gives the wavelet function as a pure function."
WaveletScale::usage = "WaveletScale is an option for ContinuousWaveletTransform and related constructs used to specify the smallest resolvable scale. "
WaveletScalogram::usage = "\!\(\*RowBox[{\"WaveletScalogram\", \"[\", StyleBox[\"wd\", \"TI\"], \"]\"}]\) plots wavelet vector coefficients in a DiscreteWaveletData or ContinuousWaveletData object \!\(\*StyleBox[\"wd\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletScalogram\", \"[\", RowBox[{StyleBox[\"wd\", \"TI\"], \",\", StyleBox[\"wind\", \"TI\"]}], \"]\"}]\) plots wavelet coefficients corresponding to the wavelet index specification \!\(\*StyleBox[\"wind\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletScalogram\", \"[\", RowBox[{StyleBox[\"wd\", \"TI\"], \",\", StyleBox[\"wind\", \"TI\"], \",\", StyleBox[\"func\", \"TI\"]}], \"]\"}]\) applies \!\(\*StyleBox[\"func\", \"TI\"]\) to coefficients before plotting. "
WaveletThreshold::usage = "\!\(\*RowBox[{\"WaveletThreshold\", \"[\", StyleBox[\"dwd\", \"TI\"], \"]\"}]\) thresholds the detail wavelet coefficients in the DiscreteWaveletData object \!\(\*StyleBox[\"dwd\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletThreshold\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"tspec\", \"TI\"]}], \"]\"}]\) thresholds the coefficients using the thresholding specification \!\(\*StyleBox[\"tspec\", \"TI\"]\).\n\!\(\*RowBox[{\"WaveletThreshold\", \"[\", RowBox[{StyleBox[\"dwd\", \"TI\"], \",\", StyleBox[\"tspec\", \"TI\"], \",\", StyleBox[\"wind\", \"TI\"]}], \"]\"}]\) thresholds the wavelet coefficients given by the wavelet indices \!\(\*StyleBox[\"wind\", \"TI\"]\)."
WeaklyConnectedComponents::usage = "\!\(\*RowBox[{\"WeaklyConnectedComponents\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the weakly connected components of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"WeaklyConnectedComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) gives the weakly connected components that include at least one of the vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]]\), \[Ellipsis] .\n\!\(\*RowBox[{\"WeaklyConnectedComponents\", \"[\", RowBox[{StyleBox[\"g\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) gives the connected components that include a vertex that matches the pattern \!\(\*StyleBox[\"patt\", \"TI\"]\).\n\!\(\*RowBox[{\"WeaklyConnectedComponents\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
WeaklyConnectedGraphQ::usage = "\!\(\*RowBox[{\"WeaklyConnectedGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is weakly connected, and False otherwise."
WeakStationarity::usage = "\!\(\*RowBox[{\"WeakStationarity\", \"[\", StyleBox[\"proc\", \"TI\"], \"]\"}]\) gives conditions for the process \!\(\*StyleBox[\"proc\", \"TI\"]\) to be weakly stationary. "
WeatherData::usage = "\!\(\*RowBox[{\"WeatherData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the most recent measurement for the specified weather property at the location corresponding to \!\(\*StyleBox[\"loc\", \"TI\"]\).\n\!\(\*RowBox[{\"WeatherData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"date\", \"TI\"]}], \"]\"}]\) gives all measurements during the specified date.\n\!\(\*RowBox[{\"WeatherData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives a list of dates and measurements for the time interval \!\(\*StyleBox[\"start\", \"TI\"]\) to \!\(\*StyleBox[\"end\", \"TI\"]\).\n\!\(\*RowBox[{\"WeatherData\", \"[\", RowBox[{StyleBox[\"loc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{\"{\", RowBox[{StyleBox[\"start\", \"TI\"], \",\", StyleBox[\"end\", \"TI\"], \",\", StyleBox[\"step\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives measurements aggregated over the time period represented by \!\(\*StyleBox[\"step\", \"TI\"]\)."
WeberE::usage = "\!\(\*RowBox[{\"WeberE\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Weber function \!\(\*RowBox[{SubscriptBox[StyleBox[\"E\", FontWeight -> \"Bold\", FontSlant -> \"Plain\"], \"\[Nu]\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\).\n\!\(\*RowBox[{\"WeberE\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the associated Weber function \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"E\", FontWeight -> \"Bold\", FontSlant -> \"Plain\"], \"\[Nu]\", \"\[Mu]\"], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\)."
Wedge::usage = "\!\(\*RowBox[{\"Wedge\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) displays as \!\(\*RowBox[{StyleBox[\"x\", \"TI\"], \"\[Wedge]\", StyleBox[\"y\", \"TI\"], \"\[Wedge]\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\)."
Wednesday::usage = "Wednesday is a day of the week."
WeibullDistribution::usage = "\!\(\*RowBox[{\"WeibullDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"]}], \"]\"}]\) represents a Weibull distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\) and scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\).\n\!\(\*RowBox[{\"WeibullDistribution\", \"[\", RowBox[{StyleBox[\"\[Alpha]\", \"TR\"], \",\", StyleBox[\"\[Beta]\", \"TR\"], \",\", StyleBox[\"\[Mu]\", \"TR\"]}], \"]\"}]\) represents a Weibull distribution with shape parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\), scale parameter \!\(\*StyleBox[\"\[Beta]\", \"TR\"]\), and location parameter \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\)."
WeierstrassHalfPeriods::usage = "\!\(\*RowBox[{\"WeierstrassHalfPeriods\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}], \"]\"}]\) gives the half\[Hyphen]periods \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", SuperscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"\[Prime]\", \"TI\"]]}], \"}\"}]\) for Weierstrass elliptic functions corresponding to the invariants \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", FontFamily -> \"Times\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"3\", FontFamily -> \"Times\"]]}], \"}\"}]\)."
WeierstrassInvariants::usage = "\!\(\*RowBox[{\"WeierstrassInvariants\", \"[\", RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", SuperscriptBox[StyleBox[\"\[Omega]\", \"TR\"], \"\[Prime]\"]}], \"}\"}], \"]\"}]\) gives the invariants \!\(\*RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]\) for Weierstrass elliptic functions corresponding to the half\[Hyphen]periods \!\(\*RowBox[{\"{\", RowBox[{StyleBox[\"\[Omega]\", \"TR\"], \",\", SuperscriptBox[StyleBox[\"\[Omega]\", \"TR\"], StyleBox[\"\[Prime]\", \"TI\"]]}], \"}\"}]\). "
WeierstrassPPrime::usage = "\!\(\*RowBox[{\"WeierstrassPPrime\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the derivative of the Weierstrass elliptic function \!\(\*RowBox[{\"\[WeierstrassP]\", \"(\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \";\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"2\"]}], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"3\"]}], \")\"}]\). "
WeierstrassP::usage = "\!\(\*RowBox[{\"WeierstrassP\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the Weierstrass elliptic function \!\(\*RowBox[{\"\[WeierstrassP]\", \"(\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \";\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"2\"]}], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"3\"]}], \")\"}]\). "
WeierstrassSigma::usage = "\!\(\*RowBox[{\"WeierstrassSigma\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the Weierstrass sigma function \!\(\*RowBox[{\"\[Sigma]\", \"(\", RowBox[{RowBox[{StyleBox[\"u\", \"TI\"], \";\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"2\"]}], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"3\"]}], \")\"}]\). "
WeierstrassZeta::usage = "\!\(\*RowBox[{\"WeierstrassZeta\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], StyleBox[\"3\", \"TR\"]]}], \"}\"}]}], \"]\"}]\) gives the Weierstrass zeta function \!\(\*RowBox[{\"\[Zeta]\", \"(\", RowBox[{StyleBox[\"u\", \"TI\"], \";\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"2\"], \",\", SubscriptBox[StyleBox[\"g\", \"TI\"], \"3\"]}], \")\"}]\). "
WeightedAdjacencyGraph::usage = "\!\(\*RowBox[{\"WeightedAdjacencyGraph\", \"[\", StyleBox[\"wmat\", \"TI\"], \"]\"}]\) gives the graph with weighted adjacency matrix \!\(\*StyleBox[\"wmat\", \"TI\"]\).\n\!\(\*RowBox[{\"WeightedAdjacencyGraph\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"wmat\", \"TI\"]}], \"]\"}]\) gives the graph with vertices \!\(\*SubscriptBox[StyleBox[\"v\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) and weighted adjacency matrix \!\(\*StyleBox[\"wmat\", \"TI\"]\)."
WeightedAdjacencyMatrix::usage = "\!\(\*RowBox[{\"WeightedAdjacencyMatrix\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) gives the adjacency matrix of edge weights of the graph \!\(\*StyleBox[\"g\", \"TI\"]\).\n\!\(\*RowBox[{\"WeightedAdjacencyMatrix\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", \"\[Ellipsis]\"}], \"]\"}]\) uses rules \!\(\*RowBox[{StyleBox[\"v\", \"TI\"], \"\[Rule]\", StyleBox[\"w\", \"TI\"]}]\) to specify the graph \!\(\*StyleBox[\"g\", \"TI\"]\). "
WeightedData::usage = "\!\(\*RowBox[{\"WeightedData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents observations \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"WeightedData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"fn\", \"TI\"]}], \"]\"}]\) represents observations \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) with weighting function \!\(\*StyleBox[\"fn\", \"TI\"]\)."
WeightedGraphQ::usage = "\!\(\*RowBox[{\"WeightedGraphQ\", \"[\", StyleBox[\"g\", \"TI\"], \"]\"}]\) yields True if the graph \!\(\*StyleBox[\"g\", \"TI\"]\) is a weighted graph and False otherwise."
Weights::usage = "Weights is an option for various fitting and other functions which specifies weights to associate with data elements."
WelchWindow::usage = "\!\(\*RowBox[{\"WelchWindow\", \"[\", StyleBox[\"x\", \"TI\"], \"]\"}]\) represents a Welch window function of \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"WelchWindow\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) uses the parameter \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\)."
WheelGraph::usage = "\!\(\*RowBox[{\"WheelGraph\", \"[\", StyleBox[\"n\", \"TI\"], \"]\"}]\) gives the wheel graph with \!\(\*StyleBox[\"n\", \"TI\"]\) vertices \!\(\*SubscriptBox[StyleBox[\"W\", \"TI\"], StyleBox[\"n\", \"TI\"]]\)."
WhenEvent::usage = "\!\(\*RowBox[{\"WhenEvent\", \"[\", RowBox[{StyleBox[\"event\", \"TI\"], \",\", StyleBox[\"action\", \"TI\"]}], \"]\"}]\) specifies an \!\(\*StyleBox[\"action\", \"TI\"]\) that occurs when the \!\(\*StyleBox[\"event\", \"TI\"]\) triggers it for equations in NDSolve and related functions. "
Which::usage = "\!\(\*RowBox[{\"Which\", \"[\", RowBox[{SubscriptBox[StyleBox[\"test\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"test\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) evaluates each of the \!\(\*SubscriptBox[StyleBox[\"test\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in turn, returning the value of the \!\(\*SubscriptBox[StyleBox[\"value\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) corresponding to the first one that yields True. "
While::usage = "\!\(\*RowBox[{\"While\", \"[\", RowBox[{StyleBox[\"test\", \"TI\"], \",\", StyleBox[\"body\", \"TI\"]}], \"]\"}]\) evaluates \!\(\*StyleBox[\"test\", \"TI\"]\), then \!\(\*StyleBox[\"body\", \"TI\"]\), repetitively, until \!\(\*StyleBox[\"test\", \"TI\"]\) first fails to give True. "
WhiteNoiseProcess::usage = "\!\(\*RowBox[{\"WhiteNoiseProcess\", \"[\", \"]\"}]\) represents a Gaussian white noise process with mean 0 and standard deviation 1.\n\!\(\*RowBox[{\"WhiteNoiseProcess\", \"[\", StyleBox[\"\[Sigma]\", \"TR\"], \"]\"}]\) represents a Gaussian white noise process with mean 0 and standard deviation \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"WhiteNoiseProcess\", \"[\", StyleBox[\"dist\", \"TI\"], \"]\"}]\) represents a white noise process based on the distribution \!\(\*StyleBox[\"dist\", \"TI\"]\)."
WhitePoint::usage = "WhitePoint is an option for ChromaticityPlot and other functions to specify what white point to show."
WhitespaceCharacter::usage = "WhitespaceCharacter represents a single whitespace character in StringExpression."
Whitespace::usage = "Whitespace represents a sequence of whitespace characters in StringExpression."
White::usage = "White represents the color white in graphics or style specifications. "
WhittakerM::usage = "\!\(\*RowBox[{\"WhittakerM\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Whittaker function \!\(\*RowBox[{SubscriptBox[StyleBox[\"M\", \"TI\"], RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
WhittakerW::usage = "\!\(\*RowBox[{\"WhittakerW\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Whittaker function \!\(\*RowBox[{SubscriptBox[StyleBox[\"W\", \"TI\"], RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"]}]], \"(\", StyleBox[\"z\", \"TI\"], \")\"}]\). "
WienerFilter::usage = "\!\(\*RowBox[{\"WienerFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) removes noise from \!\(\*StyleBox[\"image\", \"TI\"]\) by applying a range-\!\(\*StyleBox[\"r\", \"TI\"]\) Wiener filter.\n\!\(\*RowBox[{\"WienerFilter\", \"[\", RowBox[{StyleBox[\"image\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"], \",\", StyleBox[\"ns\", \"TI\"]}], \"]\"}]\) assumes an additive noise power value \!\(\*StyleBox[\"ns\", \"TI\"]\).\n\!\(\*RowBox[{\"WienerFilter\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) applies Wiener filtering to an array of data."
WienerProcess::usage = "\!\(\*RowBox[{\"WienerProcess\", \"[\", RowBox[{StyleBox[\"\[Mu]\", \"TR\"], \",\", StyleBox[\"\[Sigma]\", \"TR\"]}], \"]\"}]\) represents a Wiener process with a drift \!\(\*StyleBox[\"\[Mu]\", \"TR\"]\) and volatility \!\(\*StyleBox[\"\[Sigma]\", \"TR\"]\).\n\!\(\*RowBox[{\"WienerProcess\", \"[\", \"]\"}]\) represents a standard Wiener process with drift 0 and volatility 1."
WignerD::usage = "\!\(\*RowBox[{\"WignerD\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Psi]\", \"TR\"], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) gives the Wigner D-function \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"D\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], \"2\"]}], StyleBox[\"j\", \"TI\"]], \"(\", RowBox[{\"\[Psi]\", \",\", \"\[Theta]\", \",\", \"\[Phi]\"}], \")\"}]\).\n\!\(\*RowBox[{\"WignerD\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Theta]\", \"TR\"], \",\", StyleBox[\"\[Phi]\", \"TR\"]}], \"]\"}]\) gives the Wigner D-function \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"D\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], \"2\"]}], StyleBox[\"j\", \"TI\"]], \"(\", RowBox[{\"0\", \",\", \"\[Theta]\", \",\", \"\[Phi]\"}], \")\"}]\).\n\!\(\*RowBox[{\"WignerD\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"j\", \"TI\"], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Theta]\", \"TR\"]}], \"]\"}]\) gives the Wigner D-function \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"D\", \"TI\"], RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], \"1\"], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], \"2\"]}], StyleBox[\"j\", \"TI\"]], \"(\", RowBox[{\"0\", \",\", \"\[Theta]\", \",\", \"0\"}], \")\"}]\)."
WignerSemicircleDistribution::usage = "\!\(\*RowBox[{\"WignerSemicircleDistribution\", \"[\", StyleBox[\"r\", \"TI\"], \"]\"}]\) represents a Wigner semicircle distribution with radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at the origin.\n\!\(\*RowBox[{\"WignerSemicircleDistribution\", \"[\", RowBox[{StyleBox[\"a\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) represents a Wigner semicircle distribution with radius \!\(\*StyleBox[\"r\", \"TI\"]\) centered at \!\(\*StyleBox[\"a\", \"TI\"]\)."
WikipediaData::usage = "\!\(\*RowBox[{\"WikipediaData\", \"[\", StyleBox[\"article\", \"TI\"], \"]\"}]\) gives the plain text of the specified Wikipedia article.\n\!\(\*RowBox[{\"WikipediaData\", \"[\", RowBox[{StyleBox[\"article\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) gives the value of the specified property, modified by optional parameters, for the given Wikipedia article.\n\!\(\*RowBox[{\"WikipediaData\", \"[\", RowBox[{RowBox[{StyleBox[\"\\\"Category\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"category\", \"TI\"]}], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) gives the value of the specified property, modified by optional parameters, for the given Wikipedia category.\n\!\(\*RowBox[{\"WikipediaData\", \"[\", RowBox[{RowBox[{StyleBox[\"\\\"PageID\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"pageid\", \"TI\"]}], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) gives the value of the specified property, modified by optional parameters, for the article corresponding to the given numerical Wikipedia page ID."
WikipediaSearch::usage = "\!\(\*RowBox[{\"WikipediaSearch\", \"[\", StyleBox[\"keywords\", \"TI\"], \"]\"}]\) returns a list of Wikipedia articles whose titles include the given keywords.\n\!\(\*RowBox[{\"WikipediaSearch\", \"[\", RowBox[{RowBox[{StyleBox[\"\\\"Title\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"keywords\", \"TI\"]}], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) returns a list of Wikipedia articles whose titles include the given keywords.\n\!\(\*RowBox[{\"WikipediaSearch\", \"[\", RowBox[{RowBox[{StyleBox[\"\\\"Category\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"keywords\", \"TI\"]}], \",\", StyleBox[\"options\", \"TI\"]}], \"]\"}]\) returns a list of Wikipedia categories whose titles include the given keywords.\n\!\(\*RowBox[{\"WikipediaSearch\", \"[\", RowBox[{StyleBox[\"\\\"Content\\\"\",ShowStringCharacters->True], \"\[Rule]\", StyleBox[\"keywords\", \"TI\"]}], \"]\"}]\) returns a list of Wikipedia articles whose content includes the given keywords.\n\!\(\*RowBox[{\"WikipediaSearch\", \"[\", RowBox[{StyleBox[\"\\\"GeoLocation\\\"\",ShowStringCharacters->True], \"\[Rule]\", RowBox[{StyleBox[\"article\", \"TI\"], \"|\", StyleBox[\"location\", \"TI\"]}]}], \"]\"}]\) returns a list of Wikipedia articles whose associated coordinates are near the given article or location."
WilksWTest::usage = "\!\(\*RowBox[{\"WilksWTest\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests whether the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are independent.\n\!\(\*RowBox[{\"WilksWTest\", \"[\", RowBox[{StyleBox[\"\[Ellipsis]\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
WilksW::usage = "\!\(\*RowBox[{\"WilksW\", \"[\", RowBox[{SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) gives Wilks's \!\(\*StyleBox[\"\[ScriptCapitalW]\", \"TR\"]\) for the matrices \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"m\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
WindDirectionData::usage = "\!\(\*RowBox[{\"WindDirectionData\", \"[\", \"]\"}]\) gives the most recent measurement for wind direction near the current location.\n\!\(\*RowBox[{\"WindDirectionData\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the wind direction value for the specified time near the current location.\n\!\(\*RowBox[{\"WindDirectionData\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the most recent measurement for wind direction near the specified location.\n\!\(\*RowBox[{\"WindDirectionData\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the value or values for the specified date and location.\n\!\(\*RowBox[{\"WindDirectionData\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives values for all specified locations on the specified dates."
WindowClickSelect::usage = "WindowClickSelect is a notebook option that specifies whether the window for the notebook should become selected if you click it. "
WindowElements::usage = "WindowElements is a notebook option that specifies the elements to include in the window used to display the notebook on the screen. "
WindowFloating::usage = "WindowFloating is a notebook option that specifies whether the window for the notebook should float on top of other windows when it is displayed on the screen. "
WindowFrameElements::usage = "WindowFrameElements is an option for notebooks that specifies the elements to include in the frame of the window used to display the notebook on the screen."
WindowFrame::usage = "WindowFrame is a notebook option that specifies the type of frame to draw around the window in which the notebook is displayed on the screen. "
WindowMargins::usage = "WindowMargins is a notebook option that specifies what margins to leave around the window that is used to display the notebook on the screen. "
WindowMovable::usage = "WindowMovable is a notebook option that specifies whether to allow the window for the notebook to be moved around interactively on the screen. "
WindowOpacity::usage = "WindowOpacity is a notebook option that determines the overall opacity of a displayed window."
WindowSize::usage = "WindowSize is a notebook option that specifies the size of window that should be used to display a notebook on the screen. "
WindowStatusArea::usage = "WindowStatusArea is a notebook option that specifies what should appear in the status area in the frame of the window used to display the notebook. "
WindowTitle::usage = "WindowTitle is an option that specifies the title to give for a window. "
WindowToolbars::usage = "WindowToolbars is a notebook option that specifies the toolbars to include at the top of the window used to display the notebook on the screen. "
WindSpeedData::usage = "\!\(\*RowBox[{\"WindSpeedData\", \"[\", \"]\"}]\) gives the most recent measurement for wind speed near the current location.\n\!\(\*RowBox[{\"WindSpeedData\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the wind speed value for the specified time near the current location.\n\!\(\*RowBox[{\"WindSpeedData\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the most recent measurement for wind speed near the specified location.\n\!\(\*RowBox[{\"WindSpeedData\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the value or values for the specified date and location.\n\!\(\*RowBox[{\"WindSpeedData\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives values for all specified locations on the specified dates."
WindVectorData::usage = "\!\(\*RowBox[{\"WindVectorData\", \"[\", \"]\"}]\) gives the most recent weather station measurement for wind vector near the current location.\n\!\(\*RowBox[{\"WindVectorData\", \"[\", StyleBox[\"datespec\", \"TI\"], \"]\"}]\) gives the wind vector value for the specified time near the current location.\n\!\(\*RowBox[{\"WindVectorData\", \"[\", StyleBox[\"locationspec\", \"TI\"], \"]\"}]\) gives the most recent measurement for wind vector near the specified location.\n\!\(\*RowBox[{\"WindVectorData\", \"[\", RowBox[{StyleBox[\"locationspec\", \"TI\"], \",\", StyleBox[\"datespec\", \"TI\"]}], \"]\"}]\) gives the value or values for the specified date and location.\n\!\(\*RowBox[{\"WindVectorData\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"location\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"date\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) gives values for all specified locations on the specified dates."
WishartMatrixDistribution::usage = "\!\(\*RowBox[{\"WishartMatrixDistribution\", \"[\", RowBox[{StyleBox[\"\[Nu]\", \"TI\"], \",\", StyleBox[\"\[CapitalSigma]\", \"TR\"]}], \"]\"}]\) represents a Wishart matrix distribution with \!\(\*StyleBox[\"\[Nu]\", \"TI\"]\) degrees of freedom and covariance matrix \!\(\*StyleBox[\"\[CapitalSigma]\", \"TR\"]\)."
With::usage = "\!\(\*RowBox[{\"With\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{RowBox[{StyleBox[\"x\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", RowBox[{StyleBox[\"y\", \"TI\"], \"=\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"expr\", \"TI\"]}], \"]\"}]\) specifies that all occurrences of the symbols \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), \[Ellipsis] in \!\(\*StyleBox[\"expr\", \"TI\"]\) should be replaced by \!\(\*SubscriptBox[StyleBox[\"x\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"0\", \"TR\"]]\), \[Ellipsis]. "
WolframAlpha::usage = "\!\(\*RowBox[{\"WolframAlpha\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"query\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) sends \!\(\*StyleBox[\"query\", \"TI\"]\) to Wolfram|Alpha and imports the output.\n\!\(\*RowBox[{\"WolframAlpha\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"query\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"format\", \"TI\"]}], \"]\"}]\) imports the output according to the specified format."
WolframLanguageData::usage = "\!\(\*RowBox[{\"WolframLanguageData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the Wolfram Language symbol \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"WolframLanguageData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified Wolfram Language symbol entities.\n\!\(\*RowBox[{\"WolframLanguageData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
WordBoundary::usage = "WordBoundary represents a boundary between words for purposes of matching in StringExpression."
WordCharacter::usage = "WordCharacter represents a letter or digit character in StringExpression."
WordCloud::usage = "\!\(\*RowBox[{\"WordCloud\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a word cloud graphic in which the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are sized according to their multiplicity in the list. \n\!\(\*RowBox[{\"WordCloud\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) generates a word cloud in which the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are sized according to the weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"WordCloud\", \"[\", RowBox[{\"\[LeftAssociation]\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"\[RightAssociation]\"}], \"]\"}]\) also generates a word cloud in which the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are sized according to the weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\).\n\!\(\*RowBox[{\"WordCloud\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"\[Rule]\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) also generates a word cloud in which the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are sized according to the weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"WordCloud\", \"[\", RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \"]\"}]\) also generates a word cloud in which the \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are sized according to the weights \!\(\*SubscriptBox[StyleBox[\"w\", \"TI\"], StyleBox[\"i\", \"TI\"]]\). \n\!\(\*RowBox[{\"WordCloud\", \"[\", RowBox[{StyleBox[\"data\", \"TI\"], \",\", StyleBox[\"shape\", \"TI\"]}], \"]\"}]\) fits the word cloud into the region defined by \!\(\*StyleBox[\"shape\", \"TI\"]\)."
WordCounts::usage = "\!\(\*RowBox[{\"WordCounts\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives an association whose keys are the distinct words identified in \!\(\*StyleBox[\"string\", \"TI\"]\), and whose values give the number of times those words appear in \!\(\*StyleBox[\"string\", \"TI\"]\).\n\!\(\*RowBox[{\"WordCounts\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"n\", \"TI\"]}], \"]\"}]\) gives counts of the distinct \!\(\*StyleBox[\"n\", \"TI\"]\)-grams consisting of runs of \!\(\*StyleBox[\"n\", \"TI\"]\) words in \!\(\*StyleBox[\"string\", \"TI\"]\)."
WordCount::usage = "\!\(\*RowBox[{\"WordCount\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the total number of runs of characters identified as words in \!\(\*StyleBox[\"string\", \"TI\"]\)."
WordData::usage = "\!\(\*RowBox[{\"WordData\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"word\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives the specified property for the English word \"\!\(\*\nStyleBox[\"word\", \"TI\"]\)\".\n\!\(\*RowBox[{\"WordData\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"word\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a list of full word specifications representing possible uses and senses of \"\!\(\*\nStyleBox[\"word\", \"TI\"]\)\".\n\!\(\*RowBox[{\"WordData\", \"[\", RowBox[{StyleBox[\"wordspec\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) gives a property for a particular word specification."
WordDefinition::usage = "\!\(\*RowBox[{\"WordDefinition\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"word\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives the dictionary definitions available for \"\!\(\*\nStyleBox[\"word\", \"TI\"]\)\"."
WordList::usage = "\!\(\*RowBox[{\"WordList\", \"[\", \"]\"}]\) gives a list of common words.\n\!\(\*RowBox[{\"WordList\", \"[\", StyleBox[\"type\", \"TI\"], \"]\"}]\) gives a list of words of the specified type."
WordSearch::usage = "WordSearch is an option for Find and FindList that specifies whether the text searched for must appear as a word. "
WordSeparators::usage = "WordSeparators is an option for Read, Find, and related functions that specifies the list of strings to be taken as delimiters for words. "
WordSpacings::usage = "WordSpacings is an option for WordCloud that specifies the empty space to be added around each word. "
WordStem::usage = "\!\(\*RowBox[{\"WordStem\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"word\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) gives a stemmed form of \!\(\*StyleBox[\"word\", \"TI\"]\), removing plurals, inflections, etc."
WordTranslation::usage = "\!\(\*RowBox[{\"WordTranslation\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"word\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"lang\", \"TI\"]}], \"]\"}]\) gives translations for \!\(\*StyleBox[\"word\", \"TI\"]\) into the language \!\(\*StyleBox[\"lang\", \"TI\"]\).\n\!\(\*RowBox[{\"WordTranslation\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"word\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", RowBox[{SubscriptBox[StyleBox[\"lang\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"lang\", \"TI\"], StyleBox[\"2\", \"TR\"]]}]}], \"]\"}]\) gives translations for \!\(\*StyleBox[\"word\", \"TI\"]\) from \!\(\*SubscriptBox[StyleBox[\"lang\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) to \!\(\*SubscriptBox[StyleBox[\"lang\", \"TI\"], StyleBox[\"2\", \"TR\"]]\)."
Word::usage = "Word represents a word in Read, Find, and related functions. "
WorkingPrecision::usage = "WorkingPrecision is an option for various numerical operations that specifies how many digits of precision should be maintained in internal computations. "
WorldPlot`Albers::usage = "\!\(\*RowBox[{\"Albers\", \"[\", RowBox[{SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) is a map projection for use with WorldGraphics, where \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"1\", \"TR\"]]\), \!\(\*SubscriptBox[StyleBox[\"p\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) specify the primary latitudes to be used for the projection."
WorldPlot`Equirectangular::usage = "Equirectangular is a map projection for use with WorldGraphics. Directly maps longitude to \!\(\*StyleBox[\"x\", \"TI\"]\), latitude to \!\(\*StyleBox[\"y\", \"TI\"]\). It is the simplest projection, mathematically."
WorldPlot`LambertAzimuthal::usage = "LambertAzimuthal is a map projection for use with WorldGraphics. Warning: with this projection, you cannot represent the point opposite your view point."
WorldPlot`LambertCylindrical::usage = "LambertCylindrical is a map projection for use with WorldGraphics."
WorldPlot`Mercator::usage = "Mercator is a map projection for use with WorldGraphics. Warning: Mercator goes to Infinity at the poles."
WorldPlot`Mollweide::usage = "Mollweide is a map projection for use with WorldGraphics."
WorldPlot`Orthographic::usage = "Orthographic is a map projection for use with WorldGraphics. Warning: the projection is only good for a single hemisphere; ranges must be carefully chosen."
WorldPlot`RandomColors::usage = "RandomColors is a function to produce random colors."
WorldPlot`RandomGrays::usage = "RandomGrays is a function to produce random grayscales."
WorldPlot`ShowTooltips::usage = "ShowTooltips is an option for WorldPlot that indicates whether or not to display Tooltip labels for each country."
WorldPlot`Simple::usage = "Simple is an argument for the option WorldClipping."
WorldPlot`Sinusoidal::usage = "Sinusoidal is a map projection for use with WorldGraphics."
WorldPlot`ToMinutes::usage = "\!\(\*RowBox[{RowBox[{\"ToMinutes\", \"[\"}], StyleBox[\"degs\", \"TI\"], \"]\"}]\) converts degrees to minutes. \n\!\(\*RowBox[{RowBox[{\"ToMinutes\", \"[\", \"{\"}], StyleBox[\"degs\", \"TI\"], \",\", StyleBox[\"mins\", \"TI\"], \",\", StyleBox[\"secs\", \"TI\"], RowBox[{\"}\", \"]\"}]}]\) converts from DMS form to minutes. \n\!\(\*RowBox[{RowBox[{RowBox[{\"ToMinutes\", \"[\", RowBox[{RowBox[{RowBox[{\"{\", RowBox[{\"{\", \"{\"}]}], StyleBox[\"d\", \"TI\"]}], \",\", StyleBox[\"m\", \"TI\"], \",\", RowBox[{StyleBox[\"s\", \"TI\"], RowBox[{\"}\", \",\", \"{\"}], StyleBox[\"d\", \"TI\"]}], \",\", StyleBox[\"m\", \"TI\"], \",\", RowBox[{StyleBox[\"s\", \"TI\"], RowBox[{RowBox[{\"}\", \"}\"}], \",\"}], RowBox[{\"{\", \"{\"}], StyleBox[\"d\", \"TI\"]}], \",\", StyleBox[\"m\", \"TI\"], \",\", RowBox[{StyleBox[\"s\", \"TI\"], RowBox[{\"}\", \",\", \"{\"}], StyleBox[\"d\", \"TI\"]}], \",\", StyleBox[\"m\", \"TI\"], \",\", RowBox[{StyleBox[\"s\", \"TI\"], RowBox[{\"}\", \"}\"}], StyleBox[\"\[Ellipsis]\", \"TR\"]}]}]}], \"}\"}], \"]\"}]\) converts to \!\(\*RowBox[{\"{\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"long\", \"TI\"]}], \"}\"}], \",\", RowBox[{RowBox[{\"{\", RowBox[{StyleBox[\"lat\", \"TI\"], \",\", StyleBox[\"long\", \"TI\"]}], \"}\"}], StyleBox[\"\[Ellipsis]\", \"TI\"]}]}], \"}\"}]\) with the coordinates in minutes."
WorldPlot`WorldBackground::usage = "WorldBackground is an option for WorldGraphics. \n\!\(\*RowBox[{\"WorldBackground\", \"->\", \"None\"}]\) specifies no background. \n\!\(\*RowBox[{\"WorldBackground\", \"->\", StyleBox[\"style\", \"TI\"]}]\) specifies the style of polygon representing background (the ocean, for instance)."
WorldPlot`WorldBorders::usage = "WorldBorders is an option for WorldPlot that can specify a style for the borders, or either of the following: None means do not put borders around polygons, while Automatic means not to put borders if a shading function or explicit shadings are present."
WorldPlot`WorldClipping::usage = "WorldClipping is an option for WorldGraphics that expresses the type of clipping to be done on polygons (in the interest of computational efficiency)."
WorldPlot`WorldCountries::usage = "WorldCountries is an option for WorldPlot that specifies the list of names of polygon sets (countries) in the database, where the names are usually specified as strings."
WorldPlot`WorldDatabase::usage = "WorldDatabase is an option for WorldPlot that specifies the symbol in which polygon data is stored. The default is WorldData."
WorldPlot`WorldFrameParts::usage = "WorldFrameParts is an option for WorldGraphics."
WorldPlot`WorldFrame::usage = "WorldFrame is an option for WorldGraphics. \n\!\(\*RowBox[{\"WorldFrame\", \"->\", \"None\"}]\) specifies no frame. \n\!\(\*RowBox[{\"WorldFrame\", \"->\", StyleBox[\"style\", \"TI\"]}]\) specifies the style of line around the edge of the map."
WorldPlot`WorldGraphics::usage = "\!\(\*RowBox[{RowBox[{\"WorldGraphics\", \"[\"}], StyleBox[\"primitives\", \"TI\"], \",\", StyleBox[\"options\", \"TI\"], \"]\"}]\) represents a planetary map. It applies to standard graphics \!\(\*StyleBox[\"primitives\", \"TI\"]\). "
WorldPlot`WorldGridBehind::usage = "WorldGridBehind is an option for WorldGraphics; it specifies whether the lines of longitude and latitude should be rendered behind or in front of the graphic; the default is True (behind)."
WorldPlot`WorldGridStyle::usage = "WorldGridStyle is an option for WorldGraphics that specifies the style of lines of latitude and longitude."
WorldPlot`WorldGrid::usage = "WorldGrid is an option for WorldGraphics that places lines of latitude and longitude at specified locations."
WorldPlot`WorldPlot::usage = "\!\(\*RowBox[{RowBox[{\"WorldPlot\", \"[\"}], StyleBox[\"list\", \"TI\"], \"]\"}]\) is a function to generate maps of the world that draw data from a specified database, where \!\(\*StyleBox[\"list\", \"TI\"]\) is a list of countries from the database.\n\!\(\*RowBox[{RowBox[{\"WorldPlot\", \"[\", \"{\"}], StyleBox[\"list\", \"TI\"], \",\", StyleBox[\"shading\", \"TI\"], RowBox[{\"}\", \"]\"}]}]\) produces a map where \!\(\*StyleBox[\"shading\", \"TI\"]\) is either a function applied to each name in \!\(\*StyleBox[\"list\", \"TI\"]\), producing a color or grayscale, or is a list of shades, one per name in \!\(\*StyleBox[\"list\", \"TI\"]\)."
WorldPlot`WorldPoints::usage = "WorldPoints is an option for WorldGraphics that specifies the number of divisions between the minimum and maximum longitudes of the range, with the latitude scaled accordingly. "
WorldPlot`WorldProjection::usage = "WorldProjection is an option for WorldGraphics specified as a pure function that takes two arguments and returns a list, where the arguments are the latitude and longitude of a point, and the list is the \!\(\*StyleBox[\"x\", \"TI\"]\) and \!\(\*StyleBox[\"y\", \"TI\"]\) coordinates of the projection."
WorldPlot`WorldRange::usage = "WorldRange is an option for WorldGraphics that specifies the range of latitude and longitude that will be plotted."
WorldPlot`WorldRotatedRange::usage = "WorldRotatedRange is an option for WorldGraphics. "
WorldPlot`WorldRotation::usage = "WorldRotation is an option for WorldGraphics that turns any given projection into a transverse or oblique projection."
WorldPlot`WorldToGraphics::usage = "WorldToGraphics is an option for WorldPlot that determines whether a Graphics or WorldGraphics object is produced. "
WrapAround::usage = "WrapAround is an option for NotebookFind that specifies whether the find operation should continue past the bottom or top of a document."
WriteLine::usage = "\!\(\*RowBox[{\"WriteLine\", \"[\", RowBox[{StyleBox[\"stream\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes \"\!\(\*\nStyleBox[\"string\",\n\"TI\"]\)\", followed by a newline, to the specified output stream.\n\!\(\*RowBox[{\"WriteLine\", \"[\", RowBox[{StyleBox[\"proc\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes \"\!\(\*\nStyleBox[\"string\", \"TI\"]\)\" to an external process \!\(\*StyleBox[\"proc\", \"TI\"]\)."
WriteString::usage = "\!\(\*RowBox[{\"WriteString\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes \"\!\(\*\nStyleBox[\"string\",\n\"TI\"]\)\" to a file.\n\!\(\*RowBox[{\"WriteString\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) writes \"\!\(\*\nStyleBox[\"string\",\n\"TI\"]\)\" to a stream or process.\n\!\(\*RowBox[{\"WriteString\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) converts the \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) to strings, and then writes them in sequence to the specified output channel. "
Write::usage = "\!\(\*RowBox[{\"Write\", \"[\", RowBox[{StyleBox[\"channel\", \"TI\"], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) writes the expressions \!\(\*SubscriptBox[StyleBox[\"expr\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) in sequence, followed by a newline, to the specified output channel."
Wronskian::usage = "\!\(\*RowBox[{\"Wronskian\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Wronskian determinant for the functions \!\(\*RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}]\) depending on \!\(\*StyleBox[\"x\", \"TI\"]\).\n\!\(\*RowBox[{\"Wronskian\", \"[\", RowBox[{StyleBox[\"eqn\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Wronskian determinant for the basis of the solutions of the linear differential equation \!\(\*StyleBox[\"eqn\", \"TI\"]\) with dependent variable \!\(\*StyleBox[\"y\", \"TI\"]\) and independent variable \!\(\*StyleBox[\"x\", \"TI\"]\). \n\!\(\*RowBox[{\"Wronskian\", \"[\", RowBox[{StyleBox[\"eqns\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"y\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"x\", \"TI\"]}], \"]\"}]\) gives the Wronskian determinant for the system of linear differential equations \!\(\*StyleBox[\"eqns\", \"TI\"]\)."
XML`BoxesToMathML::usage = "\!\(\*RowBox[{BoxesToMathML, \"[\", StyleBox[\"boxes\", \"TI\"], \"]\"}]\) converts the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) box structure, \!\(\*StyleBox[\"boxes\", \"TI\"]\), into a MathML-flavored XML text string. "
XML`BoxesToSymbolicMathML::usage = "\!\(\*RowBox[{BoxesToSymbolicMathML, \"[\", StyleBox[\"boxes\", \"TI\"], \"]\"}]\) converts the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) box structure, \!\(\*StyleBox[\"boxes\", \"TI\"]\), into a MathML-flavored SymbolicXML structure."
XMLElement::usage = "\!\(\*RowBox[{\"XMLElement\", \"[\", RowBox[{StyleBox[\"tag\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{RowBox[{SubscriptBox[StyleBox[\"attr\", \"TI\"], StyleBox[\"1\", \"TR\"]], \"\[Rule]\", SubscriptBox[StyleBox[\"val\", \"TI\"], StyleBox[\"1\", \"TR\"]]}], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}]}], \"]\"}]\) represents an element in symbolic XML."
XML`ExpressionToMathML::usage = "\!\(\*RowBox[{\"ExpressionToMathML\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) expression, \!\(\*StyleBox[\"expr\", \"TI\"]\), into a MathML-flavored XML text string. "
XML`ExpressionToSymbolicExpressionML::usage = "\!\(\*RowBox[{\"ExpressionToSymbolicExpressionML\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts \!\(\*StyleBox[\"expr\", \"TI\"]\) to ExpressionML and returns the corresponding SymbolicXML. "
XML`ExpressionToSymbolicMathML::usage = "\!\(\*RowBox[{\"ExpressionToSymbolicMathML\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts the \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) expression, \!\(\*StyleBox[\"expr\", \"TI\"]\), into a MathML-flavored SymbolicXML structure. "
XML`FromSymbolicXML::usage = "\!\(\*RowBox[{\"FromSymbolicXML\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts a SymbolicXML expression \!\(\*StyleBox[\"expr\", \"TI\"]\) to a more native format, if one is available."
XML`InitializeXMLParser::usage = "\!\(\*RowBox[{\"InitializeXMLParser\", \"[\", RowBox[{StyleBox[\"root\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) creates an XMLParser object that has a list of entities corresponding to the contents of \"\!\(\*\nStyleBox[\"file\", \"TI\"]\)\" and can be used on XML documents that have a root element \!\(\*StyleBox[\"root\", \"TI\"]\)."
XML`MathMLToBoxes::usage = "\!\(\*RowBox[{MathMLToBoxes, \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) converts the string containing MathML-flavored XML text into a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) box expression."
XML`MathMLToExpression::usage = "\!\(\*RowBox[{\"MathMLToExpression\", \"[\", StyleBox[\"string\", \"TI\"], \"]\"}]\) converts the string containing MathML-flavored XML text into a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) expression."
XML`NotebookToSymbolicNotebookML::usage = "\!\(\*RowBox[{\"NotebookToSymbolicNotebookML\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts \!\(\*StyleBox[\"expr\", \"TI\"]\) to NotebookML and returns the corresponding SymbolicXML. "
XMLObject::usage = "\!\(\*RowBox[{\"XMLObject\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"type\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents the head of an XML object in symbolic XML."
XML`RawXML::usage = "\!\(\*RowBox[{\"RawXML\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) represents a raw string fragment of XML that can be used inside a SymbolicXML expression. "
XML`ReleaseXMLParser::usage = "\!\(\*RowBox[{\"ReleaseXMLParser\", \"[\", StyleBox[\"parser\", \"TI\"], \"]\"}]\) frees up resources associated with the XMLParser object \!\(\*StyleBox[\"parser\", \"TI\"]\)."
XML`SymbolicExpressionMLToExpression::usage = "\!\(\*RowBox[{\"SymbolicExpressionMLToExpression\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) takes a SymbolicXML expression \!\(\*StyleBox[\"expr\", \"TI\"]\) that represents an ExpressionML document and returns the corresponding expression. "
XML`SymbolicMathMLToBoxes::usage = "\!\(\*RowBox[{SymbolicMathMLToBoxes, \"[\", StyleBox[\"smml\", \"TI\"], \"]\"}]\) converts the MathML-flavored SymbolicXML structure, \!\(\*StyleBox[\"smml\", \"TI\"]\), into a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) box expression."
XML`SymbolicMathMLToExpression::usage = "\!\(\*RowBox[{\"SymbolicMathMLToExpression\", \"[\", StyleBox[\"smml\", \"TI\"], \"]\"}]\) converts the MathML-flavored SymbolicXML structure, \!\(\*StyleBox[\"smml\", \"TI\"]\), into a \!\(\*StyleBox[\"Wolfram Language\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) expression. The output is in the form of content MathML, wherever possible."
XML`SymbolicNotebookMLToNotebook::usage = "\!\(\*RowBox[{\"SymbolicNotebookMLToNotebook\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) takes a SymbolicXML expression \!\(\*StyleBox[\"expr\", \"TI\"]\) that represents a NotebookML document and returns the corresponding notebook expression. "
XML`SymbolicXMLErrors::usage = "\!\(\*RowBox[{\"SymbolicXMLErrors\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns a list of part specifications indicating where there are errors in the SymbolicXML expression \!\(\*StyleBox[\"expr\", \"TI\"]\) and a message about the nature of each error."
XML`SymbolicXMLQ::usage = "\!\(\*RowBox[{\"SymbolicXMLQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) returns True if the expression \!\(\*StyleBox[\"expr\", \"TI\"]\) matches some basic patterns for a SymbolicXML expression and False otherwise.\n\!\(\*RowBox[{\"SymbolicXMLQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"True\"}], \"]\"}]\) performs a complete test on \!\(\*StyleBox[\"expr\", \"TI\"]\) to determine if it is a well-formed SymbolicXML expression. \n\!\(\*RowBox[{\"SymbolicXMLQ\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", \"False\"}], \"]\"}]\) is equivalent to \!\(\*RowBox[{\"SymbolicXMLQ\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\)."
XMLTemplate::usage = "\!\(\*RowBox[{\"XMLTemplate\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"string\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) yields a TemplateObject that represents an XML template to be applied using functions like TemplateApply.\n\!\(\*RowBox[{\"XMLTemplate\", \"[\", RowBox[{\"File\", \"[\", StyleBox[\"\[Ellipsis]\", \"TR\"], \"]\"}], \"]\"}]\) takes the source for the XML template from a file."
XML`ToCompactXML::usage = "\!\(\*RowBox[{RowBox[{\"ToCompactXML\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}], \" \"}]\) generates an equivalent SymbolicXML expression that suppresses all the redundant namespace information for elements and attributes in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"ToCompactXML\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"patt\", \"TI\"]}], \"]\"}]\) suppresses only namespaces that match \!\(\*StyleBox[\"patt\", \"TI\"]\)."
XML`ToSymbolicXML::usage = "\!\(\*RowBox[{\"ToSymbolicXML\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) converts an expression \!\(\*StyleBox[\"expr\", \"TI\"]\) to an appropriate XML format and returns the result as SymbolicXML."
XML`ToVerboseXML::usage = "\!\(\*RowBox[{\"ToVerboseXML\", \"[\", StyleBox[\"expr\", \"TI\"], \"]\"}]\) generates an equivalent SymbolicXML expression that explicitly exposes all the namespace information for elements and attributes in \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"ToVerboseXML\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"pattern\", \"TI\"]}], \"]\"}]\) exposes only namespaces that match \!\(\*StyleBox[\"pattern\", \"TI\"]\)."
XML`XMLGetString::usage = "\!\(\*RowBox[{\"XMLGetString\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"data\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) returns the XML expression tree corresponding to a string.\n\!\(\*RowBox[{\"XMLGetString\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"data\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"parser\", \"TI\"]}], \"]\"}]\) uses the pre-initialized XMLParser object to parse the string. "
XML`XMLGet::usage = "\!\(\*RowBox[{\"XMLGet\", \"[\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \"]\"}]\) returns the XML expression tree corresponding to the contents of \"\!\(\*\nStyleBox[\"file\", \"TI\"]\)\".\n\!\(\*RowBox[{\"XMLGet\", \"[\", RowBox[{StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True], \",\", StyleBox[\"parser\", \"TI\"]}], \"]\"}]\) uses the pre-initialized XMLParser object to parse the file. \n\!\(\*RowBox[{\"XMLGet\", \"[\", RowBox[{StyleBox[\"\\\"http://\\!\\(\\*StyleBox[\\\"url\\\",\\\"TI\\\"]\\)\\\"\",ShowStringCharacters->True], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) reads from a URL. "
XML`XMLParser::usage = "\!\(\*RowBox[{\"XMLParser\", \"[\", RowBox[{StyleBox[\"root\", \"TI\"], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"file\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) represents a parser object created by InitializeXMLParser for XML documents with a root element \!\(\*StyleBox[\"root\", \"TI\"]\) and corresponding to the DTD \"\!\(\*\nStyleBox[\"file\", \"TI\"]\)\"."
Xnor::usage = "\!\(\*RowBox[{\"Xnor\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is the logical XNOR (not XOR) function. It gives True if an even number of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are True, and the rest are False. It gives False if an odd number of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are True, and the rest are False. "
Xor::usage = "\!\(\*RowBox[{\"Xor\", \"[\", RowBox[{SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"]\"}]\) is the logical XOR (exclusive OR) function. It gives True if an odd number of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are True, and the rest are False. It gives False if an even number of the \!\(\*SubscriptBox[StyleBox[\"e\", \"TI\"], StyleBox[\"i\", \"TI\"]]\) are True, and the rest are False. "
XYZColor::usage = "\!\(\*RowBox[{\"XYZColor\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) is a color directive with tristimulus values \!\(\*StyleBox[\"x\", \"TI\"]\), \!\(\*StyleBox[\"y\", \"TI\"]\), and \!\(\*StyleBox[\"z\", \"TI\"]\).\n\!\(\*RowBox[{\"XYZColor\", \"[\", RowBox[{StyleBox[\"x\", \"TI\"], \",\", StyleBox[\"y\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"], \",\", StyleBox[\"\[Alpha]\", \"TR\"]}], \"]\"}]\) specifies opacity \!\(\*StyleBox[\"\[Alpha]\", \"TR\"]\). "
Yellow::usage = "Yellow represents the color yellow in graphics or style specifications. "
Yesterday::usage = "Yesterday gives a DateObject representing the previous day."
YuleDissimilarity::usage = "\!\(\*RowBox[{\"YuleDissimilarity\", \"[\", RowBox[{StyleBox[\"u\", \"TI\"], \",\", StyleBox[\"v\", \"TI\"]}], \"]\"}]\) gives the Yule dissimilarity between Boolean vectors \!\(\*StyleBox[\"u\", \"TI\"]\) and \!\(\*StyleBox[\"v\", \"TI\"]\)."
ZernikeR::usage = "\!\(\*RowBox[{\"ZernikeR\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"m\", \"TI\"], \",\", StyleBox[\"r\", \"TI\"]}], \"]\"}]\) gives the radial Zernike polynomial \!\(\*RowBox[{SubsuperscriptBox[StyleBox[\"R\", \"TI\"], StyleBox[\"n\", \"TI\"], StyleBox[\"m\", \"TI\"]], \"(\", StyleBox[\"r\", \"TI\"], \")\"}]\)."
ZeroSymmetric::usage = "\!\(\*RowBox[{\"ZeroSymmetric\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"], \",\", SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"n\", \"TI\"]]}], \"}\"}], \"]\"}]\) represents the symmetry of a zero tensor in the slots \!\(\*SubscriptBox[StyleBox[\"s\", \"TI\"], StyleBox[\"i\", \"TI\"]]\)."
ZeroTest::usage = "ZeroTest is an option to various linear algebra functions that gives a function to use in testing whether symbolic expressions should be treated as zero."
ZeroWidthTimes::usage = "ZeroWidthTimes is an option for selections that specifies whether blank spaces representing multiplication are explicitly shown."
Zeta::usage = "\!\(\*RowBox[{\"Zeta\", \"[\", StyleBox[\"s\", \"TI\"], \"]\"}]\) gives the Riemann zeta function \!\(\*RowBox[{\"\[Zeta]\", \"(\", StyleBox[\"s\", \"TI\"], \")\"}]\). \n\!\(\*RowBox[{\"Zeta\", \"[\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \"]\"}]\) gives the generalized Riemann zeta function \!\(\*RowBox[{\"\[Zeta]\", \"(\", RowBox[{StyleBox[\"s\", \"TI\"], \",\", StyleBox[\"a\", \"TI\"]}], \")\"}]\). "
ZetaZero::usage = "\!\(\*RowBox[{\"ZetaZero\", \"[\", StyleBox[\"k\", \"TI\"], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero of the Riemann zeta function on the critical line.\n\!\(\*RowBox[{\"ZetaZero\", \"[\", RowBox[{StyleBox[\"k\", \"TI\"], \",\", StyleBox[\"t\", \"TI\"]}], \"]\"}]\) represents the \!\(\*StyleBox[\"k\", \"TI\"]\)\!\(\*SuperscriptBox[\"\[Null]\", \"th\"]\) zero with imaginary part greater than \!\(\*StyleBox[\"t\", \"TI\"]\)."
ZIPCodeData::usage = "\!\(\*RowBox[{\"ZIPCodeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives the value of the specified \!\(\*StyleBox[\"property\", \"TI\"]\) for the ZIP code \!\(\*StyleBox[\"entity\", \"TI\"]\).\n\!\(\*RowBox[{\"ZIPCodeData\", \"[\", RowBox[{RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"entity\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TR\"]}], \"}\"}], \",\", StyleBox[\"property\", \"TI\"]}], \"]\"}]\) gives a list of property values for the specified ZIP code entities.\n\!\(\*RowBox[{\"ZIPCodeData\", \"[\", RowBox[{StyleBox[\"entity\", \"TI\"], \",\", StyleBox[\"property\", \"TI\"], \",\", StyleBox[\"annotation\", \"TI\"]}], \"]\"}]\) gives the specified \!\(\*StyleBox[\"annotation\", \"TI\"]\) associated with the given \!\(\*StyleBox[\"property\", \"TI\"]\)."
ZipfDistribution::usage = "\!\(\*RowBox[{\"ZipfDistribution\", \"[\", StyleBox[\"\[Rho]\", \"TR\"], \"]\"}]\) represents a zeta distribution with parameter \!\(\*StyleBox[\"\[Rho]\", \"TR\"]\).\n\!\(\*RowBox[{\"ZipfDistribution\", \"[\", RowBox[{StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"\[Rho]\", \"TR\"]}], \"]\"}]\) represents a Zipf distribution with range \!\(\*StyleBox[\"n\", \"TI\"]\)."
ZTest::usage = "\!\(\*RowBox[{\"ZTest\", \"[\", StyleBox[\"data\", \"TI\"], \"]\"}]\) tests whether the mean of the \!\(\*StyleBox[\"data\", \"TI\"]\) is zero. \n\!\(\*RowBox[{\"ZTest\", \"[\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]}], \"}\"}], \"]\"}]\) tests whether the means of \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"1\", \"TR\"]]\) and \!\(\*SubscriptBox[StyleBox[\"data\", \"TI\"], StyleBox[\"2\", \"TR\"]]\) are equal.\n\!\(\*RowBox[{\"ZTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]}], \"]\"}]\) tests for zero or equal means assuming a population variance \!\(\*SuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]]\).\n\!\(\*RowBox[{\"ZTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}], \"]\"}]\) tests the mean against\!\(\*RowBox[{\" \", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]]}]\).\n\!\(\*RowBox[{\"ZTest\", \"[\", RowBox[{StyleBox[\"dspec\", \"TI\"], \",\", SuperscriptBox[StyleBox[\"\[Sigma]\", \"TR\"], StyleBox[\"2\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"\[Mu]\", \"TR\"], StyleBox[\"0\", \"TR\"]], \",\", StyleBox[\"\\\"\\!\\(\\*StyleBox[\\\"property\\\",\\\"TI\\\"]\\)\\\"\", ShowStringCharacters->True]}], \"]\"}]\) returns the value of \"\!\(\*\nStyleBox[\"property\", \"TI\"]\)\"."
ZTransform::usage = "\!\(\*RowBox[{\"ZTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", StyleBox[\"n\", \"TI\"], \",\", StyleBox[\"z\", \"TI\"]}], \"]\"}]\) gives the Z transform of \!\(\*StyleBox[\"expr\", \"TI\"]\). \n\!\(\*RowBox[{\"ZTransform\", \"[\", RowBox[{StyleBox[\"expr\", \"TI\"], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"n\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}], \",\", RowBox[{\"{\", RowBox[{SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"1\", \"TR\"]], \",\", SubscriptBox[StyleBox[\"z\", \"TI\"], StyleBox[\"2\", \"TR\"]], \",\", StyleBox[\"\[Ellipsis]\", \"TI\"]}], \"}\"}]}], \"]\"}]\) gives the multidimensional Z transform of \!\(\*StyleBox[\"expr\", \"TI\"]\)."
$Aborted::usage = "$Aborted is a special symbol that is returned as the result from a calculation that has been aborted. "
$AssertFunction::usage = "$AssertFunction specifies a function to apply to assertions that fail."
$Assumptions::usage = "$Assumptions is the default setting for the Assumptions option used in such functions as Simplify, Refine, and Integrate. "
$AsynchronousTask::usage = "$AsynchronousTask returns the current AsynchronousTaskObject."
$BaseDirectory::usage = "$BaseDirectory gives the base directory in which systemwide files to be loaded by the Wolfram System are conventionally placed. "
$BatchInput::usage = "$BatchInput is True if input in the current session is being fed directly to the Wolfram Language kernel in batch mode. "
$BatchOutput::usage = "$BatchOutput is True if output in the current session is being sent in batch mode, suitable for reading by other programs. "
$BoxForms::usage = "$BoxForms is the list of box formats."
$ByteOrdering::usage = "$ByteOrdering gives the native ordering of bytes in binary data on your computer system. "
$Canceled::usage = "$Canceled is a symbol returned when notebook input is canceled, for example from a dialog box."
$CharacterEncodings::usage = "$CharacterEncodings gives the list of character encodings that can be used."
$CharacterEncoding::usage = "$CharacterEncoding specifies the default raw character encoding to use for input and output functions. "
$CloudBase::usage = "$CloudBase gives the base URI of the server to use for cloud operations."
$CloudConnected::usage = "$CloudConnected gives True if an authenticated connection to the Wolfram Cloud has been set up, and False otherwise."
$CloudCreditsAvailable::usage = "$CloudCreditsAvailable gives the total number of cloud credits currently available in the cloud account being used."
$CloudEvaluation::usage = "$CloudEvaluation gives True if the current evaluation is occurring in the cloud, and False otherwise."
$CloudRootDirectory::usage = "$CloudRootDirectory is the cloud object corresponding to the root directory for the file structure in which the current user's cloud objects are stored."
$CloudSymbolBase::usage = "$CloudSymbolBase gives the base for storing the values of CloudSymbol objects."
$CommandLine::usage = "$CommandLine is a list of strings giving the elements of the original operating system command line with which the current instantiation of the Wolfram Language was invoked. "
$CompilationTarget::usage = "$CompilationTarget gives the default value for the option CompilationTarget of Compile."
$ConditionHold::usage = "$ConditionHold is an internal symbol."
$ConfiguredKernels::usage = "$ConfiguredKernels is the default list of kernels that are configured for remote or parallel computing."
$ContextPath::usage = "$ContextPath is a global variable that gives a list of contexts, after $Context, to search in trying to find a symbol that has been entered. "
$Context::usage = "$Context is a global variable that gives the current context. "
$ControlActiveSetting::usage = "$ControlActiveSetting is a symbol whose value is True if it is evaluated while a control is active, or in certain other previewing situations. "
$CreationDate::usage = "$CreationDate gives the date at which the particular release of the Wolfram Language kernel you are running was created. "
$CurrentLink::usage = "$CurrentLink is the LinkObject representing the WSTP connection for an external program currently being installed or being called. "
$DateStringFormat::usage = "$DateStringFormat gives the default format to use for date strings generated by DateString."
$DefaultFont::usage = "$DefaultFont give a global default setting for the option DefaultFont."
$DefaultImagingDevice::usage = "$DefaultImagingDevice gives the name of the default imaging device attached to the computer."
$DefaultLocalBase::usage = "$DefaultLocalBase gives the default base directory to use for local object storage."
$DefaultPath::usage = "$DefaultPath is the default setting for $Path for this copy of \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) session."
$DisplayFunction::usage = "$DisplayFunction gives the default setting for the option DisplayFunction in graphics functions. "
$Display::usage = "$Display gives a list of files and pipes to be used with the default $DisplayFunction. "
$DistributedContexts::usage = "$DistributedContexts is the default value of the DistributedContexts option of functions such as ParallelTable and ParallelMap."
$DumpDates::usage = "$DumpDates gives the list of all dates and times at which Dump was used in creating the \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) system you are running."
$DumpSupported::usage = "$DumpSupported is True if Dump can be used in the version of \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) you are running, and is False otherwise."
$DynamicEvaluation::usage = "$DynamicEvaluation is a symbol whose value is True if it is evaluated as part of the evaluation of a Dynamic."
$Echo::usage = "$Echo gives a list of files and pipes to which all input is echoed. "
$EmbedCodeEnvironments::usage = "$EmbedCodeEnvironments gives a list of environments currently supported by EmbedCode in your Wolfram Language session."
$EmbeddableServices::usage = "$EmbeddableServices gives a list of external embeddable services that can be accessed through EmbeddedService."
$Epilog::usage = "$Epilog is a symbol whose value, if any, is evaluated when a dialog or a Wolfram System session is terminated. "
$EvaluationCloudObject::usage = "$EvaluationCloudObject gives the cloud object containing the code currently being executed. "
$EvaluationEnvironment::usage = "$EvaluationEnvironment gives a string indicating the type of local or cloud environment in which the current Wolfram Language evaluation is being performed. "
$ExportFormats::usage = "$ExportFormats gives a list of export formats currently supported in your Wolfram Language session. "
$Failed::usage = "$Failed is a special symbol returned by certain functions when they cannot do what they were asked to do. "
$FontFamilies::usage = "$FontFamilies gives the list of the font families available to the Wolfram System."
$FormatType::usage = "$FormatType gives the default format type to use for text that appears in graphics. "
$FrontEndSession::usage = "$FrontEndSession is a global symbol that represents the current session of the front end from which the kernel is being run."
$FrontEnd::usage = "$FrontEnd is a global variable that specifies to what front end object, if any, the kernel is currently connected. "
$FullVersion::usage = "$FullVersion is a string that gives the full version of the Wolfram Language kernel you are running"
$GeoLocationCity::usage = "$GeoLocationCity gives the city entity for the current setting for $GeoLocation."
$GeoLocationCountry::usage = "$GeoLocationCountry gives the country entity for the current setting for $GeoLocation."
$GeoLocationSource::usage = "$GeoLocationSource is a string giving the source of the default geodetic location."
$GeoLocation::usage = "$GeoLocation is a settable global variable that specifies the default geodetic location to use."
$HistoryLength::usage = "$HistoryLength specifies the number of previous lines of input and output to keep in a Wolfram System session. "
$HomeDirectory::usage = "$HomeDirectory gives your \"home\" directory. "
$HTTPCookies::usage = "$HTTPCookies is a global variable that contains the shared HTTP cookies used when connecting to a web server."
$IgnoreEOF::usage = "$IgnoreEOF specifies whether the Wolfram System should terminate when it receives an end\[Hyphen]of\[Hyphen]file character as input. "
$ImageFormattingWidth::usage = "$ImageFormattingWidth gives the default target width at which to wrap when formatting objects."
$ImagingDevices::usage = "$ImagingDevices gives a list of available imaging devices."
$ImagingDevice::usage = "$ImagingDevice gives the name of the imaging device used to capture images."
$ImportFormats::usage = "$ImportFormats gives a list of import formats currently supported in your Wolfram Language session. "
$InitialDirectory::usage = "$InitialDirectory gives the initial directory when the current Wolfram System session was started. "
$InputFileName::usage = "$InputFileName is a global variable whose value is the absolute file name of the input file from which input to the Wolfram Language is currently being sought."
$InputStreamMethods::usage = "$InputStreamMethods gives the list of input stream methods that can be used."
$Input::usage = "$Input is a global variable whose value is the name of the stream from which input to the Wolfram Language is currently being sought. "
$Inspector::usage = "$Inspector is a global variable which gives a function to apply when the inspector is invoked from an interrupt menu. "
$InstallationDate::usage = "$InstallationDate gives the date and time at which the copy of the \!\(\*StyleBox[\"Wolfram System\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) kernel you are running was installed. "
$InstallationDirectory::usage = "$InstallationDirectory gives the top\[Hyphen]level directory in which your Wolfram System installation resides. "
$InterpreterTypes::usage = "$InterpreterTypes gives a list of the currently available types for the Interpreter function."
$IterationLimit::usage = "$IterationLimit gives the maximum length of evaluation chain used in trying to evaluate any expression. "
$KernelCount::usage = "$KernelCount gives the number of subkernels available for parallel computations."
$KernelID::usage = "$KernelID is a unique ID number assigned to each running parallel kernel."
$Language::usage = "$Language is a list of strings that give the names of languages to use for messages. "
$LibraryPath::usage = "$LibraryPath gives the default list of directories to search in attempting to find a library."
$LicenseExpirationDate::usage = "$LicenseExpirationDate gives the expiration date for the license under which the Wolfram System is being run."
$LicenseID::usage = "$LicenseID is a string that gives the license ID under which the Wolfram System is being run."
$LicenseProcesses::usage = "$LicenseProcesses is the number of \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) processes currently being run under the license."
$LicenseServer::usage = "$LicenseServer is a string that gives the name of the license server that is currently authorizing the Wolfram System to be run."
$LicenseSubprocesses::usage = "$LicenseSubprocesses is the number of \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) subprocesses currently being run under the license."
$Line::usage = "$Line is a global variable that specifies the number of the current input line. "
$Linked::usage = "$Linked is True if the Wolfram Language kernel is being run through WSTP. "
$LinkSupported::usage = "$LinkSupported is True if WSTP can be used in the version of \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) you are running, and is False otherwise."
$LocalBase::usage = "$LocalBase gives the base directory to use for local object storage."
$LocalSymbolBase::usage = "$LocalSymbolBase gives the base directory for storing values of LocalSymbol objects."
$MachineAddresses::usage = "$MachineAddresses gives a list of strings specifying the current IP addresses associated with the computer on which the Wolfram System is being run."
$MachineDomains::usage = "$MachineDomains is a list of strings giving the names of the current network domains associated with the computer on which the Wolfram System is being run. "
$MachineDomain::usage = "$MachineDomain is a string which gives the name of the network domain for the computer on which \!\(\*StyleBox[\"the Wolfram System\", \"RebrandingTerm\", \"ReplacedText\" -> StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]]\) is being run, if such a name is defined. "
$MachineEpsilon::usage = "$MachineEpsilon gives the difference between 1.0 and the next-nearest number representable as a machine-precision number. "
$MachineID::usage = "$MachineID is a string that gives, if possible, a unique identification code for the computer on which the Wolfram System is being run."
$MachineName::usage = "$MachineName is a string that gives the assigned name of the computer on which the Wolfram System is being run, if such a name is defined. "
$MachinePrecision::usage = "$MachinePrecision gives the number of decimal digits of precision used for machine\[Hyphen]precision numbers. "
$MachineType::usage = "$MachineType is a string giving the general type of computer on which the Wolfram System is being run. "
$MaxExtraPrecision::usage = "$MaxExtraPrecision gives the maximum number of extra digits of precision to be used in functions such as N. "
$MaxLicenseProcesses::usage = "$MaxLicenseProcesses is the maximum number of processes provided by the license."
$MaxLicenseSubprocesses::usage = "$MaxLicenseSubprocesses is the maximum number of subprocesses provided by the license."
$MaxMachineNumber::usage = "$MaxMachineNumber is the largest machine\[Hyphen]precision number that can be used on a particular computer system. "
$MaxNumber::usage = "$MaxNumber gives the maximum arbitrary\[Hyphen]precision number that can be represented on a particular computer system. "
$MaxPiecewiseCases::usage = "$MaxPiecewiseCases gives the maximum number of cases to allow in explicit Piecewise objects generated by expanding any single piecewise function. "
$MaxPrecision::usage = "$MaxPrecision gives the maximum number of digits of precision to be allowed in arbitrary\[Hyphen]precision numbers. "
$MaxRootDegree::usage = "$MaxRootDegree specifies the maximum degree of polynomial to allow in Root objects."
$MessageGroups::usage = "$MessageGroups is the list of rules that gives named message groups used in functions like On and Quiet."
$MessageList::usage = "$MessageList is a global variable that gives a list of the names of messages generated during the evaluation of the current input line. "
$MessagePrePrint::usage = "$MessagePrePrint is a global variable whose value, if set, is applied to expressions before they are included in the text of messages. "
$Messages::usage = "$Messages gives the list of files and pipes to which message output is sent. "
$MinMachineNumber::usage = "$MinMachineNumber is the smallest positive machine\[Hyphen]precision number that can be used on a particular computer system. "
$MinNumber::usage = "$MinNumber gives the minimum positive arbitrary\[Hyphen]precision number that can be represented on a particular computer system. "
$MinPrecision::usage = "$MinPrecision gives the minimum number of digits of precision to be allowed in arbitrary\[Hyphen]precision numbers. "
$ModuleNumber::usage = "$ModuleNumber gives the current serial number to be used for local variables that are created. "
$NetworkLicense::usage = "$NetworkLicense gives True if using a network license, and False otherwise."
$NewMessage::usage = "$NewMessage is a global variable which, if set, is applied to the symbol name and tag of messages that are requested but have not yet been defined. "
$NewSymbol::usage = "$NewSymbol is a global variable which, if set, is applied to the name and context of each new symbol that the Wolfram Language creates. "
$Notebooks::usage = "$Notebooks is True if the Wolfram System is being used with a notebook\[Hyphen]based front end. "
$NumberMarks::usage = "$NumberMarks gives the default value for the option NumberMarks, which specifies whether ` marks should be included in the input form representations of approximate numbers. "
$OperatingSystem::usage = "$OperatingSystem is a string giving the type of operating system under which the Wolfram System is being run. "
$OutputForms::usage = "$OutputForms is a list of the formatting functions that get stripped off when wrapped around the output."
$OutputSizeLimit::usage = "$OutputSizeLimit specifies the maximum size in bytes of expressions that will automatically be output in their entirety in a Wolfram System notebook. "
$OutputStreamMethods::usage = "$OutputStreamMethods gives the list of output stream methods that can be used."
$Output::usage = "$Output gives the list of files and pipes to which standard output from the Wolfram Language is sent. "
$Packages::usage = "$Packages gives a list of the contexts corresponding to all packages which have been loaded in your current Wolfram System session. "
$ParentLink::usage = "$ParentLink is the WSTP LinkObject currently used for input and output by the Wolfram Language kernel in a particular session. "
$ParentProcessID::usage = "$ParentProcessID gives the ID assigned to the process which invokes the Wolfram Language kernel by the operating system under which it is run. "
$PasswordFile::usage = "$PasswordFile is a string giving the password file used when the kernel was started."
$PathnameSeparator::usage = "$PathnameSeparator is a string used as a separator when full file and directory names are constructed."
$Path::usage = "$Path gives the default list of directories to search in attempting to find an external file. "
$PerformanceGoal::usage = "$PerformanceGoal gives the default setting for the option PerformanceGoal for graphics and other algorithmic functions."
$Permissions::usage = "$Permissions is the default setting used for the Permissions option when unnamed cloud objects are created."
$PipeSupported::usage = "$PipeSupported is True if pipes can be used in the version of \!\(\*StyleBox[\"Mathematica\", FontSlant -> \"Italic\"]\) you are running, and is False otherwise."
$PlotTheme::usage = "$PlotTheme gives the default setting for the option PlotTheme for graphics functions."
$Post::usage = "$Post is a global variable whose value, if set, is applied to every output expression. "
$PrePrint::usage = "$PrePrint is a global variable whose value, if set, is applied to every expression before it is printed. "
$PreRead::usage = "$PreRead is a global variable whose value, if set, is applied to the text or box form of every input expression before it is fed to the Wolfram Language. "
$Pre::usage = "$Pre is a global variable whose value, if set, is applied to every input expression. "
$PrintForms::usage = "$PrintForms is the list of basic print forms. It is automatically updated when Format definitions using new printforms are made."
$PrintLiteral::usage = "$PrintLiteral is an internal symbol."
$ProcessID::usage = "$ProcessID gives the ID assigned to the Wolfram Language kernel process by the operating system under which it is run. "
$ProcessorCount::usage = "$ProcessorCount gives the number of processor cores available on the computer system on which the Wolfram System is being run."
$ProcessorType::usage = "$ProcessorType is a string giving the architecture of the processor on which the Wolfram System is being run. "
$ProductInformation::usage = "$ProductInformation is a list of rules giving detailed information about the software product to which the current kernel belongs. "
$ProgramName::usage = "$ProgramName is the name of the program being run under the license."
$RandomState::usage = "$RandomState gives a representation of the internal state of the pseudorandom generator used by Random. "
$RecursionLimit::usage = "$RecursionLimit gives the current limit on the number of levels of recursion that the Wolfram Language can use. "
$ReleaseNumber::usage = "$ReleaseNumber is an integer which gives the current Wolfram Language kernel release number, and increases in successive releases. "
$RequesterAddress::usage = "$RequesterAddress gives the IP address originating an HTTP request that initiated the current evaluation."
$RequesterWolframID::usage = "$RequesterWolframID gives the Wolfram ID of an authenticated user requesting the current evaluation. "
$RequesterWolframUUID::usage = "$RequesterWolframUUID gives the Wolfram UUID of an authenticated user requesting the current evaluation. "
$RootDirectory::usage = "$RootDirectory gives the root directory of your file system."
$ScheduledTask::usage = "$ScheduledTask returns within a scheduled task the ScheduledTaskObject or CloudObject for the task."
$ScriptCommandLine::usage = "$ScriptCommandLine is a list of strings giving the elements of the command line with which the standalone Wolfram System script was invoked."
$Services::usage = "$Services gives a list of external services available through ServiceConnect. "
$SessionID::usage = "$SessionID is a number set up to be unique to a particular Wolfram System session. "
$SharedFunctions::usage = "$SharedFunctions is the list of functions currently being shared among parallel kernels."
$SharedVariables::usage = "$SharedVariables is the list of variables currently being shared among parallel kernels."
$SoundDisplayFunction::usage = "$SoundDisplayFunction gives the default setting for the option DisplayFunction in sound functions. "
$SuppressInputFormHeads::usage = "$SuppressInputFormHeads is a list of the heads of expressions whose InputForm should not be sent automatically to front ends."
$SynchronousEvaluation::usage = "$SynchronousEvaluation is a symbol whose value is True if it is evaluated as part of a synchronous evaluation."
$SyntaxHandler::usage = "$SyntaxHandler is a global variable which, if set, is applied to any input string that is found to contain a syntax error. "
$SystemCharacterEncoding::usage = "$SystemCharacterEncoding gives the default raw character encoding for the computer system on which the Wolfram System is being run. "
$SystemID::usage = "$SystemID is a short string that identifies the type of computer system on which the Wolfram System is being run. "
$SystemShell::usage = "$SystemShell is a symbol that specifies the system shell for the OS that is currently being used. "
$SystemTimeZone::usage = "$SystemTimeZone gives the current time zone for the computer system on which the Wolfram System is being run."
$System::usage = "$System is a string describing the type of computer system on which the Wolfram System is being run. "
$SystemWordLength::usage = "$SystemWordLength gives the effective number of bits in raw machine words on the computer system where the Wolfram System is running."
$TemplatePath::usage = "$TemplatePath gives the default list of directories to search in attempting to find a template file. "
$TemporaryDirectory::usage = "$TemporaryDirectory gives the main system directory for temporary files on your computer system."
$TemporaryPrefix::usage = "$TemporaryPrefix is a string that gives the path and beginning of the name for files and directories that are created by OpenWrite and CreateDirectory when no explicit file is specified."
$TextStyle::usage = "$TextStyle gives the default style to use for text in graphics. "
$TimedOut::usage = "$TimedOut is a special symbol returned by certain functions when an operation times out."
$TimeUnit::usage = "$TimeUnit gives the minimum time interval in seconds recorded on your computer system. "
$TimeZoneEntity::usage = "$TimeZoneEntity gives the time zone Entity corresponding to the locale setting for your computer operating system."
$TimeZone::usage = "$TimeZone gives the current time zone to assume for dates and times. "
$TracePattern::usage = "$TracePattern is the currently active pattern argument to Trace and related functions. It can be reset during the trace to alter the set of expressions recorded or printed."
$TracePostAction::usage = "$TracePostAction is the currently active fourth argument to TraceScan (or the equivalent in related functions). It can be reset during the trace to alter the action taken after intercepted expressions are evaluated."
$TracePreAction::usage = "$TracePreAction is the currently active first argument to TraceScan (or the equivalent in related functions). It can be reset during the trace to alter the action taken before intercepted expressions are evaluated."
$UnitSystem::usage = "$UnitSystem gives the unit system to assume for returned quantities."
$Urgent::usage = "$Urgent gives the list of files and pipes to which urgent output from the Wolfram Language is sent. "
$UserAgentString::usage = "$UserAgentString gives the user agent string from an HTTP request that initiated the current evaluation."
$UserBaseDirectory::usage = "$UserBaseDirectory gives the base directory in which user\[Hyphen]specific files to be loaded by the Wolfram System are conventionally placed. "
$UserDocumentsDirectory::usage = "$UserDocumentsDirectory gives your default \"documents\" directory. "
$UserName::usage = "$UserName gives the login name of the user who invoked the Wolfram Language kernel, as recorded by the operating system. "
$VersionNumber::usage = "$VersionNumber is a real number which gives the current Wolfram Language kernel version number, and increases in successive versions. "
$Version::usage = "$Version is a string that gives the version of the Wolfram Language kernel you are running. "
$WolframID::usage = "$WolframID gives the Wolfram ID of a currently logged-in user, or the user who owns a cloud object containing the code used for the current evaluation."
$WolframUUID::usage = "$WolframUUID gives the Wolfram UUID of a currently logged-in user, or the user who owns a cloud object containing the code used for the current evaluation."